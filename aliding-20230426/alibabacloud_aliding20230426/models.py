# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import Dict, List, Any


class DentryAppPropertiesValue(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
        visibility: str = None,
    ):
        self.name = name
        self.value = value
        self.visibility = visibility

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        if self.visibility is not None:
            result['Visibility'] = self.visibility
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('Visibility') is not None:
            self.visibility = m.get('Visibility')
        return self


class DentriesAppPropertiesValue(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
        visibility: str = None,
    ):
        self.name = name
        self.value = value
        self.visibility = visibility

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        if self.visibility is not None:
            result['Visibility'] = self.visibility
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('Visibility') is not None:
            self.visibility = m.get('Visibility')
        return self


class AddAttendeeHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class AddAttendeeHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: AddAttendeeHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = AddAttendeeHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class AddAttendeeShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class AddAttendeeRequestAttendeesToAdd(TeaModel):
    def __init__(
        self,
        id: str = None,
        is_optional: bool = None,
    ):
        self.id = id
        self.is_optional = is_optional

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.is_optional is not None:
            result['isOptional'] = self.is_optional
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('isOptional') is not None:
            self.is_optional = m.get('isOptional')
        return self


class AddAttendeeRequest(TeaModel):
    def __init__(
        self,
        attendees_to_add: List[AddAttendeeRequestAttendeesToAdd] = None,
        calendar_id: str = None,
        event_id: str = None,
        chat_notification: bool = None,
        push_notification: bool = None,
    ):
        # This parameter is required.
        self.attendees_to_add = attendees_to_add
        # This parameter is required.
        self.calendar_id = calendar_id
        # This parameter is required.
        self.event_id = event_id
        self.chat_notification = chat_notification
        self.push_notification = push_notification

    def validate(self):
        if self.attendees_to_add:
            for k in self.attendees_to_add:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AttendeesToAdd'] = []
        if self.attendees_to_add is not None:
            for k in self.attendees_to_add:
                result['AttendeesToAdd'].append(k.to_map() if k else None)
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.chat_notification is not None:
            result['chatNotification'] = self.chat_notification
        if self.push_notification is not None:
            result['pushNotification'] = self.push_notification
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attendees_to_add = []
        if m.get('AttendeesToAdd') is not None:
            for k in m.get('AttendeesToAdd'):
                temp_model = AddAttendeeRequestAttendeesToAdd()
                self.attendees_to_add.append(temp_model.from_map(k))
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('chatNotification') is not None:
            self.chat_notification = m.get('chatNotification')
        if m.get('pushNotification') is not None:
            self.push_notification = m.get('pushNotification')
        return self


class AddAttendeeShrinkRequest(TeaModel):
    def __init__(
        self,
        attendees_to_add_shrink: str = None,
        calendar_id: str = None,
        event_id: str = None,
        chat_notification: bool = None,
        push_notification: bool = None,
    ):
        # This parameter is required.
        self.attendees_to_add_shrink = attendees_to_add_shrink
        # This parameter is required.
        self.calendar_id = calendar_id
        # This parameter is required.
        self.event_id = event_id
        self.chat_notification = chat_notification
        self.push_notification = push_notification

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attendees_to_add_shrink is not None:
            result['AttendeesToAdd'] = self.attendees_to_add_shrink
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.chat_notification is not None:
            result['chatNotification'] = self.chat_notification
        if self.push_notification is not None:
            result['pushNotification'] = self.push_notification
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttendeesToAdd') is not None:
            self.attendees_to_add_shrink = m.get('AttendeesToAdd')
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('chatNotification') is not None:
            self.chat_notification = m.get('chatNotification')
        if m.get('pushNotification') is not None:
            self.push_notification = m.get('pushNotification')
        return self


class AddAttendeeResponseBodyContent(TeaModel):
    def __init__(
        self,
        data: Any = None,
    ):
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        return self


class AddAttendeeResponseBody(TeaModel):
    def __init__(
        self,
        content: AddAttendeeResponseBodyContent = None,
        error_code: str = None,
        error_ctx: Dict[str, Any] = None,
        error_msg: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.content = content
        self.error_code = error_code
        self.error_ctx = error_ctx
        self.error_msg = error_msg
        self.http_status_code = http_status_code
        # RequestId
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_ctx is not None:
            result['ErrorCtx'] = self.error_ctx
        if self.error_msg is not None:
            result['ErrorMsg'] = self.error_msg
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            temp_model = AddAttendeeResponseBodyContent()
            self.content = temp_model.from_map(m['Content'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorCtx') is not None:
            self.error_ctx = m.get('ErrorCtx')
        if m.get('ErrorMsg') is not None:
            self.error_msg = m.get('ErrorMsg')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddAttendeeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddAttendeeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddAttendeeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddDriveSpaceHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class AddDriveSpaceHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: AddDriveSpaceHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        # This parameter is required.
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = AddDriveSpaceHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class AddDriveSpaceShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        # This parameter is required.
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class AddDriveSpaceRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class AddDriveSpaceRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        tenant_context: AddDriveSpaceRequestTenantContext = None,
    ):
        # This parameter is required.
        self.name = name
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TenantContext') is not None:
            temp_model = AddDriveSpaceRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class AddDriveSpaceShrinkRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.name = name
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class AddDriveSpaceResponseBody(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        modify_time: str = None,
        permission_mode: str = None,
        quota: int = None,
        request_id: str = None,
        space_id: str = None,
        space_name: str = None,
        space_type: str = None,
        used_quota: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.create_time = create_time
        self.modify_time = modify_time
        self.permission_mode = permission_mode
        self.quota = quota
        self.request_id = request_id
        self.space_id = space_id
        self.space_name = space_name
        self.space_type = space_type
        self.used_quota = used_quota
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.modify_time is not None:
            result['modifyTime'] = self.modify_time
        if self.permission_mode is not None:
            result['permissionMode'] = self.permission_mode
        if self.quota is not None:
            result['quota'] = self.quota
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.space_id is not None:
            result['spaceId'] = self.space_id
        if self.space_name is not None:
            result['spaceName'] = self.space_name
        if self.space_type is not None:
            result['spaceType'] = self.space_type
        if self.used_quota is not None:
            result['usedQuota'] = self.used_quota
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('modifyTime') is not None:
            self.modify_time = m.get('modifyTime')
        if m.get('permissionMode') is not None:
            self.permission_mode = m.get('permissionMode')
        if m.get('quota') is not None:
            self.quota = m.get('quota')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('spaceId') is not None:
            self.space_id = m.get('spaceId')
        if m.get('spaceName') is not None:
            self.space_name = m.get('spaceName')
        if m.get('spaceType') is not None:
            self.space_type = m.get('spaceType')
        if m.get('usedQuota') is not None:
            self.used_quota = m.get('usedQuota')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class AddDriveSpaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddDriveSpaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddDriveSpaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddFolderHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class AddFolderHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: AddFolderHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = AddFolderHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class AddFolderShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class AddFolderRequestOptionAppProperties(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
        visibility: str = None,
    ):
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.value = value
        # This parameter is required.
        self.visibility = visibility

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        if self.visibility is not None:
            result['Visibility'] = self.visibility
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('Visibility') is not None:
            self.visibility = m.get('Visibility')
        return self


class AddFolderRequestOption(TeaModel):
    def __init__(
        self,
        app_properties: List[AddFolderRequestOptionAppProperties] = None,
        conflict_strategy: str = None,
    ):
        self.app_properties = app_properties
        self.conflict_strategy = conflict_strategy

    def validate(self):
        if self.app_properties:
            for k in self.app_properties:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AppProperties'] = []
        if self.app_properties is not None:
            for k in self.app_properties:
                result['AppProperties'].append(k.to_map() if k else None)
        if self.conflict_strategy is not None:
            result['ConflictStrategy'] = self.conflict_strategy
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.app_properties = []
        if m.get('AppProperties') is not None:
            for k in m.get('AppProperties'):
                temp_model = AddFolderRequestOptionAppProperties()
                self.app_properties.append(temp_model.from_map(k))
        if m.get('ConflictStrategy') is not None:
            self.conflict_strategy = m.get('ConflictStrategy')
        return self


class AddFolderRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class AddFolderRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        option: AddFolderRequestOption = None,
        parent_id: str = None,
        space_id: str = None,
        tenant_context: AddFolderRequestTenantContext = None,
    ):
        # This parameter is required.
        self.name = name
        self.option = option
        # This parameter is required.
        self.parent_id = parent_id
        # This parameter is required.
        self.space_id = space_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.option:
            self.option.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.option is not None:
            result['Option'] = self.option.to_map()
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Option') is not None:
            temp_model = AddFolderRequestOption()
            self.option = temp_model.from_map(m['Option'])
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('TenantContext') is not None:
            temp_model = AddFolderRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class AddFolderShrinkRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        option_shrink: str = None,
        parent_id: str = None,
        space_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.name = name
        self.option_shrink = option_shrink
        # This parameter is required.
        self.parent_id = parent_id
        # This parameter is required.
        self.space_id = space_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.option_shrink is not None:
            result['Option'] = self.option_shrink
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Option') is not None:
            self.option_shrink = m.get('Option')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class AddFolderResponseBodyDentryProperties(TeaModel):
    def __init__(
        self,
        read_only: bool = None,
    ):
        self.read_only = read_only

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.read_only is not None:
            result['ReadOnly'] = self.read_only
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReadOnly') is not None:
            self.read_only = m.get('ReadOnly')
        return self


class AddFolderResponseBodyDentry(TeaModel):
    def __init__(
        self,
        app_properties: Dict[str, List[DentryAppPropertiesValue]] = None,
        create_time: str = None,
        creator_id: str = None,
        extension: str = None,
        id: str = None,
        modified_time: str = None,
        modifier_id: str = None,
        name: str = None,
        parent_id: str = None,
        partition_type: str = None,
        path: str = None,
        properties: AddFolderResponseBodyDentryProperties = None,
        size: int = None,
        space_id: str = None,
        status: str = None,
        storage_driver: str = None,
        type: str = None,
        uuid: str = None,
        version: int = None,
    ):
        self.app_properties = app_properties
        self.create_time = create_time
        self.creator_id = creator_id
        self.extension = extension
        self.id = id
        self.modified_time = modified_time
        self.modifier_id = modifier_id
        self.name = name
        self.parent_id = parent_id
        self.partition_type = partition_type
        self.path = path
        self.properties = properties
        self.size = size
        self.space_id = space_id
        self.status = status
        self.storage_driver = storage_driver
        self.type = type
        self.uuid = uuid
        self.version = version

    def validate(self):
        if self.app_properties:
            for v in self.app_properties.values():
                for k1 in v:
                    if k1:
                        k1.validate()
        if self.properties:
            self.properties.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AppProperties'] = {}
        if self.app_properties is not None:
            for k, v in self.app_properties.items():
                l1 = []
                for k1 in v:
                    l1.append(k1.to_map() if k1 else None)
                result['AppProperties'][k] = l1
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.id is not None:
            result['Id'] = self.id
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.name is not None:
            result['Name'] = self.name
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.partition_type is not None:
            result['PartitionType'] = self.partition_type
        if self.path is not None:
            result['Path'] = self.path
        if self.properties is not None:
            result['Properties'] = self.properties.to_map()
        if self.size is not None:
            result['Size'] = self.size
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.status is not None:
            result['Status'] = self.status
        if self.storage_driver is not None:
            result['StorageDriver'] = self.storage_driver
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.app_properties = {}
        if m.get('AppProperties') is not None:
            for k, v in m.get('AppProperties').items():
                l1 = []
                for k1 in v:
                    temp_model = DentryAppPropertiesValue()
                    l1.append(temp_model.from_map(k1))
                self.app_properties['k'] = l1
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('PartitionType') is not None:
            self.partition_type = m.get('PartitionType')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Properties') is not None:
            temp_model = AddFolderResponseBodyDentryProperties()
            self.properties = temp_model.from_map(m['Properties'])
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StorageDriver') is not None:
            self.storage_driver = m.get('StorageDriver')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class AddFolderResponseBody(TeaModel):
    def __init__(
        self,
        dentry: AddFolderResponseBodyDentry = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.dentry = dentry
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.dentry:
            self.dentry.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry is not None:
            result['dentry'] = self.dentry.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dentry') is not None:
            temp_model = AddFolderResponseBodyDentry()
            self.dentry = temp_model.from_map(m['dentry'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class AddFolderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddFolderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddFolderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddMeetingRoomsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class AddMeetingRoomsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: AddMeetingRoomsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = AddMeetingRoomsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class AddMeetingRoomsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class AddMeetingRoomsRequestMeetingRoomsToAdd(TeaModel):
    def __init__(
        self,
        room_id: str = None,
    ):
        self.room_id = room_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.room_id is not None:
            result['RoomId'] = self.room_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RoomId') is not None:
            self.room_id = m.get('RoomId')
        return self


class AddMeetingRoomsRequest(TeaModel):
    def __init__(
        self,
        calendar_id: str = None,
        event_id: str = None,
        meeting_rooms_to_add: List[AddMeetingRoomsRequestMeetingRoomsToAdd] = None,
    ):
        # This parameter is required.
        self.calendar_id = calendar_id
        # This parameter is required.
        self.event_id = event_id
        # This parameter is required.
        self.meeting_rooms_to_add = meeting_rooms_to_add

    def validate(self):
        if self.meeting_rooms_to_add:
            for k in self.meeting_rooms_to_add:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        if self.event_id is not None:
            result['EventId'] = self.event_id
        result['MeetingRoomsToAdd'] = []
        if self.meeting_rooms_to_add is not None:
            for k in self.meeting_rooms_to_add:
                result['MeetingRoomsToAdd'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        self.meeting_rooms_to_add = []
        if m.get('MeetingRoomsToAdd') is not None:
            for k in m.get('MeetingRoomsToAdd'):
                temp_model = AddMeetingRoomsRequestMeetingRoomsToAdd()
                self.meeting_rooms_to_add.append(temp_model.from_map(k))
        return self


class AddMeetingRoomsShrinkRequest(TeaModel):
    def __init__(
        self,
        calendar_id: str = None,
        event_id: str = None,
        meeting_rooms_to_add_shrink: str = None,
    ):
        # This parameter is required.
        self.calendar_id = calendar_id
        # This parameter is required.
        self.event_id = event_id
        # This parameter is required.
        self.meeting_rooms_to_add_shrink = meeting_rooms_to_add_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.meeting_rooms_to_add_shrink is not None:
            result['MeetingRoomsToAdd'] = self.meeting_rooms_to_add_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('MeetingRoomsToAdd') is not None:
            self.meeting_rooms_to_add_shrink = m.get('MeetingRoomsToAdd')
        return self


class AddMeetingRoomsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: bool = None,
    ):
        # requestId
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class AddMeetingRoomsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddMeetingRoomsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddMeetingRoomsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddMultiDimTableHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class AddMultiDimTableHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: AddMultiDimTableHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = AddMultiDimTableHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class AddMultiDimTableShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class AddMultiDimTableRequestFields(TeaModel):
    def __init__(
        self,
        name: str = None,
        property: Dict[str, Any] = None,
        type: str = None,
    ):
        # This parameter is required.
        self.name = name
        self.property = property
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.property is not None:
            result['Property'] = self.property
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Property') is not None:
            self.property = m.get('Property')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AddMultiDimTableRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class AddMultiDimTableRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        fields: List[AddMultiDimTableRequestFields] = None,
        name: str = None,
        tenant_context: AddMultiDimTableRequestTenantContext = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        self.fields = fields
        self.name = name
        self.tenant_context = tenant_context

    def validate(self):
        if self.fields:
            for k in self.fields:
                if k:
                    k.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        result['Fields'] = []
        if self.fields is not None:
            for k in self.fields:
                result['Fields'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        self.fields = []
        if m.get('Fields') is not None:
            for k in m.get('Fields'):
                temp_model = AddMultiDimTableRequestFields()
                self.fields.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TenantContext') is not None:
            temp_model = AddMultiDimTableRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class AddMultiDimTableShrinkRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        fields_shrink: str = None,
        name: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        self.fields_shrink = fields_shrink
        self.name = name
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.fields_shrink is not None:
            result['Fields'] = self.fields_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('Fields') is not None:
            self.fields_shrink = m.get('Fields')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class AddMultiDimTableResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.id = id
        self.name = name
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class AddMultiDimTableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddMultiDimTableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddMultiDimTableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddPermissionHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class AddPermissionHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: AddPermissionHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = AddPermissionHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class AddPermissionShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class AddPermissionRequestMembers(TeaModel):
    def __init__(
        self,
        corp_id: str = None,
        id: str = None,
        type: str = None,
    ):
        self.corp_id = corp_id
        self.id = id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.id is not None:
            result['Id'] = self.id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AddPermissionRequestOption(TeaModel):
    def __init__(
        self,
        duration: int = None,
    ):
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class AddPermissionRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class AddPermissionRequest(TeaModel):
    def __init__(
        self,
        dentry_uuid: str = None,
        members: List[AddPermissionRequestMembers] = None,
        option: AddPermissionRequestOption = None,
        role_id: str = None,
        tenant_context: AddPermissionRequestTenantContext = None,
    ):
        self.dentry_uuid = dentry_uuid
        # This parameter is required.
        self.members = members
        self.option = option
        # This parameter is required.
        self.role_id = role_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.members:
            for k in self.members:
                if k:
                    k.validate()
        if self.option:
            self.option.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        result['Members'] = []
        if self.members is not None:
            for k in self.members:
                result['Members'].append(k.to_map() if k else None)
        if self.option is not None:
            result['Option'] = self.option.to_map()
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        self.members = []
        if m.get('Members') is not None:
            for k in m.get('Members'):
                temp_model = AddPermissionRequestMembers()
                self.members.append(temp_model.from_map(k))
        if m.get('Option') is not None:
            temp_model = AddPermissionRequestOption()
            self.option = temp_model.from_map(m['Option'])
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        if m.get('TenantContext') is not None:
            temp_model = AddPermissionRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class AddPermissionShrinkRequest(TeaModel):
    def __init__(
        self,
        dentry_uuid: str = None,
        members_shrink: str = None,
        option_shrink: str = None,
        role_id: str = None,
        tenant_context_shrink: str = None,
    ):
        self.dentry_uuid = dentry_uuid
        # This parameter is required.
        self.members_shrink = members_shrink
        self.option_shrink = option_shrink
        # This parameter is required.
        self.role_id = role_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        if self.members_shrink is not None:
            result['Members'] = self.members_shrink
        if self.option_shrink is not None:
            result['Option'] = self.option_shrink
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        if m.get('Members') is not None:
            self.members_shrink = m.get('Members')
        if m.get('Option') is not None:
            self.option_shrink = m.get('Option')
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class AddPermissionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.success = success
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class AddPermissionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddPermissionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddPermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddRecordPermissionHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class AddRecordPermissionHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: AddRecordPermissionHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = AddRecordPermissionHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class AddRecordPermissionShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class AddRecordPermissionRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class AddRecordPermissionRequest(TeaModel):
    def __init__(
        self,
        biz_type: str = None,
        conference_id: str = None,
        tenant_context: AddRecordPermissionRequestTenantContext = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.biz_type = biz_type
        # This parameter is required.
        self.conference_id = conference_id
        self.tenant_context = tenant_context
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.conference_id is not None:
            result['ConferenceId'] = self.conference_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('ConferenceId') is not None:
            self.conference_id = m.get('ConferenceId')
        if m.get('TenantContext') is not None:
            temp_model = AddRecordPermissionRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class AddRecordPermissionShrinkRequest(TeaModel):
    def __init__(
        self,
        biz_type: str = None,
        conference_id: str = None,
        tenant_context_shrink: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.biz_type = biz_type
        # This parameter is required.
        self.conference_id = conference_id
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.conference_id is not None:
            result['ConferenceId'] = self.conference_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('ConferenceId') is not None:
            self.conference_id = m.get('ConferenceId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class AddRecordPermissionResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.code = code
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class AddRecordPermissionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddRecordPermissionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddRecordPermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddScenegroupMemberHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class AddScenegroupMemberHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: AddScenegroupMemberHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = AddScenegroupMemberHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class AddScenegroupMemberShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class AddScenegroupMemberRequest(TeaModel):
    def __init__(
        self,
        open_conversation_id: str = None,
        user_ids: str = None,
    ):
        # This parameter is required.
        self.open_conversation_id = open_conversation_id
        # This parameter is required.
        self.user_ids = user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.open_conversation_id is not None:
            result['OpenConversationId'] = self.open_conversation_id
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OpenConversationId') is not None:
            self.open_conversation_id = m.get('OpenConversationId')
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        return self


class AddScenegroupMemberResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # requestId
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class AddScenegroupMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddScenegroupMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddScenegroupMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddTicketMemoHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class AddTicketMemoHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: AddTicketMemoHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = AddTicketMemoHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class AddTicketMemoShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class AddTicketMemoRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class AddTicketMemoRequestTicketMemoAttachments(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        key: str = None,
    ):
        self.file_name = file_name
        self.key = key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.key is not None:
            result['Key'] = self.key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        return self


class AddTicketMemoRequestTicketMemo(TeaModel):
    def __init__(
        self,
        attachments: List[AddTicketMemoRequestTicketMemoAttachments] = None,
        memo: str = None,
    ):
        self.attachments = attachments
        self.memo = memo

    def validate(self):
        if self.attachments:
            for k in self.attachments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Attachments'] = []
        if self.attachments is not None:
            for k in self.attachments:
                result['Attachments'].append(k.to_map() if k else None)
        if self.memo is not None:
            result['Memo'] = self.memo
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attachments = []
        if m.get('Attachments') is not None:
            for k in m.get('Attachments'):
                temp_model = AddTicketMemoRequestTicketMemoAttachments()
                self.attachments.append(temp_model.from_map(k))
        if m.get('Memo') is not None:
            self.memo = m.get('Memo')
        return self


class AddTicketMemoRequest(TeaModel):
    def __init__(
        self,
        open_team_id: str = None,
        open_ticket_id: str = None,
        tenant_context: AddTicketMemoRequestTenantContext = None,
        ticket_memo: AddTicketMemoRequestTicketMemo = None,
    ):
        # This parameter is required.
        self.open_team_id = open_team_id
        # This parameter is required.
        self.open_ticket_id = open_ticket_id
        self.tenant_context = tenant_context
        self.ticket_memo = ticket_memo

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()
        if self.ticket_memo:
            self.ticket_memo.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.open_team_id is not None:
            result['OpenTeamId'] = self.open_team_id
        if self.open_ticket_id is not None:
            result['OpenTicketId'] = self.open_ticket_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.ticket_memo is not None:
            result['TicketMemo'] = self.ticket_memo.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OpenTeamId') is not None:
            self.open_team_id = m.get('OpenTeamId')
        if m.get('OpenTicketId') is not None:
            self.open_ticket_id = m.get('OpenTicketId')
        if m.get('TenantContext') is not None:
            temp_model = AddTicketMemoRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('TicketMemo') is not None:
            temp_model = AddTicketMemoRequestTicketMemo()
            self.ticket_memo = temp_model.from_map(m['TicketMemo'])
        return self


class AddTicketMemoShrinkRequest(TeaModel):
    def __init__(
        self,
        open_team_id: str = None,
        open_ticket_id: str = None,
        tenant_context_shrink: str = None,
        ticket_memo_shrink: str = None,
    ):
        # This parameter is required.
        self.open_team_id = open_team_id
        # This parameter is required.
        self.open_ticket_id = open_ticket_id
        self.tenant_context_shrink = tenant_context_shrink
        self.ticket_memo_shrink = ticket_memo_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.open_team_id is not None:
            result['OpenTeamId'] = self.open_team_id
        if self.open_ticket_id is not None:
            result['OpenTicketId'] = self.open_ticket_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.ticket_memo_shrink is not None:
            result['TicketMemo'] = self.ticket_memo_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OpenTeamId') is not None:
            self.open_team_id = m.get('OpenTeamId')
        if m.get('OpenTicketId') is not None:
            self.open_ticket_id = m.get('OpenTicketId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('TicketMemo') is not None:
            self.ticket_memo_shrink = m.get('TicketMemo')
        return self


class AddTicketMemoResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class AddTicketMemoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddTicketMemoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddTicketMemoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddWorkspaceHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class AddWorkspaceHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: AddWorkspaceHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = AddWorkspaceHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class AddWorkspaceShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class AddWorkspaceRequestOption(TeaModel):
    def __init__(
        self,
        description: str = None,
        team_id: str = None,
    ):
        self.description = description
        self.team_id = team_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.team_id is not None:
            result['TeamId'] = self.team_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('TeamId') is not None:
            self.team_id = m.get('TeamId')
        return self


class AddWorkspaceRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class AddWorkspaceRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        option: AddWorkspaceRequestOption = None,
        tenant_context: AddWorkspaceRequestTenantContext = None,
    ):
        # This parameter is required.
        self.name = name
        self.option = option
        self.tenant_context = tenant_context

    def validate(self):
        if self.option:
            self.option.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.option is not None:
            result['Option'] = self.option.to_map()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Option') is not None:
            temp_model = AddWorkspaceRequestOption()
            self.option = temp_model.from_map(m['Option'])
        if m.get('TenantContext') is not None:
            temp_model = AddWorkspaceRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class AddWorkspaceShrinkRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        option_shrink: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.name = name
        self.option_shrink = option_shrink
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.option_shrink is not None:
            result['Option'] = self.option_shrink
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Option') is not None:
            self.option_shrink = m.get('Option')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class AddWorkspaceResponseBodyWorkspaceIcon(TeaModel):
    def __init__(
        self,
        type: str = None,
        value: str = None,
    ):
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class AddWorkspaceResponseBodyWorkspace(TeaModel):
    def __init__(
        self,
        corp_id: str = None,
        cover: str = None,
        create_time: str = None,
        creator_id: str = None,
        description: str = None,
        icon: AddWorkspaceResponseBodyWorkspaceIcon = None,
        modified_time: str = None,
        modifier_id: str = None,
        name: str = None,
        permission_role: str = None,
        root_node_id: str = None,
        team_id: str = None,
        type: str = None,
        url: str = None,
        workspace_id: str = None,
    ):
        self.corp_id = corp_id
        self.cover = cover
        self.create_time = create_time
        self.creator_id = creator_id
        self.description = description
        self.icon = icon
        self.modified_time = modified_time
        self.modifier_id = modifier_id
        self.name = name
        self.permission_role = permission_role
        self.root_node_id = root_node_id
        self.team_id = team_id
        self.type = type
        self.url = url
        self.workspace_id = workspace_id

    def validate(self):
        if self.icon:
            self.icon.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.cover is not None:
            result['Cover'] = self.cover
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.icon is not None:
            result['Icon'] = self.icon.to_map()
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.name is not None:
            result['Name'] = self.name
        if self.permission_role is not None:
            result['PermissionRole'] = self.permission_role
        if self.root_node_id is not None:
            result['RootNodeId'] = self.root_node_id
        if self.team_id is not None:
            result['TeamId'] = self.team_id
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('Cover') is not None:
            self.cover = m.get('Cover')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Icon') is not None:
            temp_model = AddWorkspaceResponseBodyWorkspaceIcon()
            self.icon = temp_model.from_map(m['Icon'])
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PermissionRole') is not None:
            self.permission_role = m.get('PermissionRole')
        if m.get('RootNodeId') is not None:
            self.root_node_id = m.get('RootNodeId')
        if m.get('TeamId') is not None:
            self.team_id = m.get('TeamId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class AddWorkspaceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        workspace: AddWorkspaceResponseBodyWorkspace = None,
    ):
        # requestId
        self.request_id = request_id
        self.workspace = workspace

    def validate(self):
        if self.workspace:
            self.workspace.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.workspace is not None:
            result['workspace'] = self.workspace.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('workspace') is not None:
            temp_model = AddWorkspaceResponseBodyWorkspace()
            self.workspace = temp_model.from_map(m['workspace'])
        return self


class AddWorkspaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddWorkspaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddWorkspaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddWorkspaceDocMembersHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class AddWorkspaceDocMembersHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: AddWorkspaceDocMembersHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = AddWorkspaceDocMembersHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class AddWorkspaceDocMembersShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class AddWorkspaceDocMembersRequestMembers(TeaModel):
    def __init__(
        self,
        member_id: str = None,
        member_type: str = None,
        role_type: str = None,
    ):
        # This parameter is required.
        self.member_id = member_id
        # This parameter is required.
        self.member_type = member_type
        # This parameter is required.
        self.role_type = role_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.member_id is not None:
            result['MemberId'] = self.member_id
        if self.member_type is not None:
            result['MemberType'] = self.member_type
        if self.role_type is not None:
            result['RoleType'] = self.role_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemberId') is not None:
            self.member_id = m.get('MemberId')
        if m.get('MemberType') is not None:
            self.member_type = m.get('MemberType')
        if m.get('RoleType') is not None:
            self.role_type = m.get('RoleType')
        return self


class AddWorkspaceDocMembersRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class AddWorkspaceDocMembersRequest(TeaModel):
    def __init__(
        self,
        members: List[AddWorkspaceDocMembersRequestMembers] = None,
        node_id: str = None,
        tenant_context: AddWorkspaceDocMembersRequestTenantContext = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.members = members
        # This parameter is required.
        self.node_id = node_id
        self.tenant_context = tenant_context
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.members:
            for k in self.members:
                if k:
                    k.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Members'] = []
        if self.members is not None:
            for k in self.members:
                result['Members'].append(k.to_map() if k else None)
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.members = []
        if m.get('Members') is not None:
            for k in m.get('Members'):
                temp_model = AddWorkspaceDocMembersRequestMembers()
                self.members.append(temp_model.from_map(k))
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('TenantContext') is not None:
            temp_model = AddWorkspaceDocMembersRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class AddWorkspaceDocMembersShrinkRequest(TeaModel):
    def __init__(
        self,
        members_shrink: str = None,
        node_id: str = None,
        tenant_context_shrink: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.members_shrink = members_shrink
        # This parameter is required.
        self.node_id = node_id
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.members_shrink is not None:
            result['Members'] = self.members_shrink
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Members') is not None:
            self.members_shrink = m.get('Members')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class AddWorkspaceDocMembersResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class AddWorkspaceDocMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddWorkspaceDocMembersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddWorkspaceDocMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddWorkspaceMembersHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class AddWorkspaceMembersHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: AddWorkspaceMembersHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = AddWorkspaceMembersHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class AddWorkspaceMembersShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class AddWorkspaceMembersRequestMembers(TeaModel):
    def __init__(
        self,
        member_id: str = None,
        member_type: str = None,
        role_type: str = None,
    ):
        self.member_id = member_id
        self.member_type = member_type
        self.role_type = role_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.member_id is not None:
            result['MemberId'] = self.member_id
        if self.member_type is not None:
            result['MemberType'] = self.member_type
        if self.role_type is not None:
            result['RoleType'] = self.role_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemberId') is not None:
            self.member_id = m.get('MemberId')
        if m.get('MemberType') is not None:
            self.member_type = m.get('MemberType')
        if m.get('RoleType') is not None:
            self.role_type = m.get('RoleType')
        return self


class AddWorkspaceMembersRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class AddWorkspaceMembersRequest(TeaModel):
    def __init__(
        self,
        members: List[AddWorkspaceMembersRequestMembers] = None,
        tenant_context: AddWorkspaceMembersRequestTenantContext = None,
        workspace_id: str = None,
    ):
        self.members = members
        self.tenant_context = tenant_context
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.members:
            for k in self.members:
                if k:
                    k.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Members'] = []
        if self.members is not None:
            for k in self.members:
                result['Members'].append(k.to_map() if k else None)
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.members = []
        if m.get('Members') is not None:
            for k in m.get('Members'):
                temp_model = AddWorkspaceMembersRequestMembers()
                self.members.append(temp_model.from_map(k))
        if m.get('TenantContext') is not None:
            temp_model = AddWorkspaceMembersRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class AddWorkspaceMembersShrinkRequest(TeaModel):
    def __init__(
        self,
        members_shrink: str = None,
        tenant_context_shrink: str = None,
        workspace_id: str = None,
    ):
        self.members_shrink = members_shrink
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.members_shrink is not None:
            result['Members'] = self.members_shrink
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Members') is not None:
            self.members_shrink = m.get('Members')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class AddWorkspaceMembersResponseBody(TeaModel):
    def __init__(
        self,
        not_in_org_list: List[str] = None,
        request_id: str = None,
    ):
        self.not_in_org_list = not_in_org_list
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.not_in_org_list is not None:
            result['NotInOrgList'] = self.not_in_org_list
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NotInOrgList') is not None:
            self.not_in_org_list = m.get('NotInOrgList')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class AddWorkspaceMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddWorkspaceMembersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddWorkspaceMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AssignTicketHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class AssignTicketHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: AssignTicketHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = AssignTicketHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class AssignTicketShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class AssignTicketRequestNotify(TeaModel):
    def __init__(
        self,
        group_notice_receiver_user_ids: List[str] = None,
        notice_all_group_member: bool = None,
        work_notice_receiver_user_ids: List[str] = None,
    ):
        self.group_notice_receiver_user_ids = group_notice_receiver_user_ids
        self.notice_all_group_member = notice_all_group_member
        self.work_notice_receiver_user_ids = work_notice_receiver_user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_notice_receiver_user_ids is not None:
            result['GroupNoticeReceiverUserIds'] = self.group_notice_receiver_user_ids
        if self.notice_all_group_member is not None:
            result['NoticeAllGroupMember'] = self.notice_all_group_member
        if self.work_notice_receiver_user_ids is not None:
            result['WorkNoticeReceiverUserIds'] = self.work_notice_receiver_user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupNoticeReceiverUserIds') is not None:
            self.group_notice_receiver_user_ids = m.get('GroupNoticeReceiverUserIds')
        if m.get('NoticeAllGroupMember') is not None:
            self.notice_all_group_member = m.get('NoticeAllGroupMember')
        if m.get('WorkNoticeReceiverUserIds') is not None:
            self.work_notice_receiver_user_ids = m.get('WorkNoticeReceiverUserIds')
        return self


class AssignTicketRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class AssignTicketRequestTicketMemoAttachments(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        key: str = None,
    ):
        self.file_name = file_name
        self.key = key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.key is not None:
            result['Key'] = self.key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        return self


class AssignTicketRequestTicketMemo(TeaModel):
    def __init__(
        self,
        attachments: List[AssignTicketRequestTicketMemoAttachments] = None,
        memo: str = None,
    ):
        self.attachments = attachments
        self.memo = memo

    def validate(self):
        if self.attachments:
            for k in self.attachments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Attachments'] = []
        if self.attachments is not None:
            for k in self.attachments:
                result['Attachments'].append(k.to_map() if k else None)
        if self.memo is not None:
            result['Memo'] = self.memo
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attachments = []
        if m.get('Attachments') is not None:
            for k in m.get('Attachments'):
                temp_model = AssignTicketRequestTicketMemoAttachments()
                self.attachments.append(temp_model.from_map(k))
        if m.get('Memo') is not None:
            self.memo = m.get('Memo')
        return self


class AssignTicketRequest(TeaModel):
    def __init__(
        self,
        notify: AssignTicketRequestNotify = None,
        open_team_id: str = None,
        open_ticket_id: str = None,
        processor_user_ids: List[str] = None,
        tenant_context: AssignTicketRequestTenantContext = None,
        ticket_memo: AssignTicketRequestTicketMemo = None,
    ):
        self.notify = notify
        # This parameter is required.
        self.open_team_id = open_team_id
        # This parameter is required.
        self.open_ticket_id = open_ticket_id
        self.processor_user_ids = processor_user_ids
        self.tenant_context = tenant_context
        self.ticket_memo = ticket_memo

    def validate(self):
        if self.notify:
            self.notify.validate()
        if self.tenant_context:
            self.tenant_context.validate()
        if self.ticket_memo:
            self.ticket_memo.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notify is not None:
            result['Notify'] = self.notify.to_map()
        if self.open_team_id is not None:
            result['OpenTeamId'] = self.open_team_id
        if self.open_ticket_id is not None:
            result['OpenTicketId'] = self.open_ticket_id
        if self.processor_user_ids is not None:
            result['ProcessorUserIds'] = self.processor_user_ids
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.ticket_memo is not None:
            result['TicketMemo'] = self.ticket_memo.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Notify') is not None:
            temp_model = AssignTicketRequestNotify()
            self.notify = temp_model.from_map(m['Notify'])
        if m.get('OpenTeamId') is not None:
            self.open_team_id = m.get('OpenTeamId')
        if m.get('OpenTicketId') is not None:
            self.open_ticket_id = m.get('OpenTicketId')
        if m.get('ProcessorUserIds') is not None:
            self.processor_user_ids = m.get('ProcessorUserIds')
        if m.get('TenantContext') is not None:
            temp_model = AssignTicketRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('TicketMemo') is not None:
            temp_model = AssignTicketRequestTicketMemo()
            self.ticket_memo = temp_model.from_map(m['TicketMemo'])
        return self


class AssignTicketShrinkRequest(TeaModel):
    def __init__(
        self,
        notify_shrink: str = None,
        open_team_id: str = None,
        open_ticket_id: str = None,
        processor_user_ids_shrink: str = None,
        tenant_context_shrink: str = None,
        ticket_memo_shrink: str = None,
    ):
        self.notify_shrink = notify_shrink
        # This parameter is required.
        self.open_team_id = open_team_id
        # This parameter is required.
        self.open_ticket_id = open_ticket_id
        self.processor_user_ids_shrink = processor_user_ids_shrink
        self.tenant_context_shrink = tenant_context_shrink
        self.ticket_memo_shrink = ticket_memo_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notify_shrink is not None:
            result['Notify'] = self.notify_shrink
        if self.open_team_id is not None:
            result['OpenTeamId'] = self.open_team_id
        if self.open_ticket_id is not None:
            result['OpenTicketId'] = self.open_ticket_id
        if self.processor_user_ids_shrink is not None:
            result['ProcessorUserIds'] = self.processor_user_ids_shrink
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.ticket_memo_shrink is not None:
            result['TicketMemo'] = self.ticket_memo_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Notify') is not None:
            self.notify_shrink = m.get('Notify')
        if m.get('OpenTeamId') is not None:
            self.open_team_id = m.get('OpenTeamId')
        if m.get('OpenTicketId') is not None:
            self.open_ticket_id = m.get('OpenTicketId')
        if m.get('ProcessorUserIds') is not None:
            self.processor_user_ids_shrink = m.get('ProcessorUserIds')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('TicketMemo') is not None:
            self.ticket_memo_shrink = m.get('TicketMemo')
        return self


class AssignTicketResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class AssignTicketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AssignTicketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AssignTicketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchGetFormDataByIdListHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class BatchGetFormDataByIdListHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: BatchGetFormDataByIdListHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = BatchGetFormDataByIdListHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class BatchGetFormDataByIdListShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class BatchGetFormDataByIdListRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        form_instance_id_list: List[str] = None,
        form_uuid: str = None,
        need_form_instance_value: bool = None,
        system_token: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        # This parameter is required.
        self.form_instance_id_list = form_instance_id_list
        # This parameter is required.
        self.form_uuid = form_uuid
        self.need_form_instance_value = need_form_instance_value
        # This parameter is required.
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.form_instance_id_list is not None:
            result['FormInstanceIdList'] = self.form_instance_id_list
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.need_form_instance_value is not None:
            result['NeedFormInstanceValue'] = self.need_form_instance_value
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('FormInstanceIdList') is not None:
            self.form_instance_id_list = m.get('FormInstanceIdList')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('NeedFormInstanceValue') is not None:
            self.need_form_instance_value = m.get('NeedFormInstanceValue')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class BatchGetFormDataByIdListShrinkRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        form_instance_id_list_shrink: str = None,
        form_uuid: str = None,
        need_form_instance_value: bool = None,
        system_token: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        # This parameter is required.
        self.form_instance_id_list_shrink = form_instance_id_list_shrink
        # This parameter is required.
        self.form_uuid = form_uuid
        self.need_form_instance_value = need_form_instance_value
        # This parameter is required.
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.form_instance_id_list_shrink is not None:
            result['FormInstanceIdList'] = self.form_instance_id_list_shrink
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.need_form_instance_value is not None:
            result['NeedFormInstanceValue'] = self.need_form_instance_value
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('FormInstanceIdList') is not None:
            self.form_instance_id_list_shrink = m.get('FormInstanceIdList')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('NeedFormInstanceValue') is not None:
            self.need_form_instance_value = m.get('NeedFormInstanceValue')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class BatchGetFormDataByIdListResponseBodyResultModifyUserName(TeaModel):
    def __init__(
        self,
        name_in_chinese: str = None,
        name_in_english: str = None,
    ):
        self.name_in_chinese = name_in_chinese
        self.name_in_english = name_in_english

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_in_chinese is not None:
            result['NameInChinese'] = self.name_in_chinese
        if self.name_in_english is not None:
            result['NameInEnglish'] = self.name_in_english
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameInChinese') is not None:
            self.name_in_chinese = m.get('NameInChinese')
        if m.get('NameInEnglish') is not None:
            self.name_in_english = m.get('NameInEnglish')
        return self


class BatchGetFormDataByIdListResponseBodyResultModifyUser(TeaModel):
    def __init__(
        self,
        name: BatchGetFormDataByIdListResponseBodyResultModifyUserName = None,
        user_id: str = None,
    ):
        self.name = name
        self.user_id = user_id

    def validate(self):
        if self.name:
            self.name.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            temp_model = BatchGetFormDataByIdListResponseBodyResultModifyUserName()
            self.name = temp_model.from_map(m['Name'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class BatchGetFormDataByIdListResponseBodyResultOriginatorName(TeaModel):
    def __init__(
        self,
        name_in_chinese: str = None,
        name_in_english: str = None,
    ):
        self.name_in_chinese = name_in_chinese
        self.name_in_english = name_in_english

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_in_chinese is not None:
            result['NameInChinese'] = self.name_in_chinese
        if self.name_in_english is not None:
            result['NameInEnglish'] = self.name_in_english
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameInChinese') is not None:
            self.name_in_chinese = m.get('NameInChinese')
        if m.get('NameInEnglish') is not None:
            self.name_in_english = m.get('NameInEnglish')
        return self


class BatchGetFormDataByIdListResponseBodyResultOriginator(TeaModel):
    def __init__(
        self,
        name: BatchGetFormDataByIdListResponseBodyResultOriginatorName = None,
        user_id: str = None,
    ):
        self.name = name
        self.user_id = user_id

    def validate(self):
        if self.name:
            self.name.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            temp_model = BatchGetFormDataByIdListResponseBodyResultOriginatorName()
            self.name = temp_model.from_map(m['Name'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class BatchGetFormDataByIdListResponseBodyResult(TeaModel):
    def __init__(
        self,
        create_time_gmt: str = None,
        creator_user_id: str = None,
        form_data: Dict[str, Any] = None,
        form_instance_id: str = None,
        form_uuid: str = None,
        id: int = None,
        instance_value: str = None,
        modified_time_gmt: str = None,
        modifier: str = None,
        modify_user: BatchGetFormDataByIdListResponseBodyResultModifyUser = None,
        originator: BatchGetFormDataByIdListResponseBodyResultOriginator = None,
        sequence: str = None,
        serial_number: str = None,
        title: str = None,
        version: int = None,
    ):
        self.create_time_gmt = create_time_gmt
        self.creator_user_id = creator_user_id
        self.form_data = form_data
        self.form_instance_id = form_instance_id
        self.form_uuid = form_uuid
        self.id = id
        self.instance_value = instance_value
        self.modified_time_gmt = modified_time_gmt
        self.modifier = modifier
        self.modify_user = modify_user
        self.originator = originator
        self.sequence = sequence
        self.serial_number = serial_number
        self.title = title
        self.version = version

    def validate(self):
        if self.modify_user:
            self.modify_user.validate()
        if self.originator:
            self.originator.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time_gmt is not None:
            result['CreateTimeGMT'] = self.create_time_gmt
        if self.creator_user_id is not None:
            result['CreatorUserId'] = self.creator_user_id
        if self.form_data is not None:
            result['FormData'] = self.form_data
        if self.form_instance_id is not None:
            result['FormInstanceId'] = self.form_instance_id
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_value is not None:
            result['InstanceValue'] = self.instance_value
        if self.modified_time_gmt is not None:
            result['ModifiedTimeGMT'] = self.modified_time_gmt
        if self.modifier is not None:
            result['Modifier'] = self.modifier
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user.to_map()
        if self.originator is not None:
            result['Originator'] = self.originator.to_map()
        if self.sequence is not None:
            result['Sequence'] = self.sequence
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        if self.title is not None:
            result['Title'] = self.title
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTimeGMT') is not None:
            self.create_time_gmt = m.get('CreateTimeGMT')
        if m.get('CreatorUserId') is not None:
            self.creator_user_id = m.get('CreatorUserId')
        if m.get('FormData') is not None:
            self.form_data = m.get('FormData')
        if m.get('FormInstanceId') is not None:
            self.form_instance_id = m.get('FormInstanceId')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceValue') is not None:
            self.instance_value = m.get('InstanceValue')
        if m.get('ModifiedTimeGMT') is not None:
            self.modified_time_gmt = m.get('ModifiedTimeGMT')
        if m.get('Modifier') is not None:
            self.modifier = m.get('Modifier')
        if m.get('ModifyUser') is not None:
            temp_model = BatchGetFormDataByIdListResponseBodyResultModifyUser()
            self.modify_user = temp_model.from_map(m['ModifyUser'])
        if m.get('Originator') is not None:
            temp_model = BatchGetFormDataByIdListResponseBodyResultOriginator()
            self.originator = temp_model.from_map(m['Originator'])
        if m.get('Sequence') is not None:
            self.sequence = m.get('Sequence')
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class BatchGetFormDataByIdListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: List[BatchGetFormDataByIdListResponseBodyResult] = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.result = result
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = BatchGetFormDataByIdListResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class BatchGetFormDataByIdListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchGetFormDataByIdListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchGetFormDataByIdListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchRemovalByFormInstanceIdListHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class BatchRemovalByFormInstanceIdListHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: BatchRemovalByFormInstanceIdListHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = BatchRemovalByFormInstanceIdListHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class BatchRemovalByFormInstanceIdListShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class BatchRemovalByFormInstanceIdListRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        asynchronous_execution: bool = None,
        execute_expression: bool = None,
        form_instance_id_list: List[str] = None,
        form_uuid: str = None,
        system_token: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        self.asynchronous_execution = asynchronous_execution
        self.execute_expression = execute_expression
        # This parameter is required.
        self.form_instance_id_list = form_instance_id_list
        # This parameter is required.
        self.form_uuid = form_uuid
        # This parameter is required.
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.asynchronous_execution is not None:
            result['AsynchronousExecution'] = self.asynchronous_execution
        if self.execute_expression is not None:
            result['ExecuteExpression'] = self.execute_expression
        if self.form_instance_id_list is not None:
            result['FormInstanceIdList'] = self.form_instance_id_list
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('AsynchronousExecution') is not None:
            self.asynchronous_execution = m.get('AsynchronousExecution')
        if m.get('ExecuteExpression') is not None:
            self.execute_expression = m.get('ExecuteExpression')
        if m.get('FormInstanceIdList') is not None:
            self.form_instance_id_list = m.get('FormInstanceIdList')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class BatchRemovalByFormInstanceIdListShrinkRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        asynchronous_execution: bool = None,
        execute_expression: bool = None,
        form_instance_id_list_shrink: str = None,
        form_uuid: str = None,
        system_token: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        self.asynchronous_execution = asynchronous_execution
        self.execute_expression = execute_expression
        # This parameter is required.
        self.form_instance_id_list_shrink = form_instance_id_list_shrink
        # This parameter is required.
        self.form_uuid = form_uuid
        # This parameter is required.
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.asynchronous_execution is not None:
            result['AsynchronousExecution'] = self.asynchronous_execution
        if self.execute_expression is not None:
            result['ExecuteExpression'] = self.execute_expression
        if self.form_instance_id_list_shrink is not None:
            result['FormInstanceIdList'] = self.form_instance_id_list_shrink
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('AsynchronousExecution') is not None:
            self.asynchronous_execution = m.get('AsynchronousExecution')
        if m.get('ExecuteExpression') is not None:
            self.execute_expression = m.get('ExecuteExpression')
        if m.get('FormInstanceIdList') is not None:
            self.form_instance_id_list_shrink = m.get('FormInstanceIdList')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class BatchRemovalByFormInstanceIdListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class BatchRemovalByFormInstanceIdListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchRemovalByFormInstanceIdListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchRemovalByFormInstanceIdListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchSaveFormDataHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class BatchSaveFormDataHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: BatchSaveFormDataHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = BatchSaveFormDataHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class BatchSaveFormDataShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class BatchSaveFormDataRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        asynchronous_execution: bool = None,
        form_data_json_list: List[str] = None,
        form_uuid: str = None,
        keep_running_after_exception: bool = None,
        no_execute_expression: bool = None,
        system_token: str = None,
    ):
        self.app_type = app_type
        self.asynchronous_execution = asynchronous_execution
        self.form_data_json_list = form_data_json_list
        self.form_uuid = form_uuid
        self.keep_running_after_exception = keep_running_after_exception
        self.no_execute_expression = no_execute_expression
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.asynchronous_execution is not None:
            result['AsynchronousExecution'] = self.asynchronous_execution
        if self.form_data_json_list is not None:
            result['FormDataJsonList'] = self.form_data_json_list
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.keep_running_after_exception is not None:
            result['KeepRunningAfterException'] = self.keep_running_after_exception
        if self.no_execute_expression is not None:
            result['NoExecuteExpression'] = self.no_execute_expression
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('AsynchronousExecution') is not None:
            self.asynchronous_execution = m.get('AsynchronousExecution')
        if m.get('FormDataJsonList') is not None:
            self.form_data_json_list = m.get('FormDataJsonList')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('KeepRunningAfterException') is not None:
            self.keep_running_after_exception = m.get('KeepRunningAfterException')
        if m.get('NoExecuteExpression') is not None:
            self.no_execute_expression = m.get('NoExecuteExpression')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class BatchSaveFormDataShrinkRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        asynchronous_execution: bool = None,
        form_data_json_list_shrink: str = None,
        form_uuid: str = None,
        keep_running_after_exception: bool = None,
        no_execute_expression: bool = None,
        system_token: str = None,
    ):
        self.app_type = app_type
        self.asynchronous_execution = asynchronous_execution
        self.form_data_json_list_shrink = form_data_json_list_shrink
        self.form_uuid = form_uuid
        self.keep_running_after_exception = keep_running_after_exception
        self.no_execute_expression = no_execute_expression
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.asynchronous_execution is not None:
            result['AsynchronousExecution'] = self.asynchronous_execution
        if self.form_data_json_list_shrink is not None:
            result['FormDataJsonList'] = self.form_data_json_list_shrink
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.keep_running_after_exception is not None:
            result['KeepRunningAfterException'] = self.keep_running_after_exception
        if self.no_execute_expression is not None:
            result['NoExecuteExpression'] = self.no_execute_expression
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('AsynchronousExecution') is not None:
            self.asynchronous_execution = m.get('AsynchronousExecution')
        if m.get('FormDataJsonList') is not None:
            self.form_data_json_list_shrink = m.get('FormDataJsonList')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('KeepRunningAfterException') is not None:
            self.keep_running_after_exception = m.get('KeepRunningAfterException')
        if m.get('NoExecuteExpression') is not None:
            self.no_execute_expression = m.get('NoExecuteExpression')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class BatchSaveFormDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: List[str] = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.result = result
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class BatchSaveFormDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchSaveFormDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchSaveFormDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchUpdateFormDataByInstanceIdHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class BatchUpdateFormDataByInstanceIdHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: BatchUpdateFormDataByInstanceIdHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = BatchUpdateFormDataByInstanceIdHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class BatchUpdateFormDataByInstanceIdShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class BatchUpdateFormDataByInstanceIdRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        asynchronous_execution: bool = None,
        form_instance_id_list: List[str] = None,
        form_uuid: str = None,
        ignore_empty: bool = None,
        no_execute_expression: bool = None,
        system_token: str = None,
        update_form_data_json: str = None,
        use_latest_form_schema_version: bool = None,
    ):
        self.app_type = app_type
        self.asynchronous_execution = asynchronous_execution
        # This parameter is required.
        self.form_instance_id_list = form_instance_id_list
        # This parameter is required.
        self.form_uuid = form_uuid
        self.ignore_empty = ignore_empty
        self.no_execute_expression = no_execute_expression
        # This parameter is required.
        self.system_token = system_token
        # This parameter is required.
        self.update_form_data_json = update_form_data_json
        self.use_latest_form_schema_version = use_latest_form_schema_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.asynchronous_execution is not None:
            result['AsynchronousExecution'] = self.asynchronous_execution
        if self.form_instance_id_list is not None:
            result['FormInstanceIdList'] = self.form_instance_id_list
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.ignore_empty is not None:
            result['IgnoreEmpty'] = self.ignore_empty
        if self.no_execute_expression is not None:
            result['NoExecuteExpression'] = self.no_execute_expression
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        if self.update_form_data_json is not None:
            result['UpdateFormDataJson'] = self.update_form_data_json
        if self.use_latest_form_schema_version is not None:
            result['UseLatestFormSchemaVersion'] = self.use_latest_form_schema_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('AsynchronousExecution') is not None:
            self.asynchronous_execution = m.get('AsynchronousExecution')
        if m.get('FormInstanceIdList') is not None:
            self.form_instance_id_list = m.get('FormInstanceIdList')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('IgnoreEmpty') is not None:
            self.ignore_empty = m.get('IgnoreEmpty')
        if m.get('NoExecuteExpression') is not None:
            self.no_execute_expression = m.get('NoExecuteExpression')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        if m.get('UpdateFormDataJson') is not None:
            self.update_form_data_json = m.get('UpdateFormDataJson')
        if m.get('UseLatestFormSchemaVersion') is not None:
            self.use_latest_form_schema_version = m.get('UseLatestFormSchemaVersion')
        return self


class BatchUpdateFormDataByInstanceIdShrinkRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        asynchronous_execution: bool = None,
        form_instance_id_list_shrink: str = None,
        form_uuid: str = None,
        ignore_empty: bool = None,
        no_execute_expression: bool = None,
        system_token: str = None,
        update_form_data_json: str = None,
        use_latest_form_schema_version: bool = None,
    ):
        self.app_type = app_type
        self.asynchronous_execution = asynchronous_execution
        # This parameter is required.
        self.form_instance_id_list_shrink = form_instance_id_list_shrink
        # This parameter is required.
        self.form_uuid = form_uuid
        self.ignore_empty = ignore_empty
        self.no_execute_expression = no_execute_expression
        # This parameter is required.
        self.system_token = system_token
        # This parameter is required.
        self.update_form_data_json = update_form_data_json
        self.use_latest_form_schema_version = use_latest_form_schema_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.asynchronous_execution is not None:
            result['AsynchronousExecution'] = self.asynchronous_execution
        if self.form_instance_id_list_shrink is not None:
            result['FormInstanceIdList'] = self.form_instance_id_list_shrink
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.ignore_empty is not None:
            result['IgnoreEmpty'] = self.ignore_empty
        if self.no_execute_expression is not None:
            result['NoExecuteExpression'] = self.no_execute_expression
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        if self.update_form_data_json is not None:
            result['UpdateFormDataJson'] = self.update_form_data_json
        if self.use_latest_form_schema_version is not None:
            result['UseLatestFormSchemaVersion'] = self.use_latest_form_schema_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('AsynchronousExecution') is not None:
            self.asynchronous_execution = m.get('AsynchronousExecution')
        if m.get('FormInstanceIdList') is not None:
            self.form_instance_id_list_shrink = m.get('FormInstanceIdList')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('IgnoreEmpty') is not None:
            self.ignore_empty = m.get('IgnoreEmpty')
        if m.get('NoExecuteExpression') is not None:
            self.no_execute_expression = m.get('NoExecuteExpression')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        if m.get('UpdateFormDataJson') is not None:
            self.update_form_data_json = m.get('UpdateFormDataJson')
        if m.get('UseLatestFormSchemaVersion') is not None:
            self.use_latest_form_schema_version = m.get('UseLatestFormSchemaVersion')
        return self


class BatchUpdateFormDataByInstanceIdResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: List[str] = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.result = result
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class BatchUpdateFormDataByInstanceIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchUpdateFormDataByInstanceIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchUpdateFormDataByInstanceIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchUpdateFormDataByInstanceMapHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class BatchUpdateFormDataByInstanceMapHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: BatchUpdateFormDataByInstanceMapHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = BatchUpdateFormDataByInstanceMapHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class BatchUpdateFormDataByInstanceMapShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class BatchUpdateFormDataByInstanceMapRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        asynchronous_execution: bool = None,
        form_uuid: str = None,
        ignore_empty: bool = None,
        no_execute_expression: bool = None,
        system_token: str = None,
        update_form_data_json_map: Dict[str, Any] = None,
        use_latest_form_schema_version: bool = None,
    ):
        self.app_type = app_type
        self.asynchronous_execution = asynchronous_execution
        self.form_uuid = form_uuid
        self.ignore_empty = ignore_empty
        self.no_execute_expression = no_execute_expression
        self.system_token = system_token
        self.update_form_data_json_map = update_form_data_json_map
        self.use_latest_form_schema_version = use_latest_form_schema_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.asynchronous_execution is not None:
            result['AsynchronousExecution'] = self.asynchronous_execution
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.ignore_empty is not None:
            result['IgnoreEmpty'] = self.ignore_empty
        if self.no_execute_expression is not None:
            result['NoExecuteExpression'] = self.no_execute_expression
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        if self.update_form_data_json_map is not None:
            result['UpdateFormDataJsonMap'] = self.update_form_data_json_map
        if self.use_latest_form_schema_version is not None:
            result['UseLatestFormSchemaVersion'] = self.use_latest_form_schema_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('AsynchronousExecution') is not None:
            self.asynchronous_execution = m.get('AsynchronousExecution')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('IgnoreEmpty') is not None:
            self.ignore_empty = m.get('IgnoreEmpty')
        if m.get('NoExecuteExpression') is not None:
            self.no_execute_expression = m.get('NoExecuteExpression')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        if m.get('UpdateFormDataJsonMap') is not None:
            self.update_form_data_json_map = m.get('UpdateFormDataJsonMap')
        if m.get('UseLatestFormSchemaVersion') is not None:
            self.use_latest_form_schema_version = m.get('UseLatestFormSchemaVersion')
        return self


class BatchUpdateFormDataByInstanceMapShrinkRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        asynchronous_execution: bool = None,
        form_uuid: str = None,
        ignore_empty: bool = None,
        no_execute_expression: bool = None,
        system_token: str = None,
        update_form_data_json_map_shrink: str = None,
        use_latest_form_schema_version: bool = None,
    ):
        self.app_type = app_type
        self.asynchronous_execution = asynchronous_execution
        self.form_uuid = form_uuid
        self.ignore_empty = ignore_empty
        self.no_execute_expression = no_execute_expression
        self.system_token = system_token
        self.update_form_data_json_map_shrink = update_form_data_json_map_shrink
        self.use_latest_form_schema_version = use_latest_form_schema_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.asynchronous_execution is not None:
            result['AsynchronousExecution'] = self.asynchronous_execution
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.ignore_empty is not None:
            result['IgnoreEmpty'] = self.ignore_empty
        if self.no_execute_expression is not None:
            result['NoExecuteExpression'] = self.no_execute_expression
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        if self.update_form_data_json_map_shrink is not None:
            result['UpdateFormDataJsonMap'] = self.update_form_data_json_map_shrink
        if self.use_latest_form_schema_version is not None:
            result['UseLatestFormSchemaVersion'] = self.use_latest_form_schema_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('AsynchronousExecution') is not None:
            self.asynchronous_execution = m.get('AsynchronousExecution')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('IgnoreEmpty') is not None:
            self.ignore_empty = m.get('IgnoreEmpty')
        if m.get('NoExecuteExpression') is not None:
            self.no_execute_expression = m.get('NoExecuteExpression')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        if m.get('UpdateFormDataJsonMap') is not None:
            self.update_form_data_json_map_shrink = m.get('UpdateFormDataJsonMap')
        if m.get('UseLatestFormSchemaVersion') is not None:
            self.use_latest_form_schema_version = m.get('UseLatestFormSchemaVersion')
        return self


class BatchUpdateFormDataByInstanceMapResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: List[str] = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.result = result
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class BatchUpdateFormDataByInstanceMapResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchUpdateFormDataByInstanceMapResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchUpdateFormDataByInstanceMapResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelScheduleConferenceHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CancelScheduleConferenceHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CancelScheduleConferenceHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CancelScheduleConferenceHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CancelScheduleConferenceShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CancelScheduleConferenceRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CancelScheduleConferenceRequest(TeaModel):
    def __init__(
        self,
        schedule_conference_id: str = None,
        tenant_context: CancelScheduleConferenceRequestTenantContext = None,
    ):
        # This parameter is required.
        self.schedule_conference_id = schedule_conference_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.schedule_conference_id is not None:
            result['ScheduleConferenceId'] = self.schedule_conference_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ScheduleConferenceId') is not None:
            self.schedule_conference_id = m.get('ScheduleConferenceId')
        if m.get('TenantContext') is not None:
            temp_model = CancelScheduleConferenceRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class CancelScheduleConferenceShrinkRequest(TeaModel):
    def __init__(
        self,
        schedule_conference_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.schedule_conference_id = schedule_conference_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.schedule_conference_id is not None:
            result['ScheduleConferenceId'] = self.schedule_conference_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ScheduleConferenceId') is not None:
            self.schedule_conference_id = m.get('ScheduleConferenceId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class CancelScheduleConferenceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # requestId
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CancelScheduleConferenceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CancelScheduleConferenceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelScheduleConferenceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckAlibabaStaffHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CheckAlibabaStaffHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CheckAlibabaStaffHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CheckAlibabaStaffHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CheckAlibabaStaffShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CheckAlibabaStaffRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CheckAlibabaStaffRequest(TeaModel):
    def __init__(
        self,
        mobile: str = None,
        tenant_context: CheckAlibabaStaffRequestTenantContext = None,
    ):
        self.mobile = mobile
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('TenantContext') is not None:
            temp_model = CheckAlibabaStaffRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class CheckAlibabaStaffShrinkRequest(TeaModel):
    def __init__(
        self,
        mobile: str = None,
        tenant_context_shrink: str = None,
    ):
        self.mobile = mobile
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class CheckAlibabaStaffResponseBody(TeaModel):
    def __init__(
        self,
        is_alibaba_staff: bool = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.is_alibaba_staff = is_alibaba_staff
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_alibaba_staff is not None:
            result['isAlibabaStaff'] = self.is_alibaba_staff
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('isAlibabaStaff') is not None:
            self.is_alibaba_staff = m.get('isAlibabaStaff')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class CheckAlibabaStaffResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CheckAlibabaStaffResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CheckAlibabaStaffResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckUserIsGroupMemberHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CheckUserIsGroupMemberHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CheckUserIsGroupMemberHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CheckUserIsGroupMemberHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CheckUserIsGroupMemberShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CheckUserIsGroupMemberRequest(TeaModel):
    def __init__(
        self,
        open_conversation_id: str = None,
    ):
        self.open_conversation_id = open_conversation_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.open_conversation_id is not None:
            result['OpenConversationId'] = self.open_conversation_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OpenConversationId') is not None:
            self.open_conversation_id = m.get('OpenConversationId')
        return self


class CheckUserIsGroupMemberResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.result = result
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class CheckUserIsGroupMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CheckUserIsGroupMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CheckUserIsGroupMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ClearHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ClearHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ClearHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ClearHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ClearShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ClearRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class ClearRequest(TeaModel):
    def __init__(
        self,
        range_address: str = None,
        sheet_id: str = None,
        tenant_context: ClearRequestTenantContext = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.range_address = range_address
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context = tenant_context
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.range_address is not None:
            result['RangeAddress'] = self.range_address
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RangeAddress') is not None:
            self.range_address = m.get('RangeAddress')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            temp_model = ClearRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class ClearShrinkRequest(TeaModel):
    def __init__(
        self,
        range_address: str = None,
        sheet_id: str = None,
        tenant_context_shrink: str = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.range_address = range_address
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.range_address is not None:
            result['RangeAddress'] = self.range_address
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RangeAddress') is not None:
            self.range_address = m.get('RangeAddress')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class ClearResponseBody(TeaModel):
    def __init__(
        self,
        a_1notation: str = None,
        request_id: str = None,
    ):
        self.a_1notation = a_1notation
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.a_1notation is not None:
            result['a1Notation'] = self.a_1notation
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('a1Notation') is not None:
            self.a_1notation = m.get('a1Notation')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ClearResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ClearResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ClearResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ClearDataHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ClearDataHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ClearDataHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ClearDataHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ClearDataShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ClearDataRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class ClearDataRequest(TeaModel):
    def __init__(
        self,
        range_address: str = None,
        sheet_id: str = None,
        tenant_context: ClearDataRequestTenantContext = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.range_address = range_address
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context = tenant_context
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.range_address is not None:
            result['RangeAddress'] = self.range_address
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RangeAddress') is not None:
            self.range_address = m.get('RangeAddress')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            temp_model = ClearDataRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class ClearDataShrinkRequest(TeaModel):
    def __init__(
        self,
        range_address: str = None,
        sheet_id: str = None,
        tenant_context_shrink: str = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.range_address = range_address
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.range_address is not None:
            result['RangeAddress'] = self.range_address
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RangeAddress') is not None:
            self.range_address = m.get('RangeAddress')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class ClearDataResponseBody(TeaModel):
    def __init__(
        self,
        a_1notation: str = None,
        request_id: str = None,
    ):
        self.a_1notation = a_1notation
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.a_1notation is not None:
            result['a1Notation'] = self.a_1notation
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('a1Notation') is not None:
            self.a_1notation = m.get('a1Notation')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ClearDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ClearDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ClearDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CloseVideoConferenceHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CloseVideoConferenceHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CloseVideoConferenceHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CloseVideoConferenceHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CloseVideoConferenceShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CloseVideoConferenceRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CloseVideoConferenceRequest(TeaModel):
    def __init__(
        self,
        tenant_context: CloseVideoConferenceRequestTenantContext = None,
        conference_id: str = None,
    ):
        self.tenant_context = tenant_context
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = CloseVideoConferenceRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class CloseVideoConferenceShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        conference_id: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class CloseVideoConferenceResponseBody(TeaModel):
    def __init__(
        self,
        cause: str = None,
        code: int = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.cause = cause
        self.code = code
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cause is not None:
            result['cause'] = self.cause
        if self.code is not None:
            result['code'] = self.code
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cause') is not None:
            self.cause = m.get('cause')
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class CloseVideoConferenceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CloseVideoConferenceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CloseVideoConferenceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CommentListReportHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CommentListReportHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CommentListReportHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CommentListReportHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CommentListReportShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CommentListReportRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CommentListReportRequest(TeaModel):
    def __init__(
        self,
        offset: int = None,
        report_id: str = None,
        size: int = None,
        tenant_context: CommentListReportRequestTenantContext = None,
    ):
        # This parameter is required.
        self.offset = offset
        # This parameter is required.
        self.report_id = report_id
        # This parameter is required.
        self.size = size
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.offset is not None:
            result['Offset'] = self.offset
        if self.report_id is not None:
            result['ReportId'] = self.report_id
        if self.size is not None:
            result['Size'] = self.size
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        if m.get('ReportId') is not None:
            self.report_id = m.get('ReportId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('TenantContext') is not None:
            temp_model = CommentListReportRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class CommentListReportShrinkRequest(TeaModel):
    def __init__(
        self,
        offset: int = None,
        report_id: str = None,
        size: int = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.offset = offset
        # This parameter is required.
        self.report_id = report_id
        # This parameter is required.
        self.size = size
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.offset is not None:
            result['Offset'] = self.offset
        if self.report_id is not None:
            result['ReportId'] = self.report_id
        if self.size is not None:
            result['Size'] = self.size
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        if m.get('ReportId') is not None:
            self.report_id = m.get('ReportId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class CommentListReportResponseBodyComments(TeaModel):
    def __init__(
        self,
        content: str = None,
        create_time: str = None,
        userid: str = None,
    ):
        self.content = content
        self.create_time = create_time
        self.userid = userid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.userid is not None:
            result['Userid'] = self.userid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Userid') is not None:
            self.userid = m.get('Userid')
        return self


class CommentListReportResponseBody(TeaModel):
    def __init__(
        self,
        comments: List[CommentListReportResponseBodyComments] = None,
        has_more: bool = None,
        next_cursor: int = None,
        request_id: str = None,
    ):
        self.comments = comments
        self.has_more = has_more
        self.next_cursor = next_cursor
        # requestId
        self.request_id = request_id

    def validate(self):
        if self.comments:
            for k in self.comments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['comments'] = []
        if self.comments is not None:
            for k in self.comments:
                result['comments'].append(k.to_map() if k else None)
        if self.has_more is not None:
            result['hasMore'] = self.has_more
        if self.next_cursor is not None:
            result['nextCursor'] = self.next_cursor
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.comments = []
        if m.get('comments') is not None:
            for k in m.get('comments'):
                temp_model = CommentListReportResponseBodyComments()
                self.comments.append(temp_model.from_map(k))
        if m.get('hasMore') is not None:
            self.has_more = m.get('hasMore')
        if m.get('nextCursor') is not None:
            self.next_cursor = m.get('nextCursor')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CommentListReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CommentListReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CommentListReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CommitFileHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CommitFileHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CommitFileHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CommitFileHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CommitFileShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CommitFileRequestOptionAppProperties(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
        visibility: str = None,
    ):
        self.name = name
        self.value = value
        self.visibility = visibility

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        if self.visibility is not None:
            result['Visibility'] = self.visibility
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('Visibility') is not None:
            self.visibility = m.get('Visibility')
        return self


class CommitFileRequestOption(TeaModel):
    def __init__(
        self,
        app_properties: List[CommitFileRequestOptionAppProperties] = None,
        conflict_strategy: str = None,
        convert_to_online_doc: bool = None,
        convert_to_online_doc_target_document_type: str = None,
        size: int = None,
    ):
        self.app_properties = app_properties
        self.conflict_strategy = conflict_strategy
        self.convert_to_online_doc = convert_to_online_doc
        self.convert_to_online_doc_target_document_type = convert_to_online_doc_target_document_type
        self.size = size

    def validate(self):
        if self.app_properties:
            for k in self.app_properties:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AppProperties'] = []
        if self.app_properties is not None:
            for k in self.app_properties:
                result['AppProperties'].append(k.to_map() if k else None)
        if self.conflict_strategy is not None:
            result['ConflictStrategy'] = self.conflict_strategy
        if self.convert_to_online_doc is not None:
            result['ConvertToOnlineDoc'] = self.convert_to_online_doc
        if self.convert_to_online_doc_target_document_type is not None:
            result['ConvertToOnlineDocTargetDocumentType'] = self.convert_to_online_doc_target_document_type
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.app_properties = []
        if m.get('AppProperties') is not None:
            for k in m.get('AppProperties'):
                temp_model = CommitFileRequestOptionAppProperties()
                self.app_properties.append(temp_model.from_map(k))
        if m.get('ConflictStrategy') is not None:
            self.conflict_strategy = m.get('ConflictStrategy')
        if m.get('ConvertToOnlineDoc') is not None:
            self.convert_to_online_doc = m.get('ConvertToOnlineDoc')
        if m.get('ConvertToOnlineDocTargetDocumentType') is not None:
            self.convert_to_online_doc_target_document_type = m.get('ConvertToOnlineDocTargetDocumentType')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class CommitFileRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CommitFileRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        option: CommitFileRequestOption = None,
        parent_dentry_uuid: str = None,
        tenant_context: CommitFileRequestTenantContext = None,
        upload_key: str = None,
    ):
        self.name = name
        self.option = option
        self.parent_dentry_uuid = parent_dentry_uuid
        self.tenant_context = tenant_context
        self.upload_key = upload_key

    def validate(self):
        if self.option:
            self.option.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.option is not None:
            result['Option'] = self.option.to_map()
        if self.parent_dentry_uuid is not None:
            result['ParentDentryUuid'] = self.parent_dentry_uuid
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.upload_key is not None:
            result['UploadKey'] = self.upload_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Option') is not None:
            temp_model = CommitFileRequestOption()
            self.option = temp_model.from_map(m['Option'])
        if m.get('ParentDentryUuid') is not None:
            self.parent_dentry_uuid = m.get('ParentDentryUuid')
        if m.get('TenantContext') is not None:
            temp_model = CommitFileRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('UploadKey') is not None:
            self.upload_key = m.get('UploadKey')
        return self


class CommitFileShrinkRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        option_shrink: str = None,
        parent_dentry_uuid: str = None,
        tenant_context_shrink: str = None,
        upload_key: str = None,
    ):
        self.name = name
        self.option_shrink = option_shrink
        self.parent_dentry_uuid = parent_dentry_uuid
        self.tenant_context_shrink = tenant_context_shrink
        self.upload_key = upload_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.option_shrink is not None:
            result['Option'] = self.option_shrink
        if self.parent_dentry_uuid is not None:
            result['ParentDentryUuid'] = self.parent_dentry_uuid
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.upload_key is not None:
            result['UploadKey'] = self.upload_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Option') is not None:
            self.option_shrink = m.get('Option')
        if m.get('ParentDentryUuid') is not None:
            self.parent_dentry_uuid = m.get('ParentDentryUuid')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('UploadKey') is not None:
            self.upload_key = m.get('UploadKey')
        return self


class CommitFileResponseBodyDentryProperties(TeaModel):
    def __init__(
        self,
        read_only: bool = None,
    ):
        self.read_only = read_only

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.read_only is not None:
            result['ReadOnly'] = self.read_only
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReadOnly') is not None:
            self.read_only = m.get('ReadOnly')
        return self


class CommitFileResponseBodyDentryThumbnail(TeaModel):
    def __init__(
        self,
        height: int = None,
        url: str = None,
        width: int = None,
    ):
        self.height = height
        self.url = url
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class CommitFileResponseBodyDentry(TeaModel):
    def __init__(
        self,
        app_properties: Dict[str, List[DentryAppPropertiesValue]] = None,
        category: str = None,
        create_time: str = None,
        creator_id: str = None,
        extension: str = None,
        id: str = None,
        modified_time: str = None,
        modifier_id: str = None,
        name: str = None,
        parent_id: str = None,
        partition_type: str = None,
        path: str = None,
        properties: CommitFileResponseBodyDentryProperties = None,
        size: int = None,
        space_id: str = None,
        status: str = None,
        storage_driver: str = None,
        thumbnail: CommitFileResponseBodyDentryThumbnail = None,
        type: str = None,
        uuid: str = None,
        version: int = None,
    ):
        self.app_properties = app_properties
        self.category = category
        self.create_time = create_time
        self.creator_id = creator_id
        self.extension = extension
        self.id = id
        self.modified_time = modified_time
        self.modifier_id = modifier_id
        self.name = name
        self.parent_id = parent_id
        self.partition_type = partition_type
        self.path = path
        self.properties = properties
        self.size = size
        self.space_id = space_id
        self.status = status
        self.storage_driver = storage_driver
        self.thumbnail = thumbnail
        self.type = type
        self.uuid = uuid
        self.version = version

    def validate(self):
        if self.app_properties:
            for v in self.app_properties.values():
                for k1 in v:
                    if k1:
                        k1.validate()
        if self.properties:
            self.properties.validate()
        if self.thumbnail:
            self.thumbnail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AppProperties'] = {}
        if self.app_properties is not None:
            for k, v in self.app_properties.items():
                l1 = []
                for k1 in v:
                    l1.append(k1.to_map() if k1 else None)
                result['AppProperties'][k] = l1
        if self.category is not None:
            result['Category'] = self.category
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.id is not None:
            result['Id'] = self.id
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.name is not None:
            result['Name'] = self.name
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.partition_type is not None:
            result['PartitionType'] = self.partition_type
        if self.path is not None:
            result['Path'] = self.path
        if self.properties is not None:
            result['Properties'] = self.properties.to_map()
        if self.size is not None:
            result['Size'] = self.size
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.status is not None:
            result['Status'] = self.status
        if self.storage_driver is not None:
            result['StorageDriver'] = self.storage_driver
        if self.thumbnail is not None:
            result['Thumbnail'] = self.thumbnail.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.app_properties = {}
        if m.get('AppProperties') is not None:
            for k, v in m.get('AppProperties').items():
                l1 = []
                for k1 in v:
                    temp_model = DentryAppPropertiesValue()
                    l1.append(temp_model.from_map(k1))
                self.app_properties['k'] = l1
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('PartitionType') is not None:
            self.partition_type = m.get('PartitionType')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Properties') is not None:
            temp_model = CommitFileResponseBodyDentryProperties()
            self.properties = temp_model.from_map(m['Properties'])
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StorageDriver') is not None:
            self.storage_driver = m.get('StorageDriver')
        if m.get('Thumbnail') is not None:
            temp_model = CommitFileResponseBodyDentryThumbnail()
            self.thumbnail = temp_model.from_map(m['Thumbnail'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class CommitFileResponseBody(TeaModel):
    def __init__(
        self,
        dentry: CommitFileResponseBodyDentry = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.dentry = dentry
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.dentry:
            self.dentry.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry is not None:
            result['dentry'] = self.dentry.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dentry') is not None:
            temp_model = CommitFileResponseBodyDentry()
            self.dentry = temp_model.from_map(m['dentry'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class CommitFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CommitFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CommitFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CopyDentryHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CopyDentryHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CopyDentryHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CopyDentryHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CopyDentryShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CopyDentryRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CopyDentryRequest(TeaModel):
    def __init__(
        self,
        dentry_id: str = None,
        name: str = None,
        space_id: str = None,
        target_space_id: str = None,
        tenant_context: CopyDentryRequestTenantContext = None,
        to_next_dentry_id: str = None,
        to_parent_dentry_id: str = None,
        to_prev_dentry_id: str = None,
    ):
        # This parameter is required.
        self.dentry_id = dentry_id
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.space_id = space_id
        # This parameter is required.
        self.target_space_id = target_space_id
        self.tenant_context = tenant_context
        self.to_next_dentry_id = to_next_dentry_id
        self.to_parent_dentry_id = to_parent_dentry_id
        self.to_prev_dentry_id = to_prev_dentry_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_id is not None:
            result['DentryId'] = self.dentry_id
        if self.name is not None:
            result['Name'] = self.name
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.target_space_id is not None:
            result['TargetSpaceId'] = self.target_space_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.to_next_dentry_id is not None:
            result['ToNextDentryId'] = self.to_next_dentry_id
        if self.to_parent_dentry_id is not None:
            result['ToParentDentryId'] = self.to_parent_dentry_id
        if self.to_prev_dentry_id is not None:
            result['ToPrevDentryId'] = self.to_prev_dentry_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryId') is not None:
            self.dentry_id = m.get('DentryId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('TargetSpaceId') is not None:
            self.target_space_id = m.get('TargetSpaceId')
        if m.get('TenantContext') is not None:
            temp_model = CopyDentryRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('ToNextDentryId') is not None:
            self.to_next_dentry_id = m.get('ToNextDentryId')
        if m.get('ToParentDentryId') is not None:
            self.to_parent_dentry_id = m.get('ToParentDentryId')
        if m.get('ToPrevDentryId') is not None:
            self.to_prev_dentry_id = m.get('ToPrevDentryId')
        return self


class CopyDentryShrinkRequest(TeaModel):
    def __init__(
        self,
        dentry_id: str = None,
        name: str = None,
        space_id: str = None,
        target_space_id: str = None,
        tenant_context_shrink: str = None,
        to_next_dentry_id: str = None,
        to_parent_dentry_id: str = None,
        to_prev_dentry_id: str = None,
    ):
        # This parameter is required.
        self.dentry_id = dentry_id
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.space_id = space_id
        # This parameter is required.
        self.target_space_id = target_space_id
        self.tenant_context_shrink = tenant_context_shrink
        self.to_next_dentry_id = to_next_dentry_id
        self.to_parent_dentry_id = to_parent_dentry_id
        self.to_prev_dentry_id = to_prev_dentry_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_id is not None:
            result['DentryId'] = self.dentry_id
        if self.name is not None:
            result['Name'] = self.name
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.target_space_id is not None:
            result['TargetSpaceId'] = self.target_space_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.to_next_dentry_id is not None:
            result['ToNextDentryId'] = self.to_next_dentry_id
        if self.to_parent_dentry_id is not None:
            result['ToParentDentryId'] = self.to_parent_dentry_id
        if self.to_prev_dentry_id is not None:
            result['ToPrevDentryId'] = self.to_prev_dentry_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryId') is not None:
            self.dentry_id = m.get('DentryId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('TargetSpaceId') is not None:
            self.target_space_id = m.get('TargetSpaceId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('ToNextDentryId') is not None:
            self.to_next_dentry_id = m.get('ToNextDentryId')
        if m.get('ToParentDentryId') is not None:
            self.to_parent_dentry_id = m.get('ToParentDentryId')
        if m.get('ToPrevDentryId') is not None:
            self.to_prev_dentry_id = m.get('ToPrevDentryId')
        return self


class CopyDentryResponseBodyLinkSourceInfoIconUrl(TeaModel):
    def __init__(
        self,
        line: str = None,
        small: str = None,
    ):
        self.line = line
        self.small = small

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.line is not None:
            result['Line'] = self.line
        if self.small is not None:
            result['Small'] = self.small
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Line') is not None:
            self.line = m.get('Line')
        if m.get('Small') is not None:
            self.small = m.get('Small')
        return self


class CopyDentryResponseBodyLinkSourceInfo(TeaModel):
    def __init__(
        self,
        extension: str = None,
        icon_url: CopyDentryResponseBodyLinkSourceInfoIconUrl = None,
        id: str = None,
        link_type: int = None,
        space_id: str = None,
    ):
        self.extension = extension
        self.icon_url = icon_url
        self.id = id
        self.link_type = link_type
        self.space_id = space_id

    def validate(self):
        if self.icon_url:
            self.icon_url.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.icon_url is not None:
            result['IconUrl'] = self.icon_url.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.link_type is not None:
            result['LinkType'] = self.link_type
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('IconUrl') is not None:
            temp_model = CopyDentryResponseBodyLinkSourceInfoIconUrl()
            self.icon_url = temp_model.from_map(m['IconUrl'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LinkType') is not None:
            self.link_type = m.get('LinkType')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        return self


class CopyDentryResponseBodySpaceHdIconVO(TeaModel):
    def __init__(
        self,
        icon: str = None,
        type: str = None,
    ):
        self.icon = icon
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CopyDentryResponseBodySpaceIconVO(TeaModel):
    def __init__(
        self,
        icon: str = None,
        type: str = None,
    ):
        self.icon = icon
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CopyDentryResponseBodySpaceOwner(TeaModel):
    def __init__(
        self,
        name: str = None,
        user_id: str = None,
    ):
        self.name = name
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CopyDentryResponseBodySpaceRecentListCreator(TeaModel):
    def __init__(
        self,
        name: str = None,
        user_id: str = None,
    ):
        self.name = name
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CopyDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl(TeaModel):
    def __init__(
        self,
        line: str = None,
        small: str = None,
    ):
        self.line = line
        self.small = small

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.line is not None:
            result['Line'] = self.line
        if self.small is not None:
            result['Small'] = self.small
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Line') is not None:
            self.line = m.get('Line')
        if m.get('Small') is not None:
            self.small = m.get('Small')
        return self


class CopyDentryResponseBodySpaceRecentListLinkSourceInfo(TeaModel):
    def __init__(
        self,
        extension: str = None,
        icon_url: CopyDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl = None,
        id: str = None,
        link_type: int = None,
        space_id: str = None,
    ):
        self.extension = extension
        self.icon_url = icon_url
        self.id = id
        self.link_type = link_type
        self.space_id = space_id

    def validate(self):
        if self.icon_url:
            self.icon_url.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.icon_url is not None:
            result['IconUrl'] = self.icon_url.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.link_type is not None:
            result['LinkType'] = self.link_type
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('IconUrl') is not None:
            temp_model = CopyDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl()
            self.icon_url = temp_model.from_map(m['IconUrl'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LinkType') is not None:
            self.link_type = m.get('LinkType')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        return self


class CopyDentryResponseBodySpaceRecentListStatisticalInfo(TeaModel):
    def __init__(
        self,
        word_count: int = None,
    ):
        self.word_count = word_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.word_count is not None:
            result['WordCount'] = self.word_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WordCount') is not None:
            self.word_count = m.get('WordCount')
        return self


class CopyDentryResponseBodySpaceRecentListUpdater(TeaModel):
    def __init__(
        self,
        name: str = None,
        user_id: str = None,
    ):
        self.name = name
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CopyDentryResponseBodySpaceRecentListVisitorInfo(TeaModel):
    def __init__(
        self,
        dentry_actions: List[str] = None,
        role_code: str = None,
        space_actions: List[str] = None,
    ):
        self.dentry_actions = dentry_actions
        self.role_code = role_code
        self.space_actions = space_actions

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_actions is not None:
            result['DentryActions'] = self.dentry_actions
        if self.role_code is not None:
            result['RoleCode'] = self.role_code
        if self.space_actions is not None:
            result['SpaceActions'] = self.space_actions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryActions') is not None:
            self.dentry_actions = m.get('DentryActions')
        if m.get('RoleCode') is not None:
            self.role_code = m.get('RoleCode')
        if m.get('SpaceActions') is not None:
            self.space_actions = m.get('SpaceActions')
        return self


class CopyDentryResponseBodySpaceRecentList(TeaModel):
    def __init__(
        self,
        content_type: str = None,
        created_time: int = None,
        creator: CopyDentryResponseBodySpaceRecentListCreator = None,
        dentry_id: str = None,
        dentry_type: str = None,
        dentry_uuid: str = None,
        doc_key: str = None,
        extension: str = None,
        has_children: bool = None,
        link_source_info: CopyDentryResponseBodySpaceRecentListLinkSourceInfo = None,
        name: str = None,
        path: str = None,
        space: Any = None,
        space_id: str = None,
        statistical_info: CopyDentryResponseBodySpaceRecentListStatisticalInfo = None,
        updated_time: int = None,
        updater: CopyDentryResponseBodySpaceRecentListUpdater = None,
        url: str = None,
        visitor_info: CopyDentryResponseBodySpaceRecentListVisitorInfo = None,
    ):
        self.content_type = content_type
        self.created_time = created_time
        self.creator = creator
        self.dentry_id = dentry_id
        self.dentry_type = dentry_type
        self.dentry_uuid = dentry_uuid
        self.doc_key = doc_key
        self.extension = extension
        self.has_children = has_children
        self.link_source_info = link_source_info
        self.name = name
        self.path = path
        self.space = space
        self.space_id = space_id
        self.statistical_info = statistical_info
        self.updated_time = updated_time
        self.updater = updater
        self.url = url
        self.visitor_info = visitor_info

    def validate(self):
        if self.creator:
            self.creator.validate()
        if self.link_source_info:
            self.link_source_info.validate()
        if self.statistical_info:
            self.statistical_info.validate()
        if self.updater:
            self.updater.validate()
        if self.visitor_info:
            self.visitor_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['ContentType'] = self.content_type
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.creator is not None:
            result['Creator'] = self.creator.to_map()
        if self.dentry_id is not None:
            result['DentryId'] = self.dentry_id
        if self.dentry_type is not None:
            result['DentryType'] = self.dentry_type
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        if self.doc_key is not None:
            result['DocKey'] = self.doc_key
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.has_children is not None:
            result['HasChildren'] = self.has_children
        if self.link_source_info is not None:
            result['LinkSourceInfo'] = self.link_source_info.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.path is not None:
            result['Path'] = self.path
        if self.space is not None:
            result['Space'] = self.space
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.statistical_info is not None:
            result['StatisticalInfo'] = self.statistical_info.to_map()
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        if self.updater is not None:
            result['Updater'] = self.updater.to_map()
        if self.url is not None:
            result['Url'] = self.url
        if self.visitor_info is not None:
            result['VisitorInfo'] = self.visitor_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContentType') is not None:
            self.content_type = m.get('ContentType')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Creator') is not None:
            temp_model = CopyDentryResponseBodySpaceRecentListCreator()
            self.creator = temp_model.from_map(m['Creator'])
        if m.get('DentryId') is not None:
            self.dentry_id = m.get('DentryId')
        if m.get('DentryType') is not None:
            self.dentry_type = m.get('DentryType')
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        if m.get('DocKey') is not None:
            self.doc_key = m.get('DocKey')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('HasChildren') is not None:
            self.has_children = m.get('HasChildren')
        if m.get('LinkSourceInfo') is not None:
            temp_model = CopyDentryResponseBodySpaceRecentListLinkSourceInfo()
            self.link_source_info = temp_model.from_map(m['LinkSourceInfo'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Space') is not None:
            self.space = m.get('Space')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('StatisticalInfo') is not None:
            temp_model = CopyDentryResponseBodySpaceRecentListStatisticalInfo()
            self.statistical_info = temp_model.from_map(m['StatisticalInfo'])
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        if m.get('Updater') is not None:
            temp_model = CopyDentryResponseBodySpaceRecentListUpdater()
            self.updater = temp_model.from_map(m['Updater'])
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('VisitorInfo') is not None:
            temp_model = CopyDentryResponseBodySpaceRecentListVisitorInfo()
            self.visitor_info = temp_model.from_map(m['VisitorInfo'])
        return self


class CopyDentryResponseBodySpaceVisitorInfo(TeaModel):
    def __init__(
        self,
        dentry_actions: List[str] = None,
        role_code: str = None,
        space_actions: List[str] = None,
    ):
        self.dentry_actions = dentry_actions
        self.role_code = role_code
        self.space_actions = space_actions

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_actions is not None:
            result['DentryActions'] = self.dentry_actions
        if self.role_code is not None:
            result['RoleCode'] = self.role_code
        if self.space_actions is not None:
            result['SpaceActions'] = self.space_actions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryActions') is not None:
            self.dentry_actions = m.get('DentryActions')
        if m.get('RoleCode') is not None:
            self.role_code = m.get('RoleCode')
        if m.get('SpaceActions') is not None:
            self.space_actions = m.get('SpaceActions')
        return self


class CopyDentryResponseBodySpace(TeaModel):
    def __init__(
        self,
        cover: str = None,
        description: str = None,
        hd_icon_vo: CopyDentryResponseBodySpaceHdIconVO = None,
        icon_vo: CopyDentryResponseBodySpaceIconVO = None,
        id: str = None,
        name: str = None,
        owner: CopyDentryResponseBodySpaceOwner = None,
        recent_list: List[CopyDentryResponseBodySpaceRecentList] = None,
        type: int = None,
        url: str = None,
        visitor_info: CopyDentryResponseBodySpaceVisitorInfo = None,
    ):
        self.cover = cover
        self.description = description
        self.hd_icon_vo = hd_icon_vo
        self.icon_vo = icon_vo
        self.id = id
        self.name = name
        self.owner = owner
        self.recent_list = recent_list
        self.type = type
        self.url = url
        self.visitor_info = visitor_info

    def validate(self):
        if self.hd_icon_vo:
            self.hd_icon_vo.validate()
        if self.icon_vo:
            self.icon_vo.validate()
        if self.owner:
            self.owner.validate()
        if self.recent_list:
            for k in self.recent_list:
                if k:
                    k.validate()
        if self.visitor_info:
            self.visitor_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cover is not None:
            result['Cover'] = self.cover
        if self.description is not None:
            result['Description'] = self.description
        if self.hd_icon_vo is not None:
            result['HdIconVO'] = self.hd_icon_vo.to_map()
        if self.icon_vo is not None:
            result['IconVO'] = self.icon_vo.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner.to_map()
        result['RecentList'] = []
        if self.recent_list is not None:
            for k in self.recent_list:
                result['RecentList'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        if self.visitor_info is not None:
            result['VisitorInfo'] = self.visitor_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cover') is not None:
            self.cover = m.get('Cover')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('HdIconVO') is not None:
            temp_model = CopyDentryResponseBodySpaceHdIconVO()
            self.hd_icon_vo = temp_model.from_map(m['HdIconVO'])
        if m.get('IconVO') is not None:
            temp_model = CopyDentryResponseBodySpaceIconVO()
            self.icon_vo = temp_model.from_map(m['IconVO'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            temp_model = CopyDentryResponseBodySpaceOwner()
            self.owner = temp_model.from_map(m['Owner'])
        self.recent_list = []
        if m.get('RecentList') is not None:
            for k in m.get('RecentList'):
                temp_model = CopyDentryResponseBodySpaceRecentList()
                self.recent_list.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('VisitorInfo') is not None:
            temp_model = CopyDentryResponseBodySpaceVisitorInfo()
            self.visitor_info = temp_model.from_map(m['VisitorInfo'])
        return self


class CopyDentryResponseBody(TeaModel):
    def __init__(
        self,
        content_type: str = None,
        created_time: int = None,
        creator: Dict[str, Any] = None,
        dentry_id: str = None,
        dentry_type: str = None,
        dentry_uuid: str = None,
        doc_key: str = None,
        extension: str = None,
        has_children: bool = None,
        link_source_info: CopyDentryResponseBodyLinkSourceInfo = None,
        name: str = None,
        path: str = None,
        request_id: str = None,
        space: CopyDentryResponseBodySpace = None,
        space_id: str = None,
        updated_time: int = None,
        updater: Dict[str, Any] = None,
        url: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
        visitor_info: Dict[str, Any] = None,
    ):
        self.content_type = content_type
        self.created_time = created_time
        self.creator = creator
        self.dentry_id = dentry_id
        self.dentry_type = dentry_type
        self.dentry_uuid = dentry_uuid
        self.doc_key = doc_key
        self.extension = extension
        self.has_children = has_children
        self.link_source_info = link_source_info
        self.name = name
        self.path = path
        self.request_id = request_id
        self.space = space
        self.space_id = space_id
        self.updated_time = updated_time
        self.updater = updater
        self.url = url
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type
        self.visitor_info = visitor_info

    def validate(self):
        if self.link_source_info:
            self.link_source_info.validate()
        if self.space:
            self.space.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['contentType'] = self.content_type
        if self.created_time is not None:
            result['createdTime'] = self.created_time
        if self.creator is not None:
            result['creator'] = self.creator
        if self.dentry_id is not None:
            result['dentryId'] = self.dentry_id
        if self.dentry_type is not None:
            result['dentryType'] = self.dentry_type
        if self.dentry_uuid is not None:
            result['dentryUuid'] = self.dentry_uuid
        if self.doc_key is not None:
            result['docKey'] = self.doc_key
        if self.extension is not None:
            result['extension'] = self.extension
        if self.has_children is not None:
            result['hasChildren'] = self.has_children
        if self.link_source_info is not None:
            result['linkSourceInfo'] = self.link_source_info.to_map()
        if self.name is not None:
            result['name'] = self.name
        if self.path is not None:
            result['path'] = self.path
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.space is not None:
            result['space'] = self.space.to_map()
        if self.space_id is not None:
            result['spaceId'] = self.space_id
        if self.updated_time is not None:
            result['updatedTime'] = self.updated_time
        if self.updater is not None:
            result['updater'] = self.updater
        if self.url is not None:
            result['url'] = self.url
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        if self.visitor_info is not None:
            result['visitorInfo'] = self.visitor_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contentType') is not None:
            self.content_type = m.get('contentType')
        if m.get('createdTime') is not None:
            self.created_time = m.get('createdTime')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('dentryId') is not None:
            self.dentry_id = m.get('dentryId')
        if m.get('dentryType') is not None:
            self.dentry_type = m.get('dentryType')
        if m.get('dentryUuid') is not None:
            self.dentry_uuid = m.get('dentryUuid')
        if m.get('docKey') is not None:
            self.doc_key = m.get('docKey')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('hasChildren') is not None:
            self.has_children = m.get('hasChildren')
        if m.get('linkSourceInfo') is not None:
            temp_model = CopyDentryResponseBodyLinkSourceInfo()
            self.link_source_info = temp_model.from_map(m['linkSourceInfo'])
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('space') is not None:
            temp_model = CopyDentryResponseBodySpace()
            self.space = temp_model.from_map(m['space'])
        if m.get('spaceId') is not None:
            self.space_id = m.get('spaceId')
        if m.get('updatedTime') is not None:
            self.updated_time = m.get('updatedTime')
        if m.get('updater') is not None:
            self.updater = m.get('updater')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        if m.get('visitorInfo') is not None:
            self.visitor_info = m.get('visitorInfo')
        return self


class CopyDentryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CopyDentryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CopyDentryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDeliveryPlanHeadersAccountContext(TeaModel):
    def __init__(
        self,
        user_token: str = None,
    ):
        self.user_token = user_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_token is not None:
            result['userToken'] = self.user_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('userToken') is not None:
            self.user_token = m.get('userToken')
        return self


class CreateDeliveryPlanHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateDeliveryPlanHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateDeliveryPlanHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateDeliveryPlanShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateDeliveryPlanRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CreateDeliveryPlanRequest(TeaModel):
    def __init__(
        self,
        content: Dict[str, Any] = None,
        end_time: int = None,
        res_id: str = None,
        start_time: int = None,
        tenant_context: CreateDeliveryPlanRequestTenantContext = None,
        user_id_list: List[str] = None,
    ):
        self.content = content
        self.end_time = end_time
        self.res_id = res_id
        self.start_time = start_time
        self.tenant_context = tenant_context
        self.user_id_list = user_id_list

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.res_id is not None:
            result['ResId'] = self.res_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.user_id_list is not None:
            result['UserIdList'] = self.user_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ResId') is not None:
            self.res_id = m.get('ResId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            temp_model = CreateDeliveryPlanRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('UserIdList') is not None:
            self.user_id_list = m.get('UserIdList')
        return self


class CreateDeliveryPlanShrinkRequest(TeaModel):
    def __init__(
        self,
        content_shrink: str = None,
        end_time: int = None,
        res_id: str = None,
        start_time: int = None,
        tenant_context_shrink: str = None,
        user_id_list_shrink: str = None,
    ):
        self.content_shrink = content_shrink
        self.end_time = end_time
        self.res_id = res_id
        self.start_time = start_time
        self.tenant_context_shrink = tenant_context_shrink
        self.user_id_list_shrink = user_id_list_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_shrink is not None:
            result['Content'] = self.content_shrink
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.res_id is not None:
            result['ResId'] = self.res_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.user_id_list_shrink is not None:
            result['UserIdList'] = self.user_id_list_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content_shrink = m.get('Content')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ResId') is not None:
            self.res_id = m.get('ResId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('UserIdList') is not None:
            self.user_id_list_shrink = m.get('UserIdList')
        return self


class CreateDeliveryPlanResponseBody(TeaModel):
    def __init__(
        self,
        arguments: List[Any] = None,
        request_id: str = None,
        success: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.arguments = arguments
        self.request_id = request_id
        self.success = success
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arguments is not None:
            result['arguments'] = self.arguments
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('arguments') is not None:
            self.arguments = m.get('arguments')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class CreateDeliveryPlanResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDeliveryPlanResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDeliveryPlanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDingtalkPersonalTodoTaskHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateDingtalkPersonalTodoTaskHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateDingtalkPersonalTodoTaskHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateDingtalkPersonalTodoTaskHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateDingtalkPersonalTodoTaskShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateDingtalkPersonalTodoTaskRequestNotifyConfigs(TeaModel):
    def __init__(
        self,
        ding_notify: str = None,
    ):
        self.ding_notify = ding_notify

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ding_notify is not None:
            result['DingNotify'] = self.ding_notify
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DingNotify') is not None:
            self.ding_notify = m.get('DingNotify')
        return self


class CreateDingtalkPersonalTodoTaskRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CreateDingtalkPersonalTodoTaskRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        due_time: int = None,
        executor_ids: List[str] = None,
        notify_configs: CreateDingtalkPersonalTodoTaskRequestNotifyConfigs = None,
        participant_ids: List[str] = None,
        subject: str = None,
        tenant_context: CreateDingtalkPersonalTodoTaskRequestTenantContext = None,
        user_token: str = None,
    ):
        self.description = description
        self.due_time = due_time
        # This parameter is required.
        self.executor_ids = executor_ids
        self.notify_configs = notify_configs
        self.participant_ids = participant_ids
        # This parameter is required.
        self.subject = subject
        self.tenant_context = tenant_context
        self.user_token = user_token

    def validate(self):
        if self.notify_configs:
            self.notify_configs.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.due_time is not None:
            result['DueTime'] = self.due_time
        if self.executor_ids is not None:
            result['ExecutorIds'] = self.executor_ids
        if self.notify_configs is not None:
            result['NotifyConfigs'] = self.notify_configs.to_map()
        if self.participant_ids is not None:
            result['ParticipantIds'] = self.participant_ids
        if self.subject is not None:
            result['Subject'] = self.subject
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.user_token is not None:
            result['UserToken'] = self.user_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DueTime') is not None:
            self.due_time = m.get('DueTime')
        if m.get('ExecutorIds') is not None:
            self.executor_ids = m.get('ExecutorIds')
        if m.get('NotifyConfigs') is not None:
            temp_model = CreateDingtalkPersonalTodoTaskRequestNotifyConfigs()
            self.notify_configs = temp_model.from_map(m['NotifyConfigs'])
        if m.get('ParticipantIds') is not None:
            self.participant_ids = m.get('ParticipantIds')
        if m.get('Subject') is not None:
            self.subject = m.get('Subject')
        if m.get('TenantContext') is not None:
            temp_model = CreateDingtalkPersonalTodoTaskRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('UserToken') is not None:
            self.user_token = m.get('UserToken')
        return self


class CreateDingtalkPersonalTodoTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        due_time: int = None,
        executor_ids_shrink: str = None,
        notify_configs_shrink: str = None,
        participant_ids_shrink: str = None,
        subject: str = None,
        tenant_context_shrink: str = None,
        user_token: str = None,
    ):
        self.description = description
        self.due_time = due_time
        # This parameter is required.
        self.executor_ids_shrink = executor_ids_shrink
        self.notify_configs_shrink = notify_configs_shrink
        self.participant_ids_shrink = participant_ids_shrink
        # This parameter is required.
        self.subject = subject
        self.tenant_context_shrink = tenant_context_shrink
        self.user_token = user_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.due_time is not None:
            result['DueTime'] = self.due_time
        if self.executor_ids_shrink is not None:
            result['ExecutorIds'] = self.executor_ids_shrink
        if self.notify_configs_shrink is not None:
            result['NotifyConfigs'] = self.notify_configs_shrink
        if self.participant_ids_shrink is not None:
            result['ParticipantIds'] = self.participant_ids_shrink
        if self.subject is not None:
            result['Subject'] = self.subject
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.user_token is not None:
            result['UserToken'] = self.user_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DueTime') is not None:
            self.due_time = m.get('DueTime')
        if m.get('ExecutorIds') is not None:
            self.executor_ids_shrink = m.get('ExecutorIds')
        if m.get('NotifyConfigs') is not None:
            self.notify_configs_shrink = m.get('NotifyConfigs')
        if m.get('ParticipantIds') is not None:
            self.participant_ids_shrink = m.get('ParticipantIds')
        if m.get('Subject') is not None:
            self.subject = m.get('Subject')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('UserToken') is not None:
            self.user_token = m.get('UserToken')
        return self


class CreateDingtalkPersonalTodoTaskResponseBody(TeaModel):
    def __init__(
        self,
        created_time: int = None,
        request_id: str = None,
        task_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.created_time = created_time
        self.request_id = request_id
        self.task_id = task_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_time is not None:
            result['createdTime'] = self.created_time
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.task_id is not None:
            result['taskId'] = self.task_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createdTime') is not None:
            self.created_time = m.get('createdTime')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class CreateDingtalkPersonalTodoTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDingtalkPersonalTodoTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDingtalkPersonalTodoTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEventHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateEventHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateEventHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateEventHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateEventShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateEventRequestAttendees(TeaModel):
    def __init__(
        self,
        id: str = None,
        is_optional: bool = None,
    ):
        self.id = id
        self.is_optional = is_optional

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.is_optional is not None:
            result['isOptional'] = self.is_optional
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('isOptional') is not None:
            self.is_optional = m.get('isOptional')
        return self


class CreateEventRequestCardInstances(TeaModel):
    def __init__(
        self,
        out_track_id: str = None,
        scenario: str = None,
    ):
        self.out_track_id = out_track_id
        self.scenario = scenario

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.out_track_id is not None:
            result['OutTrackId'] = self.out_track_id
        if self.scenario is not None:
            result['Scenario'] = self.scenario
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OutTrackId') is not None:
            self.out_track_id = m.get('OutTrackId')
        if m.get('Scenario') is not None:
            self.scenario = m.get('Scenario')
        return self


class CreateEventRequestEnd(TeaModel):
    def __init__(
        self,
        date: str = None,
        date_time: str = None,
        time_zone: str = None,
    ):
        self.date = date
        self.date_time = date_time
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['date'] = self.date
        if self.date_time is not None:
            result['dateTime'] = self.date_time
        if self.time_zone is not None:
            result['timeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('date') is not None:
            self.date = m.get('date')
        if m.get('dateTime') is not None:
            self.date_time = m.get('dateTime')
        if m.get('timeZone') is not None:
            self.time_zone = m.get('timeZone')
        return self


class CreateEventRequestLocation(TeaModel):
    def __init__(
        self,
        display_name: str = None,
    ):
        self.display_name = display_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['displayName'] = self.display_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        return self


class CreateEventRequestOnlineMeetingInfo(TeaModel):
    def __init__(
        self,
        type: str = None,
    ):
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateEventRequestRecurrencePattern(TeaModel):
    def __init__(
        self,
        day_of_month: int = None,
        days_of_week: str = None,
        index: str = None,
        interval: int = None,
        type: str = None,
    ):
        self.day_of_month = day_of_month
        self.days_of_week = days_of_week
        self.index = index
        self.interval = interval
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.day_of_month is not None:
            result['dayOfMonth'] = self.day_of_month
        if self.days_of_week is not None:
            result['daysOfWeek'] = self.days_of_week
        if self.index is not None:
            result['index'] = self.index
        if self.interval is not None:
            result['interval'] = self.interval
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dayOfMonth') is not None:
            self.day_of_month = m.get('dayOfMonth')
        if m.get('daysOfWeek') is not None:
            self.days_of_week = m.get('daysOfWeek')
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateEventRequestRecurrenceRange(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        number_of_occurrences: int = None,
        type: str = None,
    ):
        self.end_date = end_date
        self.number_of_occurrences = number_of_occurrences
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['endDate'] = self.end_date
        if self.number_of_occurrences is not None:
            result['numberOfOccurrences'] = self.number_of_occurrences
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endDate') is not None:
            self.end_date = m.get('endDate')
        if m.get('numberOfOccurrences') is not None:
            self.number_of_occurrences = m.get('numberOfOccurrences')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateEventRequestRecurrence(TeaModel):
    def __init__(
        self,
        pattern: CreateEventRequestRecurrencePattern = None,
        range: CreateEventRequestRecurrenceRange = None,
    ):
        self.pattern = pattern
        self.range = range

    def validate(self):
        if self.pattern:
            self.pattern.validate()
        if self.range:
            self.range.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pattern is not None:
            result['pattern'] = self.pattern.to_map()
        if self.range is not None:
            result['range'] = self.range.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('pattern') is not None:
            temp_model = CreateEventRequestRecurrencePattern()
            self.pattern = temp_model.from_map(m['pattern'])
        if m.get('range') is not None:
            temp_model = CreateEventRequestRecurrenceRange()
            self.range = temp_model.from_map(m['range'])
        return self


class CreateEventRequestReminders(TeaModel):
    def __init__(
        self,
        method: str = None,
        minutes: int = None,
    ):
        self.method = method
        self.minutes = minutes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.method is not None:
            result['method'] = self.method
        if self.minutes is not None:
            result['minutes'] = self.minutes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('method') is not None:
            self.method = m.get('method')
        if m.get('minutes') is not None:
            self.minutes = m.get('minutes')
        return self


class CreateEventRequestRichTextDescription(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('text') is not None:
            self.text = m.get('text')
        return self


class CreateEventRequestUiConfigs(TeaModel):
    def __init__(
        self,
        ui_name: str = None,
        ui_status: str = None,
    ):
        self.ui_name = ui_name
        self.ui_status = ui_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ui_name is not None:
            result['uiName'] = self.ui_name
        if self.ui_status is not None:
            result['uiStatus'] = self.ui_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('uiName') is not None:
            self.ui_name = m.get('uiName')
        if m.get('uiStatus') is not None:
            self.ui_status = m.get('uiStatus')
        return self


class CreateEventRequestStart(TeaModel):
    def __init__(
        self,
        date: str = None,
        date_time: str = None,
        time_zone: str = None,
    ):
        self.date = date
        self.date_time = date_time
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['date'] = self.date
        if self.date_time is not None:
            result['dateTime'] = self.date_time
        if self.time_zone is not None:
            result['timeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('date') is not None:
            self.date = m.get('date')
        if m.get('dateTime') is not None:
            self.date_time = m.get('dateTime')
        if m.get('timeZone') is not None:
            self.time_zone = m.get('timeZone')
        return self


class CreateEventRequest(TeaModel):
    def __init__(
        self,
        attendees: List[CreateEventRequestAttendees] = None,
        card_instances: List[CreateEventRequestCardInstances] = None,
        description: str = None,
        end: CreateEventRequestEnd = None,
        extra: Dict[str, str] = None,
        is_all_day: bool = None,
        location: CreateEventRequestLocation = None,
        online_meeting_info: CreateEventRequestOnlineMeetingInfo = None,
        recurrence: CreateEventRequestRecurrence = None,
        reminders: List[CreateEventRequestReminders] = None,
        rich_text_description: CreateEventRequestRichTextDescription = None,
        summary: str = None,
        ui_configs: List[CreateEventRequestUiConfigs] = None,
        calendar_id: str = None,
        start: CreateEventRequestStart = None,
    ):
        self.attendees = attendees
        self.card_instances = card_instances
        self.description = description
        self.end = end
        self.extra = extra
        self.is_all_day = is_all_day
        self.location = location
        self.online_meeting_info = online_meeting_info
        self.recurrence = recurrence
        self.reminders = reminders
        self.rich_text_description = rich_text_description
        # This parameter is required.
        self.summary = summary
        self.ui_configs = ui_configs
        # This parameter is required.
        self.calendar_id = calendar_id
        # This parameter is required.
        self.start = start

    def validate(self):
        if self.attendees:
            for k in self.attendees:
                if k:
                    k.validate()
        if self.card_instances:
            for k in self.card_instances:
                if k:
                    k.validate()
        if self.end:
            self.end.validate()
        if self.location:
            self.location.validate()
        if self.online_meeting_info:
            self.online_meeting_info.validate()
        if self.recurrence:
            self.recurrence.validate()
        if self.reminders:
            for k in self.reminders:
                if k:
                    k.validate()
        if self.rich_text_description:
            self.rich_text_description.validate()
        if self.ui_configs:
            for k in self.ui_configs:
                if k:
                    k.validate()
        if self.start:
            self.start.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Attendees'] = []
        if self.attendees is not None:
            for k in self.attendees:
                result['Attendees'].append(k.to_map() if k else None)
        result['CardInstances'] = []
        if self.card_instances is not None:
            for k in self.card_instances:
                result['CardInstances'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.end is not None:
            result['End'] = self.end.to_map()
        if self.extra is not None:
            result['Extra'] = self.extra
        if self.is_all_day is not None:
            result['IsAllDay'] = self.is_all_day
        if self.location is not None:
            result['Location'] = self.location.to_map()
        if self.online_meeting_info is not None:
            result['OnlineMeetingInfo'] = self.online_meeting_info.to_map()
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence.to_map()
        result['Reminders'] = []
        if self.reminders is not None:
            for k in self.reminders:
                result['Reminders'].append(k.to_map() if k else None)
        if self.rich_text_description is not None:
            result['RichTextDescription'] = self.rich_text_description.to_map()
        if self.summary is not None:
            result['Summary'] = self.summary
        result['UiConfigs'] = []
        if self.ui_configs is not None:
            for k in self.ui_configs:
                result['UiConfigs'].append(k.to_map() if k else None)
        if self.calendar_id is not None:
            result['calendarId'] = self.calendar_id
        if self.start is not None:
            result['start'] = self.start.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attendees = []
        if m.get('Attendees') is not None:
            for k in m.get('Attendees'):
                temp_model = CreateEventRequestAttendees()
                self.attendees.append(temp_model.from_map(k))
        self.card_instances = []
        if m.get('CardInstances') is not None:
            for k in m.get('CardInstances'):
                temp_model = CreateEventRequestCardInstances()
                self.card_instances.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('End') is not None:
            temp_model = CreateEventRequestEnd()
            self.end = temp_model.from_map(m['End'])
        if m.get('Extra') is not None:
            self.extra = m.get('Extra')
        if m.get('IsAllDay') is not None:
            self.is_all_day = m.get('IsAllDay')
        if m.get('Location') is not None:
            temp_model = CreateEventRequestLocation()
            self.location = temp_model.from_map(m['Location'])
        if m.get('OnlineMeetingInfo') is not None:
            temp_model = CreateEventRequestOnlineMeetingInfo()
            self.online_meeting_info = temp_model.from_map(m['OnlineMeetingInfo'])
        if m.get('Recurrence') is not None:
            temp_model = CreateEventRequestRecurrence()
            self.recurrence = temp_model.from_map(m['Recurrence'])
        self.reminders = []
        if m.get('Reminders') is not None:
            for k in m.get('Reminders'):
                temp_model = CreateEventRequestReminders()
                self.reminders.append(temp_model.from_map(k))
        if m.get('RichTextDescription') is not None:
            temp_model = CreateEventRequestRichTextDescription()
            self.rich_text_description = temp_model.from_map(m['RichTextDescription'])
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        self.ui_configs = []
        if m.get('UiConfigs') is not None:
            for k in m.get('UiConfigs'):
                temp_model = CreateEventRequestUiConfigs()
                self.ui_configs.append(temp_model.from_map(k))
        if m.get('calendarId') is not None:
            self.calendar_id = m.get('calendarId')
        if m.get('start') is not None:
            temp_model = CreateEventRequestStart()
            self.start = temp_model.from_map(m['start'])
        return self


class CreateEventShrinkRequest(TeaModel):
    def __init__(
        self,
        attendees_shrink: str = None,
        card_instances_shrink: str = None,
        description: str = None,
        end_shrink: str = None,
        extra_shrink: str = None,
        is_all_day: bool = None,
        location_shrink: str = None,
        online_meeting_info_shrink: str = None,
        recurrence_shrink: str = None,
        reminders_shrink: str = None,
        rich_text_description_shrink: str = None,
        summary: str = None,
        ui_configs_shrink: str = None,
        calendar_id: str = None,
        start_shrink: str = None,
    ):
        self.attendees_shrink = attendees_shrink
        self.card_instances_shrink = card_instances_shrink
        self.description = description
        self.end_shrink = end_shrink
        self.extra_shrink = extra_shrink
        self.is_all_day = is_all_day
        self.location_shrink = location_shrink
        self.online_meeting_info_shrink = online_meeting_info_shrink
        self.recurrence_shrink = recurrence_shrink
        self.reminders_shrink = reminders_shrink
        self.rich_text_description_shrink = rich_text_description_shrink
        # This parameter is required.
        self.summary = summary
        self.ui_configs_shrink = ui_configs_shrink
        # This parameter is required.
        self.calendar_id = calendar_id
        # This parameter is required.
        self.start_shrink = start_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attendees_shrink is not None:
            result['Attendees'] = self.attendees_shrink
        if self.card_instances_shrink is not None:
            result['CardInstances'] = self.card_instances_shrink
        if self.description is not None:
            result['Description'] = self.description
        if self.end_shrink is not None:
            result['End'] = self.end_shrink
        if self.extra_shrink is not None:
            result['Extra'] = self.extra_shrink
        if self.is_all_day is not None:
            result['IsAllDay'] = self.is_all_day
        if self.location_shrink is not None:
            result['Location'] = self.location_shrink
        if self.online_meeting_info_shrink is not None:
            result['OnlineMeetingInfo'] = self.online_meeting_info_shrink
        if self.recurrence_shrink is not None:
            result['Recurrence'] = self.recurrence_shrink
        if self.reminders_shrink is not None:
            result['Reminders'] = self.reminders_shrink
        if self.rich_text_description_shrink is not None:
            result['RichTextDescription'] = self.rich_text_description_shrink
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.ui_configs_shrink is not None:
            result['UiConfigs'] = self.ui_configs_shrink
        if self.calendar_id is not None:
            result['calendarId'] = self.calendar_id
        if self.start_shrink is not None:
            result['start'] = self.start_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Attendees') is not None:
            self.attendees_shrink = m.get('Attendees')
        if m.get('CardInstances') is not None:
            self.card_instances_shrink = m.get('CardInstances')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('End') is not None:
            self.end_shrink = m.get('End')
        if m.get('Extra') is not None:
            self.extra_shrink = m.get('Extra')
        if m.get('IsAllDay') is not None:
            self.is_all_day = m.get('IsAllDay')
        if m.get('Location') is not None:
            self.location_shrink = m.get('Location')
        if m.get('OnlineMeetingInfo') is not None:
            self.online_meeting_info_shrink = m.get('OnlineMeetingInfo')
        if m.get('Recurrence') is not None:
            self.recurrence_shrink = m.get('Recurrence')
        if m.get('Reminders') is not None:
            self.reminders_shrink = m.get('Reminders')
        if m.get('RichTextDescription') is not None:
            self.rich_text_description_shrink = m.get('RichTextDescription')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('UiConfigs') is not None:
            self.ui_configs_shrink = m.get('UiConfigs')
        if m.get('calendarId') is not None:
            self.calendar_id = m.get('calendarId')
        if m.get('start') is not None:
            self.start_shrink = m.get('start')
        return self


class CreateEventResponseBodyAttendees(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        is_optional: bool = None,
        response_status: str = None,
        self_: bool = None,
    ):
        self.display_name = display_name
        self.is_optional = is_optional
        self.response_status = response_status
        self.self_ = self_

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.is_optional is not None:
            result['IsOptional'] = self.is_optional
        if self.response_status is not None:
            result['ResponseStatus'] = self.response_status
        if self.self_ is not None:
            result['Self'] = self.self_
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('IsOptional') is not None:
            self.is_optional = m.get('IsOptional')
        if m.get('ResponseStatus') is not None:
            self.response_status = m.get('ResponseStatus')
        if m.get('Self') is not None:
            self.self_ = m.get('Self')
        return self


class CreateEventResponseBodyEnd(TeaModel):
    def __init__(
        self,
        date: str = None,
        date_time: str = None,
        time_zone: str = None,
    ):
        self.date = date
        self.date_time = date_time
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['Date'] = self.date
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.time_zone is not None:
            result['TimeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Date') is not None:
            self.date = m.get('Date')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('TimeZone') is not None:
            self.time_zone = m.get('TimeZone')
        return self


class CreateEventResponseBodyLocation(TeaModel):
    def __init__(
        self,
        display_name: str = None,
    ):
        self.display_name = display_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        return self


class CreateEventResponseBodyOnlineMeetingInfo(TeaModel):
    def __init__(
        self,
        conference_id: str = None,
        extra_info: Dict[str, Any] = None,
        type: str = None,
        url: str = None,
    ):
        self.conference_id = conference_id
        self.extra_info = extra_info
        self.type = type
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conference_id is not None:
            result['ConferenceId'] = self.conference_id
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConferenceId') is not None:
            self.conference_id = m.get('ConferenceId')
        if m.get('ExtraInfo') is not None:
            self.extra_info = m.get('ExtraInfo')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class CreateEventResponseBodyOrganizer(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        id: str = None,
        response_status: str = None,
        self_: bool = None,
    ):
        self.display_name = display_name
        self.id = id
        self.response_status = response_status
        self.self_ = self_

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.id is not None:
            result['Id'] = self.id
        if self.response_status is not None:
            result['ResponseStatus'] = self.response_status
        if self.self_ is not None:
            result['Self'] = self.self_
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ResponseStatus') is not None:
            self.response_status = m.get('ResponseStatus')
        if m.get('Self') is not None:
            self.self_ = m.get('Self')
        return self


class CreateEventResponseBodyRecurrencePattern(TeaModel):
    def __init__(
        self,
        day_of_month: int = None,
        days_of_week: str = None,
        index: str = None,
        interval: int = None,
        type: str = None,
    ):
        self.day_of_month = day_of_month
        self.days_of_week = days_of_week
        self.index = index
        self.interval = interval
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.day_of_month is not None:
            result['DayOfMonth'] = self.day_of_month
        if self.days_of_week is not None:
            result['DaysOfWeek'] = self.days_of_week
        if self.index is not None:
            result['Index'] = self.index
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DayOfMonth') is not None:
            self.day_of_month = m.get('DayOfMonth')
        if m.get('DaysOfWeek') is not None:
            self.days_of_week = m.get('DaysOfWeek')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateEventResponseBodyRecurrenceRange(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        number_of_occurrences: int = None,
        type: str = None,
    ):
        self.end_date = end_date
        self.number_of_occurrences = number_of_occurrences
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.number_of_occurrences is not None:
            result['NumberOfOccurrences'] = self.number_of_occurrences
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('NumberOfOccurrences') is not None:
            self.number_of_occurrences = m.get('NumberOfOccurrences')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateEventResponseBodyRecurrence(TeaModel):
    def __init__(
        self,
        pattern: CreateEventResponseBodyRecurrencePattern = None,
        range: CreateEventResponseBodyRecurrenceRange = None,
    ):
        self.pattern = pattern
        self.range = range

    def validate(self):
        if self.pattern:
            self.pattern.validate()
        if self.range:
            self.range.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pattern is not None:
            result['Pattern'] = self.pattern.to_map()
        if self.range is not None:
            result['Range'] = self.range.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pattern') is not None:
            temp_model = CreateEventResponseBodyRecurrencePattern()
            self.pattern = temp_model.from_map(m['Pattern'])
        if m.get('Range') is not None:
            temp_model = CreateEventResponseBodyRecurrenceRange()
            self.range = temp_model.from_map(m['Range'])
        return self


class CreateEventResponseBodyReminders(TeaModel):
    def __init__(
        self,
        method: str = None,
        minutes: str = None,
    ):
        self.method = method
        self.minutes = minutes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.method is not None:
            result['Method'] = self.method
        if self.minutes is not None:
            result['Minutes'] = self.minutes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('Minutes') is not None:
            self.minutes = m.get('Minutes')
        return self


class CreateEventResponseBodyRichTextDescription(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('text') is not None:
            self.text = m.get('text')
        return self


class CreateEventResponseBodyStart(TeaModel):
    def __init__(
        self,
        date: str = None,
        date_time: str = None,
        time_zone: str = None,
    ):
        self.date = date
        self.date_time = date_time
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['Date'] = self.date
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.time_zone is not None:
            result['TimeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Date') is not None:
            self.date = m.get('Date')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('TimeZone') is not None:
            self.time_zone = m.get('TimeZone')
        return self


class CreateEventResponseBodyUiConfigs(TeaModel):
    def __init__(
        self,
        ui_name: str = None,
        ui_status: str = None,
    ):
        self.ui_name = ui_name
        self.ui_status = ui_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ui_name is not None:
            result['UiName'] = self.ui_name
        if self.ui_status is not None:
            result['UiStatus'] = self.ui_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UiName') is not None:
            self.ui_name = m.get('UiName')
        if m.get('UiStatus') is not None:
            self.ui_status = m.get('UiStatus')
        return self


class CreateEventResponseBody(TeaModel):
    def __init__(
        self,
        attendees: List[CreateEventResponseBodyAttendees] = None,
        create_time: str = None,
        description: str = None,
        end: CreateEventResponseBodyEnd = None,
        id: str = None,
        is_all_day: bool = None,
        location: CreateEventResponseBodyLocation = None,
        online_meeting_info: CreateEventResponseBodyOnlineMeetingInfo = None,
        organizer: CreateEventResponseBodyOrganizer = None,
        recurrence: CreateEventResponseBodyRecurrence = None,
        reminders: List[CreateEventResponseBodyReminders] = None,
        request_id: str = None,
        rich_text_description: CreateEventResponseBodyRichTextDescription = None,
        start: CreateEventResponseBodyStart = None,
        summary: str = None,
        ui_configs: List[CreateEventResponseBodyUiConfigs] = None,
        update_time: str = None,
    ):
        self.attendees = attendees
        self.create_time = create_time
        self.description = description
        self.end = end
        self.id = id
        self.is_all_day = is_all_day
        self.location = location
        self.online_meeting_info = online_meeting_info
        self.organizer = organizer
        self.recurrence = recurrence
        self.reminders = reminders
        # requestId
        self.request_id = request_id
        self.rich_text_description = rich_text_description
        self.start = start
        self.summary = summary
        self.ui_configs = ui_configs
        self.update_time = update_time

    def validate(self):
        if self.attendees:
            for k in self.attendees:
                if k:
                    k.validate()
        if self.end:
            self.end.validate()
        if self.location:
            self.location.validate()
        if self.online_meeting_info:
            self.online_meeting_info.validate()
        if self.organizer:
            self.organizer.validate()
        if self.recurrence:
            self.recurrence.validate()
        if self.reminders:
            for k in self.reminders:
                if k:
                    k.validate()
        if self.rich_text_description:
            self.rich_text_description.validate()
        if self.start:
            self.start.validate()
        if self.ui_configs:
            for k in self.ui_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['attendees'] = []
        if self.attendees is not None:
            for k in self.attendees:
                result['attendees'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.description is not None:
            result['description'] = self.description
        if self.end is not None:
            result['end'] = self.end.to_map()
        if self.id is not None:
            result['id'] = self.id
        if self.is_all_day is not None:
            result['isAllDay'] = self.is_all_day
        if self.location is not None:
            result['location'] = self.location.to_map()
        if self.online_meeting_info is not None:
            result['onlineMeetingInfo'] = self.online_meeting_info.to_map()
        if self.organizer is not None:
            result['organizer'] = self.organizer.to_map()
        if self.recurrence is not None:
            result['recurrence'] = self.recurrence.to_map()
        result['reminders'] = []
        if self.reminders is not None:
            for k in self.reminders:
                result['reminders'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.rich_text_description is not None:
            result['richTextDescription'] = self.rich_text_description.to_map()
        if self.start is not None:
            result['start'] = self.start.to_map()
        if self.summary is not None:
            result['summary'] = self.summary
        result['uiConfigs'] = []
        if self.ui_configs is not None:
            for k in self.ui_configs:
                result['uiConfigs'].append(k.to_map() if k else None)
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attendees = []
        if m.get('attendees') is not None:
            for k in m.get('attendees'):
                temp_model = CreateEventResponseBodyAttendees()
                self.attendees.append(temp_model.from_map(k))
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('end') is not None:
            temp_model = CreateEventResponseBodyEnd()
            self.end = temp_model.from_map(m['end'])
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('isAllDay') is not None:
            self.is_all_day = m.get('isAllDay')
        if m.get('location') is not None:
            temp_model = CreateEventResponseBodyLocation()
            self.location = temp_model.from_map(m['location'])
        if m.get('onlineMeetingInfo') is not None:
            temp_model = CreateEventResponseBodyOnlineMeetingInfo()
            self.online_meeting_info = temp_model.from_map(m['onlineMeetingInfo'])
        if m.get('organizer') is not None:
            temp_model = CreateEventResponseBodyOrganizer()
            self.organizer = temp_model.from_map(m['organizer'])
        if m.get('recurrence') is not None:
            temp_model = CreateEventResponseBodyRecurrence()
            self.recurrence = temp_model.from_map(m['recurrence'])
        self.reminders = []
        if m.get('reminders') is not None:
            for k in m.get('reminders'):
                temp_model = CreateEventResponseBodyReminders()
                self.reminders.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('richTextDescription') is not None:
            temp_model = CreateEventResponseBodyRichTextDescription()
            self.rich_text_description = temp_model.from_map(m['richTextDescription'])
        if m.get('start') is not None:
            temp_model = CreateEventResponseBodyStart()
            self.start = temp_model.from_map(m['start'])
        if m.get('summary') is not None:
            self.summary = m.get('summary')
        self.ui_configs = []
        if m.get('uiConfigs') is not None:
            for k in m.get('uiConfigs'):
                temp_model = CreateEventResponseBodyUiConfigs()
                self.ui_configs.append(temp_model.from_map(k))
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        return self


class CreateEventResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEventResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLiveHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateLiveHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateLiveHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateLiveHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateLiveShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateLiveRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CreateLiveRequest(TeaModel):
    def __init__(
        self,
        cover_url: str = None,
        introduction: str = None,
        pre_end_time: int = None,
        pre_start_time: int = None,
        public_type: int = None,
        tenant_context: CreateLiveRequestTenantContext = None,
        title: str = None,
    ):
        self.cover_url = cover_url
        self.introduction = introduction
        # This parameter is required.
        self.pre_end_time = pre_end_time
        # This parameter is required.
        self.pre_start_time = pre_start_time
        self.public_type = public_type
        self.tenant_context = tenant_context
        # This parameter is required.
        self.title = title

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cover_url is not None:
            result['CoverUrl'] = self.cover_url
        if self.introduction is not None:
            result['Introduction'] = self.introduction
        if self.pre_end_time is not None:
            result['PreEndTime'] = self.pre_end_time
        if self.pre_start_time is not None:
            result['PreStartTime'] = self.pre_start_time
        if self.public_type is not None:
            result['PublicType'] = self.public_type
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CoverUrl') is not None:
            self.cover_url = m.get('CoverUrl')
        if m.get('Introduction') is not None:
            self.introduction = m.get('Introduction')
        if m.get('PreEndTime') is not None:
            self.pre_end_time = m.get('PreEndTime')
        if m.get('PreStartTime') is not None:
            self.pre_start_time = m.get('PreStartTime')
        if m.get('PublicType') is not None:
            self.public_type = m.get('PublicType')
        if m.get('TenantContext') is not None:
            temp_model = CreateLiveRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class CreateLiveShrinkRequest(TeaModel):
    def __init__(
        self,
        cover_url: str = None,
        introduction: str = None,
        pre_end_time: int = None,
        pre_start_time: int = None,
        public_type: int = None,
        tenant_context_shrink: str = None,
        title: str = None,
    ):
        self.cover_url = cover_url
        self.introduction = introduction
        # This parameter is required.
        self.pre_end_time = pre_end_time
        # This parameter is required.
        self.pre_start_time = pre_start_time
        self.public_type = public_type
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cover_url is not None:
            result['CoverUrl'] = self.cover_url
        if self.introduction is not None:
            result['Introduction'] = self.introduction
        if self.pre_end_time is not None:
            result['PreEndTime'] = self.pre_end_time
        if self.pre_start_time is not None:
            result['PreStartTime'] = self.pre_start_time
        if self.public_type is not None:
            result['PublicType'] = self.public_type
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CoverUrl') is not None:
            self.cover_url = m.get('CoverUrl')
        if m.get('Introduction') is not None:
            self.introduction = m.get('Introduction')
        if m.get('PreEndTime') is not None:
            self.pre_end_time = m.get('PreEndTime')
        if m.get('PreStartTime') is not None:
            self.pre_start_time = m.get('PreStartTime')
        if m.get('PublicType') is not None:
            self.public_type = m.get('PublicType')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class CreateLiveResponseBody(TeaModel):
    def __init__(
        self,
        live_id: str = None,
        request_id: str = None,
    ):
        self.live_id = live_id
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_id is not None:
            result['liveId'] = self.live_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('liveId') is not None:
            self.live_id = m.get('liveId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateLiveResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLiveResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLiveResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMeetingRoomHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateMeetingRoomHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateMeetingRoomHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateMeetingRoomHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateMeetingRoomShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateMeetingRoomRequestReservationAuthorityAuthorizedMembers(TeaModel):
    def __init__(
        self,
        member_id: str = None,
        member_name: str = None,
        member_type: str = None,
    ):
        self.member_id = member_id
        self.member_name = member_name
        self.member_type = member_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.member_id is not None:
            result['MemberId'] = self.member_id
        if self.member_name is not None:
            result['MemberName'] = self.member_name
        if self.member_type is not None:
            result['MemberType'] = self.member_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemberId') is not None:
            self.member_id = m.get('MemberId')
        if m.get('MemberName') is not None:
            self.member_name = m.get('MemberName')
        if m.get('MemberType') is not None:
            self.member_type = m.get('MemberType')
        return self


class CreateMeetingRoomRequestReservationAuthority(TeaModel):
    def __init__(
        self,
        authorized_members: List[CreateMeetingRoomRequestReservationAuthorityAuthorizedMembers] = None,
    ):
        self.authorized_members = authorized_members

    def validate(self):
        if self.authorized_members:
            for k in self.authorized_members:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AuthorizedMembers'] = []
        if self.authorized_members is not None:
            for k in self.authorized_members:
                result['AuthorizedMembers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.authorized_members = []
        if m.get('AuthorizedMembers') is not None:
            for k in m.get('AuthorizedMembers'):
                temp_model = CreateMeetingRoomRequestReservationAuthorityAuthorizedMembers()
                self.authorized_members.append(temp_model.from_map(k))
        return self


class CreateMeetingRoomRequestRoomLocation(TeaModel):
    def __init__(
        self,
        desc: str = None,
        title: str = None,
    ):
        self.desc = desc
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class CreateMeetingRoomRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CreateMeetingRoomRequest(TeaModel):
    def __init__(
        self,
        enable_cycle_reservation: bool = None,
        group_id: int = None,
        isv_room_id: str = None,
        reservation_authority: CreateMeetingRoomRequestReservationAuthority = None,
        room_capacity: int = None,
        room_label_ids: List[int] = None,
        room_location: CreateMeetingRoomRequestRoomLocation = None,
        room_name: str = None,
        room_picture: str = None,
        room_status: int = None,
        tenant_context: CreateMeetingRoomRequestTenantContext = None,
    ):
        self.enable_cycle_reservation = enable_cycle_reservation
        self.group_id = group_id
        self.isv_room_id = isv_room_id
        self.reservation_authority = reservation_authority
        self.room_capacity = room_capacity
        self.room_label_ids = room_label_ids
        self.room_location = room_location
        self.room_name = room_name
        self.room_picture = room_picture
        self.room_status = room_status
        self.tenant_context = tenant_context

    def validate(self):
        if self.reservation_authority:
            self.reservation_authority.validate()
        if self.room_location:
            self.room_location.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_cycle_reservation is not None:
            result['EnableCycleReservation'] = self.enable_cycle_reservation
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.isv_room_id is not None:
            result['IsvRoomId'] = self.isv_room_id
        if self.reservation_authority is not None:
            result['ReservationAuthority'] = self.reservation_authority.to_map()
        if self.room_capacity is not None:
            result['RoomCapacity'] = self.room_capacity
        if self.room_label_ids is not None:
            result['RoomLabelIds'] = self.room_label_ids
        if self.room_location is not None:
            result['RoomLocation'] = self.room_location.to_map()
        if self.room_name is not None:
            result['RoomName'] = self.room_name
        if self.room_picture is not None:
            result['RoomPicture'] = self.room_picture
        if self.room_status is not None:
            result['RoomStatus'] = self.room_status
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableCycleReservation') is not None:
            self.enable_cycle_reservation = m.get('EnableCycleReservation')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IsvRoomId') is not None:
            self.isv_room_id = m.get('IsvRoomId')
        if m.get('ReservationAuthority') is not None:
            temp_model = CreateMeetingRoomRequestReservationAuthority()
            self.reservation_authority = temp_model.from_map(m['ReservationAuthority'])
        if m.get('RoomCapacity') is not None:
            self.room_capacity = m.get('RoomCapacity')
        if m.get('RoomLabelIds') is not None:
            self.room_label_ids = m.get('RoomLabelIds')
        if m.get('RoomLocation') is not None:
            temp_model = CreateMeetingRoomRequestRoomLocation()
            self.room_location = temp_model.from_map(m['RoomLocation'])
        if m.get('RoomName') is not None:
            self.room_name = m.get('RoomName')
        if m.get('RoomPicture') is not None:
            self.room_picture = m.get('RoomPicture')
        if m.get('RoomStatus') is not None:
            self.room_status = m.get('RoomStatus')
        if m.get('TenantContext') is not None:
            temp_model = CreateMeetingRoomRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class CreateMeetingRoomShrinkRequest(TeaModel):
    def __init__(
        self,
        enable_cycle_reservation: bool = None,
        group_id: int = None,
        isv_room_id: str = None,
        reservation_authority_shrink: str = None,
        room_capacity: int = None,
        room_label_ids_shrink: str = None,
        room_location_shrink: str = None,
        room_name: str = None,
        room_picture: str = None,
        room_status: int = None,
        tenant_context_shrink: str = None,
    ):
        self.enable_cycle_reservation = enable_cycle_reservation
        self.group_id = group_id
        self.isv_room_id = isv_room_id
        self.reservation_authority_shrink = reservation_authority_shrink
        self.room_capacity = room_capacity
        self.room_label_ids_shrink = room_label_ids_shrink
        self.room_location_shrink = room_location_shrink
        self.room_name = room_name
        self.room_picture = room_picture
        self.room_status = room_status
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_cycle_reservation is not None:
            result['EnableCycleReservation'] = self.enable_cycle_reservation
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.isv_room_id is not None:
            result['IsvRoomId'] = self.isv_room_id
        if self.reservation_authority_shrink is not None:
            result['ReservationAuthority'] = self.reservation_authority_shrink
        if self.room_capacity is not None:
            result['RoomCapacity'] = self.room_capacity
        if self.room_label_ids_shrink is not None:
            result['RoomLabelIds'] = self.room_label_ids_shrink
        if self.room_location_shrink is not None:
            result['RoomLocation'] = self.room_location_shrink
        if self.room_name is not None:
            result['RoomName'] = self.room_name
        if self.room_picture is not None:
            result['RoomPicture'] = self.room_picture
        if self.room_status is not None:
            result['RoomStatus'] = self.room_status
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableCycleReservation') is not None:
            self.enable_cycle_reservation = m.get('EnableCycleReservation')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IsvRoomId') is not None:
            self.isv_room_id = m.get('IsvRoomId')
        if m.get('ReservationAuthority') is not None:
            self.reservation_authority_shrink = m.get('ReservationAuthority')
        if m.get('RoomCapacity') is not None:
            self.room_capacity = m.get('RoomCapacity')
        if m.get('RoomLabelIds') is not None:
            self.room_label_ids_shrink = m.get('RoomLabelIds')
        if m.get('RoomLocation') is not None:
            self.room_location_shrink = m.get('RoomLocation')
        if m.get('RoomName') is not None:
            self.room_name = m.get('RoomName')
        if m.get('RoomPicture') is not None:
            self.room_picture = m.get('RoomPicture')
        if m.get('RoomStatus') is not None:
            self.room_status = m.get('RoomStatus')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class CreateMeetingRoomResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        # requestId
        self.request_id = request_id
        self.result = result
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class CreateMeetingRoomResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateMeetingRoomResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMeetingRoomResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMeetingRoomGroupHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateMeetingRoomGroupHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateMeetingRoomGroupHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateMeetingRoomGroupHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateMeetingRoomGroupShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateMeetingRoomGroupRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CreateMeetingRoomGroupRequest(TeaModel):
    def __init__(
        self,
        group_name: str = None,
        parent_group_id: int = None,
        tenant_context: CreateMeetingRoomGroupRequestTenantContext = None,
    ):
        self.group_name = group_name
        # This parameter is required.
        self.parent_group_id = parent_group_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.parent_group_id is not None:
            result['ParentGroupId'] = self.parent_group_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('ParentGroupId') is not None:
            self.parent_group_id = m.get('ParentGroupId')
        if m.get('TenantContext') is not None:
            temp_model = CreateMeetingRoomGroupRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class CreateMeetingRoomGroupShrinkRequest(TeaModel):
    def __init__(
        self,
        group_name: str = None,
        parent_group_id: int = None,
        tenant_context_shrink: str = None,
    ):
        self.group_name = group_name
        # This parameter is required.
        self.parent_group_id = parent_group_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.parent_group_id is not None:
            result['ParentGroupId'] = self.parent_group_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('ParentGroupId') is not None:
            self.parent_group_id = m.get('ParentGroupId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class CreateMeetingRoomGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: int = None,
    ):
        # requestId
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class CreateMeetingRoomGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateMeetingRoomGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMeetingRoomGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMessageHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_id: str = None,
    ):
        self.common_headers = common_headers
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateMessageRequestMessagesContentCardCallback(TeaModel):
    def __init__(
        self,
        content: str = None,
        related_message_id: str = None,
    ):
        # This parameter is required.
        self.content = content
        # This parameter is required.
        self.related_message_id = related_message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.related_message_id is not None:
            result['relatedMessageId'] = self.related_message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('relatedMessageId') is not None:
            self.related_message_id = m.get('relatedMessageId')
        return self


class CreateMessageRequestMessagesContentDingCard(TeaModel):
    def __init__(
        self,
        content: str = None,
        content_type: str = None,
        finished: bool = None,
        template_id: str = None,
    ):
        self.content = content
        # This parameter is required.
        self.content_type = content_type
        self.finished = finished
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.content_type is not None:
            result['contentType'] = self.content_type
        if self.finished is not None:
            result['finished'] = self.finished
        if self.template_id is not None:
            result['templateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('contentType') is not None:
            self.content_type = m.get('contentType')
        if m.get('finished') is not None:
            self.finished = m.get('finished')
        if m.get('templateId') is not None:
            self.template_id = m.get('templateId')
        return self


class CreateMessageRequestMessagesContentDingNormalCardCardData(TeaModel):
    def __init__(
        self,
        card_param_map: Dict[str, Any] = None,
    ):
        self.card_param_map = card_param_map

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_param_map is not None:
            result['cardParamMap'] = self.card_param_map
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardParamMap') is not None:
            self.card_param_map = m.get('cardParamMap')
        return self


class CreateMessageRequestMessagesContentDingNormalCardCardUpdateOptions(TeaModel):
    def __init__(
        self,
        update_card_data_by_key: bool = None,
        update_private_data_by_key: bool = None,
    ):
        self.update_card_data_by_key = update_card_data_by_key
        self.update_private_data_by_key = update_private_data_by_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.update_card_data_by_key is not None:
            result['updateCardDataByKey'] = self.update_card_data_by_key
        if self.update_private_data_by_key is not None:
            result['updatePrivateDataByKey'] = self.update_private_data_by_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('updateCardDataByKey') is not None:
            self.update_card_data_by_key = m.get('updateCardDataByKey')
        if m.get('updatePrivateDataByKey') is not None:
            self.update_private_data_by_key = m.get('updatePrivateDataByKey')
        return self


class CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig(TeaModel):
    def __init__(
        self,
        interval: int = None,
        pull_strategy: str = None,
        time_unit: str = None,
    ):
        self.interval = interval
        self.pull_strategy = pull_strategy
        self.time_unit = time_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interval is not None:
            result['interval'] = self.interval
        if self.pull_strategy is not None:
            result['pullStrategy'] = self.pull_strategy
        if self.time_unit is not None:
            result['timeUnit'] = self.time_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('pullStrategy') is not None:
            self.pull_strategy = m.get('pullStrategy')
        if m.get('timeUnit') is not None:
            self.time_unit = m.get('timeUnit')
        return self


class CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigs(TeaModel):
    def __init__(
        self,
        const_params: Dict[str, Any] = None,
        dynamic_data_source_id: str = None,
        pull_config: CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig = None,
    ):
        self.const_params = const_params
        self.dynamic_data_source_id = dynamic_data_source_id
        self.pull_config = pull_config

    def validate(self):
        if self.pull_config:
            self.pull_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.const_params is not None:
            result['constParams'] = self.const_params
        if self.dynamic_data_source_id is not None:
            result['dynamicDataSourceId'] = self.dynamic_data_source_id
        if self.pull_config is not None:
            result['pullConfig'] = self.pull_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('constParams') is not None:
            self.const_params = m.get('constParams')
        if m.get('dynamicDataSourceId') is not None:
            self.dynamic_data_source_id = m.get('dynamicDataSourceId')
        if m.get('pullConfig') is not None:
            temp_model = CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig()
            self.pull_config = temp_model.from_map(m['pullConfig'])
        return self


class CreateMessageRequestMessagesContentDingNormalCard(TeaModel):
    def __init__(
        self,
        card_data: CreateMessageRequestMessagesContentDingNormalCardCardData = None,
        card_template_id: str = None,
        card_update_options: CreateMessageRequestMessagesContentDingNormalCardCardUpdateOptions = None,
        dynamic_data_source_configs: List[CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigs] = None,
        private_data: Dict[str, dict] = None,
    ):
        self.card_data = card_data
        self.card_template_id = card_template_id
        self.card_update_options = card_update_options
        self.dynamic_data_source_configs = dynamic_data_source_configs
        self.private_data = private_data

    def validate(self):
        if self.card_data:
            self.card_data.validate()
        if self.card_update_options:
            self.card_update_options.validate()
        if self.dynamic_data_source_configs:
            for k in self.dynamic_data_source_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_data is not None:
            result['cardData'] = self.card_data.to_map()
        if self.card_template_id is not None:
            result['cardTemplateId'] = self.card_template_id
        if self.card_update_options is not None:
            result['cardUpdateOptions'] = self.card_update_options.to_map()
        result['dynamicDataSourceConfigs'] = []
        if self.dynamic_data_source_configs is not None:
            for k in self.dynamic_data_source_configs:
                result['dynamicDataSourceConfigs'].append(k.to_map() if k else None)
        if self.private_data is not None:
            result['privateData'] = self.private_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardData') is not None:
            temp_model = CreateMessageRequestMessagesContentDingNormalCardCardData()
            self.card_data = temp_model.from_map(m['cardData'])
        if m.get('cardTemplateId') is not None:
            self.card_template_id = m.get('cardTemplateId')
        if m.get('cardUpdateOptions') is not None:
            temp_model = CreateMessageRequestMessagesContentDingNormalCardCardUpdateOptions()
            self.card_update_options = temp_model.from_map(m['cardUpdateOptions'])
        self.dynamic_data_source_configs = []
        if m.get('dynamicDataSourceConfigs') is not None:
            for k in m.get('dynamicDataSourceConfigs'):
                temp_model = CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigs()
                self.dynamic_data_source_configs.append(temp_model.from_map(k))
        if m.get('privateData') is not None:
            self.private_data = m.get('privateData')
        return self


class CreateMessageRequestMessagesContentMarkdown(TeaModel):
    def __init__(
        self,
        value: str = None,
    ):
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class CreateMessageRequestMessagesContentStructViewPartsDataPart(TeaModel):
    def __init__(
        self,
        data: Any = None,
    ):
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class CreateMessageRequestMessagesContentStructViewPartsReasonPart(TeaModel):
    def __init__(
        self,
        reason: str = None,
    ):
        self.reason = reason

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reason is not None:
            result['reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        return self


class CreateMessageRequestMessagesContentStructViewPartsRecommendPartRecommends(TeaModel):
    def __init__(
        self,
        mobile_url: str = None,
        text: str = None,
        url: str = None,
    ):
        self.mobile_url = mobile_url
        self.text = text
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mobile_url is not None:
            result['mobileUrl'] = self.mobile_url
        if self.text is not None:
            result['text'] = self.text
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('mobileUrl') is not None:
            self.mobile_url = m.get('mobileUrl')
        if m.get('text') is not None:
            self.text = m.get('text')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class CreateMessageRequestMessagesContentStructViewPartsRecommendPart(TeaModel):
    def __init__(
        self,
        recommends: List[CreateMessageRequestMessagesContentStructViewPartsRecommendPartRecommends] = None,
    ):
        self.recommends = recommends

    def validate(self):
        if self.recommends:
            for k in self.recommends:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['recommends'] = []
        if self.recommends is not None:
            for k in self.recommends:
                result['recommends'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.recommends = []
        if m.get('recommends') is not None:
            for k in m.get('recommends'):
                temp_model = CreateMessageRequestMessagesContentStructViewPartsRecommendPartRecommends()
                self.recommends.append(temp_model.from_map(k))
        return self


class CreateMessageRequestMessagesContentStructViewPartsReferencePartReferences(TeaModel):
    def __init__(
        self,
        index: str = None,
        name: str = None,
        source_code: str = None,
        source_icon: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.index = index
        self.name = name
        self.source_code = source_code
        self.source_icon = source_icon
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['index'] = self.index
        if self.name is not None:
            result['name'] = self.name
        if self.source_code is not None:
            result['sourceCode'] = self.source_code
        if self.source_icon is not None:
            result['sourceIcon'] = self.source_icon
        if self.summary is not None:
            result['summary'] = self.summary
        if self.title is not None:
            result['title'] = self.title
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('sourceCode') is not None:
            self.source_code = m.get('sourceCode')
        if m.get('sourceIcon') is not None:
            self.source_icon = m.get('sourceIcon')
        if m.get('summary') is not None:
            self.summary = m.get('summary')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class CreateMessageRequestMessagesContentStructViewPartsReferencePart(TeaModel):
    def __init__(
        self,
        references: List[CreateMessageRequestMessagesContentStructViewPartsReferencePartReferences] = None,
    ):
        self.references = references

    def validate(self):
        if self.references:
            for k in self.references:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['references'] = []
        if self.references is not None:
            for k in self.references:
                result['references'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.references = []
        if m.get('references') is not None:
            for k in m.get('references'):
                temp_model = CreateMessageRequestMessagesContentStructViewPartsReferencePartReferences()
                self.references.append(temp_model.from_map(k))
        return self


class CreateMessageRequestMessagesContentStructViewPartsTextPart(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('text') is not None:
            self.text = m.get('text')
        return self


class CreateMessageRequestMessagesContentStructViewParts(TeaModel):
    def __init__(
        self,
        append: bool = None,
        data_part: CreateMessageRequestMessagesContentStructViewPartsDataPart = None,
        finish: bool = None,
        part_desc: str = None,
        part_id: str = None,
        reason_part: CreateMessageRequestMessagesContentStructViewPartsReasonPart = None,
        recommend_part: CreateMessageRequestMessagesContentStructViewPartsRecommendPart = None,
        reference_part: CreateMessageRequestMessagesContentStructViewPartsReferencePart = None,
        text_part: CreateMessageRequestMessagesContentStructViewPartsTextPart = None,
        type: str = None,
    ):
        self.append = append
        self.data_part = data_part
        self.finish = finish
        self.part_desc = part_desc
        self.part_id = part_id
        self.reason_part = reason_part
        self.recommend_part = recommend_part
        self.reference_part = reference_part
        self.text_part = text_part
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.data_part:
            self.data_part.validate()
        if self.reason_part:
            self.reason_part.validate()
        if self.recommend_part:
            self.recommend_part.validate()
        if self.reference_part:
            self.reference_part.validate()
        if self.text_part:
            self.text_part.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.append is not None:
            result['append'] = self.append
        if self.data_part is not None:
            result['dataPart'] = self.data_part.to_map()
        if self.finish is not None:
            result['finish'] = self.finish
        if self.part_desc is not None:
            result['partDesc'] = self.part_desc
        if self.part_id is not None:
            result['partId'] = self.part_id
        if self.reason_part is not None:
            result['reasonPart'] = self.reason_part.to_map()
        if self.recommend_part is not None:
            result['recommendPart'] = self.recommend_part.to_map()
        if self.reference_part is not None:
            result['referencePart'] = self.reference_part.to_map()
        if self.text_part is not None:
            result['textPart'] = self.text_part.to_map()
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('append') is not None:
            self.append = m.get('append')
        if m.get('dataPart') is not None:
            temp_model = CreateMessageRequestMessagesContentStructViewPartsDataPart()
            self.data_part = temp_model.from_map(m['dataPart'])
        if m.get('finish') is not None:
            self.finish = m.get('finish')
        if m.get('partDesc') is not None:
            self.part_desc = m.get('partDesc')
        if m.get('partId') is not None:
            self.part_id = m.get('partId')
        if m.get('reasonPart') is not None:
            temp_model = CreateMessageRequestMessagesContentStructViewPartsReasonPart()
            self.reason_part = temp_model.from_map(m['reasonPart'])
        if m.get('recommendPart') is not None:
            temp_model = CreateMessageRequestMessagesContentStructViewPartsRecommendPart()
            self.recommend_part = temp_model.from_map(m['recommendPart'])
        if m.get('referencePart') is not None:
            temp_model = CreateMessageRequestMessagesContentStructViewPartsReferencePart()
            self.reference_part = temp_model.from_map(m['referencePart'])
        if m.get('textPart') is not None:
            temp_model = CreateMessageRequestMessagesContentStructViewPartsTextPart()
            self.text_part = temp_model.from_map(m['textPart'])
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateMessageRequestMessagesContentStructView(TeaModel):
    def __init__(
        self,
        parts: List[CreateMessageRequestMessagesContentStructViewParts] = None,
    ):
        self.parts = parts

    def validate(self):
        if self.parts:
            for k in self.parts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['parts'] = []
        if self.parts is not None:
            for k in self.parts:
                result['parts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.parts = []
        if m.get('parts') is not None:
            for k in m.get('parts'):
                temp_model = CreateMessageRequestMessagesContentStructViewParts()
                self.parts.append(temp_model.from_map(k))
        return self


class CreateMessageRequestMessagesContentText(TeaModel):
    def __init__(
        self,
        value: str = None,
    ):
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class CreateMessageRequestMessagesContent(TeaModel):
    def __init__(
        self,
        card_callback: CreateMessageRequestMessagesContentCardCallback = None,
        ding_card: CreateMessageRequestMessagesContentDingCard = None,
        ding_normal_card: CreateMessageRequestMessagesContentDingNormalCard = None,
        markdown: CreateMessageRequestMessagesContentMarkdown = None,
        struct_view: CreateMessageRequestMessagesContentStructView = None,
        text: CreateMessageRequestMessagesContentText = None,
        type: str = None,
    ):
        self.card_callback = card_callback
        self.ding_card = ding_card
        self.ding_normal_card = ding_normal_card
        self.markdown = markdown
        self.struct_view = struct_view
        self.text = text
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.card_callback:
            self.card_callback.validate()
        if self.ding_card:
            self.ding_card.validate()
        if self.ding_normal_card:
            self.ding_normal_card.validate()
        if self.markdown:
            self.markdown.validate()
        if self.struct_view:
            self.struct_view.validate()
        if self.text:
            self.text.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_callback is not None:
            result['cardCallback'] = self.card_callback.to_map()
        if self.ding_card is not None:
            result['dingCard'] = self.ding_card.to_map()
        if self.ding_normal_card is not None:
            result['dingNormalCard'] = self.ding_normal_card.to_map()
        if self.markdown is not None:
            result['markdown'] = self.markdown.to_map()
        if self.struct_view is not None:
            result['structView'] = self.struct_view.to_map()
        if self.text is not None:
            result['text'] = self.text.to_map()
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardCallback') is not None:
            temp_model = CreateMessageRequestMessagesContentCardCallback()
            self.card_callback = temp_model.from_map(m['cardCallback'])
        if m.get('dingCard') is not None:
            temp_model = CreateMessageRequestMessagesContentDingCard()
            self.ding_card = temp_model.from_map(m['dingCard'])
        if m.get('dingNormalCard') is not None:
            temp_model = CreateMessageRequestMessagesContentDingNormalCard()
            self.ding_normal_card = temp_model.from_map(m['dingNormalCard'])
        if m.get('markdown') is not None:
            temp_model = CreateMessageRequestMessagesContentMarkdown()
            self.markdown = temp_model.from_map(m['markdown'])
        if m.get('structView') is not None:
            temp_model = CreateMessageRequestMessagesContentStructView()
            self.struct_view = temp_model.from_map(m['structView'])
        if m.get('text') is not None:
            temp_model = CreateMessageRequestMessagesContentText()
            self.text = temp_model.from_map(m['text'])
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateMessageRequestMessages(TeaModel):
    def __init__(
        self,
        content: CreateMessageRequestMessagesContent = None,
        content_desc: str = None,
        create_at: int = None,
        role: str = None,
    ):
        self.content = content
        self.content_desc = content_desc
        self.create_at = create_at
        self.role = role

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content.to_map()
        if self.content_desc is not None:
            result['contentDesc'] = self.content_desc
        if self.create_at is not None:
            result['createAt'] = self.create_at
        if self.role is not None:
            result['role'] = self.role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            temp_model = CreateMessageRequestMessagesContent()
            self.content = temp_model.from_map(m['content'])
        if m.get('contentDesc') is not None:
            self.content_desc = m.get('contentDesc')
        if m.get('createAt') is not None:
            self.create_at = m.get('createAt')
        if m.get('role') is not None:
            self.role = m.get('role')
        return self


class CreateMessageRequest(TeaModel):
    def __init__(
        self,
        assistant_id: str = None,
        messages: List[CreateMessageRequestMessages] = None,
        original_assistant_id: str = None,
        source_id_of_original_assistant_id: str = None,
        source_type_of_original_assistant_id: str = None,
        thread_id: str = None,
    ):
        # This parameter is required.
        self.assistant_id = assistant_id
        # This parameter is required.
        self.messages = messages
        self.original_assistant_id = original_assistant_id
        self.source_id_of_original_assistant_id = source_id_of_original_assistant_id
        self.source_type_of_original_assistant_id = source_type_of_original_assistant_id
        # This parameter is required.
        self.thread_id = thread_id

    def validate(self):
        if self.messages:
            for k in self.messages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assistant_id is not None:
            result['assistantId'] = self.assistant_id
        result['messages'] = []
        if self.messages is not None:
            for k in self.messages:
                result['messages'].append(k.to_map() if k else None)
        if self.original_assistant_id is not None:
            result['originalAssistantId'] = self.original_assistant_id
        if self.source_id_of_original_assistant_id is not None:
            result['sourceIdOfOriginalAssistantId'] = self.source_id_of_original_assistant_id
        if self.source_type_of_original_assistant_id is not None:
            result['sourceTypeOfOriginalAssistantId'] = self.source_type_of_original_assistant_id
        if self.thread_id is not None:
            result['threadId'] = self.thread_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assistantId') is not None:
            self.assistant_id = m.get('assistantId')
        self.messages = []
        if m.get('messages') is not None:
            for k in m.get('messages'):
                temp_model = CreateMessageRequestMessages()
                self.messages.append(temp_model.from_map(k))
        if m.get('originalAssistantId') is not None:
            self.original_assistant_id = m.get('originalAssistantId')
        if m.get('sourceIdOfOriginalAssistantId') is not None:
            self.source_id_of_original_assistant_id = m.get('sourceIdOfOriginalAssistantId')
        if m.get('sourceTypeOfOriginalAssistantId') is not None:
            self.source_type_of_original_assistant_id = m.get('sourceTypeOfOriginalAssistantId')
        if m.get('threadId') is not None:
            self.thread_id = m.get('threadId')
        return self


class CreateMessageResponseBodyMessagesContentCardCallback(TeaModel):
    def __init__(
        self,
        content: str = None,
        related_message_id: str = None,
    ):
        self.content = content
        self.related_message_id = related_message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.related_message_id is not None:
            result['relatedMessageId'] = self.related_message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('relatedMessageId') is not None:
            self.related_message_id = m.get('relatedMessageId')
        return self


class CreateMessageResponseBodyMessagesContentDingCard(TeaModel):
    def __init__(
        self,
        content: str = None,
        content_type: str = None,
        finished: bool = None,
        template_id: str = None,
    ):
        self.content = content
        # This parameter is required.
        self.content_type = content_type
        self.finished = finished
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.content_type is not None:
            result['contentType'] = self.content_type
        if self.finished is not None:
            result['finished'] = self.finished
        if self.template_id is not None:
            result['templateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('contentType') is not None:
            self.content_type = m.get('contentType')
        if m.get('finished') is not None:
            self.finished = m.get('finished')
        if m.get('templateId') is not None:
            self.template_id = m.get('templateId')
        return self


class CreateMessageResponseBodyMessagesContentDingNormalCardCardData(TeaModel):
    def __init__(
        self,
        card_param_map: Dict[str, Any] = None,
    ):
        self.card_param_map = card_param_map

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_param_map is not None:
            result['cardParamMap'] = self.card_param_map
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardParamMap') is not None:
            self.card_param_map = m.get('cardParamMap')
        return self


class CreateMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions(TeaModel):
    def __init__(
        self,
        update_card_data_by_key: bool = None,
        update_private_data_by_key: bool = None,
    ):
        self.update_card_data_by_key = update_card_data_by_key
        self.update_private_data_by_key = update_private_data_by_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.update_card_data_by_key is not None:
            result['updateCardDataByKey'] = self.update_card_data_by_key
        if self.update_private_data_by_key is not None:
            result['updatePrivateDataByKey'] = self.update_private_data_by_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('updateCardDataByKey') is not None:
            self.update_card_data_by_key = m.get('updateCardDataByKey')
        if m.get('updatePrivateDataByKey') is not None:
            self.update_private_data_by_key = m.get('updatePrivateDataByKey')
        return self


class CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig(TeaModel):
    def __init__(
        self,
        interval: int = None,
        pull_strategy: str = None,
        time_unit: str = None,
    ):
        self.interval = interval
        self.pull_strategy = pull_strategy
        self.time_unit = time_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interval is not None:
            result['interval'] = self.interval
        if self.pull_strategy is not None:
            result['pullStrategy'] = self.pull_strategy
        if self.time_unit is not None:
            result['timeUnit'] = self.time_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('pullStrategy') is not None:
            self.pull_strategy = m.get('pullStrategy')
        if m.get('timeUnit') is not None:
            self.time_unit = m.get('timeUnit')
        return self


class CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs(TeaModel):
    def __init__(
        self,
        const_params: Dict[str, Any] = None,
        dynamic_data_source_id: str = None,
        pull_config: CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig = None,
    ):
        self.const_params = const_params
        self.dynamic_data_source_id = dynamic_data_source_id
        self.pull_config = pull_config

    def validate(self):
        if self.pull_config:
            self.pull_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.const_params is not None:
            result['constParams'] = self.const_params
        if self.dynamic_data_source_id is not None:
            result['dynamicDataSourceId'] = self.dynamic_data_source_id
        if self.pull_config is not None:
            result['pullConfig'] = self.pull_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('constParams') is not None:
            self.const_params = m.get('constParams')
        if m.get('dynamicDataSourceId') is not None:
            self.dynamic_data_source_id = m.get('dynamicDataSourceId')
        if m.get('pullConfig') is not None:
            temp_model = CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig()
            self.pull_config = temp_model.from_map(m['pullConfig'])
        return self


class CreateMessageResponseBodyMessagesContentDingNormalCard(TeaModel):
    def __init__(
        self,
        card_data: CreateMessageResponseBodyMessagesContentDingNormalCardCardData = None,
        card_template_id: str = None,
        card_update_options: CreateMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions = None,
        dynamic_data_source_configs: List[CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs] = None,
        private_data: Dict[str, dict] = None,
    ):
        self.card_data = card_data
        self.card_template_id = card_template_id
        self.card_update_options = card_update_options
        self.dynamic_data_source_configs = dynamic_data_source_configs
        self.private_data = private_data

    def validate(self):
        if self.card_data:
            self.card_data.validate()
        if self.card_update_options:
            self.card_update_options.validate()
        if self.dynamic_data_source_configs:
            for k in self.dynamic_data_source_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_data is not None:
            result['cardData'] = self.card_data.to_map()
        if self.card_template_id is not None:
            result['cardTemplateId'] = self.card_template_id
        if self.card_update_options is not None:
            result['cardUpdateOptions'] = self.card_update_options.to_map()
        result['dynamicDataSourceConfigs'] = []
        if self.dynamic_data_source_configs is not None:
            for k in self.dynamic_data_source_configs:
                result['dynamicDataSourceConfigs'].append(k.to_map() if k else None)
        if self.private_data is not None:
            result['privateData'] = self.private_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardData') is not None:
            temp_model = CreateMessageResponseBodyMessagesContentDingNormalCardCardData()
            self.card_data = temp_model.from_map(m['cardData'])
        if m.get('cardTemplateId') is not None:
            self.card_template_id = m.get('cardTemplateId')
        if m.get('cardUpdateOptions') is not None:
            temp_model = CreateMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions()
            self.card_update_options = temp_model.from_map(m['cardUpdateOptions'])
        self.dynamic_data_source_configs = []
        if m.get('dynamicDataSourceConfigs') is not None:
            for k in m.get('dynamicDataSourceConfigs'):
                temp_model = CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs()
                self.dynamic_data_source_configs.append(temp_model.from_map(k))
        if m.get('privateData') is not None:
            self.private_data = m.get('privateData')
        return self


class CreateMessageResponseBodyMessagesContentMarkdown(TeaModel):
    def __init__(
        self,
        value: str = None,
    ):
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class CreateMessageResponseBodyMessagesContentStructViewPartsDataPart(TeaModel):
    def __init__(
        self,
        data: Any = None,
    ):
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class CreateMessageResponseBodyMessagesContentStructViewPartsReasonPart(TeaModel):
    def __init__(
        self,
        reason: str = None,
    ):
        self.reason = reason

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reason is not None:
            result['reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        return self


class CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends(TeaModel):
    def __init__(
        self,
        mobile_url: str = None,
        text: str = None,
        url: str = None,
    ):
        self.mobile_url = mobile_url
        self.text = text
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mobile_url is not None:
            result['mobileUrl'] = self.mobile_url
        if self.text is not None:
            result['text'] = self.text
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('mobileUrl') is not None:
            self.mobile_url = m.get('mobileUrl')
        if m.get('text') is not None:
            self.text = m.get('text')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPart(TeaModel):
    def __init__(
        self,
        recommends: List[CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends] = None,
    ):
        self.recommends = recommends

    def validate(self):
        if self.recommends:
            for k in self.recommends:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['recommends'] = []
        if self.recommends is not None:
            for k in self.recommends:
                result['recommends'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.recommends = []
        if m.get('recommends') is not None:
            for k in m.get('recommends'):
                temp_model = CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends()
                self.recommends.append(temp_model.from_map(k))
        return self


class CreateMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences(TeaModel):
    def __init__(
        self,
        index: str = None,
        name: str = None,
        source_code: str = None,
        source_icon: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.index = index
        self.name = name
        self.source_code = source_code
        self.source_icon = source_icon
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['index'] = self.index
        if self.name is not None:
            result['name'] = self.name
        if self.source_code is not None:
            result['sourceCode'] = self.source_code
        if self.source_icon is not None:
            result['sourceIcon'] = self.source_icon
        if self.summary is not None:
            result['summary'] = self.summary
        if self.title is not None:
            result['title'] = self.title
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('sourceCode') is not None:
            self.source_code = m.get('sourceCode')
        if m.get('sourceIcon') is not None:
            self.source_icon = m.get('sourceIcon')
        if m.get('summary') is not None:
            self.summary = m.get('summary')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class CreateMessageResponseBodyMessagesContentStructViewPartsReferencePart(TeaModel):
    def __init__(
        self,
        references: List[CreateMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences] = None,
    ):
        self.references = references

    def validate(self):
        if self.references:
            for k in self.references:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['references'] = []
        if self.references is not None:
            for k in self.references:
                result['references'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.references = []
        if m.get('references') is not None:
            for k in m.get('references'):
                temp_model = CreateMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences()
                self.references.append(temp_model.from_map(k))
        return self


class CreateMessageResponseBodyMessagesContentStructViewPartsTextPart(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('text') is not None:
            self.text = m.get('text')
        return self


class CreateMessageResponseBodyMessagesContentStructViewParts(TeaModel):
    def __init__(
        self,
        append: bool = None,
        data_part: CreateMessageResponseBodyMessagesContentStructViewPartsDataPart = None,
        finish: bool = None,
        part_desc: str = None,
        part_id: str = None,
        reason_part: CreateMessageResponseBodyMessagesContentStructViewPartsReasonPart = None,
        recommend_part: CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPart = None,
        reference_part: CreateMessageResponseBodyMessagesContentStructViewPartsReferencePart = None,
        text_part: CreateMessageResponseBodyMessagesContentStructViewPartsTextPart = None,
        type: str = None,
    ):
        self.append = append
        self.data_part = data_part
        self.finish = finish
        self.part_desc = part_desc
        self.part_id = part_id
        self.reason_part = reason_part
        self.recommend_part = recommend_part
        self.reference_part = reference_part
        self.text_part = text_part
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.data_part:
            self.data_part.validate()
        if self.reason_part:
            self.reason_part.validate()
        if self.recommend_part:
            self.recommend_part.validate()
        if self.reference_part:
            self.reference_part.validate()
        if self.text_part:
            self.text_part.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.append is not None:
            result['append'] = self.append
        if self.data_part is not None:
            result['dataPart'] = self.data_part.to_map()
        if self.finish is not None:
            result['finish'] = self.finish
        if self.part_desc is not None:
            result['partDesc'] = self.part_desc
        if self.part_id is not None:
            result['partId'] = self.part_id
        if self.reason_part is not None:
            result['reasonPart'] = self.reason_part.to_map()
        if self.recommend_part is not None:
            result['recommendPart'] = self.recommend_part.to_map()
        if self.reference_part is not None:
            result['referencePart'] = self.reference_part.to_map()
        if self.text_part is not None:
            result['textPart'] = self.text_part.to_map()
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('append') is not None:
            self.append = m.get('append')
        if m.get('dataPart') is not None:
            temp_model = CreateMessageResponseBodyMessagesContentStructViewPartsDataPart()
            self.data_part = temp_model.from_map(m['dataPart'])
        if m.get('finish') is not None:
            self.finish = m.get('finish')
        if m.get('partDesc') is not None:
            self.part_desc = m.get('partDesc')
        if m.get('partId') is not None:
            self.part_id = m.get('partId')
        if m.get('reasonPart') is not None:
            temp_model = CreateMessageResponseBodyMessagesContentStructViewPartsReasonPart()
            self.reason_part = temp_model.from_map(m['reasonPart'])
        if m.get('recommendPart') is not None:
            temp_model = CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPart()
            self.recommend_part = temp_model.from_map(m['recommendPart'])
        if m.get('referencePart') is not None:
            temp_model = CreateMessageResponseBodyMessagesContentStructViewPartsReferencePart()
            self.reference_part = temp_model.from_map(m['referencePart'])
        if m.get('textPart') is not None:
            temp_model = CreateMessageResponseBodyMessagesContentStructViewPartsTextPart()
            self.text_part = temp_model.from_map(m['textPart'])
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateMessageResponseBodyMessagesContentStructView(TeaModel):
    def __init__(
        self,
        parts: List[CreateMessageResponseBodyMessagesContentStructViewParts] = None,
    ):
        self.parts = parts

    def validate(self):
        if self.parts:
            for k in self.parts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['parts'] = []
        if self.parts is not None:
            for k in self.parts:
                result['parts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.parts = []
        if m.get('parts') is not None:
            for k in m.get('parts'):
                temp_model = CreateMessageResponseBodyMessagesContentStructViewParts()
                self.parts.append(temp_model.from_map(k))
        return self


class CreateMessageResponseBodyMessagesContentText(TeaModel):
    def __init__(
        self,
        value: str = None,
    ):
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class CreateMessageResponseBodyMessagesContent(TeaModel):
    def __init__(
        self,
        card_callback: CreateMessageResponseBodyMessagesContentCardCallback = None,
        ding_card: CreateMessageResponseBodyMessagesContentDingCard = None,
        ding_normal_card: CreateMessageResponseBodyMessagesContentDingNormalCard = None,
        markdown: CreateMessageResponseBodyMessagesContentMarkdown = None,
        struct_view: CreateMessageResponseBodyMessagesContentStructView = None,
        text: CreateMessageResponseBodyMessagesContentText = None,
        type: str = None,
    ):
        self.card_callback = card_callback
        self.ding_card = ding_card
        self.ding_normal_card = ding_normal_card
        self.markdown = markdown
        self.struct_view = struct_view
        self.text = text
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.card_callback:
            self.card_callback.validate()
        if self.ding_card:
            self.ding_card.validate()
        if self.ding_normal_card:
            self.ding_normal_card.validate()
        if self.markdown:
            self.markdown.validate()
        if self.struct_view:
            self.struct_view.validate()
        if self.text:
            self.text.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_callback is not None:
            result['cardCallback'] = self.card_callback.to_map()
        if self.ding_card is not None:
            result['dingCard'] = self.ding_card.to_map()
        if self.ding_normal_card is not None:
            result['dingNormalCard'] = self.ding_normal_card.to_map()
        if self.markdown is not None:
            result['markdown'] = self.markdown.to_map()
        if self.struct_view is not None:
            result['structView'] = self.struct_view.to_map()
        if self.text is not None:
            result['text'] = self.text.to_map()
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardCallback') is not None:
            temp_model = CreateMessageResponseBodyMessagesContentCardCallback()
            self.card_callback = temp_model.from_map(m['cardCallback'])
        if m.get('dingCard') is not None:
            temp_model = CreateMessageResponseBodyMessagesContentDingCard()
            self.ding_card = temp_model.from_map(m['dingCard'])
        if m.get('dingNormalCard') is not None:
            temp_model = CreateMessageResponseBodyMessagesContentDingNormalCard()
            self.ding_normal_card = temp_model.from_map(m['dingNormalCard'])
        if m.get('markdown') is not None:
            temp_model = CreateMessageResponseBodyMessagesContentMarkdown()
            self.markdown = temp_model.from_map(m['markdown'])
        if m.get('structView') is not None:
            temp_model = CreateMessageResponseBodyMessagesContentStructView()
            self.struct_view = temp_model.from_map(m['structView'])
        if m.get('text') is not None:
            temp_model = CreateMessageResponseBodyMessagesContentText()
            self.text = temp_model.from_map(m['text'])
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateMessageResponseBodyMessages(TeaModel):
    def __init__(
        self,
        content: CreateMessageResponseBodyMessagesContent = None,
        content_desc: str = None,
        create_at: int = None,
        id: str = None,
        role: str = None,
        run_id: str = None,
        thread_id: str = None,
    ):
        self.content = content
        self.content_desc = content_desc
        self.create_at = create_at
        self.id = id
        self.role = role
        self.run_id = run_id
        self.thread_id = thread_id

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content.to_map()
        if self.content_desc is not None:
            result['contentDesc'] = self.content_desc
        if self.create_at is not None:
            result['createAt'] = self.create_at
        if self.id is not None:
            result['id'] = self.id
        if self.role is not None:
            result['role'] = self.role
        if self.run_id is not None:
            result['runId'] = self.run_id
        if self.thread_id is not None:
            result['threadId'] = self.thread_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            temp_model = CreateMessageResponseBodyMessagesContent()
            self.content = temp_model.from_map(m['content'])
        if m.get('contentDesc') is not None:
            self.content_desc = m.get('contentDesc')
        if m.get('createAt') is not None:
            self.create_at = m.get('createAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('role') is not None:
            self.role = m.get('role')
        if m.get('runId') is not None:
            self.run_id = m.get('runId')
        if m.get('threadId') is not None:
            self.thread_id = m.get('threadId')
        return self


class CreateMessageResponseBody(TeaModel):
    def __init__(
        self,
        messages: List[CreateMessageResponseBodyMessages] = None,
        request_id: str = None,
    ):
        self.messages = messages
        self.request_id = request_id

    def validate(self):
        if self.messages:
            for k in self.messages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['messages'] = []
        if self.messages is not None:
            for k in self.messages:
                result['messages'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.messages = []
        if m.get('messages') is not None:
            for k in m.get('messages'):
                temp_model = CreateMessageResponseBodyMessages()
                self.messages.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateMessageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateMessageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMessageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMultiDimTableFieldHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateMultiDimTableFieldHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateMultiDimTableFieldHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateMultiDimTableFieldHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateMultiDimTableFieldShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateMultiDimTableFieldRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CreateMultiDimTableFieldRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        name: str = None,
        property: Dict[str, Any] = None,
        sheet_id_or_name: str = None,
        tenant_context: CreateMultiDimTableFieldRequestTenantContext = None,
        type: str = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.name = name
        self.property = property
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context = tenant_context
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.name is not None:
            result['Name'] = self.name
        if self.property is not None:
            result['Property'] = self.property
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Property') is not None:
            self.property = m.get('Property')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            temp_model = CreateMultiDimTableFieldRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateMultiDimTableFieldShrinkRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        name: str = None,
        property_shrink: str = None,
        sheet_id_or_name: str = None,
        tenant_context_shrink: str = None,
        type: str = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.name = name
        self.property_shrink = property_shrink
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.name is not None:
            result['Name'] = self.name
        if self.property_shrink is not None:
            result['Property'] = self.property_shrink
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Property') is not None:
            self.property_shrink = m.get('Property')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateMultiDimTableFieldResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        property: Dict[str, Any] = None,
        type: str = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.id = id
        self.name = name
        self.property = property
        self.type = type
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.property is not None:
            result['Property'] = self.property
        if self.type is not None:
            result['Type'] = self.type
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Property') is not None:
            self.property = m.get('Property')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class CreateMultiDimTableFieldResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateMultiDimTableFieldResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMultiDimTableFieldResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOrUpdateFormDataHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateOrUpdateFormDataHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateOrUpdateFormDataHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateOrUpdateFormDataHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateOrUpdateFormDataShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateOrUpdateFormDataRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        form_data_json: str = None,
        form_uuid: str = None,
        no_execute_expression: bool = None,
        search_condition: str = None,
        system_token: str = None,
        user_id: str = None,
    ):
        self.app_type = app_type
        self.form_data_json = form_data_json
        self.form_uuid = form_uuid
        self.no_execute_expression = no_execute_expression
        self.search_condition = search_condition
        self.system_token = system_token
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.form_data_json is not None:
            result['FormDataJson'] = self.form_data_json
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.no_execute_expression is not None:
            result['NoExecuteExpression'] = self.no_execute_expression
        if self.search_condition is not None:
            result['SearchCondition'] = self.search_condition
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('FormDataJson') is not None:
            self.form_data_json = m.get('FormDataJson')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('NoExecuteExpression') is not None:
            self.no_execute_expression = m.get('NoExecuteExpression')
        if m.get('SearchCondition') is not None:
            self.search_condition = m.get('SearchCondition')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CreateOrUpdateFormDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: List[str] = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.result = result
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class CreateOrUpdateFormDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOrUpdateFormDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOrUpdateFormDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOrgHonorTemplateHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateOrgHonorTemplateHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateOrgHonorTemplateHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateOrgHonorTemplateHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateOrgHonorTemplateShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateOrgHonorTemplateRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CreateOrgHonorTemplateRequest(TeaModel):
    def __init__(
        self,
        tenant_context: CreateOrgHonorTemplateRequestTenantContext = None,
        avatar_frame_media_id: str = None,
        default_bg_color: str = None,
        medal_desc: str = None,
        medal_media_id: str = None,
        medal_name: str = None,
        org_id: int = None,
        user_id: str = None,
    ):
        self.tenant_context = tenant_context
        # This parameter is required.
        self.avatar_frame_media_id = avatar_frame_media_id
        # This parameter is required.
        self.default_bg_color = default_bg_color
        # This parameter is required.
        self.medal_desc = medal_desc
        # This parameter is required.
        self.medal_media_id = medal_media_id
        # This parameter is required.
        self.medal_name = medal_name
        # This parameter is required.
        self.org_id = org_id
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.avatar_frame_media_id is not None:
            result['avatarFrameMediaId'] = self.avatar_frame_media_id
        if self.default_bg_color is not None:
            result['defaultBgColor'] = self.default_bg_color
        if self.medal_desc is not None:
            result['medalDesc'] = self.medal_desc
        if self.medal_media_id is not None:
            result['medalMediaId'] = self.medal_media_id
        if self.medal_name is not None:
            result['medalName'] = self.medal_name
        if self.org_id is not None:
            result['orgId'] = self.org_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = CreateOrgHonorTemplateRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('avatarFrameMediaId') is not None:
            self.avatar_frame_media_id = m.get('avatarFrameMediaId')
        if m.get('defaultBgColor') is not None:
            self.default_bg_color = m.get('defaultBgColor')
        if m.get('medalDesc') is not None:
            self.medal_desc = m.get('medalDesc')
        if m.get('medalMediaId') is not None:
            self.medal_media_id = m.get('medalMediaId')
        if m.get('medalName') is not None:
            self.medal_name = m.get('medalName')
        if m.get('orgId') is not None:
            self.org_id = m.get('orgId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class CreateOrgHonorTemplateShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        avatar_frame_media_id: str = None,
        default_bg_color: str = None,
        medal_desc: str = None,
        medal_media_id: str = None,
        medal_name: str = None,
        org_id: int = None,
        user_id: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.avatar_frame_media_id = avatar_frame_media_id
        # This parameter is required.
        self.default_bg_color = default_bg_color
        # This parameter is required.
        self.medal_desc = medal_desc
        # This parameter is required.
        self.medal_media_id = medal_media_id
        # This parameter is required.
        self.medal_name = medal_name
        # This parameter is required.
        self.org_id = org_id
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.avatar_frame_media_id is not None:
            result['avatarFrameMediaId'] = self.avatar_frame_media_id
        if self.default_bg_color is not None:
            result['defaultBgColor'] = self.default_bg_color
        if self.medal_desc is not None:
            result['medalDesc'] = self.medal_desc
        if self.medal_media_id is not None:
            result['medalMediaId'] = self.medal_media_id
        if self.medal_name is not None:
            result['medalName'] = self.medal_name
        if self.org_id is not None:
            result['orgId'] = self.org_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('avatarFrameMediaId') is not None:
            self.avatar_frame_media_id = m.get('avatarFrameMediaId')
        if m.get('defaultBgColor') is not None:
            self.default_bg_color = m.get('defaultBgColor')
        if m.get('medalDesc') is not None:
            self.medal_desc = m.get('medalDesc')
        if m.get('medalMediaId') is not None:
            self.medal_media_id = m.get('medalMediaId')
        if m.get('medalName') is not None:
            self.medal_name = m.get('medalName')
        if m.get('orgId') is not None:
            self.org_id = m.get('orgId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class CreateOrgHonorTemplateResponseBody(TeaModel):
    def __init__(
        self,
        honor_id: str = None,
        request_id: str = None,
    ):
        self.honor_id = honor_id
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honor_id is not None:
            result['honorId'] = self.honor_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('honorId') is not None:
            self.honor_id = m.get('honorId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateOrgHonorTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOrgHonorTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOrgHonorTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePersonalTodoTaskHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreatePersonalTodoTaskHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreatePersonalTodoTaskHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreatePersonalTodoTaskHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreatePersonalTodoTaskShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreatePersonalTodoTaskRequestNotifyConfigs(TeaModel):
    def __init__(
        self,
        ding_notify: str = None,
    ):
        self.ding_notify = ding_notify

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ding_notify is not None:
            result['DingNotify'] = self.ding_notify
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DingNotify') is not None:
            self.ding_notify = m.get('DingNotify')
        return self


class CreatePersonalTodoTaskRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CreatePersonalTodoTaskRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        due_time: int = None,
        executor_ids: List[str] = None,
        notify_configs: CreatePersonalTodoTaskRequestNotifyConfigs = None,
        participant_ids: List[str] = None,
        reminder_time_stamp: int = None,
        subject: str = None,
        tenant_context: CreatePersonalTodoTaskRequestTenantContext = None,
    ):
        self.description = description
        self.due_time = due_time
        # This parameter is required.
        self.executor_ids = executor_ids
        self.notify_configs = notify_configs
        self.participant_ids = participant_ids
        self.reminder_time_stamp = reminder_time_stamp
        # This parameter is required.
        self.subject = subject
        self.tenant_context = tenant_context

    def validate(self):
        if self.notify_configs:
            self.notify_configs.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.due_time is not None:
            result['DueTime'] = self.due_time
        if self.executor_ids is not None:
            result['ExecutorIds'] = self.executor_ids
        if self.notify_configs is not None:
            result['NotifyConfigs'] = self.notify_configs.to_map()
        if self.participant_ids is not None:
            result['ParticipantIds'] = self.participant_ids
        if self.reminder_time_stamp is not None:
            result['ReminderTimeStamp'] = self.reminder_time_stamp
        if self.subject is not None:
            result['Subject'] = self.subject
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DueTime') is not None:
            self.due_time = m.get('DueTime')
        if m.get('ExecutorIds') is not None:
            self.executor_ids = m.get('ExecutorIds')
        if m.get('NotifyConfigs') is not None:
            temp_model = CreatePersonalTodoTaskRequestNotifyConfigs()
            self.notify_configs = temp_model.from_map(m['NotifyConfigs'])
        if m.get('ParticipantIds') is not None:
            self.participant_ids = m.get('ParticipantIds')
        if m.get('ReminderTimeStamp') is not None:
            self.reminder_time_stamp = m.get('ReminderTimeStamp')
        if m.get('Subject') is not None:
            self.subject = m.get('Subject')
        if m.get('TenantContext') is not None:
            temp_model = CreatePersonalTodoTaskRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class CreatePersonalTodoTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        due_time: int = None,
        executor_ids_shrink: str = None,
        notify_configs_shrink: str = None,
        participant_ids_shrink: str = None,
        reminder_time_stamp: int = None,
        subject: str = None,
        tenant_context_shrink: str = None,
    ):
        self.description = description
        self.due_time = due_time
        # This parameter is required.
        self.executor_ids_shrink = executor_ids_shrink
        self.notify_configs_shrink = notify_configs_shrink
        self.participant_ids_shrink = participant_ids_shrink
        self.reminder_time_stamp = reminder_time_stamp
        # This parameter is required.
        self.subject = subject
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.due_time is not None:
            result['DueTime'] = self.due_time
        if self.executor_ids_shrink is not None:
            result['ExecutorIds'] = self.executor_ids_shrink
        if self.notify_configs_shrink is not None:
            result['NotifyConfigs'] = self.notify_configs_shrink
        if self.participant_ids_shrink is not None:
            result['ParticipantIds'] = self.participant_ids_shrink
        if self.reminder_time_stamp is not None:
            result['ReminderTimeStamp'] = self.reminder_time_stamp
        if self.subject is not None:
            result['Subject'] = self.subject
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DueTime') is not None:
            self.due_time = m.get('DueTime')
        if m.get('ExecutorIds') is not None:
            self.executor_ids_shrink = m.get('ExecutorIds')
        if m.get('NotifyConfigs') is not None:
            self.notify_configs_shrink = m.get('NotifyConfigs')
        if m.get('ParticipantIds') is not None:
            self.participant_ids_shrink = m.get('ParticipantIds')
        if m.get('ReminderTimeStamp') is not None:
            self.reminder_time_stamp = m.get('ReminderTimeStamp')
        if m.get('Subject') is not None:
            self.subject = m.get('Subject')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class CreatePersonalTodoTaskResponseBody(TeaModel):
    def __init__(
        self,
        created_time: int = None,
        request_id: str = None,
        task_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.created_time = created_time
        self.request_id = request_id
        self.task_id = task_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_time is not None:
            result['createdTime'] = self.created_time
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.task_id is not None:
            result['taskId'] = self.task_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createdTime') is not None:
            self.created_time = m.get('createdTime')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class CreatePersonalTodoTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreatePersonalTodoTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePersonalTodoTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateReportHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateReportHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateReportHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateReportHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateReportShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateReportRequestContents(TeaModel):
    def __init__(
        self,
        content: str = None,
        content_type: str = None,
        key: str = None,
        sort: int = None,
        type: int = None,
    ):
        # This parameter is required.
        self.content = content
        # This parameter is required.
        self.content_type = content_type
        # This parameter is required.
        self.key = key
        # This parameter is required.
        self.sort = sort
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.content_type is not None:
            result['ContentType'] = self.content_type
        if self.key is not None:
            result['Key'] = self.key
        if self.sort is not None:
            result['Sort'] = self.sort
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('ContentType') is not None:
            self.content_type = m.get('ContentType')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Sort') is not None:
            self.sort = m.get('Sort')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateReportRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CreateReportRequest(TeaModel):
    def __init__(
        self,
        contents: List[CreateReportRequestContents] = None,
        dd_from: str = None,
        template_id: str = None,
        tenant_context: CreateReportRequestTenantContext = None,
        to_chat: bool = None,
        to_cids: List[str] = None,
        to_userids: List[str] = None,
    ):
        # This parameter is required.
        self.contents = contents
        # This parameter is required.
        self.dd_from = dd_from
        # This parameter is required.
        self.template_id = template_id
        self.tenant_context = tenant_context
        # This parameter is required.
        self.to_chat = to_chat
        self.to_cids = to_cids
        self.to_userids = to_userids

    def validate(self):
        if self.contents:
            for k in self.contents:
                if k:
                    k.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Contents'] = []
        if self.contents is not None:
            for k in self.contents:
                result['Contents'].append(k.to_map() if k else None)
        if self.dd_from is not None:
            result['DdFrom'] = self.dd_from
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.to_chat is not None:
            result['ToChat'] = self.to_chat
        if self.to_cids is not None:
            result['ToCids'] = self.to_cids
        if self.to_userids is not None:
            result['ToUserids'] = self.to_userids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.contents = []
        if m.get('Contents') is not None:
            for k in m.get('Contents'):
                temp_model = CreateReportRequestContents()
                self.contents.append(temp_model.from_map(k))
        if m.get('DdFrom') is not None:
            self.dd_from = m.get('DdFrom')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TenantContext') is not None:
            temp_model = CreateReportRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('ToChat') is not None:
            self.to_chat = m.get('ToChat')
        if m.get('ToCids') is not None:
            self.to_cids = m.get('ToCids')
        if m.get('ToUserids') is not None:
            self.to_userids = m.get('ToUserids')
        return self


class CreateReportShrinkRequest(TeaModel):
    def __init__(
        self,
        contents_shrink: str = None,
        dd_from: str = None,
        template_id: str = None,
        tenant_context_shrink: str = None,
        to_chat: bool = None,
        to_cids_shrink: str = None,
        to_userids_shrink: str = None,
    ):
        # This parameter is required.
        self.contents_shrink = contents_shrink
        # This parameter is required.
        self.dd_from = dd_from
        # This parameter is required.
        self.template_id = template_id
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.to_chat = to_chat
        self.to_cids_shrink = to_cids_shrink
        self.to_userids_shrink = to_userids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contents_shrink is not None:
            result['Contents'] = self.contents_shrink
        if self.dd_from is not None:
            result['DdFrom'] = self.dd_from
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.to_chat is not None:
            result['ToChat'] = self.to_chat
        if self.to_cids_shrink is not None:
            result['ToCids'] = self.to_cids_shrink
        if self.to_userids_shrink is not None:
            result['ToUserids'] = self.to_userids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Contents') is not None:
            self.contents_shrink = m.get('Contents')
        if m.get('DdFrom') is not None:
            self.dd_from = m.get('DdFrom')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('ToChat') is not None:
            self.to_chat = m.get('ToChat')
        if m.get('ToCids') is not None:
            self.to_cids_shrink = m.get('ToCids')
        if m.get('ToUserids') is not None:
            self.to_userids_shrink = m.get('ToUserids')
        return self


class CreateReportResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # requestId
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRunHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_id: str = None,
    ):
        self.common_headers = common_headers
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateRunRequest(TeaModel):
    def __init__(
        self,
        assistant_id: str = None,
        original_assistant_id: str = None,
        source_id_of_original_assistant_id: str = None,
        source_type_of_original_assistant_id: str = None,
        stream: bool = None,
        thread_id: str = None,
    ):
        # This parameter is required.
        self.assistant_id = assistant_id
        self.original_assistant_id = original_assistant_id
        self.source_id_of_original_assistant_id = source_id_of_original_assistant_id
        self.source_type_of_original_assistant_id = source_type_of_original_assistant_id
        self.stream = stream
        # This parameter is required.
        self.thread_id = thread_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assistant_id is not None:
            result['assistantId'] = self.assistant_id
        if self.original_assistant_id is not None:
            result['originalAssistantId'] = self.original_assistant_id
        if self.source_id_of_original_assistant_id is not None:
            result['sourceIdOfOriginalAssistantId'] = self.source_id_of_original_assistant_id
        if self.source_type_of_original_assistant_id is not None:
            result['sourceTypeOfOriginalAssistantId'] = self.source_type_of_original_assistant_id
        if self.stream is not None:
            result['stream'] = self.stream
        if self.thread_id is not None:
            result['threadId'] = self.thread_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assistantId') is not None:
            self.assistant_id = m.get('assistantId')
        if m.get('originalAssistantId') is not None:
            self.original_assistant_id = m.get('originalAssistantId')
        if m.get('sourceIdOfOriginalAssistantId') is not None:
            self.source_id_of_original_assistant_id = m.get('sourceIdOfOriginalAssistantId')
        if m.get('sourceTypeOfOriginalAssistantId') is not None:
            self.source_type_of_original_assistant_id = m.get('sourceTypeOfOriginalAssistantId')
        if m.get('stream') is not None:
            self.stream = m.get('stream')
        if m.get('threadId') is not None:
            self.thread_id = m.get('threadId')
        return self


class CreateRunResponseBodyMessagesContentCardCallback(TeaModel):
    def __init__(
        self,
        content: str = None,
        related_message_id: str = None,
    ):
        self.content = content
        self.related_message_id = related_message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.related_message_id is not None:
            result['relatedMessageId'] = self.related_message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('relatedMessageId') is not None:
            self.related_message_id = m.get('relatedMessageId')
        return self


class CreateRunResponseBodyMessagesContentDingCard(TeaModel):
    def __init__(
        self,
        content: str = None,
        content_type: str = None,
        finished: bool = None,
        template_id: str = None,
    ):
        self.content = content
        # This parameter is required.
        self.content_type = content_type
        self.finished = finished
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.content_type is not None:
            result['contentType'] = self.content_type
        if self.finished is not None:
            result['finished'] = self.finished
        if self.template_id is not None:
            result['templateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('contentType') is not None:
            self.content_type = m.get('contentType')
        if m.get('finished') is not None:
            self.finished = m.get('finished')
        if m.get('templateId') is not None:
            self.template_id = m.get('templateId')
        return self


class CreateRunResponseBodyMessagesContentDingNormalCardCardData(TeaModel):
    def __init__(
        self,
        card_param_map: Any = None,
    ):
        self.card_param_map = card_param_map

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_param_map is not None:
            result['cardParamMap'] = self.card_param_map
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardParamMap') is not None:
            self.card_param_map = m.get('cardParamMap')
        return self


class CreateRunResponseBodyMessagesContentDingNormalCardCardUpdateOptions(TeaModel):
    def __init__(
        self,
        update_card_data_by_key: bool = None,
        update_private_data_by_key: bool = None,
    ):
        self.update_card_data_by_key = update_card_data_by_key
        self.update_private_data_by_key = update_private_data_by_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.update_card_data_by_key is not None:
            result['updateCardDataByKey'] = self.update_card_data_by_key
        if self.update_private_data_by_key is not None:
            result['updatePrivateDataByKey'] = self.update_private_data_by_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('updateCardDataByKey') is not None:
            self.update_card_data_by_key = m.get('updateCardDataByKey')
        if m.get('updatePrivateDataByKey') is not None:
            self.update_private_data_by_key = m.get('updatePrivateDataByKey')
        return self


class CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig(TeaModel):
    def __init__(
        self,
        interval: int = None,
        pull_strategy: str = None,
        time_unit: str = None,
    ):
        self.interval = interval
        self.pull_strategy = pull_strategy
        self.time_unit = time_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interval is not None:
            result['interval'] = self.interval
        if self.pull_strategy is not None:
            result['pullStrategy'] = self.pull_strategy
        if self.time_unit is not None:
            result['timeUnit'] = self.time_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('pullStrategy') is not None:
            self.pull_strategy = m.get('pullStrategy')
        if m.get('timeUnit') is not None:
            self.time_unit = m.get('timeUnit')
        return self


class CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs(TeaModel):
    def __init__(
        self,
        const_params: Dict[str, Any] = None,
        dynamic_data_source_id: str = None,
        pull_config: CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig = None,
    ):
        self.const_params = const_params
        self.dynamic_data_source_id = dynamic_data_source_id
        self.pull_config = pull_config

    def validate(self):
        if self.pull_config:
            self.pull_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.const_params is not None:
            result['constParams'] = self.const_params
        if self.dynamic_data_source_id is not None:
            result['dynamicDataSourceId'] = self.dynamic_data_source_id
        if self.pull_config is not None:
            result['pullConfig'] = self.pull_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('constParams') is not None:
            self.const_params = m.get('constParams')
        if m.get('dynamicDataSourceId') is not None:
            self.dynamic_data_source_id = m.get('dynamicDataSourceId')
        if m.get('pullConfig') is not None:
            temp_model = CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig()
            self.pull_config = temp_model.from_map(m['pullConfig'])
        return self


class CreateRunResponseBodyMessagesContentDingNormalCard(TeaModel):
    def __init__(
        self,
        card_data: CreateRunResponseBodyMessagesContentDingNormalCardCardData = None,
        card_template_id: str = None,
        card_update_options: CreateRunResponseBodyMessagesContentDingNormalCardCardUpdateOptions = None,
        dynamic_data_source_configs: List[CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs] = None,
        private_data: Dict[str, dict] = None,
    ):
        self.card_data = card_data
        self.card_template_id = card_template_id
        self.card_update_options = card_update_options
        self.dynamic_data_source_configs = dynamic_data_source_configs
        self.private_data = private_data

    def validate(self):
        if self.card_data:
            self.card_data.validate()
        if self.card_update_options:
            self.card_update_options.validate()
        if self.dynamic_data_source_configs:
            for k in self.dynamic_data_source_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_data is not None:
            result['cardData'] = self.card_data.to_map()
        if self.card_template_id is not None:
            result['cardTemplateId'] = self.card_template_id
        if self.card_update_options is not None:
            result['cardUpdateOptions'] = self.card_update_options.to_map()
        result['dynamicDataSourceConfigs'] = []
        if self.dynamic_data_source_configs is not None:
            for k in self.dynamic_data_source_configs:
                result['dynamicDataSourceConfigs'].append(k.to_map() if k else None)
        if self.private_data is not None:
            result['privateData'] = self.private_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardData') is not None:
            temp_model = CreateRunResponseBodyMessagesContentDingNormalCardCardData()
            self.card_data = temp_model.from_map(m['cardData'])
        if m.get('cardTemplateId') is not None:
            self.card_template_id = m.get('cardTemplateId')
        if m.get('cardUpdateOptions') is not None:
            temp_model = CreateRunResponseBodyMessagesContentDingNormalCardCardUpdateOptions()
            self.card_update_options = temp_model.from_map(m['cardUpdateOptions'])
        self.dynamic_data_source_configs = []
        if m.get('dynamicDataSourceConfigs') is not None:
            for k in m.get('dynamicDataSourceConfigs'):
                temp_model = CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs()
                self.dynamic_data_source_configs.append(temp_model.from_map(k))
        if m.get('privateData') is not None:
            self.private_data = m.get('privateData')
        return self


class CreateRunResponseBodyMessagesContentMarkdown(TeaModel):
    def __init__(
        self,
        value: str = None,
    ):
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class CreateRunResponseBodyMessagesContentStructViewPartsDataPart(TeaModel):
    def __init__(
        self,
        data: Any = None,
    ):
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class CreateRunResponseBodyMessagesContentStructViewPartsReasonPart(TeaModel):
    def __init__(
        self,
        reason: str = None,
    ):
        self.reason = reason

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reason is not None:
            result['reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        return self


class CreateRunResponseBodyMessagesContentStructViewPartsRecommendPartRecommends(TeaModel):
    def __init__(
        self,
        mobile_url: str = None,
        text: str = None,
        url: str = None,
    ):
        self.mobile_url = mobile_url
        self.text = text
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mobile_url is not None:
            result['mobileUrl'] = self.mobile_url
        if self.text is not None:
            result['text'] = self.text
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('mobileUrl') is not None:
            self.mobile_url = m.get('mobileUrl')
        if m.get('text') is not None:
            self.text = m.get('text')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class CreateRunResponseBodyMessagesContentStructViewPartsRecommendPart(TeaModel):
    def __init__(
        self,
        recommends: List[CreateRunResponseBodyMessagesContentStructViewPartsRecommendPartRecommends] = None,
    ):
        self.recommends = recommends

    def validate(self):
        if self.recommends:
            for k in self.recommends:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['recommends'] = []
        if self.recommends is not None:
            for k in self.recommends:
                result['recommends'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.recommends = []
        if m.get('recommends') is not None:
            for k in m.get('recommends'):
                temp_model = CreateRunResponseBodyMessagesContentStructViewPartsRecommendPartRecommends()
                self.recommends.append(temp_model.from_map(k))
        return self


class CreateRunResponseBodyMessagesContentStructViewPartsReferencePartReferences(TeaModel):
    def __init__(
        self,
        index: str = None,
        name: str = None,
        source_code: str = None,
        source_icon: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.index = index
        self.name = name
        self.source_code = source_code
        self.source_icon = source_icon
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['index'] = self.index
        if self.name is not None:
            result['name'] = self.name
        if self.source_code is not None:
            result['sourceCode'] = self.source_code
        if self.source_icon is not None:
            result['sourceIcon'] = self.source_icon
        if self.summary is not None:
            result['summary'] = self.summary
        if self.title is not None:
            result['title'] = self.title
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('sourceCode') is not None:
            self.source_code = m.get('sourceCode')
        if m.get('sourceIcon') is not None:
            self.source_icon = m.get('sourceIcon')
        if m.get('summary') is not None:
            self.summary = m.get('summary')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class CreateRunResponseBodyMessagesContentStructViewPartsReferencePart(TeaModel):
    def __init__(
        self,
        references: List[CreateRunResponseBodyMessagesContentStructViewPartsReferencePartReferences] = None,
    ):
        self.references = references

    def validate(self):
        if self.references:
            for k in self.references:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['references'] = []
        if self.references is not None:
            for k in self.references:
                result['references'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.references = []
        if m.get('references') is not None:
            for k in m.get('references'):
                temp_model = CreateRunResponseBodyMessagesContentStructViewPartsReferencePartReferences()
                self.references.append(temp_model.from_map(k))
        return self


class CreateRunResponseBodyMessagesContentStructViewPartsTextPart(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('text') is not None:
            self.text = m.get('text')
        return self


class CreateRunResponseBodyMessagesContentStructViewParts(TeaModel):
    def __init__(
        self,
        append: bool = None,
        data_part: CreateRunResponseBodyMessagesContentStructViewPartsDataPart = None,
        finish: bool = None,
        part_desc: str = None,
        part_id: str = None,
        reason_part: CreateRunResponseBodyMessagesContentStructViewPartsReasonPart = None,
        recommend_part: CreateRunResponseBodyMessagesContentStructViewPartsRecommendPart = None,
        reference_part: CreateRunResponseBodyMessagesContentStructViewPartsReferencePart = None,
        text_part: CreateRunResponseBodyMessagesContentStructViewPartsTextPart = None,
        type: str = None,
    ):
        self.append = append
        self.data_part = data_part
        self.finish = finish
        self.part_desc = part_desc
        self.part_id = part_id
        self.reason_part = reason_part
        self.recommend_part = recommend_part
        self.reference_part = reference_part
        self.text_part = text_part
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.data_part:
            self.data_part.validate()
        if self.reason_part:
            self.reason_part.validate()
        if self.recommend_part:
            self.recommend_part.validate()
        if self.reference_part:
            self.reference_part.validate()
        if self.text_part:
            self.text_part.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.append is not None:
            result['append'] = self.append
        if self.data_part is not None:
            result['dataPart'] = self.data_part.to_map()
        if self.finish is not None:
            result['finish'] = self.finish
        if self.part_desc is not None:
            result['partDesc'] = self.part_desc
        if self.part_id is not None:
            result['partId'] = self.part_id
        if self.reason_part is not None:
            result['reasonPart'] = self.reason_part.to_map()
        if self.recommend_part is not None:
            result['recommendPart'] = self.recommend_part.to_map()
        if self.reference_part is not None:
            result['referencePart'] = self.reference_part.to_map()
        if self.text_part is not None:
            result['textPart'] = self.text_part.to_map()
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('append') is not None:
            self.append = m.get('append')
        if m.get('dataPart') is not None:
            temp_model = CreateRunResponseBodyMessagesContentStructViewPartsDataPart()
            self.data_part = temp_model.from_map(m['dataPart'])
        if m.get('finish') is not None:
            self.finish = m.get('finish')
        if m.get('partDesc') is not None:
            self.part_desc = m.get('partDesc')
        if m.get('partId') is not None:
            self.part_id = m.get('partId')
        if m.get('reasonPart') is not None:
            temp_model = CreateRunResponseBodyMessagesContentStructViewPartsReasonPart()
            self.reason_part = temp_model.from_map(m['reasonPart'])
        if m.get('recommendPart') is not None:
            temp_model = CreateRunResponseBodyMessagesContentStructViewPartsRecommendPart()
            self.recommend_part = temp_model.from_map(m['recommendPart'])
        if m.get('referencePart') is not None:
            temp_model = CreateRunResponseBodyMessagesContentStructViewPartsReferencePart()
            self.reference_part = temp_model.from_map(m['referencePart'])
        if m.get('textPart') is not None:
            temp_model = CreateRunResponseBodyMessagesContentStructViewPartsTextPart()
            self.text_part = temp_model.from_map(m['textPart'])
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateRunResponseBodyMessagesContentStructView(TeaModel):
    def __init__(
        self,
        parts: List[CreateRunResponseBodyMessagesContentStructViewParts] = None,
    ):
        self.parts = parts

    def validate(self):
        if self.parts:
            for k in self.parts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['parts'] = []
        if self.parts is not None:
            for k in self.parts:
                result['parts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.parts = []
        if m.get('parts') is not None:
            for k in m.get('parts'):
                temp_model = CreateRunResponseBodyMessagesContentStructViewParts()
                self.parts.append(temp_model.from_map(k))
        return self


class CreateRunResponseBodyMessagesContentText(TeaModel):
    def __init__(
        self,
        value: str = None,
    ):
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class CreateRunResponseBodyMessagesContent(TeaModel):
    def __init__(
        self,
        card_callback: CreateRunResponseBodyMessagesContentCardCallback = None,
        ding_card: CreateRunResponseBodyMessagesContentDingCard = None,
        ding_normal_card: CreateRunResponseBodyMessagesContentDingNormalCard = None,
        markdown: CreateRunResponseBodyMessagesContentMarkdown = None,
        struct_view: CreateRunResponseBodyMessagesContentStructView = None,
        text: CreateRunResponseBodyMessagesContentText = None,
        type: str = None,
    ):
        self.card_callback = card_callback
        self.ding_card = ding_card
        self.ding_normal_card = ding_normal_card
        self.markdown = markdown
        self.struct_view = struct_view
        self.text = text
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.card_callback:
            self.card_callback.validate()
        if self.ding_card:
            self.ding_card.validate()
        if self.ding_normal_card:
            self.ding_normal_card.validate()
        if self.markdown:
            self.markdown.validate()
        if self.struct_view:
            self.struct_view.validate()
        if self.text:
            self.text.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_callback is not None:
            result['cardCallback'] = self.card_callback.to_map()
        if self.ding_card is not None:
            result['dingCard'] = self.ding_card.to_map()
        if self.ding_normal_card is not None:
            result['dingNormalCard'] = self.ding_normal_card.to_map()
        if self.markdown is not None:
            result['markdown'] = self.markdown.to_map()
        if self.struct_view is not None:
            result['structView'] = self.struct_view.to_map()
        if self.text is not None:
            result['text'] = self.text.to_map()
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardCallback') is not None:
            temp_model = CreateRunResponseBodyMessagesContentCardCallback()
            self.card_callback = temp_model.from_map(m['cardCallback'])
        if m.get('dingCard') is not None:
            temp_model = CreateRunResponseBodyMessagesContentDingCard()
            self.ding_card = temp_model.from_map(m['dingCard'])
        if m.get('dingNormalCard') is not None:
            temp_model = CreateRunResponseBodyMessagesContentDingNormalCard()
            self.ding_normal_card = temp_model.from_map(m['dingNormalCard'])
        if m.get('markdown') is not None:
            temp_model = CreateRunResponseBodyMessagesContentMarkdown()
            self.markdown = temp_model.from_map(m['markdown'])
        if m.get('structView') is not None:
            temp_model = CreateRunResponseBodyMessagesContentStructView()
            self.struct_view = temp_model.from_map(m['structView'])
        if m.get('text') is not None:
            temp_model = CreateRunResponseBodyMessagesContentText()
            self.text = temp_model.from_map(m['text'])
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateRunResponseBodyMessages(TeaModel):
    def __init__(
        self,
        content: CreateRunResponseBodyMessagesContent = None,
        content_desc: str = None,
        create_at: int = None,
        id: str = None,
        role: str = None,
        run_id: str = None,
        thread_id: str = None,
    ):
        self.content = content
        self.content_desc = content_desc
        self.create_at = create_at
        self.id = id
        self.role = role
        self.run_id = run_id
        self.thread_id = thread_id

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content.to_map()
        if self.content_desc is not None:
            result['contentDesc'] = self.content_desc
        if self.create_at is not None:
            result['createAt'] = self.create_at
        if self.id is not None:
            result['id'] = self.id
        if self.role is not None:
            result['role'] = self.role
        if self.run_id is not None:
            result['runId'] = self.run_id
        if self.thread_id is not None:
            result['threadId'] = self.thread_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            temp_model = CreateRunResponseBodyMessagesContent()
            self.content = temp_model.from_map(m['content'])
        if m.get('contentDesc') is not None:
            self.content_desc = m.get('contentDesc')
        if m.get('createAt') is not None:
            self.create_at = m.get('createAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('role') is not None:
            self.role = m.get('role')
        if m.get('runId') is not None:
            self.run_id = m.get('runId')
        if m.get('threadId') is not None:
            self.thread_id = m.get('threadId')
        return self


class CreateRunResponseBodyRun(TeaModel):
    def __init__(
        self,
        cancelled_at: int = None,
        completed_at: int = None,
        create_at: int = None,
        expires_at: int = None,
        failed_at: int = None,
        id: str = None,
        last_error_msg: str = None,
        started_at: int = None,
        status: str = None,
        thread_id: str = None,
    ):
        self.cancelled_at = cancelled_at
        self.completed_at = completed_at
        self.create_at = create_at
        self.expires_at = expires_at
        self.failed_at = failed_at
        self.id = id
        self.last_error_msg = last_error_msg
        self.started_at = started_at
        self.status = status
        self.thread_id = thread_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cancelled_at is not None:
            result['cancelledAt'] = self.cancelled_at
        if self.completed_at is not None:
            result['completedAt'] = self.completed_at
        if self.create_at is not None:
            result['createAt'] = self.create_at
        if self.expires_at is not None:
            result['expiresAt'] = self.expires_at
        if self.failed_at is not None:
            result['failedAt'] = self.failed_at
        if self.id is not None:
            result['id'] = self.id
        if self.last_error_msg is not None:
            result['lastErrorMsg'] = self.last_error_msg
        if self.started_at is not None:
            result['startedAt'] = self.started_at
        if self.status is not None:
            result['status'] = self.status
        if self.thread_id is not None:
            result['threadId'] = self.thread_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cancelledAt') is not None:
            self.cancelled_at = m.get('cancelledAt')
        if m.get('completedAt') is not None:
            self.completed_at = m.get('completedAt')
        if m.get('createAt') is not None:
            self.create_at = m.get('createAt')
        if m.get('expiresAt') is not None:
            self.expires_at = m.get('expiresAt')
        if m.get('failedAt') is not None:
            self.failed_at = m.get('failedAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('lastErrorMsg') is not None:
            self.last_error_msg = m.get('lastErrorMsg')
        if m.get('startedAt') is not None:
            self.started_at = m.get('startedAt')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('threadId') is not None:
            self.thread_id = m.get('threadId')
        return self


class CreateRunResponseBody(TeaModel):
    def __init__(
        self,
        messages: List[CreateRunResponseBodyMessages] = None,
        request_id: str = None,
        run: CreateRunResponseBodyRun = None,
    ):
        self.messages = messages
        self.request_id = request_id
        self.run = run

    def validate(self):
        if self.messages:
            for k in self.messages:
                if k:
                    k.validate()
        if self.run:
            self.run.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['messages'] = []
        if self.messages is not None:
            for k in self.messages:
                result['messages'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.run is not None:
            result['run'] = self.run.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.messages = []
        if m.get('messages') is not None:
            for k in m.get('messages'):
                temp_model = CreateRunResponseBodyMessages()
                self.messages.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('run') is not None:
            temp_model = CreateRunResponseBodyRun()
            self.run = temp_model.from_map(m['run'])
        return self


class CreateRunResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRunResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRunResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateScenegroupHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateScenegroupHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateScenegroupHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateScenegroupHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateScenegroupShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateScenegroupRequest(TeaModel):
    def __init__(
        self,
        add_friend_forbidden: int = None,
        all_members_can_create_calendar: int = None,
        all_members_can_create_mcs_conf: int = None,
        chat_banned_type: int = None,
        group_email_disabled: int = None,
        group_live_switch: int = None,
        icon: str = None,
        management_type: int = None,
        members_to_admin_chat: int = None,
        mention_all_authority: int = None,
        only_admin_can_ding: int = None,
        only_admin_can_set_msg_top: int = None,
        searchable: int = None,
        show_history_type: int = None,
        subadmin_ids: str = None,
        template_id: str = None,
        title: str = None,
        user_ids: str = None,
        uuid: str = None,
        validation_type: int = None,
    ):
        self.add_friend_forbidden = add_friend_forbidden
        self.all_members_can_create_calendar = all_members_can_create_calendar
        self.all_members_can_create_mcs_conf = all_members_can_create_mcs_conf
        self.chat_banned_type = chat_banned_type
        self.group_email_disabled = group_email_disabled
        self.group_live_switch = group_live_switch
        self.icon = icon
        self.management_type = management_type
        self.members_to_admin_chat = members_to_admin_chat
        self.mention_all_authority = mention_all_authority
        self.only_admin_can_ding = only_admin_can_ding
        self.only_admin_can_set_msg_top = only_admin_can_set_msg_top
        self.searchable = searchable
        self.show_history_type = show_history_type
        self.subadmin_ids = subadmin_ids
        # This parameter is required.
        self.template_id = template_id
        # This parameter is required.
        self.title = title
        self.user_ids = user_ids
        self.uuid = uuid
        self.validation_type = validation_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.add_friend_forbidden is not None:
            result['AddFriendForbidden'] = self.add_friend_forbidden
        if self.all_members_can_create_calendar is not None:
            result['AllMembersCanCreateCalendar'] = self.all_members_can_create_calendar
        if self.all_members_can_create_mcs_conf is not None:
            result['AllMembersCanCreateMcsConf'] = self.all_members_can_create_mcs_conf
        if self.chat_banned_type is not None:
            result['ChatBannedType'] = self.chat_banned_type
        if self.group_email_disabled is not None:
            result['GroupEmailDisabled'] = self.group_email_disabled
        if self.group_live_switch is not None:
            result['GroupLiveSwitch'] = self.group_live_switch
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.management_type is not None:
            result['ManagementType'] = self.management_type
        if self.members_to_admin_chat is not None:
            result['MembersToAdminChat'] = self.members_to_admin_chat
        if self.mention_all_authority is not None:
            result['MentionAllAuthority'] = self.mention_all_authority
        if self.only_admin_can_ding is not None:
            result['OnlyAdminCanDing'] = self.only_admin_can_ding
        if self.only_admin_can_set_msg_top is not None:
            result['OnlyAdminCanSetMsgTop'] = self.only_admin_can_set_msg_top
        if self.searchable is not None:
            result['Searchable'] = self.searchable
        if self.show_history_type is not None:
            result['ShowHistoryType'] = self.show_history_type
        if self.subadmin_ids is not None:
            result['SubadminIds'] = self.subadmin_ids
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.title is not None:
            result['Title'] = self.title
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.validation_type is not None:
            result['ValidationType'] = self.validation_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddFriendForbidden') is not None:
            self.add_friend_forbidden = m.get('AddFriendForbidden')
        if m.get('AllMembersCanCreateCalendar') is not None:
            self.all_members_can_create_calendar = m.get('AllMembersCanCreateCalendar')
        if m.get('AllMembersCanCreateMcsConf') is not None:
            self.all_members_can_create_mcs_conf = m.get('AllMembersCanCreateMcsConf')
        if m.get('ChatBannedType') is not None:
            self.chat_banned_type = m.get('ChatBannedType')
        if m.get('GroupEmailDisabled') is not None:
            self.group_email_disabled = m.get('GroupEmailDisabled')
        if m.get('GroupLiveSwitch') is not None:
            self.group_live_switch = m.get('GroupLiveSwitch')
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('ManagementType') is not None:
            self.management_type = m.get('ManagementType')
        if m.get('MembersToAdminChat') is not None:
            self.members_to_admin_chat = m.get('MembersToAdminChat')
        if m.get('MentionAllAuthority') is not None:
            self.mention_all_authority = m.get('MentionAllAuthority')
        if m.get('OnlyAdminCanDing') is not None:
            self.only_admin_can_ding = m.get('OnlyAdminCanDing')
        if m.get('OnlyAdminCanSetMsgTop') is not None:
            self.only_admin_can_set_msg_top = m.get('OnlyAdminCanSetMsgTop')
        if m.get('Searchable') is not None:
            self.searchable = m.get('Searchable')
        if m.get('ShowHistoryType') is not None:
            self.show_history_type = m.get('ShowHistoryType')
        if m.get('SubadminIds') is not None:
            self.subadmin_ids = m.get('SubadminIds')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('ValidationType') is not None:
            self.validation_type = m.get('ValidationType')
        return self


class CreateScenegroupResponseBody(TeaModel):
    def __init__(
        self,
        open_conversation_id: str = None,
        request_id: str = None,
    ):
        self.open_conversation_id = open_conversation_id
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.open_conversation_id is not None:
            result['openConversationId'] = self.open_conversation_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('openConversationId') is not None:
            self.open_conversation_id = m.get('openConversationId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateScenegroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateScenegroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateScenegroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateScheduleConferenceHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateScheduleConferenceHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateScheduleConferenceHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateScheduleConferenceHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateScheduleConferenceShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfOpenRecordSetting(TeaModel):
    def __init__(
        self,
        is_follow_host: bool = None,
        mode: str = None,
        record_auto_start: int = None,
        record_auto_start_type: int = None,
    ):
        self.is_follow_host = is_follow_host
        self.mode = mode
        self.record_auto_start = record_auto_start
        self.record_auto_start_type = record_auto_start_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_follow_host is not None:
            result['IsFollowHost'] = self.is_follow_host
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.record_auto_start is not None:
            result['RecordAutoStart'] = self.record_auto_start
        if self.record_auto_start_type is not None:
            result['RecordAutoStartType'] = self.record_auto_start_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsFollowHost') is not None:
            self.is_follow_host = m.get('IsFollowHost')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('RecordAutoStart') is not None:
            self.record_auto_start = m.get('RecordAutoStart')
        if m.get('RecordAutoStartType') is not None:
            self.record_auto_start_type = m.get('RecordAutoStartType')
        return self


class CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings(TeaModel):
    def __init__(
        self,
        auto_open_mode: int = None,
        cool_app_code: str = None,
        extension_app_biz_data: str = None,
    ):
        self.auto_open_mode = auto_open_mode
        self.cool_app_code = cool_app_code
        self.extension_app_biz_data = extension_app_biz_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_open_mode is not None:
            result['AutoOpenMode'] = self.auto_open_mode
        if self.cool_app_code is not None:
            result['CoolAppCode'] = self.cool_app_code
        if self.extension_app_biz_data is not None:
            result['ExtensionAppBizData'] = self.extension_app_biz_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoOpenMode') is not None:
            self.auto_open_mode = m.get('AutoOpenMode')
        if m.get('CoolAppCode') is not None:
            self.cool_app_code = m.get('CoolAppCode')
        if m.get('ExtensionAppBizData') is not None:
            self.extension_app_biz_data = m.get('ExtensionAppBizData')
        return self


class CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSetting(TeaModel):
    def __init__(
        self,
        cloud_record_owner_user_id: str = None,
        enable_chat: int = None,
        enable_web_anonymous_join: bool = None,
        join_before_host: int = None,
        lock_media_status_mic_mute: int = None,
        lock_nick: int = None,
        minutes_owner_user_id: str = None,
        mozi_conf_extension_app_settings: List[CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings] = None,
        push_all_meeting_records: bool = None,
        push_cloud_record_card: bool = None,
        push_minutes_card: bool = None,
        waiting_room: int = None,
    ):
        self.cloud_record_owner_user_id = cloud_record_owner_user_id
        self.enable_chat = enable_chat
        self.enable_web_anonymous_join = enable_web_anonymous_join
        self.join_before_host = join_before_host
        self.lock_media_status_mic_mute = lock_media_status_mic_mute
        self.lock_nick = lock_nick
        self.minutes_owner_user_id = minutes_owner_user_id
        self.mozi_conf_extension_app_settings = mozi_conf_extension_app_settings
        self.push_all_meeting_records = push_all_meeting_records
        self.push_cloud_record_card = push_cloud_record_card
        self.push_minutes_card = push_minutes_card
        self.waiting_room = waiting_room

    def validate(self):
        if self.mozi_conf_extension_app_settings:
            for k in self.mozi_conf_extension_app_settings:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cloud_record_owner_user_id is not None:
            result['CloudRecordOwnerUserId'] = self.cloud_record_owner_user_id
        if self.enable_chat is not None:
            result['EnableChat'] = self.enable_chat
        if self.enable_web_anonymous_join is not None:
            result['EnableWebAnonymousJoin'] = self.enable_web_anonymous_join
        if self.join_before_host is not None:
            result['JoinBeforeHost'] = self.join_before_host
        if self.lock_media_status_mic_mute is not None:
            result['LockMediaStatusMicMute'] = self.lock_media_status_mic_mute
        if self.lock_nick is not None:
            result['LockNick'] = self.lock_nick
        if self.minutes_owner_user_id is not None:
            result['MinutesOwnerUserId'] = self.minutes_owner_user_id
        result['MoziConfExtensionAppSettings'] = []
        if self.mozi_conf_extension_app_settings is not None:
            for k in self.mozi_conf_extension_app_settings:
                result['MoziConfExtensionAppSettings'].append(k.to_map() if k else None)
        if self.push_all_meeting_records is not None:
            result['PushAllMeetingRecords'] = self.push_all_meeting_records
        if self.push_cloud_record_card is not None:
            result['PushCloudRecordCard'] = self.push_cloud_record_card
        if self.push_minutes_card is not None:
            result['PushMinutesCard'] = self.push_minutes_card
        if self.waiting_room is not None:
            result['WaitingRoom'] = self.waiting_room
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CloudRecordOwnerUserId') is not None:
            self.cloud_record_owner_user_id = m.get('CloudRecordOwnerUserId')
        if m.get('EnableChat') is not None:
            self.enable_chat = m.get('EnableChat')
        if m.get('EnableWebAnonymousJoin') is not None:
            self.enable_web_anonymous_join = m.get('EnableWebAnonymousJoin')
        if m.get('JoinBeforeHost') is not None:
            self.join_before_host = m.get('JoinBeforeHost')
        if m.get('LockMediaStatusMicMute') is not None:
            self.lock_media_status_mic_mute = m.get('LockMediaStatusMicMute')
        if m.get('LockNick') is not None:
            self.lock_nick = m.get('LockNick')
        if m.get('MinutesOwnerUserId') is not None:
            self.minutes_owner_user_id = m.get('MinutesOwnerUserId')
        self.mozi_conf_extension_app_settings = []
        if m.get('MoziConfExtensionAppSettings') is not None:
            for k in m.get('MoziConfExtensionAppSettings'):
                temp_model = CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings()
                self.mozi_conf_extension_app_settings.append(temp_model.from_map(k))
        if m.get('PushAllMeetingRecords') is not None:
            self.push_all_meeting_records = m.get('PushAllMeetingRecords')
        if m.get('PushCloudRecordCard') is not None:
            self.push_cloud_record_card = m.get('PushCloudRecordCard')
        if m.get('PushMinutesCard') is not None:
            self.push_minutes_card = m.get('PushMinutesCard')
        if m.get('WaitingRoom') is not None:
            self.waiting_room = m.get('WaitingRoom')
        return self


class CreateScheduleConferenceRequestScheduleConfSettingModel(TeaModel):
    def __init__(
        self,
        cohost_user_ids: List[str] = None,
        conf_allowed_corp_id: str = None,
        host_user_id: str = None,
        lock_room: int = None,
        mozi_conf_open_record_setting: CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfOpenRecordSetting = None,
        mozi_conf_virtual_extra_setting: CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSetting = None,
        mute_on_join: int = None,
        screen_share_forbidden: int = None,
    ):
        self.cohost_user_ids = cohost_user_ids
        self.conf_allowed_corp_id = conf_allowed_corp_id
        self.host_user_id = host_user_id
        self.lock_room = lock_room
        self.mozi_conf_open_record_setting = mozi_conf_open_record_setting
        self.mozi_conf_virtual_extra_setting = mozi_conf_virtual_extra_setting
        self.mute_on_join = mute_on_join
        self.screen_share_forbidden = screen_share_forbidden

    def validate(self):
        if self.mozi_conf_open_record_setting:
            self.mozi_conf_open_record_setting.validate()
        if self.mozi_conf_virtual_extra_setting:
            self.mozi_conf_virtual_extra_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cohost_user_ids is not None:
            result['CohostUserIds'] = self.cohost_user_ids
        if self.conf_allowed_corp_id is not None:
            result['ConfAllowedCorpId'] = self.conf_allowed_corp_id
        if self.host_user_id is not None:
            result['HostUserId'] = self.host_user_id
        if self.lock_room is not None:
            result['LockRoom'] = self.lock_room
        if self.mozi_conf_open_record_setting is not None:
            result['MoziConfOpenRecordSetting'] = self.mozi_conf_open_record_setting.to_map()
        if self.mozi_conf_virtual_extra_setting is not None:
            result['MoziConfVirtualExtraSetting'] = self.mozi_conf_virtual_extra_setting.to_map()
        if self.mute_on_join is not None:
            result['MuteOnJoin'] = self.mute_on_join
        if self.screen_share_forbidden is not None:
            result['ScreenShareForbidden'] = self.screen_share_forbidden
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CohostUserIds') is not None:
            self.cohost_user_ids = m.get('CohostUserIds')
        if m.get('ConfAllowedCorpId') is not None:
            self.conf_allowed_corp_id = m.get('ConfAllowedCorpId')
        if m.get('HostUserId') is not None:
            self.host_user_id = m.get('HostUserId')
        if m.get('LockRoom') is not None:
            self.lock_room = m.get('LockRoom')
        if m.get('MoziConfOpenRecordSetting') is not None:
            temp_model = CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfOpenRecordSetting()
            self.mozi_conf_open_record_setting = temp_model.from_map(m['MoziConfOpenRecordSetting'])
        if m.get('MoziConfVirtualExtraSetting') is not None:
            temp_model = CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSetting()
            self.mozi_conf_virtual_extra_setting = temp_model.from_map(m['MoziConfVirtualExtraSetting'])
        if m.get('MuteOnJoin') is not None:
            self.mute_on_join = m.get('MuteOnJoin')
        if m.get('ScreenShareForbidden') is not None:
            self.screen_share_forbidden = m.get('ScreenShareForbidden')
        return self


class CreateScheduleConferenceRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CreateScheduleConferenceRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        schedule_conf_setting_model: CreateScheduleConferenceRequestScheduleConfSettingModel = None,
        start_time: int = None,
        tenant_context: CreateScheduleConferenceRequestTenantContext = None,
        title: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        self.schedule_conf_setting_model = schedule_conf_setting_model
        # This parameter is required.
        self.start_time = start_time
        self.tenant_context = tenant_context
        # This parameter is required.
        self.title = title

    def validate(self):
        if self.schedule_conf_setting_model:
            self.schedule_conf_setting_model.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.schedule_conf_setting_model is not None:
            result['ScheduleConfSettingModel'] = self.schedule_conf_setting_model.to_map()
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ScheduleConfSettingModel') is not None:
            temp_model = CreateScheduleConferenceRequestScheduleConfSettingModel()
            self.schedule_conf_setting_model = temp_model.from_map(m['ScheduleConfSettingModel'])
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            temp_model = CreateScheduleConferenceRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class CreateScheduleConferenceShrinkRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        schedule_conf_setting_model_shrink: str = None,
        start_time: int = None,
        tenant_context_shrink: str = None,
        title: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        self.schedule_conf_setting_model_shrink = schedule_conf_setting_model_shrink
        # This parameter is required.
        self.start_time = start_time
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.schedule_conf_setting_model_shrink is not None:
            result['ScheduleConfSettingModel'] = self.schedule_conf_setting_model_shrink
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ScheduleConfSettingModel') is not None:
            self.schedule_conf_setting_model_shrink = m.get('ScheduleConfSettingModel')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class CreateScheduleConferenceResponseBody(TeaModel):
    def __init__(
        self,
        phones: List[str] = None,
        request_id: str = None,
        room_code: str = None,
        schedule_conference_id: str = None,
        url: str = None,
    ):
        self.phones = phones
        # requestId
        self.request_id = request_id
        self.room_code = room_code
        self.schedule_conference_id = schedule_conference_id
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.phones is not None:
            result['phones'] = self.phones
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.room_code is not None:
            result['roomCode'] = self.room_code
        if self.schedule_conference_id is not None:
            result['scheduleConferenceId'] = self.schedule_conference_id
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('phones') is not None:
            self.phones = m.get('phones')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('roomCode') is not None:
            self.room_code = m.get('roomCode')
        if m.get('scheduleConferenceId') is not None:
            self.schedule_conference_id = m.get('scheduleConferenceId')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class CreateScheduleConferenceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateScheduleConferenceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateScheduleConferenceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSearchDomeHeadersAccountContext(TeaModel):
    def __init__(
        self,
        user_token: str = None,
    ):
        self.user_token = user_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_token is not None:
            result['userToken'] = self.user_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('userToken') is not None:
            self.user_token = m.get('userToken')
        return self


class CreateSearchDomeHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateSearchDomeHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateSearchDomeHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateSearchDomeShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateSearchDomeRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CreateSearchDomeRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        end_time: int = None,
        res_id: str = None,
        start_time: int = None,
        tenant_context: CreateSearchDomeRequestTenantContext = None,
        user_id_list: List[str] = None,
    ):
        self.content = content
        self.end_time = end_time
        self.res_id = res_id
        self.start_time = start_time
        self.tenant_context = tenant_context
        self.user_id_list = user_id_list

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.res_id is not None:
            result['ResId'] = self.res_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.user_id_list is not None:
            result['UserIdList'] = self.user_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ResId') is not None:
            self.res_id = m.get('ResId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            temp_model = CreateSearchDomeRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('UserIdList') is not None:
            self.user_id_list = m.get('UserIdList')
        return self


class CreateSearchDomeShrinkRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        end_time: int = None,
        res_id: str = None,
        start_time: int = None,
        tenant_context_shrink: str = None,
        user_id_list_shrink: str = None,
    ):
        self.content = content
        self.end_time = end_time
        self.res_id = res_id
        self.start_time = start_time
        self.tenant_context_shrink = tenant_context_shrink
        self.user_id_list_shrink = user_id_list_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.res_id is not None:
            result['ResId'] = self.res_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.user_id_list_shrink is not None:
            result['UserIdList'] = self.user_id_list_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ResId') is not None:
            self.res_id = m.get('ResId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('UserIdList') is not None:
            self.user_id_list_shrink = m.get('UserIdList')
        return self


class CreateSearchDomeResponseBody(TeaModel):
    def __init__(
        self,
        arguments: List[Any] = None,
        request_id: str = None,
        success: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.arguments = arguments
        self.request_id = request_id
        self.success = success
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arguments is not None:
            result['arguments'] = self.arguments
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('arguments') is not None:
            self.arguments = m.get('arguments')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class CreateSearchDomeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSearchDomeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSearchDomeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSearchKeywordHeadersAccountContext(TeaModel):
    def __init__(
        self,
        user_token: str = None,
    ):
        self.user_token = user_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_token is not None:
            result['userToken'] = self.user_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('userToken') is not None:
            self.user_token = m.get('userToken')
        return self


class CreateSearchKeywordHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateSearchKeywordHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateSearchKeywordHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateSearchKeywordShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateSearchKeywordRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CreateSearchKeywordRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        end_time: int = None,
        res_id: str = None,
        start_time: int = None,
        tenant_context: CreateSearchKeywordRequestTenantContext = None,
        user_id_list: List[str] = None,
    ):
        self.content = content
        self.end_time = end_time
        self.res_id = res_id
        self.start_time = start_time
        self.tenant_context = tenant_context
        self.user_id_list = user_id_list

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.res_id is not None:
            result['ResId'] = self.res_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.user_id_list is not None:
            result['UserIdList'] = self.user_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ResId') is not None:
            self.res_id = m.get('ResId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            temp_model = CreateSearchKeywordRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('UserIdList') is not None:
            self.user_id_list = m.get('UserIdList')
        return self


class CreateSearchKeywordShrinkRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        end_time: int = None,
        res_id: str = None,
        start_time: int = None,
        tenant_context_shrink: str = None,
        user_id_list_shrink: str = None,
    ):
        self.content = content
        self.end_time = end_time
        self.res_id = res_id
        self.start_time = start_time
        self.tenant_context_shrink = tenant_context_shrink
        self.user_id_list_shrink = user_id_list_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.res_id is not None:
            result['ResId'] = self.res_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.user_id_list_shrink is not None:
            result['UserIdList'] = self.user_id_list_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ResId') is not None:
            self.res_id = m.get('ResId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('UserIdList') is not None:
            self.user_id_list_shrink = m.get('UserIdList')
        return self


class CreateSearchKeywordResponseBody(TeaModel):
    def __init__(
        self,
        arguments: List[Any] = None,
        request_id: str = None,
        success: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.arguments = arguments
        self.request_id = request_id
        self.success = success
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arguments is not None:
            result['arguments'] = self.arguments
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('arguments') is not None:
            self.arguments = m.get('arguments')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class CreateSearchKeywordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSearchKeywordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSearchKeywordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSheetHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateSheetHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateSheetHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateSheetHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateSheetShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateSheetRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CreateSheetRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        tenant_context: CreateSheetRequestTenantContext = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.name = name
        self.tenant_context = tenant_context
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TenantContext') is not None:
            temp_model = CreateSheetRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class CreateSheetShrinkRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        tenant_context_shrink: str = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.name = name
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class CreateSheetResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        request_id: str = None,
        visibility: str = None,
    ):
        self.id = id
        self.name = name
        self.request_id = request_id
        self.visibility = visibility

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.visibility is not None:
            result['visibility'] = self.visibility
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('visibility') is not None:
            self.visibility = m.get('visibility')
        return self


class CreateSheetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSheetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSheetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSubscribedCalendarHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateSubscribedCalendarHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateSubscribedCalendarHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateSubscribedCalendarHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateSubscribedCalendarShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateSubscribedCalendarRequestSubscribeScope(TeaModel):
    def __init__(
        self,
        corp_ids: List[str] = None,
        open_conversation_ids: List[str] = None,
        user_ids: List[str] = None,
    ):
        self.corp_ids = corp_ids
        self.open_conversation_ids = open_conversation_ids
        self.user_ids = user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.corp_ids is not None:
            result['CorpIds'] = self.corp_ids
        if self.open_conversation_ids is not None:
            result['OpenConversationIds'] = self.open_conversation_ids
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CorpIds') is not None:
            self.corp_ids = m.get('CorpIds')
        if m.get('OpenConversationIds') is not None:
            self.open_conversation_ids = m.get('OpenConversationIds')
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        return self


class CreateSubscribedCalendarRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        managers: List[str] = None,
        name: str = None,
        subscribe_scope: CreateSubscribedCalendarRequestSubscribeScope = None,
    ):
        self.description = description
        self.managers = managers
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.subscribe_scope = subscribe_scope

    def validate(self):
        if self.subscribe_scope:
            self.subscribe_scope.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.managers is not None:
            result['Managers'] = self.managers
        if self.name is not None:
            result['Name'] = self.name
        if self.subscribe_scope is not None:
            result['SubscribeScope'] = self.subscribe_scope.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Managers') is not None:
            self.managers = m.get('Managers')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SubscribeScope') is not None:
            temp_model = CreateSubscribedCalendarRequestSubscribeScope()
            self.subscribe_scope = temp_model.from_map(m['SubscribeScope'])
        return self


class CreateSubscribedCalendarShrinkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        managers_shrink: str = None,
        name: str = None,
        subscribe_scope_shrink: str = None,
    ):
        self.description = description
        self.managers_shrink = managers_shrink
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.subscribe_scope_shrink = subscribe_scope_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.managers_shrink is not None:
            result['Managers'] = self.managers_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.subscribe_scope_shrink is not None:
            result['SubscribeScope'] = self.subscribe_scope_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Managers') is not None:
            self.managers_shrink = m.get('Managers')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SubscribeScope') is not None:
            self.subscribe_scope_shrink = m.get('SubscribeScope')
        return self


class CreateSubscribedCalendarResponseBody(TeaModel):
    def __init__(
        self,
        calendar_id: str = None,
        request_id: str = None,
    ):
        self.calendar_id = calendar_id
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calendar_id is not None:
            result['calendarId'] = self.calendar_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('calendarId') is not None:
            self.calendar_id = m.get('calendarId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateSubscribedCalendarResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSubscribedCalendarResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSubscribedCalendarResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateThreadHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_id: str = None,
    ):
        self.common_headers = common_headers
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateThreadRequest(TeaModel):
    def __init__(
        self,
        assistant_id: str = None,
        original_assistant_id: str = None,
        source_id_of_original_assistant_id: str = None,
        source_type_of_original_assistant_id: int = None,
    ):
        # This parameter is required.
        self.assistant_id = assistant_id
        self.original_assistant_id = original_assistant_id
        self.source_id_of_original_assistant_id = source_id_of_original_assistant_id
        self.source_type_of_original_assistant_id = source_type_of_original_assistant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assistant_id is not None:
            result['assistantId'] = self.assistant_id
        if self.original_assistant_id is not None:
            result['originalAssistantId'] = self.original_assistant_id
        if self.source_id_of_original_assistant_id is not None:
            result['sourceIdOfOriginalAssistantId'] = self.source_id_of_original_assistant_id
        if self.source_type_of_original_assistant_id is not None:
            result['sourceTypeOfOriginalAssistantId'] = self.source_type_of_original_assistant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assistantId') is not None:
            self.assistant_id = m.get('assistantId')
        if m.get('originalAssistantId') is not None:
            self.original_assistant_id = m.get('originalAssistantId')
        if m.get('sourceIdOfOriginalAssistantId') is not None:
            self.source_id_of_original_assistant_id = m.get('sourceIdOfOriginalAssistantId')
        if m.get('sourceTypeOfOriginalAssistantId') is not None:
            self.source_type_of_original_assistant_id = m.get('sourceTypeOfOriginalAssistantId')
        return self


class CreateThreadResponseBodyThread(TeaModel):
    def __init__(
        self,
        create_at: int = None,
        id: str = None,
    ):
        self.create_at = create_at
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_at is not None:
            result['createAt'] = self.create_at
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createAt') is not None:
            self.create_at = m.get('createAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class CreateThreadResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        thread: CreateThreadResponseBodyThread = None,
    ):
        self.request_id = request_id
        self.thread = thread

    def validate(self):
        if self.thread:
            self.thread.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.thread is not None:
            result['thread'] = self.thread.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('thread') is not None:
            temp_model = CreateThreadResponseBodyThread()
            self.thread = temp_model.from_map(m['thread'])
        return self


class CreateThreadResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateThreadResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateThreadResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTicketHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateTicketHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateTicketHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateTicketHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateTicketShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateTicketRequestNotify(TeaModel):
    def __init__(
        self,
        group_notice_receiver_user_ids: List[str] = None,
        notice_all_group_member: bool = None,
        work_notice_receiver_user_ids: List[str] = None,
    ):
        self.group_notice_receiver_user_ids = group_notice_receiver_user_ids
        self.notice_all_group_member = notice_all_group_member
        self.work_notice_receiver_user_ids = work_notice_receiver_user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_notice_receiver_user_ids is not None:
            result['GroupNoticeReceiverUserIds'] = self.group_notice_receiver_user_ids
        if self.notice_all_group_member is not None:
            result['NoticeAllGroupMember'] = self.notice_all_group_member
        if self.work_notice_receiver_user_ids is not None:
            result['WorkNoticeReceiverUserIds'] = self.work_notice_receiver_user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupNoticeReceiverUserIds') is not None:
            self.group_notice_receiver_user_ids = m.get('GroupNoticeReceiverUserIds')
        if m.get('NoticeAllGroupMember') is not None:
            self.notice_all_group_member = m.get('NoticeAllGroupMember')
        if m.get('WorkNoticeReceiverUserIds') is not None:
            self.work_notice_receiver_user_ids = m.get('WorkNoticeReceiverUserIds')
        return self


class CreateTicketRequestSceneContextGroupMsgs(TeaModel):
    def __init__(
        self,
        anchor: bool = None,
        open_msg_id: str = None,
    ):
        self.anchor = anchor
        self.open_msg_id = open_msg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.anchor is not None:
            result['Anchor'] = self.anchor
        if self.open_msg_id is not None:
            result['OpenMsgId'] = self.open_msg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Anchor') is not None:
            self.anchor = m.get('Anchor')
        if m.get('OpenMsgId') is not None:
            self.open_msg_id = m.get('OpenMsgId')
        return self


class CreateTicketRequestSceneContext(TeaModel):
    def __init__(
        self,
        group_msgs: List[CreateTicketRequestSceneContextGroupMsgs] = None,
        open_conversation_id: str = None,
        relevantor_user_ids: List[str] = None,
        topic_id: str = None,
    ):
        self.group_msgs = group_msgs
        self.open_conversation_id = open_conversation_id
        self.relevantor_user_ids = relevantor_user_ids
        self.topic_id = topic_id

    def validate(self):
        if self.group_msgs:
            for k in self.group_msgs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['GroupMsgs'] = []
        if self.group_msgs is not None:
            for k in self.group_msgs:
                result['GroupMsgs'].append(k.to_map() if k else None)
        if self.open_conversation_id is not None:
            result['OpenConversationId'] = self.open_conversation_id
        if self.relevantor_user_ids is not None:
            result['RelevantorUserIds'] = self.relevantor_user_ids
        if self.topic_id is not None:
            result['TopicId'] = self.topic_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.group_msgs = []
        if m.get('GroupMsgs') is not None:
            for k in m.get('GroupMsgs'):
                temp_model = CreateTicketRequestSceneContextGroupMsgs()
                self.group_msgs.append(temp_model.from_map(k))
        if m.get('OpenConversationId') is not None:
            self.open_conversation_id = m.get('OpenConversationId')
        if m.get('RelevantorUserIds') is not None:
            self.relevantor_user_ids = m.get('RelevantorUserIds')
        if m.get('TopicId') is not None:
            self.topic_id = m.get('TopicId')
        return self


class CreateTicketRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CreateTicketRequest(TeaModel):
    def __init__(
        self,
        custom_fields: str = None,
        notify: CreateTicketRequestNotify = None,
        open_team_id: str = None,
        open_template_biz_id: str = None,
        processor_user_ids: List[str] = None,
        scene: str = None,
        scene_context: CreateTicketRequestSceneContext = None,
        tenant_context: CreateTicketRequestTenantContext = None,
        title: str = None,
    ):
        self.custom_fields = custom_fields
        self.notify = notify
        # This parameter is required.
        self.open_team_id = open_team_id
        # This parameter is required.
        self.open_template_biz_id = open_template_biz_id
        # This parameter is required.
        self.processor_user_ids = processor_user_ids
        # This parameter is required.
        self.scene = scene
        self.scene_context = scene_context
        self.tenant_context = tenant_context
        # This parameter is required.
        self.title = title

    def validate(self):
        if self.notify:
            self.notify.validate()
        if self.scene_context:
            self.scene_context.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_fields is not None:
            result['CustomFields'] = self.custom_fields
        if self.notify is not None:
            result['Notify'] = self.notify.to_map()
        if self.open_team_id is not None:
            result['OpenTeamId'] = self.open_team_id
        if self.open_template_biz_id is not None:
            result['OpenTemplateBizId'] = self.open_template_biz_id
        if self.processor_user_ids is not None:
            result['ProcessorUserIds'] = self.processor_user_ids
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.scene_context is not None:
            result['SceneContext'] = self.scene_context.to_map()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomFields') is not None:
            self.custom_fields = m.get('CustomFields')
        if m.get('Notify') is not None:
            temp_model = CreateTicketRequestNotify()
            self.notify = temp_model.from_map(m['Notify'])
        if m.get('OpenTeamId') is not None:
            self.open_team_id = m.get('OpenTeamId')
        if m.get('OpenTemplateBizId') is not None:
            self.open_template_biz_id = m.get('OpenTemplateBizId')
        if m.get('ProcessorUserIds') is not None:
            self.processor_user_ids = m.get('ProcessorUserIds')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('SceneContext') is not None:
            temp_model = CreateTicketRequestSceneContext()
            self.scene_context = temp_model.from_map(m['SceneContext'])
        if m.get('TenantContext') is not None:
            temp_model = CreateTicketRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class CreateTicketShrinkRequest(TeaModel):
    def __init__(
        self,
        custom_fields: str = None,
        notify_shrink: str = None,
        open_team_id: str = None,
        open_template_biz_id: str = None,
        processor_user_ids_shrink: str = None,
        scene: str = None,
        scene_context_shrink: str = None,
        tenant_context_shrink: str = None,
        title: str = None,
    ):
        self.custom_fields = custom_fields
        self.notify_shrink = notify_shrink
        # This parameter is required.
        self.open_team_id = open_team_id
        # This parameter is required.
        self.open_template_biz_id = open_template_biz_id
        # This parameter is required.
        self.processor_user_ids_shrink = processor_user_ids_shrink
        # This parameter is required.
        self.scene = scene
        self.scene_context_shrink = scene_context_shrink
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_fields is not None:
            result['CustomFields'] = self.custom_fields
        if self.notify_shrink is not None:
            result['Notify'] = self.notify_shrink
        if self.open_team_id is not None:
            result['OpenTeamId'] = self.open_team_id
        if self.open_template_biz_id is not None:
            result['OpenTemplateBizId'] = self.open_template_biz_id
        if self.processor_user_ids_shrink is not None:
            result['ProcessorUserIds'] = self.processor_user_ids_shrink
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.scene_context_shrink is not None:
            result['SceneContext'] = self.scene_context_shrink
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomFields') is not None:
            self.custom_fields = m.get('CustomFields')
        if m.get('Notify') is not None:
            self.notify_shrink = m.get('Notify')
        if m.get('OpenTeamId') is not None:
            self.open_team_id = m.get('OpenTeamId')
        if m.get('OpenTemplateBizId') is not None:
            self.open_template_biz_id = m.get('OpenTemplateBizId')
        if m.get('ProcessorUserIds') is not None:
            self.processor_user_ids_shrink = m.get('ProcessorUserIds')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('SceneContext') is not None:
            self.scene_context_shrink = m.get('SceneContext')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class CreateTicketResponseBody(TeaModel):
    def __init__(
        self,
        open_ticket_id: str = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.open_ticket_id = open_ticket_id
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.open_ticket_id is not None:
            result['openTicketId'] = self.open_ticket_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('openTicketId') is not None:
            self.open_ticket_id = m.get('openTicketId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class CreateTicketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateTicketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTicketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTodoTaskHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateTodoTaskHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateTodoTaskHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateTodoTaskHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateTodoTaskShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateTodoTaskRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CreateTodoTaskRequestActionListParam(TeaModel):
    def __init__(
        self,
        body: str = None,
        header: Dict[str, str] = None,
    ):
        self.body = body
        self.header = header

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['body'] = self.body
        if self.header is not None:
            result['header'] = self.header
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            self.body = m.get('body')
        if m.get('header') is not None:
            self.header = m.get('header')
        return self


class CreateTodoTaskRequestActionList(TeaModel):
    def __init__(
        self,
        action_key: str = None,
        action_type: int = None,
        button_style_type: int = None,
        param: CreateTodoTaskRequestActionListParam = None,
        pc_url: str = None,
        title: str = None,
        url: str = None,
    ):
        self.action_key = action_key
        self.action_type = action_type
        self.button_style_type = button_style_type
        self.param = param
        self.pc_url = pc_url
        self.title = title
        self.url = url

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_key is not None:
            result['actionKey'] = self.action_key
        if self.action_type is not None:
            result['actionType'] = self.action_type
        if self.button_style_type is not None:
            result['buttonStyleType'] = self.button_style_type
        if self.param is not None:
            result['param'] = self.param.to_map()
        if self.pc_url is not None:
            result['pcUrl'] = self.pc_url
        if self.title is not None:
            result['title'] = self.title
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('actionKey') is not None:
            self.action_key = m.get('actionKey')
        if m.get('actionType') is not None:
            self.action_type = m.get('actionType')
        if m.get('buttonStyleType') is not None:
            self.button_style_type = m.get('buttonStyleType')
        if m.get('param') is not None:
            temp_model = CreateTodoTaskRequestActionListParam()
            self.param = temp_model.from_map(m['param'])
        if m.get('pcUrl') is not None:
            self.pc_url = m.get('pcUrl')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class CreateTodoTaskRequestContentFieldList(TeaModel):
    def __init__(
        self,
        field_key: str = None,
        field_value: str = None,
    ):
        # fieldKey
        self.field_key = field_key
        # fieldValue
        self.field_value = field_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_key is not None:
            result['fieldKey'] = self.field_key
        if self.field_value is not None:
            result['fieldValue'] = self.field_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldKey') is not None:
            self.field_key = m.get('fieldKey')
        if m.get('fieldValue') is not None:
            self.field_value = m.get('fieldValue')
        return self


class CreateTodoTaskRequestDetailUrl(TeaModel):
    def __init__(
        self,
        app_url: str = None,
        pc_url: str = None,
    ):
        self.app_url = app_url
        self.pc_url = pc_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_url is not None:
            result['appUrl'] = self.app_url
        if self.pc_url is not None:
            result['pcUrl'] = self.pc_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('appUrl') is not None:
            self.app_url = m.get('appUrl')
        if m.get('pcUrl') is not None:
            self.pc_url = m.get('pcUrl')
        return self


class CreateTodoTaskRequestNotifyConfigs(TeaModel):
    def __init__(
        self,
        ding_notify: str = None,
    ):
        self.ding_notify = ding_notify

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ding_notify is not None:
            result['dingNotify'] = self.ding_notify
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dingNotify') is not None:
            self.ding_notify = m.get('dingNotify')
        return self


class CreateTodoTaskRequest(TeaModel):
    def __init__(
        self,
        tenant_context: CreateTodoTaskRequestTenantContext = None,
        action_list: List[CreateTodoTaskRequestActionList] = None,
        content_field_list: List[CreateTodoTaskRequestContentFieldList] = None,
        creator_id: str = None,
        description: str = None,
        detail_url: CreateTodoTaskRequestDetailUrl = None,
        due_time: int = None,
        executor_ids: List[str] = None,
        is_only_show_executor: bool = None,
        notify_configs: CreateTodoTaskRequestNotifyConfigs = None,
        operator_id: str = None,
        participant_ids: List[str] = None,
        priority: int = None,
        source_id: str = None,
        subject: str = None,
    ):
        self.tenant_context = tenant_context
        self.action_list = action_list
        self.content_field_list = content_field_list
        self.creator_id = creator_id
        self.description = description
        self.detail_url = detail_url
        self.due_time = due_time
        self.executor_ids = executor_ids
        self.is_only_show_executor = is_only_show_executor
        self.notify_configs = notify_configs
        self.operator_id = operator_id
        self.participant_ids = participant_ids
        self.priority = priority
        self.source_id = source_id
        # This parameter is required.
        self.subject = subject

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()
        if self.action_list:
            for k in self.action_list:
                if k:
                    k.validate()
        if self.content_field_list:
            for k in self.content_field_list:
                if k:
                    k.validate()
        if self.detail_url:
            self.detail_url.validate()
        if self.notify_configs:
            self.notify_configs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        result['actionList'] = []
        if self.action_list is not None:
            for k in self.action_list:
                result['actionList'].append(k.to_map() if k else None)
        result['contentFieldList'] = []
        if self.content_field_list is not None:
            for k in self.content_field_list:
                result['contentFieldList'].append(k.to_map() if k else None)
        if self.creator_id is not None:
            result['creatorId'] = self.creator_id
        if self.description is not None:
            result['description'] = self.description
        if self.detail_url is not None:
            result['detailUrl'] = self.detail_url.to_map()
        if self.due_time is not None:
            result['dueTime'] = self.due_time
        if self.executor_ids is not None:
            result['executorIds'] = self.executor_ids
        if self.is_only_show_executor is not None:
            result['isOnlyShowExecutor'] = self.is_only_show_executor
        if self.notify_configs is not None:
            result['notifyConfigs'] = self.notify_configs.to_map()
        if self.operator_id is not None:
            result['operatorId'] = self.operator_id
        if self.participant_ids is not None:
            result['participantIds'] = self.participant_ids
        if self.priority is not None:
            result['priority'] = self.priority
        if self.source_id is not None:
            result['sourceId'] = self.source_id
        if self.subject is not None:
            result['subject'] = self.subject
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = CreateTodoTaskRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        self.action_list = []
        if m.get('actionList') is not None:
            for k in m.get('actionList'):
                temp_model = CreateTodoTaskRequestActionList()
                self.action_list.append(temp_model.from_map(k))
        self.content_field_list = []
        if m.get('contentFieldList') is not None:
            for k in m.get('contentFieldList'):
                temp_model = CreateTodoTaskRequestContentFieldList()
                self.content_field_list.append(temp_model.from_map(k))
        if m.get('creatorId') is not None:
            self.creator_id = m.get('creatorId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('detailUrl') is not None:
            temp_model = CreateTodoTaskRequestDetailUrl()
            self.detail_url = temp_model.from_map(m['detailUrl'])
        if m.get('dueTime') is not None:
            self.due_time = m.get('dueTime')
        if m.get('executorIds') is not None:
            self.executor_ids = m.get('executorIds')
        if m.get('isOnlyShowExecutor') is not None:
            self.is_only_show_executor = m.get('isOnlyShowExecutor')
        if m.get('notifyConfigs') is not None:
            temp_model = CreateTodoTaskRequestNotifyConfigs()
            self.notify_configs = temp_model.from_map(m['notifyConfigs'])
        if m.get('operatorId') is not None:
            self.operator_id = m.get('operatorId')
        if m.get('participantIds') is not None:
            self.participant_ids = m.get('participantIds')
        if m.get('priority') is not None:
            self.priority = m.get('priority')
        if m.get('sourceId') is not None:
            self.source_id = m.get('sourceId')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        return self


class CreateTodoTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        action_list_shrink: str = None,
        content_field_list_shrink: str = None,
        creator_id: str = None,
        description: str = None,
        detail_url_shrink: str = None,
        due_time: int = None,
        executor_ids_shrink: str = None,
        is_only_show_executor: bool = None,
        notify_configs_shrink: str = None,
        operator_id: str = None,
        participant_ids_shrink: str = None,
        priority: int = None,
        source_id: str = None,
        subject: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        self.action_list_shrink = action_list_shrink
        self.content_field_list_shrink = content_field_list_shrink
        self.creator_id = creator_id
        self.description = description
        self.detail_url_shrink = detail_url_shrink
        self.due_time = due_time
        self.executor_ids_shrink = executor_ids_shrink
        self.is_only_show_executor = is_only_show_executor
        self.notify_configs_shrink = notify_configs_shrink
        self.operator_id = operator_id
        self.participant_ids_shrink = participant_ids_shrink
        self.priority = priority
        self.source_id = source_id
        # This parameter is required.
        self.subject = subject

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.action_list_shrink is not None:
            result['actionList'] = self.action_list_shrink
        if self.content_field_list_shrink is not None:
            result['contentFieldList'] = self.content_field_list_shrink
        if self.creator_id is not None:
            result['creatorId'] = self.creator_id
        if self.description is not None:
            result['description'] = self.description
        if self.detail_url_shrink is not None:
            result['detailUrl'] = self.detail_url_shrink
        if self.due_time is not None:
            result['dueTime'] = self.due_time
        if self.executor_ids_shrink is not None:
            result['executorIds'] = self.executor_ids_shrink
        if self.is_only_show_executor is not None:
            result['isOnlyShowExecutor'] = self.is_only_show_executor
        if self.notify_configs_shrink is not None:
            result['notifyConfigs'] = self.notify_configs_shrink
        if self.operator_id is not None:
            result['operatorId'] = self.operator_id
        if self.participant_ids_shrink is not None:
            result['participantIds'] = self.participant_ids_shrink
        if self.priority is not None:
            result['priority'] = self.priority
        if self.source_id is not None:
            result['sourceId'] = self.source_id
        if self.subject is not None:
            result['subject'] = self.subject
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('actionList') is not None:
            self.action_list_shrink = m.get('actionList')
        if m.get('contentFieldList') is not None:
            self.content_field_list_shrink = m.get('contentFieldList')
        if m.get('creatorId') is not None:
            self.creator_id = m.get('creatorId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('detailUrl') is not None:
            self.detail_url_shrink = m.get('detailUrl')
        if m.get('dueTime') is not None:
            self.due_time = m.get('dueTime')
        if m.get('executorIds') is not None:
            self.executor_ids_shrink = m.get('executorIds')
        if m.get('isOnlyShowExecutor') is not None:
            self.is_only_show_executor = m.get('isOnlyShowExecutor')
        if m.get('notifyConfigs') is not None:
            self.notify_configs_shrink = m.get('notifyConfigs')
        if m.get('operatorId') is not None:
            self.operator_id = m.get('operatorId')
        if m.get('participantIds') is not None:
            self.participant_ids_shrink = m.get('participantIds')
        if m.get('priority') is not None:
            self.priority = m.get('priority')
        if m.get('sourceId') is not None:
            self.source_id = m.get('sourceId')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        return self


class CreateTodoTaskResponseBodyContentFieldList(TeaModel):
    def __init__(
        self,
        field_key: str = None,
        field_value: str = None,
    ):
        # fieldKey
        self.field_key = field_key
        # fieldValue
        self.field_value = field_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_key is not None:
            result['fieldKey'] = self.field_key
        if self.field_value is not None:
            result['fieldValue'] = self.field_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldKey') is not None:
            self.field_key = m.get('fieldKey')
        if m.get('fieldValue') is not None:
            self.field_value = m.get('fieldValue')
        return self


class CreateTodoTaskResponseBodyDetailUrl(TeaModel):
    def __init__(
        self,
        app_url: str = None,
        pc_url: str = None,
    ):
        self.app_url = app_url
        self.pc_url = pc_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_url is not None:
            result['appUrl'] = self.app_url
        if self.pc_url is not None:
            result['pcUrl'] = self.pc_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('appUrl') is not None:
            self.app_url = m.get('appUrl')
        if m.get('pcUrl') is not None:
            self.pc_url = m.get('pcUrl')
        return self


class CreateTodoTaskResponseBodyNotifyConfigs(TeaModel):
    def __init__(
        self,
        ding_notify: str = None,
    ):
        self.ding_notify = ding_notify

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ding_notify is not None:
            result['dingNotify'] = self.ding_notify
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dingNotify') is not None:
            self.ding_notify = m.get('dingNotify')
        return self


class CreateTodoTaskResponseBody(TeaModel):
    def __init__(
        self,
        biz_tag: str = None,
        content_field_list: List[CreateTodoTaskResponseBodyContentFieldList] = None,
        created_time: int = None,
        creator_id: str = None,
        description: str = None,
        detail_url: CreateTodoTaskResponseBodyDetailUrl = None,
        done: bool = None,
        due_time: int = None,
        executor_ids: List[str] = None,
        finish_time: int = None,
        id: str = None,
        is_only_show_executor: bool = None,
        modified_time: int = None,
        modifier_id: str = None,
        notify_configs: CreateTodoTaskResponseBodyNotifyConfigs = None,
        participant_ids: List[str] = None,
        priority: int = None,
        request_id: str = None,
        source: str = None,
        source_id: str = None,
        start_time: int = None,
        subject: str = None,
    ):
        self.biz_tag = biz_tag
        self.content_field_list = content_field_list
        self.created_time = created_time
        self.creator_id = creator_id
        self.description = description
        self.detail_url = detail_url
        self.done = done
        self.due_time = due_time
        self.executor_ids = executor_ids
        self.finish_time = finish_time
        self.id = id
        self.is_only_show_executor = is_only_show_executor
        self.modified_time = modified_time
        self.modifier_id = modifier_id
        self.notify_configs = notify_configs
        self.participant_ids = participant_ids
        self.priority = priority
        # requestId
        self.request_id = request_id
        self.source = source
        self.source_id = source_id
        self.start_time = start_time
        self.subject = subject

    def validate(self):
        if self.content_field_list:
            for k in self.content_field_list:
                if k:
                    k.validate()
        if self.detail_url:
            self.detail_url.validate()
        if self.notify_configs:
            self.notify_configs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_tag is not None:
            result['bizTag'] = self.biz_tag
        result['contentFieldList'] = []
        if self.content_field_list is not None:
            for k in self.content_field_list:
                result['contentFieldList'].append(k.to_map() if k else None)
        if self.created_time is not None:
            result['createdTime'] = self.created_time
        if self.creator_id is not None:
            result['creatorId'] = self.creator_id
        if self.description is not None:
            result['description'] = self.description
        if self.detail_url is not None:
            result['detailUrl'] = self.detail_url.to_map()
        if self.done is not None:
            result['done'] = self.done
        if self.due_time is not None:
            result['dueTime'] = self.due_time
        if self.executor_ids is not None:
            result['executorIds'] = self.executor_ids
        if self.finish_time is not None:
            result['finishTime'] = self.finish_time
        if self.id is not None:
            result['id'] = self.id
        if self.is_only_show_executor is not None:
            result['isOnlyShowExecutor'] = self.is_only_show_executor
        if self.modified_time is not None:
            result['modifiedTime'] = self.modified_time
        if self.modifier_id is not None:
            result['modifierId'] = self.modifier_id
        if self.notify_configs is not None:
            result['notifyConfigs'] = self.notify_configs.to_map()
        if self.participant_ids is not None:
            result['participantIds'] = self.participant_ids
        if self.priority is not None:
            result['priority'] = self.priority
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.source is not None:
            result['source'] = self.source
        if self.source_id is not None:
            result['sourceId'] = self.source_id
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.subject is not None:
            result['subject'] = self.subject
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bizTag') is not None:
            self.biz_tag = m.get('bizTag')
        self.content_field_list = []
        if m.get('contentFieldList') is not None:
            for k in m.get('contentFieldList'):
                temp_model = CreateTodoTaskResponseBodyContentFieldList()
                self.content_field_list.append(temp_model.from_map(k))
        if m.get('createdTime') is not None:
            self.created_time = m.get('createdTime')
        if m.get('creatorId') is not None:
            self.creator_id = m.get('creatorId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('detailUrl') is not None:
            temp_model = CreateTodoTaskResponseBodyDetailUrl()
            self.detail_url = temp_model.from_map(m['detailUrl'])
        if m.get('done') is not None:
            self.done = m.get('done')
        if m.get('dueTime') is not None:
            self.due_time = m.get('dueTime')
        if m.get('executorIds') is not None:
            self.executor_ids = m.get('executorIds')
        if m.get('finishTime') is not None:
            self.finish_time = m.get('finishTime')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('isOnlyShowExecutor') is not None:
            self.is_only_show_executor = m.get('isOnlyShowExecutor')
        if m.get('modifiedTime') is not None:
            self.modified_time = m.get('modifiedTime')
        if m.get('modifierId') is not None:
            self.modifier_id = m.get('modifierId')
        if m.get('notifyConfigs') is not None:
            temp_model = CreateTodoTaskResponseBodyNotifyConfigs()
            self.notify_configs = temp_model.from_map(m['notifyConfigs'])
        if m.get('participantIds') is not None:
            self.participant_ids = m.get('participantIds')
        if m.get('priority') is not None:
            self.priority = m.get('priority')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('sourceId') is not None:
            self.source_id = m.get('sourceId')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        return self


class CreateTodoTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateTodoTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTodoTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateVideoConferenceHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateVideoConferenceHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateVideoConferenceHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateVideoConferenceHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateVideoConferenceShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateVideoConferenceRequest(TeaModel):
    def __init__(
        self,
        conf_title: str = None,
        invite_caller: bool = None,
        invite_user_ids: List[str] = None,
    ):
        # This parameter is required.
        self.conf_title = conf_title
        self.invite_caller = invite_caller
        self.invite_user_ids = invite_user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conf_title is not None:
            result['ConfTitle'] = self.conf_title
        if self.invite_caller is not None:
            result['InviteCaller'] = self.invite_caller
        if self.invite_user_ids is not None:
            result['InviteUserIds'] = self.invite_user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfTitle') is not None:
            self.conf_title = m.get('ConfTitle')
        if m.get('InviteCaller') is not None:
            self.invite_caller = m.get('InviteCaller')
        if m.get('InviteUserIds') is not None:
            self.invite_user_ids = m.get('InviteUserIds')
        return self


class CreateVideoConferenceShrinkRequest(TeaModel):
    def __init__(
        self,
        conf_title: str = None,
        invite_caller: bool = None,
        invite_user_ids_shrink: str = None,
    ):
        # This parameter is required.
        self.conf_title = conf_title
        self.invite_caller = invite_caller
        self.invite_user_ids_shrink = invite_user_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conf_title is not None:
            result['ConfTitle'] = self.conf_title
        if self.invite_caller is not None:
            result['InviteCaller'] = self.invite_caller
        if self.invite_user_ids_shrink is not None:
            result['InviteUserIds'] = self.invite_user_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfTitle') is not None:
            self.conf_title = m.get('ConfTitle')
        if m.get('InviteCaller') is not None:
            self.invite_caller = m.get('InviteCaller')
        if m.get('InviteUserIds') is not None:
            self.invite_user_ids_shrink = m.get('InviteUserIds')
        return self


class CreateVideoConferenceResponseBody(TeaModel):
    def __init__(
        self,
        conference_id: str = None,
        conference_password: str = None,
        external_link_url: str = None,
        host_password: str = None,
        phone_numbers: List[str] = None,
        request_id: str = None,
        room_code: str = None,
    ):
        self.conference_id = conference_id
        self.conference_password = conference_password
        self.external_link_url = external_link_url
        self.host_password = host_password
        self.phone_numbers = phone_numbers
        # requestId
        self.request_id = request_id
        self.room_code = room_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        if self.conference_password is not None:
            result['conferencePassword'] = self.conference_password
        if self.external_link_url is not None:
            result['externalLinkUrl'] = self.external_link_url
        if self.host_password is not None:
            result['hostPassword'] = self.host_password
        if self.phone_numbers is not None:
            result['phoneNumbers'] = self.phone_numbers
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.room_code is not None:
            result['roomCode'] = self.room_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        if m.get('conferencePassword') is not None:
            self.conference_password = m.get('conferencePassword')
        if m.get('externalLinkUrl') is not None:
            self.external_link_url = m.get('externalLinkUrl')
        if m.get('hostPassword') is not None:
            self.host_password = m.get('hostPassword')
        if m.get('phoneNumbers') is not None:
            self.phone_numbers = m.get('phoneNumbers')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('roomCode') is not None:
            self.room_code = m.get('roomCode')
        return self


class CreateVideoConferenceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateVideoConferenceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateVideoConferenceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateWorkspaceHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateWorkspaceHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateWorkspaceHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateWorkspaceHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateWorkspaceShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateWorkspaceRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CreateWorkspaceRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        tenant_context: CreateWorkspaceRequestTenantContext = None,
    ):
        self.description = description
        # This parameter is required.
        self.name = name
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TenantContext') is not None:
            temp_model = CreateWorkspaceRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class CreateWorkspaceShrinkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        tenant_context_shrink: str = None,
    ):
        self.description = description
        # This parameter is required.
        self.name = name
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class CreateWorkspaceResponseBody(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        request_id: str = None,
        url: str = None,
        workspace_id: str = None,
    ):
        self.description = description
        self.name = name
        # requestId
        self.request_id = request_id
        self.url = url
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.url is not None:
            result['url'] = self.url
        if self.workspace_id is not None:
            result['workspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('workspaceId') is not None:
            self.workspace_id = m.get('workspaceId')
        return self


class CreateWorkspaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateWorkspaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateWorkspaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateWorkspaceDocHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class CreateWorkspaceDocHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: CreateWorkspaceDocHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = CreateWorkspaceDocHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class CreateWorkspaceDocShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class CreateWorkspaceDocRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class CreateWorkspaceDocRequest(TeaModel):
    def __init__(
        self,
        doc_type: str = None,
        name: str = None,
        parent_node_id: str = None,
        template_id: str = None,
        template_type: str = None,
        tenant_context: CreateWorkspaceDocRequestTenantContext = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.doc_type = doc_type
        # This parameter is required.
        self.name = name
        self.parent_node_id = parent_node_id
        self.template_id = template_id
        self.template_type = template_type
        self.tenant_context = tenant_context
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.name is not None:
            result['Name'] = self.name
        if self.parent_node_id is not None:
            result['ParentNodeId'] = self.parent_node_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParentNodeId') is not None:
            self.parent_node_id = m.get('ParentNodeId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('TenantContext') is not None:
            temp_model = CreateWorkspaceDocRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class CreateWorkspaceDocShrinkRequest(TeaModel):
    def __init__(
        self,
        doc_type: str = None,
        name: str = None,
        parent_node_id: str = None,
        template_id: str = None,
        template_type: str = None,
        tenant_context_shrink: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.doc_type = doc_type
        # This parameter is required.
        self.name = name
        self.parent_node_id = parent_node_id
        self.template_id = template_id
        self.template_type = template_type
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.name is not None:
            result['Name'] = self.name
        if self.parent_node_id is not None:
            result['ParentNodeId'] = self.parent_node_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParentNodeId') is not None:
            self.parent_node_id = m.get('ParentNodeId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class CreateWorkspaceDocResponseBody(TeaModel):
    def __init__(
        self,
        dentry_uuid: str = None,
        doc_key: str = None,
        node_id: str = None,
        request_id: str = None,
        url: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
        workspace_id: str = None,
    ):
        self.dentry_uuid = dentry_uuid
        self.doc_key = doc_key
        self.node_id = node_id
        # requestId
        self.request_id = request_id
        self.url = url
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_uuid is not None:
            result['dentryUuid'] = self.dentry_uuid
        if self.doc_key is not None:
            result['docKey'] = self.doc_key
        if self.node_id is not None:
            result['nodeId'] = self.node_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.url is not None:
            result['url'] = self.url
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        if self.workspace_id is not None:
            result['workspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dentryUuid') is not None:
            self.dentry_uuid = m.get('dentryUuid')
        if m.get('docKey') is not None:
            self.doc_key = m.get('docKey')
        if m.get('nodeId') is not None:
            self.node_id = m.get('nodeId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        if m.get('workspaceId') is not None:
            self.workspace_id = m.get('workspaceId')
        return self


class CreateWorkspaceDocResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateWorkspaceDocResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateWorkspaceDocResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteColumnsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DeleteColumnsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DeleteColumnsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DeleteColumnsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DeleteColumnsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DeleteColumnsRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class DeleteColumnsRequest(TeaModel):
    def __init__(
        self,
        column: int = None,
        column_count: int = None,
        sheet_id: str = None,
        tenant_context: DeleteColumnsRequestTenantContext = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.column = column
        # This parameter is required.
        self.column_count = column_count
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context = tenant_context
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column is not None:
            result['Column'] = self.column
        if self.column_count is not None:
            result['ColumnCount'] = self.column_count
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Column') is not None:
            self.column = m.get('Column')
        if m.get('ColumnCount') is not None:
            self.column_count = m.get('ColumnCount')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            temp_model = DeleteColumnsRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class DeleteColumnsShrinkRequest(TeaModel):
    def __init__(
        self,
        column: int = None,
        column_count: int = None,
        sheet_id: str = None,
        tenant_context_shrink: str = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.column = column
        # This parameter is required.
        self.column_count = column_count
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column is not None:
            result['Column'] = self.column
        if self.column_count is not None:
            result['ColumnCount'] = self.column_count
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Column') is not None:
            self.column = m.get('Column')
        if m.get('ColumnCount') is not None:
            self.column_count = m.get('ColumnCount')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class DeleteColumnsResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
    ):
        self.id = id
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteColumnsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteColumnsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteColumnsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDentryHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DeleteDentryHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DeleteDentryHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DeleteDentryHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DeleteDentryShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DeleteDentryRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class DeleteDentryRequest(TeaModel):
    def __init__(
        self,
        dentry_id: str = None,
        space_id: str = None,
        tenant_context: DeleteDentryRequestTenantContext = None,
        to_recycle_bin: bool = None,
    ):
        # This parameter is required.
        self.dentry_id = dentry_id
        # This parameter is required.
        self.space_id = space_id
        self.tenant_context = tenant_context
        self.to_recycle_bin = to_recycle_bin

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_id is not None:
            result['DentryId'] = self.dentry_id
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.to_recycle_bin is not None:
            result['ToRecycleBin'] = self.to_recycle_bin
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryId') is not None:
            self.dentry_id = m.get('DentryId')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('TenantContext') is not None:
            temp_model = DeleteDentryRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('ToRecycleBin') is not None:
            self.to_recycle_bin = m.get('ToRecycleBin')
        return self


class DeleteDentryShrinkRequest(TeaModel):
    def __init__(
        self,
        dentry_id: str = None,
        space_id: str = None,
        tenant_context_shrink: str = None,
        to_recycle_bin: bool = None,
    ):
        # This parameter is required.
        self.dentry_id = dentry_id
        # This parameter is required.
        self.space_id = space_id
        self.tenant_context_shrink = tenant_context_shrink
        self.to_recycle_bin = to_recycle_bin

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_id is not None:
            result['DentryId'] = self.dentry_id
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.to_recycle_bin is not None:
            result['ToRecycleBin'] = self.to_recycle_bin
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryId') is not None:
            self.dentry_id = m.get('DentryId')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('ToRecycleBin') is not None:
            self.to_recycle_bin = m.get('ToRecycleBin')
        return self


class DeleteDentryResponseBody(TeaModel):
    def __init__(
        self,
        async_: bool = None,
        request_id: str = None,
        task_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.async_ = async_
        self.request_id = request_id
        self.task_id = task_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_ is not None:
            result['async'] = self.async_
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.task_id is not None:
            result['taskId'] = self.task_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('async') is not None:
            self.async_ = m.get('async')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class DeleteDentryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDentryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDentryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDriveSpaceHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DeleteDriveSpaceHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DeleteDriveSpaceHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        # This parameter is required.
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DeleteDriveSpaceHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DeleteDriveSpaceShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        # This parameter is required.
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DeleteDriveSpaceRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class DeleteDriveSpaceRequest(TeaModel):
    def __init__(
        self,
        space_id: str = None,
        tenant_context: DeleteDriveSpaceRequestTenantContext = None,
    ):
        # This parameter is required.
        self.space_id = space_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('TenantContext') is not None:
            temp_model = DeleteDriveSpaceRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class DeleteDriveSpaceShrinkRequest(TeaModel):
    def __init__(
        self,
        space_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.space_id = space_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class DeleteDriveSpaceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class DeleteDriveSpaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDriveSpaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDriveSpaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEventHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DeleteEventHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DeleteEventHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DeleteEventHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DeleteEventShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DeleteEventRequest(TeaModel):
    def __init__(
        self,
        calendar_id: str = None,
        event_id: str = None,
        push_notification: bool = None,
    ):
        # This parameter is required.
        self.calendar_id = calendar_id
        # This parameter is required.
        self.event_id = event_id
        self.push_notification = push_notification

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.push_notification is not None:
            result['pushNotification'] = self.push_notification
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('pushNotification') is not None:
            self.push_notification = m.get('pushNotification')
        return self


class DeleteEventResponseBodyContent(TeaModel):
    def __init__(
        self,
        data: Any = None,
    ):
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class DeleteEventResponseBody(TeaModel):
    def __init__(
        self,
        content: DeleteEventResponseBodyContent = None,
        error_code: str = None,
        error_ctx: Dict[str, Any] = None,
        error_msg: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.content = content
        self.error_code = error_code
        self.error_ctx = error_ctx
        self.error_msg = error_msg
        self.http_status_code = http_status_code
        # requestId
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content.to_map()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_ctx is not None:
            result['errorCtx'] = self.error_ctx
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            temp_model = DeleteEventResponseBodyContent()
            self.content = temp_model.from_map(m['content'])
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorCtx') is not None:
            self.error_ctx = m.get('errorCtx')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteEventResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEventResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteFormDataHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DeleteFormDataHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DeleteFormDataHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DeleteFormDataHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DeleteFormDataShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DeleteFormDataRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        form_instance_id: str = None,
        language: str = None,
        system_token: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        # This parameter is required.
        self.form_instance_id = form_instance_id
        self.language = language
        # This parameter is required.
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.form_instance_id is not None:
            result['FormInstanceId'] = self.form_instance_id
        if self.language is not None:
            result['Language'] = self.language
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('FormInstanceId') is not None:
            self.form_instance_id = m.get('FormInstanceId')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class DeleteFormDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class DeleteFormDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteFormDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteFormDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteInstanceHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DeleteInstanceHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DeleteInstanceHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DeleteInstanceHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DeleteInstanceShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DeleteInstanceRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        language: str = None,
        process_instance_id: str = None,
        system_token: str = None,
    ):
        self.app_type = app_type
        self.language = language
        self.process_instance_id = process_instance_id
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.language is not None:
            result['Language'] = self.language
        if self.process_instance_id is not None:
            result['ProcessInstanceId'] = self.process_instance_id
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('ProcessInstanceId') is not None:
            self.process_instance_id = m.get('ProcessInstanceId')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class DeleteInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class DeleteInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DeleteLiveHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DeleteLiveHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DeleteLiveHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DeleteLiveShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DeleteLiveRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class DeleteLiveRequest(TeaModel):
    def __init__(
        self,
        live_id: str = None,
        tenant_context: DeleteLiveRequestTenantContext = None,
    ):
        # This parameter is required.
        self.live_id = live_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_id is not None:
            result['LiveId'] = self.live_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveId') is not None:
            self.live_id = m.get('LiveId')
        if m.get('TenantContext') is not None:
            temp_model = DeleteLiveRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class DeleteLiveShrinkRequest(TeaModel):
    def __init__(
        self,
        live_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.live_id = live_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_id is not None:
            result['LiveId'] = self.live_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveId') is not None:
            self.live_id = m.get('LiveId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class DeleteLiveResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # requestId
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteLiveResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMeetingRoomHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DeleteMeetingRoomHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DeleteMeetingRoomHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DeleteMeetingRoomHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DeleteMeetingRoomShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DeleteMeetingRoomRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class DeleteMeetingRoomRequest(TeaModel):
    def __init__(
        self,
        room_id: str = None,
        tenant_context: DeleteMeetingRoomRequestTenantContext = None,
    ):
        # This parameter is required.
        self.room_id = room_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.room_id is not None:
            result['RoomId'] = self.room_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RoomId') is not None:
            self.room_id = m.get('RoomId')
        if m.get('TenantContext') is not None:
            temp_model = DeleteMeetingRoomRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class DeleteMeetingRoomShrinkRequest(TeaModel):
    def __init__(
        self,
        room_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.room_id = room_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.room_id is not None:
            result['RoomId'] = self.room_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RoomId') is not None:
            self.room_id = m.get('RoomId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class DeleteMeetingRoomResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: bool = None,
    ):
        # requestId
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class DeleteMeetingRoomResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMeetingRoomResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMeetingRoomResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMeetingRoomGroupHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DeleteMeetingRoomGroupHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DeleteMeetingRoomGroupHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DeleteMeetingRoomGroupHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DeleteMeetingRoomGroupShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DeleteMeetingRoomGroupRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class DeleteMeetingRoomGroupRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        tenant_context: DeleteMeetingRoomGroupRequestTenantContext = None,
    ):
        # This parameter is required.
        self.group_id = group_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('TenantContext') is not None:
            temp_model = DeleteMeetingRoomGroupRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class DeleteMeetingRoomGroupShrinkRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.group_id = group_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class DeleteMeetingRoomGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: bool = None,
    ):
        # requestId
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class DeleteMeetingRoomGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMeetingRoomGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMeetingRoomGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMultiDimTableFieldHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DeleteMultiDimTableFieldHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DeleteMultiDimTableFieldHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DeleteMultiDimTableFieldHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DeleteMultiDimTableFieldShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DeleteMultiDimTableFieldRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class DeleteMultiDimTableFieldRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        field_id_or_name: str = None,
        sheet_id_or_name: str = None,
        tenant_context: DeleteMultiDimTableFieldRequestTenantContext = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.field_id_or_name = field_id_or_name
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.field_id_or_name is not None:
            result['FieldIdOrName'] = self.field_id_or_name
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('FieldIdOrName') is not None:
            self.field_id_or_name = m.get('FieldIdOrName')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            temp_model = DeleteMultiDimTableFieldRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class DeleteMultiDimTableFieldShrinkRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        field_id_or_name: str = None,
        sheet_id_or_name: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.field_id_or_name = field_id_or_name
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.field_id_or_name is not None:
            result['FieldIdOrName'] = self.field_id_or_name
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('FieldIdOrName') is not None:
            self.field_id_or_name = m.get('FieldIdOrName')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class DeleteMultiDimTableFieldResponseBody(TeaModel):
    def __init__(
        self,
        success: bool = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.success = success
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success is not None:
            result['Success'] = self.success
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class DeleteMultiDimTableFieldResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMultiDimTableFieldResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMultiDimTableFieldResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMultiDimTableRecordsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DeleteMultiDimTableRecordsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DeleteMultiDimTableRecordsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DeleteMultiDimTableRecordsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DeleteMultiDimTableRecordsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DeleteMultiDimTableRecordsRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class DeleteMultiDimTableRecordsRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        record_ids: List[str] = None,
        sheet_id_or_name: str = None,
        tenant_context: DeleteMultiDimTableRecordsRequestTenantContext = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.record_ids = record_ids
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.record_ids is not None:
            result['RecordIds'] = self.record_ids
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('RecordIds') is not None:
            self.record_ids = m.get('RecordIds')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            temp_model = DeleteMultiDimTableRecordsRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class DeleteMultiDimTableRecordsShrinkRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        record_ids_shrink: str = None,
        sheet_id_or_name: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.record_ids_shrink = record_ids_shrink
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.record_ids_shrink is not None:
            result['RecordIds'] = self.record_ids_shrink
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('RecordIds') is not None:
            self.record_ids_shrink = m.get('RecordIds')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class DeleteMultiDimTableRecordsResponseBody(TeaModel):
    def __init__(
        self,
        success: bool = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.success = success
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success is not None:
            result['Success'] = self.success
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class DeleteMultiDimTableRecordsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMultiDimTableRecordsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMultiDimTableRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePermissionHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DeletePermissionHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DeletePermissionHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DeletePermissionHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DeletePermissionShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DeletePermissionRequestMembers(TeaModel):
    def __init__(
        self,
        corp_id: str = None,
        id: str = None,
        type: str = None,
    ):
        self.corp_id = corp_id
        self.id = id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.id is not None:
            result['Id'] = self.id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DeletePermissionRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class DeletePermissionRequest(TeaModel):
    def __init__(
        self,
        dentry_uuid: str = None,
        members: List[DeletePermissionRequestMembers] = None,
        role_id: str = None,
        tenant_context: DeletePermissionRequestTenantContext = None,
    ):
        # This parameter is required.
        self.dentry_uuid = dentry_uuid
        # This parameter is required.
        self.members = members
        # This parameter is required.
        self.role_id = role_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.members:
            for k in self.members:
                if k:
                    k.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        result['Members'] = []
        if self.members is not None:
            for k in self.members:
                result['Members'].append(k.to_map() if k else None)
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        self.members = []
        if m.get('Members') is not None:
            for k in m.get('Members'):
                temp_model = DeletePermissionRequestMembers()
                self.members.append(temp_model.from_map(k))
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        if m.get('TenantContext') is not None:
            temp_model = DeletePermissionRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class DeletePermissionShrinkRequest(TeaModel):
    def __init__(
        self,
        dentry_uuid: str = None,
        members_shrink: str = None,
        role_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.dentry_uuid = dentry_uuid
        # This parameter is required.
        self.members_shrink = members_shrink
        # This parameter is required.
        self.role_id = role_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        if self.members_shrink is not None:
            result['Members'] = self.members_shrink
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        if m.get('Members') is not None:
            self.members_shrink = m.get('Members')
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class DeletePermissionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.success = success
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class DeletePermissionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePermissionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRowsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DeleteRowsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DeleteRowsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DeleteRowsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DeleteRowsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DeleteRowsRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class DeleteRowsRequest(TeaModel):
    def __init__(
        self,
        row: int = None,
        row_count: int = None,
        sheet_id: str = None,
        tenant_context: DeleteRowsRequestTenantContext = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.row = row
        # This parameter is required.
        self.row_count = row_count
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context = tenant_context
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.row is not None:
            result['Row'] = self.row
        if self.row_count is not None:
            result['RowCount'] = self.row_count
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Row') is not None:
            self.row = m.get('Row')
        if m.get('RowCount') is not None:
            self.row_count = m.get('RowCount')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            temp_model = DeleteRowsRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class DeleteRowsShrinkRequest(TeaModel):
    def __init__(
        self,
        row: int = None,
        row_count: int = None,
        sheet_id: str = None,
        tenant_context_shrink: str = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.row = row
        # This parameter is required.
        self.row_count = row_count
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.row is not None:
            result['Row'] = self.row
        if self.row_count is not None:
            result['RowCount'] = self.row_count
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Row') is not None:
            self.row = m.get('Row')
        if m.get('RowCount') is not None:
            self.row_count = m.get('RowCount')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class DeleteRowsResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
    ):
        self.id = id
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteRowsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRowsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRowsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteScenegroupMemberHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DeleteScenegroupMemberHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DeleteScenegroupMemberHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DeleteScenegroupMemberHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DeleteScenegroupMemberShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DeleteScenegroupMemberRequest(TeaModel):
    def __init__(
        self,
        open_conversation_id: str = None,
        user_ids: str = None,
    ):
        # This parameter is required.
        self.open_conversation_id = open_conversation_id
        # This parameter is required.
        self.user_ids = user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.open_conversation_id is not None:
            result['OpenConversationId'] = self.open_conversation_id
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OpenConversationId') is not None:
            self.open_conversation_id = m.get('OpenConversationId')
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        return self


class DeleteScenegroupMemberResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # requestId
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteScenegroupMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteScenegroupMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteScenegroupMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSheetHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DeleteSheetHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DeleteSheetHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DeleteSheetHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DeleteSheetShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DeleteSheetRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class DeleteSheetRequest(TeaModel):
    def __init__(
        self,
        sheet_id: str = None,
        tenant_context: DeleteSheetRequestTenantContext = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context = tenant_context
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            temp_model = DeleteSheetRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class DeleteSheetShrinkRequest(TeaModel):
    def __init__(
        self,
        sheet_id: str = None,
        tenant_context_shrink: str = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class DeleteSheetResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # requestId
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteSheetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSheetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSheetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSubscribedCalendarHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DeleteSubscribedCalendarHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DeleteSubscribedCalendarHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DeleteSubscribedCalendarHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DeleteSubscribedCalendarShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DeleteSubscribedCalendarRequest(TeaModel):
    def __init__(
        self,
        calendar_id: str = None,
    ):
        # This parameter is required.
        self.calendar_id = calendar_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        return self


class DeleteSubscribedCalendarResponseBody(TeaModel):
    def __init__(
        self,
        result: bool = None,
        request_id: str = None,
    ):
        self.result = result
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['Result'] = self.result
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteSubscribedCalendarResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSubscribedCalendarResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSubscribedCalendarResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTodoTaskHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DeleteTodoTaskHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DeleteTodoTaskHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DeleteTodoTaskHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DeleteTodoTaskShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DeleteTodoTaskRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class DeleteTodoTaskRequest(TeaModel):
    def __init__(
        self,
        tenant_context: DeleteTodoTaskRequestTenantContext = None,
        operator_id: str = None,
        task_id: str = None,
    ):
        self.tenant_context = tenant_context
        self.operator_id = operator_id
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.operator_id is not None:
            result['operatorId'] = self.operator_id
        if self.task_id is not None:
            result['taskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = DeleteTodoTaskRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('operatorId') is not None:
            self.operator_id = m.get('operatorId')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        return self


class DeleteTodoTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        operator_id: str = None,
        task_id: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        self.operator_id = operator_id
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.operator_id is not None:
            result['operatorId'] = self.operator_id
        if self.task_id is not None:
            result['taskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('operatorId') is not None:
            self.operator_id = m.get('operatorId')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        return self


class DeleteTodoTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: bool = None,
    ):
        # requestId
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class DeleteTodoTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTodoTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTodoTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteWorkspaceDocMembersHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DeleteWorkspaceDocMembersHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DeleteWorkspaceDocMembersHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DeleteWorkspaceDocMembersHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DeleteWorkspaceDocMembersShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DeleteWorkspaceDocMembersRequestMembers(TeaModel):
    def __init__(
        self,
        member_id: str = None,
        member_type: str = None,
    ):
        # This parameter is required.
        self.member_id = member_id
        # This parameter is required.
        self.member_type = member_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.member_id is not None:
            result['MemberId'] = self.member_id
        if self.member_type is not None:
            result['MemberType'] = self.member_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemberId') is not None:
            self.member_id = m.get('MemberId')
        if m.get('MemberType') is not None:
            self.member_type = m.get('MemberType')
        return self


class DeleteWorkspaceDocMembersRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class DeleteWorkspaceDocMembersRequest(TeaModel):
    def __init__(
        self,
        members: List[DeleteWorkspaceDocMembersRequestMembers] = None,
        node_id: str = None,
        tenant_context: DeleteWorkspaceDocMembersRequestTenantContext = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.members = members
        # This parameter is required.
        self.node_id = node_id
        self.tenant_context = tenant_context
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.members:
            for k in self.members:
                if k:
                    k.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Members'] = []
        if self.members is not None:
            for k in self.members:
                result['Members'].append(k.to_map() if k else None)
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.members = []
        if m.get('Members') is not None:
            for k in m.get('Members'):
                temp_model = DeleteWorkspaceDocMembersRequestMembers()
                self.members.append(temp_model.from_map(k))
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('TenantContext') is not None:
            temp_model = DeleteWorkspaceDocMembersRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DeleteWorkspaceDocMembersShrinkRequest(TeaModel):
    def __init__(
        self,
        members_shrink: str = None,
        node_id: str = None,
        tenant_context_shrink: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.members_shrink = members_shrink
        # This parameter is required.
        self.node_id = node_id
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.members_shrink is not None:
            result['Members'] = self.members_shrink
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Members') is not None:
            self.members_shrink = m.get('Members')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DeleteWorkspaceDocMembersResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteWorkspaceDocMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteWorkspaceDocMembersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteWorkspaceDocMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteWorkspaceMembersHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DeleteWorkspaceMembersHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DeleteWorkspaceMembersHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DeleteWorkspaceMembersHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DeleteWorkspaceMembersShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DeleteWorkspaceMembersRequestMembers(TeaModel):
    def __init__(
        self,
        member_id: str = None,
        member_type: str = None,
    ):
        # This parameter is required.
        self.member_id = member_id
        # This parameter is required.
        self.member_type = member_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.member_id is not None:
            result['MemberId'] = self.member_id
        if self.member_type is not None:
            result['MemberType'] = self.member_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemberId') is not None:
            self.member_id = m.get('MemberId')
        if m.get('MemberType') is not None:
            self.member_type = m.get('MemberType')
        return self


class DeleteWorkspaceMembersRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class DeleteWorkspaceMembersRequest(TeaModel):
    def __init__(
        self,
        members: List[DeleteWorkspaceMembersRequestMembers] = None,
        tenant_context: DeleteWorkspaceMembersRequestTenantContext = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.members = members
        self.tenant_context = tenant_context
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.members:
            for k in self.members:
                if k:
                    k.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Members'] = []
        if self.members is not None:
            for k in self.members:
                result['Members'].append(k.to_map() if k else None)
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.members = []
        if m.get('Members') is not None:
            for k in m.get('Members'):
                temp_model = DeleteWorkspaceMembersRequestMembers()
                self.members.append(temp_model.from_map(k))
        if m.get('TenantContext') is not None:
            temp_model = DeleteWorkspaceMembersRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DeleteWorkspaceMembersShrinkRequest(TeaModel):
    def __init__(
        self,
        members_shrink: str = None,
        tenant_context_shrink: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.members_shrink = members_shrink
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.members_shrink is not None:
            result['Members'] = self.members_shrink
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Members') is not None:
            self.members_shrink = m.get('Members')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DeleteWorkspaceMembersResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteWorkspaceMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteWorkspaceMembersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteWorkspaceMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DocBlocksQueryHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DocBlocksQueryHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DocBlocksQueryHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DocBlocksQueryHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DocBlocksQueryShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DocBlocksQueryRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class DocBlocksQueryRequest(TeaModel):
    def __init__(
        self,
        block_type: str = None,
        doc_key: str = None,
        end_index: int = None,
        start_index: int = None,
        tenant_context: DocBlocksQueryRequestTenantContext = None,
    ):
        self.block_type = block_type
        # This parameter is required.
        self.doc_key = doc_key
        self.end_index = end_index
        self.start_index = start_index
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_type is not None:
            result['BlockType'] = self.block_type
        if self.doc_key is not None:
            result['DocKey'] = self.doc_key
        if self.end_index is not None:
            result['EndIndex'] = self.end_index
        if self.start_index is not None:
            result['StartIndex'] = self.start_index
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BlockType') is not None:
            self.block_type = m.get('BlockType')
        if m.get('DocKey') is not None:
            self.doc_key = m.get('DocKey')
        if m.get('EndIndex') is not None:
            self.end_index = m.get('EndIndex')
        if m.get('StartIndex') is not None:
            self.start_index = m.get('StartIndex')
        if m.get('TenantContext') is not None:
            temp_model = DocBlocksQueryRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class DocBlocksQueryShrinkRequest(TeaModel):
    def __init__(
        self,
        block_type: str = None,
        doc_key: str = None,
        end_index: int = None,
        start_index: int = None,
        tenant_context_shrink: str = None,
    ):
        self.block_type = block_type
        # This parameter is required.
        self.doc_key = doc_key
        self.end_index = end_index
        self.start_index = start_index
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_type is not None:
            result['BlockType'] = self.block_type
        if self.doc_key is not None:
            result['DocKey'] = self.doc_key
        if self.end_index is not None:
            result['EndIndex'] = self.end_index
        if self.start_index is not None:
            result['StartIndex'] = self.start_index
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BlockType') is not None:
            self.block_type = m.get('BlockType')
        if m.get('DocKey') is not None:
            self.doc_key = m.get('DocKey')
        if m.get('EndIndex') is not None:
            self.end_index = m.get('EndIndex')
        if m.get('StartIndex') is not None:
            self.start_index = m.get('StartIndex')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class DocBlocksQueryResponseBodyResult(TeaModel):
    def __init__(
        self,
        data: List[Any] = None,
    ):
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        return self


class DocBlocksQueryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: DocBlocksQueryResponseBodyResult = None,
        success: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.result = result
        self.success = success
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = DocBlocksQueryResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class DocBlocksQueryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DocBlocksQueryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DocBlocksQueryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DocUpdateContentHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class DocUpdateContentHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: DocUpdateContentHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = DocUpdateContentHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class DocUpdateContentShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class DocUpdateContentRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class DocUpdateContentRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        data_type: str = None,
        doc_key: str = None,
        tenant_context: DocUpdateContentRequestTenantContext = None,
    ):
        # This parameter is required.
        self.content = content
        self.data_type = data_type
        # This parameter is required.
        self.doc_key = doc_key
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.doc_key is not None:
            result['DocKey'] = self.doc_key
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('DocKey') is not None:
            self.doc_key = m.get('DocKey')
        if m.get('TenantContext') is not None:
            temp_model = DocUpdateContentRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class DocUpdateContentShrinkRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        data_type: str = None,
        doc_key: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.content = content
        self.data_type = data_type
        # This parameter is required.
        self.doc_key = doc_key
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.doc_key is not None:
            result['DocKey'] = self.doc_key
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('DocKey') is not None:
            self.doc_key = m.get('DocKey')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class DocUpdateContentResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        value: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.value = value
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.value is not None:
            result['value'] = self.value
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class DocUpdateContentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DocUpdateContentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DocUpdateContentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecuteBatchTaskHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ExecuteBatchTaskHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ExecuteBatchTaskHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ExecuteBatchTaskHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ExecuteBatchTaskShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ExecuteBatchTaskRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        out_result: str = None,
        remark: str = None,
        system_token: str = None,
        task_information_list: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        # This parameter is required.
        self.out_result = out_result
        self.remark = remark
        # This parameter is required.
        self.system_token = system_token
        # This parameter is required.
        self.task_information_list = task_information_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.out_result is not None:
            result['OutResult'] = self.out_result
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        if self.task_information_list is not None:
            result['TaskInformationList'] = self.task_information_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('OutResult') is not None:
            self.out_result = m.get('OutResult')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        if m.get('TaskInformationList') is not None:
            self.task_information_list = m.get('TaskInformationList')
        return self


class ExecuteBatchTaskResponseBody(TeaModel):
    def __init__(
        self,
        fail_number: int = None,
        request_id: str = None,
        success_number: int = None,
        total: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.fail_number = fail_number
        self.request_id = request_id
        self.success_number = success_number
        self.total = total
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fail_number is not None:
            result['failNumber'] = self.fail_number
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success_number is not None:
            result['successNumber'] = self.success_number
        if self.total is not None:
            result['total'] = self.total
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('failNumber') is not None:
            self.fail_number = m.get('failNumber')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('successNumber') is not None:
            self.success_number = m.get('successNumber')
        if m.get('total') is not None:
            self.total = m.get('total')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class ExecuteBatchTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExecuteBatchTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecuteBatchTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecutePlatformTaskHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ExecutePlatformTaskHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ExecutePlatformTaskHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ExecutePlatformTaskHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ExecutePlatformTaskShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ExecutePlatformTaskRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        form_data_json: str = None,
        language: str = None,
        no_execute_expressions: str = None,
        out_result: str = None,
        process_instance_id: str = None,
        remark: str = None,
        system_token: str = None,
    ):
        self.app_type = app_type
        self.form_data_json = form_data_json
        self.language = language
        self.no_execute_expressions = no_execute_expressions
        self.out_result = out_result
        self.process_instance_id = process_instance_id
        self.remark = remark
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.form_data_json is not None:
            result['FormDataJson'] = self.form_data_json
        if self.language is not None:
            result['Language'] = self.language
        if self.no_execute_expressions is not None:
            result['NoExecuteExpressions'] = self.no_execute_expressions
        if self.out_result is not None:
            result['OutResult'] = self.out_result
        if self.process_instance_id is not None:
            result['ProcessInstanceId'] = self.process_instance_id
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('FormDataJson') is not None:
            self.form_data_json = m.get('FormDataJson')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('NoExecuteExpressions') is not None:
            self.no_execute_expressions = m.get('NoExecuteExpressions')
        if m.get('OutResult') is not None:
            self.out_result = m.get('OutResult')
        if m.get('ProcessInstanceId') is not None:
            self.process_instance_id = m.get('ProcessInstanceId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class ExecutePlatformTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class ExecutePlatformTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExecutePlatformTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecutePlatformTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecuteTaskHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ExecuteTaskHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ExecuteTaskHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ExecuteTaskHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ExecuteTaskShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ExecuteTaskRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        digital_sign_url: str = None,
        form_data_json: str = None,
        language: str = None,
        no_execute_expressions: str = None,
        out_result: str = None,
        process_instance_id: str = None,
        remark: str = None,
        system_token: str = None,
        task_id: int = None,
    ):
        self.app_type = app_type
        self.digital_sign_url = digital_sign_url
        self.form_data_json = form_data_json
        self.language = language
        self.no_execute_expressions = no_execute_expressions
        self.out_result = out_result
        self.process_instance_id = process_instance_id
        self.remark = remark
        self.system_token = system_token
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.digital_sign_url is not None:
            result['DigitalSignUrl'] = self.digital_sign_url
        if self.form_data_json is not None:
            result['FormDataJson'] = self.form_data_json
        if self.language is not None:
            result['Language'] = self.language
        if self.no_execute_expressions is not None:
            result['NoExecuteExpressions'] = self.no_execute_expressions
        if self.out_result is not None:
            result['OutResult'] = self.out_result
        if self.process_instance_id is not None:
            result['ProcessInstanceId'] = self.process_instance_id
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('DigitalSignUrl') is not None:
            self.digital_sign_url = m.get('DigitalSignUrl')
        if m.get('FormDataJson') is not None:
            self.form_data_json = m.get('FormDataJson')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('NoExecuteExpressions') is not None:
            self.no_execute_expressions = m.get('NoExecuteExpressions')
        if m.get('OutResult') is not None:
            self.out_result = m.get('OutResult')
        if m.get('ProcessInstanceId') is not None:
            self.process_instance_id = m.get('ProcessInstanceId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ExecuteTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class ExecuteTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExecuteTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecuteTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExpandGroupCapacityHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ExpandGroupCapacityHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ExpandGroupCapacityHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ExpandGroupCapacityHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ExpandGroupCapacityShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ExpandGroupCapacityRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class ExpandGroupCapacityRequest(TeaModel):
    def __init__(
        self,
        open_conversation_id: str = None,
        tenant_context: ExpandGroupCapacityRequestTenantContext = None,
    ):
        # This parameter is required.
        self.open_conversation_id = open_conversation_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.open_conversation_id is not None:
            result['OpenConversationId'] = self.open_conversation_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OpenConversationId') is not None:
            self.open_conversation_id = m.get('OpenConversationId')
        if m.get('TenantContext') is not None:
            temp_model = ExpandGroupCapacityRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class ExpandGroupCapacityShrinkRequest(TeaModel):
    def __init__(
        self,
        open_conversation_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.open_conversation_id = open_conversation_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.open_conversation_id is not None:
            result['OpenConversationId'] = self.open_conversation_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OpenConversationId') is not None:
            self.open_conversation_id = m.get('OpenConversationId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class ExpandGroupCapacityResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.success = success
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class ExpandGroupCapacityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExpandGroupCapacityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExpandGroupCapacityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class FinishTicketHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class FinishTicketHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: FinishTicketHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = FinishTicketHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class FinishTicketShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class FinishTicketRequestNotify(TeaModel):
    def __init__(
        self,
        group_notice_receiver_user_ids: List[str] = None,
        notice_all_group_member: bool = None,
        work_notice_receiver_user_ids: List[str] = None,
    ):
        self.group_notice_receiver_user_ids = group_notice_receiver_user_ids
        self.notice_all_group_member = notice_all_group_member
        self.work_notice_receiver_user_ids = work_notice_receiver_user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_notice_receiver_user_ids is not None:
            result['GroupNoticeReceiverUserIds'] = self.group_notice_receiver_user_ids
        if self.notice_all_group_member is not None:
            result['NoticeAllGroupMember'] = self.notice_all_group_member
        if self.work_notice_receiver_user_ids is not None:
            result['WorkNoticeReceiverUserIds'] = self.work_notice_receiver_user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupNoticeReceiverUserIds') is not None:
            self.group_notice_receiver_user_ids = m.get('GroupNoticeReceiverUserIds')
        if m.get('NoticeAllGroupMember') is not None:
            self.notice_all_group_member = m.get('NoticeAllGroupMember')
        if m.get('WorkNoticeReceiverUserIds') is not None:
            self.work_notice_receiver_user_ids = m.get('WorkNoticeReceiverUserIds')
        return self


class FinishTicketRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class FinishTicketRequestTicketMemoAttachments(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        key: str = None,
    ):
        self.file_name = file_name
        self.key = key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.key is not None:
            result['Key'] = self.key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        return self


class FinishTicketRequestTicketMemo(TeaModel):
    def __init__(
        self,
        attachments: List[FinishTicketRequestTicketMemoAttachments] = None,
        memo: str = None,
    ):
        self.attachments = attachments
        self.memo = memo

    def validate(self):
        if self.attachments:
            for k in self.attachments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Attachments'] = []
        if self.attachments is not None:
            for k in self.attachments:
                result['Attachments'].append(k.to_map() if k else None)
        if self.memo is not None:
            result['Memo'] = self.memo
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attachments = []
        if m.get('Attachments') is not None:
            for k in m.get('Attachments'):
                temp_model = FinishTicketRequestTicketMemoAttachments()
                self.attachments.append(temp_model.from_map(k))
        if m.get('Memo') is not None:
            self.memo = m.get('Memo')
        return self


class FinishTicketRequest(TeaModel):
    def __init__(
        self,
        notify: FinishTicketRequestNotify = None,
        open_team_id: str = None,
        open_ticket_id: str = None,
        tenant_context: FinishTicketRequestTenantContext = None,
        ticket_memo: FinishTicketRequestTicketMemo = None,
    ):
        self.notify = notify
        # This parameter is required.
        self.open_team_id = open_team_id
        # This parameter is required.
        self.open_ticket_id = open_ticket_id
        self.tenant_context = tenant_context
        self.ticket_memo = ticket_memo

    def validate(self):
        if self.notify:
            self.notify.validate()
        if self.tenant_context:
            self.tenant_context.validate()
        if self.ticket_memo:
            self.ticket_memo.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notify is not None:
            result['Notify'] = self.notify.to_map()
        if self.open_team_id is not None:
            result['OpenTeamId'] = self.open_team_id
        if self.open_ticket_id is not None:
            result['OpenTicketId'] = self.open_ticket_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.ticket_memo is not None:
            result['TicketMemo'] = self.ticket_memo.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Notify') is not None:
            temp_model = FinishTicketRequestNotify()
            self.notify = temp_model.from_map(m['Notify'])
        if m.get('OpenTeamId') is not None:
            self.open_team_id = m.get('OpenTeamId')
        if m.get('OpenTicketId') is not None:
            self.open_ticket_id = m.get('OpenTicketId')
        if m.get('TenantContext') is not None:
            temp_model = FinishTicketRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('TicketMemo') is not None:
            temp_model = FinishTicketRequestTicketMemo()
            self.ticket_memo = temp_model.from_map(m['TicketMemo'])
        return self


class FinishTicketShrinkRequest(TeaModel):
    def __init__(
        self,
        notify_shrink: str = None,
        open_team_id: str = None,
        open_ticket_id: str = None,
        tenant_context_shrink: str = None,
        ticket_memo_shrink: str = None,
    ):
        self.notify_shrink = notify_shrink
        # This parameter is required.
        self.open_team_id = open_team_id
        # This parameter is required.
        self.open_ticket_id = open_ticket_id
        self.tenant_context_shrink = tenant_context_shrink
        self.ticket_memo_shrink = ticket_memo_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notify_shrink is not None:
            result['Notify'] = self.notify_shrink
        if self.open_team_id is not None:
            result['OpenTeamId'] = self.open_team_id
        if self.open_ticket_id is not None:
            result['OpenTicketId'] = self.open_ticket_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.ticket_memo_shrink is not None:
            result['TicketMemo'] = self.ticket_memo_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Notify') is not None:
            self.notify_shrink = m.get('Notify')
        if m.get('OpenTeamId') is not None:
            self.open_team_id = m.get('OpenTeamId')
        if m.get('OpenTicketId') is not None:
            self.open_ticket_id = m.get('OpenTicketId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('TicketMemo') is not None:
            self.ticket_memo_shrink = m.get('TicketMemo')
        return self


class FinishTicketResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class FinishTicketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: FinishTicketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = FinishTicketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetActivityListHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetActivityListHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetActivityListHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetActivityListHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetActivityListShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetActivityListRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        language: str = None,
        process_code: str = None,
        system_token: str = None,
    ):
        self.app_type = app_type
        self.language = language
        self.process_code = process_code
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.language is not None:
            result['Language'] = self.language
        if self.process_code is not None:
            result['ProcessCode'] = self.process_code
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('ProcessCode') is not None:
            self.process_code = m.get('ProcessCode')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class GetActivityListResponseBodyResult(TeaModel):
    def __init__(
        self,
        activity_id: str = None,
        activity_name: str = None,
        activity_name_in_english: str = None,
    ):
        self.activity_id = activity_id
        self.activity_name = activity_name
        self.activity_name_in_english = activity_name_in_english

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_id is not None:
            result['ActivityId'] = self.activity_id
        if self.activity_name is not None:
            result['ActivityName'] = self.activity_name
        if self.activity_name_in_english is not None:
            result['ActivityNameInEnglish'] = self.activity_name_in_english
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityId') is not None:
            self.activity_id = m.get('ActivityId')
        if m.get('ActivityName') is not None:
            self.activity_name = m.get('ActivityName')
        if m.get('ActivityNameInEnglish') is not None:
            self.activity_name_in_english = m.get('ActivityNameInEnglish')
        return self


class GetActivityListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: List[GetActivityListResponseBodyResult] = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.result = result
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = GetActivityListResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetActivityListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetActivityListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetActivityListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAllSheetsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetAllSheetsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetAllSheetsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetAllSheetsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetAllSheetsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetAllSheetsRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetAllSheetsRequest(TeaModel):
    def __init__(
        self,
        tenant_context: GetAllSheetsRequestTenantContext = None,
        workbook_id: str = None,
    ):
        self.tenant_context = tenant_context
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = GetAllSheetsRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class GetAllSheetsShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        workbook_id: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class GetAllSheetsResponseBodyValue(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
    ):
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GetAllSheetsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        value: List[GetAllSheetsResponseBodyValue] = None,
    ):
        # requestId
        self.request_id = request_id
        self.value = value

    def validate(self):
        if self.value:
            for k in self.value:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['value'] = []
        if self.value is not None:
            for k in self.value:
                result['value'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.value = []
        if m.get('value') is not None:
            for k in m.get('value'):
                temp_model = GetAllSheetsResponseBodyValue()
                self.value.append(temp_model.from_map(k))
        return self


class GetAllSheetsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAllSheetsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAllSheetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAssistantCapabilityHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_id: str = None,
    ):
        self.common_headers = common_headers
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetAssistantCapabilityRequestMessagesContentCardCallback(TeaModel):
    def __init__(
        self,
        content: str = None,
        related_message_id: str = None,
    ):
        # This parameter is required.
        self.content = content
        # This parameter is required.
        self.related_message_id = related_message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.related_message_id is not None:
            result['relatedMessageId'] = self.related_message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('relatedMessageId') is not None:
            self.related_message_id = m.get('relatedMessageId')
        return self


class GetAssistantCapabilityRequestMessagesContentDingCard(TeaModel):
    def __init__(
        self,
        content: str = None,
        content_type: str = None,
        finished: bool = None,
        template_id: str = None,
    ):
        self.content = content
        # This parameter is required.
        self.content_type = content_type
        self.finished = finished
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.content_type is not None:
            result['contentType'] = self.content_type
        if self.finished is not None:
            result['finished'] = self.finished
        if self.template_id is not None:
            result['templateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('contentType') is not None:
            self.content_type = m.get('contentType')
        if m.get('finished') is not None:
            self.finished = m.get('finished')
        if m.get('templateId') is not None:
            self.template_id = m.get('templateId')
        return self


class GetAssistantCapabilityRequestMessagesContentDingNormalCardCardData(TeaModel):
    def __init__(
        self,
        card_param_map: Any = None,
    ):
        self.card_param_map = card_param_map

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_param_map is not None:
            result['cardParamMap'] = self.card_param_map
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardParamMap') is not None:
            self.card_param_map = m.get('cardParamMap')
        return self


class GetAssistantCapabilityRequestMessagesContentDingNormalCardCardUpdateOptions(TeaModel):
    def __init__(
        self,
        update_card_data_by_key: bool = None,
        update_private_data_by_key: bool = None,
    ):
        self.update_card_data_by_key = update_card_data_by_key
        self.update_private_data_by_key = update_private_data_by_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.update_card_data_by_key is not None:
            result['updateCardDataByKey'] = self.update_card_data_by_key
        if self.update_private_data_by_key is not None:
            result['updatePrivateDataByKey'] = self.update_private_data_by_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('updateCardDataByKey') is not None:
            self.update_card_data_by_key = m.get('updateCardDataByKey')
        if m.get('updatePrivateDataByKey') is not None:
            self.update_private_data_by_key = m.get('updatePrivateDataByKey')
        return self


class GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig(TeaModel):
    def __init__(
        self,
        interval: int = None,
        pull_strategy: str = None,
        time_unit: str = None,
    ):
        self.interval = interval
        self.pull_strategy = pull_strategy
        self.time_unit = time_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interval is not None:
            result['interval'] = self.interval
        if self.pull_strategy is not None:
            result['pullStrategy'] = self.pull_strategy
        if self.time_unit is not None:
            result['timeUnit'] = self.time_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('pullStrategy') is not None:
            self.pull_strategy = m.get('pullStrategy')
        if m.get('timeUnit') is not None:
            self.time_unit = m.get('timeUnit')
        return self


class GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigs(TeaModel):
    def __init__(
        self,
        const_params: Dict[str, Any] = None,
        dynamic_data_source_id: str = None,
        pull_config: GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig = None,
    ):
        self.const_params = const_params
        self.dynamic_data_source_id = dynamic_data_source_id
        self.pull_config = pull_config

    def validate(self):
        if self.pull_config:
            self.pull_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.const_params is not None:
            result['constParams'] = self.const_params
        if self.dynamic_data_source_id is not None:
            result['dynamicDataSourceId'] = self.dynamic_data_source_id
        if self.pull_config is not None:
            result['pullConfig'] = self.pull_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('constParams') is not None:
            self.const_params = m.get('constParams')
        if m.get('dynamicDataSourceId') is not None:
            self.dynamic_data_source_id = m.get('dynamicDataSourceId')
        if m.get('pullConfig') is not None:
            temp_model = GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig()
            self.pull_config = temp_model.from_map(m['pullConfig'])
        return self


class GetAssistantCapabilityRequestMessagesContentDingNormalCard(TeaModel):
    def __init__(
        self,
        card_data: GetAssistantCapabilityRequestMessagesContentDingNormalCardCardData = None,
        card_template_id: str = None,
        card_update_options: GetAssistantCapabilityRequestMessagesContentDingNormalCardCardUpdateOptions = None,
        dynamic_data_source_configs: List[GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigs] = None,
        private_data: Dict[str, Any] = None,
    ):
        self.card_data = card_data
        self.card_template_id = card_template_id
        self.card_update_options = card_update_options
        self.dynamic_data_source_configs = dynamic_data_source_configs
        self.private_data = private_data

    def validate(self):
        if self.card_data:
            self.card_data.validate()
        if self.card_update_options:
            self.card_update_options.validate()
        if self.dynamic_data_source_configs:
            for k in self.dynamic_data_source_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_data is not None:
            result['cardData'] = self.card_data.to_map()
        if self.card_template_id is not None:
            result['cardTemplateId'] = self.card_template_id
        if self.card_update_options is not None:
            result['cardUpdateOptions'] = self.card_update_options.to_map()
        result['dynamicDataSourceConfigs'] = []
        if self.dynamic_data_source_configs is not None:
            for k in self.dynamic_data_source_configs:
                result['dynamicDataSourceConfigs'].append(k.to_map() if k else None)
        if self.private_data is not None:
            result['privateData'] = self.private_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardData') is not None:
            temp_model = GetAssistantCapabilityRequestMessagesContentDingNormalCardCardData()
            self.card_data = temp_model.from_map(m['cardData'])
        if m.get('cardTemplateId') is not None:
            self.card_template_id = m.get('cardTemplateId')
        if m.get('cardUpdateOptions') is not None:
            temp_model = GetAssistantCapabilityRequestMessagesContentDingNormalCardCardUpdateOptions()
            self.card_update_options = temp_model.from_map(m['cardUpdateOptions'])
        self.dynamic_data_source_configs = []
        if m.get('dynamicDataSourceConfigs') is not None:
            for k in m.get('dynamicDataSourceConfigs'):
                temp_model = GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigs()
                self.dynamic_data_source_configs.append(temp_model.from_map(k))
        if m.get('privateData') is not None:
            self.private_data = m.get('privateData')
        return self


class GetAssistantCapabilityRequestMessagesContentMarkdown(TeaModel):
    def __init__(
        self,
        value: str = None,
    ):
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class GetAssistantCapabilityRequestMessagesContentStructViewPartsDataPart(TeaModel):
    def __init__(
        self,
        data: Any = None,
    ):
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class GetAssistantCapabilityRequestMessagesContentStructViewPartsReasonPart(TeaModel):
    def __init__(
        self,
        reason: str = None,
    ):
        self.reason = reason

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reason is not None:
            result['reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        return self


class GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPartRecommends(TeaModel):
    def __init__(
        self,
        mobile_url: str = None,
        text: str = None,
        url: str = None,
    ):
        self.mobile_url = mobile_url
        self.text = text
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mobile_url is not None:
            result['mobileUrl'] = self.mobile_url
        if self.text is not None:
            result['text'] = self.text
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('mobileUrl') is not None:
            self.mobile_url = m.get('mobileUrl')
        if m.get('text') is not None:
            self.text = m.get('text')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPart(TeaModel):
    def __init__(
        self,
        recommends: List[GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPartRecommends] = None,
    ):
        self.recommends = recommends

    def validate(self):
        if self.recommends:
            for k in self.recommends:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['recommends'] = []
        if self.recommends is not None:
            for k in self.recommends:
                result['recommends'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.recommends = []
        if m.get('recommends') is not None:
            for k in m.get('recommends'):
                temp_model = GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPartRecommends()
                self.recommends.append(temp_model.from_map(k))
        return self


class GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePartReferences(TeaModel):
    def __init__(
        self,
        index: str = None,
        name: str = None,
        source_code: str = None,
        source_icon: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.index = index
        self.name = name
        self.source_code = source_code
        self.source_icon = source_icon
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['index'] = self.index
        if self.name is not None:
            result['name'] = self.name
        if self.source_code is not None:
            result['sourceCode'] = self.source_code
        if self.source_icon is not None:
            result['sourceIcon'] = self.source_icon
        if self.summary is not None:
            result['summary'] = self.summary
        if self.title is not None:
            result['title'] = self.title
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('sourceCode') is not None:
            self.source_code = m.get('sourceCode')
        if m.get('sourceIcon') is not None:
            self.source_icon = m.get('sourceIcon')
        if m.get('summary') is not None:
            self.summary = m.get('summary')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePart(TeaModel):
    def __init__(
        self,
        references: List[GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePartReferences] = None,
    ):
        self.references = references

    def validate(self):
        if self.references:
            for k in self.references:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['references'] = []
        if self.references is not None:
            for k in self.references:
                result['references'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.references = []
        if m.get('references') is not None:
            for k in m.get('references'):
                temp_model = GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePartReferences()
                self.references.append(temp_model.from_map(k))
        return self


class GetAssistantCapabilityRequestMessagesContentStructViewPartsTextPart(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('text') is not None:
            self.text = m.get('text')
        return self


class GetAssistantCapabilityRequestMessagesContentStructViewParts(TeaModel):
    def __init__(
        self,
        append: bool = None,
        data_part: GetAssistantCapabilityRequestMessagesContentStructViewPartsDataPart = None,
        finish: bool = None,
        part_desc: str = None,
        part_id: str = None,
        reason_part: GetAssistantCapabilityRequestMessagesContentStructViewPartsReasonPart = None,
        recommend_part: GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPart = None,
        reference_part: GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePart = None,
        text_part: GetAssistantCapabilityRequestMessagesContentStructViewPartsTextPart = None,
        type: str = None,
    ):
        self.append = append
        self.data_part = data_part
        self.finish = finish
        self.part_desc = part_desc
        self.part_id = part_id
        self.reason_part = reason_part
        self.recommend_part = recommend_part
        self.reference_part = reference_part
        self.text_part = text_part
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.data_part:
            self.data_part.validate()
        if self.reason_part:
            self.reason_part.validate()
        if self.recommend_part:
            self.recommend_part.validate()
        if self.reference_part:
            self.reference_part.validate()
        if self.text_part:
            self.text_part.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.append is not None:
            result['append'] = self.append
        if self.data_part is not None:
            result['dataPart'] = self.data_part.to_map()
        if self.finish is not None:
            result['finish'] = self.finish
        if self.part_desc is not None:
            result['partDesc'] = self.part_desc
        if self.part_id is not None:
            result['partId'] = self.part_id
        if self.reason_part is not None:
            result['reasonPart'] = self.reason_part.to_map()
        if self.recommend_part is not None:
            result['recommendPart'] = self.recommend_part.to_map()
        if self.reference_part is not None:
            result['referencePart'] = self.reference_part.to_map()
        if self.text_part is not None:
            result['textPart'] = self.text_part.to_map()
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('append') is not None:
            self.append = m.get('append')
        if m.get('dataPart') is not None:
            temp_model = GetAssistantCapabilityRequestMessagesContentStructViewPartsDataPart()
            self.data_part = temp_model.from_map(m['dataPart'])
        if m.get('finish') is not None:
            self.finish = m.get('finish')
        if m.get('partDesc') is not None:
            self.part_desc = m.get('partDesc')
        if m.get('partId') is not None:
            self.part_id = m.get('partId')
        if m.get('reasonPart') is not None:
            temp_model = GetAssistantCapabilityRequestMessagesContentStructViewPartsReasonPart()
            self.reason_part = temp_model.from_map(m['reasonPart'])
        if m.get('recommendPart') is not None:
            temp_model = GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPart()
            self.recommend_part = temp_model.from_map(m['recommendPart'])
        if m.get('referencePart') is not None:
            temp_model = GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePart()
            self.reference_part = temp_model.from_map(m['referencePart'])
        if m.get('textPart') is not None:
            temp_model = GetAssistantCapabilityRequestMessagesContentStructViewPartsTextPart()
            self.text_part = temp_model.from_map(m['textPart'])
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GetAssistantCapabilityRequestMessagesContentStructView(TeaModel):
    def __init__(
        self,
        parts: List[GetAssistantCapabilityRequestMessagesContentStructViewParts] = None,
    ):
        self.parts = parts

    def validate(self):
        if self.parts:
            for k in self.parts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['parts'] = []
        if self.parts is not None:
            for k in self.parts:
                result['parts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.parts = []
        if m.get('parts') is not None:
            for k in m.get('parts'):
                temp_model = GetAssistantCapabilityRequestMessagesContentStructViewParts()
                self.parts.append(temp_model.from_map(k))
        return self


class GetAssistantCapabilityRequestMessagesContentText(TeaModel):
    def __init__(
        self,
        value: str = None,
    ):
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class GetAssistantCapabilityRequestMessagesContent(TeaModel):
    def __init__(
        self,
        card_callback: GetAssistantCapabilityRequestMessagesContentCardCallback = None,
        ding_card: GetAssistantCapabilityRequestMessagesContentDingCard = None,
        ding_normal_card: GetAssistantCapabilityRequestMessagesContentDingNormalCard = None,
        markdown: GetAssistantCapabilityRequestMessagesContentMarkdown = None,
        struct_view: GetAssistantCapabilityRequestMessagesContentStructView = None,
        text: GetAssistantCapabilityRequestMessagesContentText = None,
        type: str = None,
    ):
        self.card_callback = card_callback
        self.ding_card = ding_card
        self.ding_normal_card = ding_normal_card
        self.markdown = markdown
        self.struct_view = struct_view
        self.text = text
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.card_callback:
            self.card_callback.validate()
        if self.ding_card:
            self.ding_card.validate()
        if self.ding_normal_card:
            self.ding_normal_card.validate()
        if self.markdown:
            self.markdown.validate()
        if self.struct_view:
            self.struct_view.validate()
        if self.text:
            self.text.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_callback is not None:
            result['cardCallback'] = self.card_callback.to_map()
        if self.ding_card is not None:
            result['dingCard'] = self.ding_card.to_map()
        if self.ding_normal_card is not None:
            result['dingNormalCard'] = self.ding_normal_card.to_map()
        if self.markdown is not None:
            result['markdown'] = self.markdown.to_map()
        if self.struct_view is not None:
            result['structView'] = self.struct_view.to_map()
        if self.text is not None:
            result['text'] = self.text.to_map()
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardCallback') is not None:
            temp_model = GetAssistantCapabilityRequestMessagesContentCardCallback()
            self.card_callback = temp_model.from_map(m['cardCallback'])
        if m.get('dingCard') is not None:
            temp_model = GetAssistantCapabilityRequestMessagesContentDingCard()
            self.ding_card = temp_model.from_map(m['dingCard'])
        if m.get('dingNormalCard') is not None:
            temp_model = GetAssistantCapabilityRequestMessagesContentDingNormalCard()
            self.ding_normal_card = temp_model.from_map(m['dingNormalCard'])
        if m.get('markdown') is not None:
            temp_model = GetAssistantCapabilityRequestMessagesContentMarkdown()
            self.markdown = temp_model.from_map(m['markdown'])
        if m.get('structView') is not None:
            temp_model = GetAssistantCapabilityRequestMessagesContentStructView()
            self.struct_view = temp_model.from_map(m['structView'])
        if m.get('text') is not None:
            temp_model = GetAssistantCapabilityRequestMessagesContentText()
            self.text = temp_model.from_map(m['text'])
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GetAssistantCapabilityRequestMessages(TeaModel):
    def __init__(
        self,
        content: GetAssistantCapabilityRequestMessagesContent = None,
        content_desc: str = None,
        create_at: int = None,
        role: str = None,
    ):
        self.content = content
        self.content_desc = content_desc
        self.create_at = create_at
        self.role = role

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content.to_map()
        if self.content_desc is not None:
            result['contentDesc'] = self.content_desc
        if self.create_at is not None:
            result['createAt'] = self.create_at
        if self.role is not None:
            result['role'] = self.role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            temp_model = GetAssistantCapabilityRequestMessagesContent()
            self.content = temp_model.from_map(m['content'])
        if m.get('contentDesc') is not None:
            self.content_desc = m.get('contentDesc')
        if m.get('createAt') is not None:
            self.create_at = m.get('createAt')
        if m.get('role') is not None:
            self.role = m.get('role')
        return self


class GetAssistantCapabilityRequest(TeaModel):
    def __init__(
        self,
        assistant_id: str = None,
        messages: List[GetAssistantCapabilityRequestMessages] = None,
        original_assistant_id: str = None,
        protocol: str = None,
        source_id_of_original_assistant_id: str = None,
        source_type_of_original_assistant_id: str = None,
        thread_id: str = None,
        timeout: int = None,
    ):
        # This parameter is required.
        self.assistant_id = assistant_id
        # This parameter is required.
        self.messages = messages
        self.original_assistant_id = original_assistant_id
        self.protocol = protocol
        self.source_id_of_original_assistant_id = source_id_of_original_assistant_id
        self.source_type_of_original_assistant_id = source_type_of_original_assistant_id
        self.thread_id = thread_id
        self.timeout = timeout

    def validate(self):
        if self.messages:
            for k in self.messages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assistant_id is not None:
            result['assistantId'] = self.assistant_id
        result['messages'] = []
        if self.messages is not None:
            for k in self.messages:
                result['messages'].append(k.to_map() if k else None)
        if self.original_assistant_id is not None:
            result['originalAssistantId'] = self.original_assistant_id
        if self.protocol is not None:
            result['protocol'] = self.protocol
        if self.source_id_of_original_assistant_id is not None:
            result['sourceIdOfOriginalAssistantId'] = self.source_id_of_original_assistant_id
        if self.source_type_of_original_assistant_id is not None:
            result['sourceTypeOfOriginalAssistantId'] = self.source_type_of_original_assistant_id
        if self.thread_id is not None:
            result['threadId'] = self.thread_id
        if self.timeout is not None:
            result['timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assistantId') is not None:
            self.assistant_id = m.get('assistantId')
        self.messages = []
        if m.get('messages') is not None:
            for k in m.get('messages'):
                temp_model = GetAssistantCapabilityRequestMessages()
                self.messages.append(temp_model.from_map(k))
        if m.get('originalAssistantId') is not None:
            self.original_assistant_id = m.get('originalAssistantId')
        if m.get('protocol') is not None:
            self.protocol = m.get('protocol')
        if m.get('sourceIdOfOriginalAssistantId') is not None:
            self.source_id_of_original_assistant_id = m.get('sourceIdOfOriginalAssistantId')
        if m.get('sourceTypeOfOriginalAssistantId') is not None:
            self.source_type_of_original_assistant_id = m.get('sourceTypeOfOriginalAssistantId')
        if m.get('threadId') is not None:
            self.thread_id = m.get('threadId')
        if m.get('timeout') is not None:
            self.timeout = m.get('timeout')
        return self


class GetAssistantCapabilityResponseBodyCapabilityAssessmentCapabilityList(TeaModel):
    def __init__(
        self,
        capability_overview: str = None,
        description: str = None,
        name: str = None,
    ):
        self.capability_overview = capability_overview
        self.description = description
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.capability_overview is not None:
            result['capabilityOverview'] = self.capability_overview
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('capabilityOverview') is not None:
            self.capability_overview = m.get('capabilityOverview')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetAssistantCapabilityResponseBodyCapabilityAssessment(TeaModel):
    def __init__(
        self,
        brief_capability: str = None,
        capability_list: List[GetAssistantCapabilityResponseBodyCapabilityAssessmentCapabilityList] = None,
    ):
        self.brief_capability = brief_capability
        self.capability_list = capability_list

    def validate(self):
        if self.capability_list:
            for k in self.capability_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.brief_capability is not None:
            result['briefCapability'] = self.brief_capability
        result['capabilityList'] = []
        if self.capability_list is not None:
            for k in self.capability_list:
                result['capabilityList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('briefCapability') is not None:
            self.brief_capability = m.get('briefCapability')
        self.capability_list = []
        if m.get('capabilityList') is not None:
            for k in m.get('capabilityList'):
                temp_model = GetAssistantCapabilityResponseBodyCapabilityAssessmentCapabilityList()
                self.capability_list.append(temp_model.from_map(k))
        return self


class GetAssistantCapabilityResponseBody(TeaModel):
    def __init__(
        self,
        assistant_description: str = None,
        can_handle: bool = None,
        capability_assessment: GetAssistantCapabilityResponseBodyCapabilityAssessment = None,
        request_id: str = None,
    ):
        self.assistant_description = assistant_description
        self.can_handle = can_handle
        self.capability_assessment = capability_assessment
        self.request_id = request_id

    def validate(self):
        if self.capability_assessment:
            self.capability_assessment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assistant_description is not None:
            result['assistantDescription'] = self.assistant_description
        if self.can_handle is not None:
            result['canHandle'] = self.can_handle
        if self.capability_assessment is not None:
            result['capabilityAssessment'] = self.capability_assessment.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assistantDescription') is not None:
            self.assistant_description = m.get('assistantDescription')
        if m.get('canHandle') is not None:
            self.can_handle = m.get('canHandle')
        if m.get('capabilityAssessment') is not None:
            temp_model = GetAssistantCapabilityResponseBodyCapabilityAssessment()
            self.capability_assessment = temp_model.from_map(m['capabilityAssessment'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetAssistantCapabilityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAssistantCapabilityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAssistantCapabilityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetConversaionSpaceHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetConversaionSpaceHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetConversaionSpaceHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetConversaionSpaceHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetConversaionSpaceShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetConversaionSpaceRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetConversaionSpaceRequest(TeaModel):
    def __init__(
        self,
        open_conversation_id: str = None,
        tenant_context: GetConversaionSpaceRequestTenantContext = None,
    ):
        # This parameter is required.
        self.open_conversation_id = open_conversation_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.open_conversation_id is not None:
            result['OpenConversationId'] = self.open_conversation_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OpenConversationId') is not None:
            self.open_conversation_id = m.get('OpenConversationId')
        if m.get('TenantContext') is not None:
            temp_model = GetConversaionSpaceRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetConversaionSpaceShrinkRequest(TeaModel):
    def __init__(
        self,
        open_conversation_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.open_conversation_id = open_conversation_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.open_conversation_id is not None:
            result['OpenConversationId'] = self.open_conversation_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OpenConversationId') is not None:
            self.open_conversation_id = m.get('OpenConversationId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetConversaionSpaceResponseBodySpace(TeaModel):
    def __init__(
        self,
        corp_id: str = None,
        create_time: str = None,
        modified_time: str = None,
        space_id: str = None,
    ):
        self.corp_id = corp_id
        self.create_time = create_time
        self.modified_time = modified_time
        self.space_id = space_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        return self


class GetConversaionSpaceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        space: GetConversaionSpaceResponseBodySpace = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.space = space
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.space:
            self.space.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.space is not None:
            result['space'] = self.space.to_map()
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('space') is not None:
            temp_model = GetConversaionSpaceResponseBodySpace()
            self.space = temp_model.from_map(m['space'])
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetConversaionSpaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetConversaionSpaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetConversaionSpaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCorpAccomplishmentTasksHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetCorpAccomplishmentTasksHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetCorpAccomplishmentTasksHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetCorpAccomplishmentTasksHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetCorpAccomplishmentTasksShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetCorpAccomplishmentTasksRequest(TeaModel):
    def __init__(
        self,
        app_types: str = None,
        corp_id: str = None,
        create_from_time_gmt: int = None,
        create_to_time_gmt: int = None,
        keyword: str = None,
        language: str = None,
        page_number: int = None,
        page_size: int = None,
        process_codes: str = None,
        token: str = None,
    ):
        self.app_types = app_types
        # This parameter is required.
        self.corp_id = corp_id
        self.create_from_time_gmt = create_from_time_gmt
        self.create_to_time_gmt = create_to_time_gmt
        self.keyword = keyword
        self.language = language
        self.page_number = page_number
        self.page_size = page_size
        self.process_codes = process_codes
        # This parameter is required.
        self.token = token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_types is not None:
            result['AppTypes'] = self.app_types
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.create_from_time_gmt is not None:
            result['CreateFromTimeGMT'] = self.create_from_time_gmt
        if self.create_to_time_gmt is not None:
            result['CreateToTimeGMT'] = self.create_to_time_gmt
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.language is not None:
            result['Language'] = self.language
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.process_codes is not None:
            result['ProcessCodes'] = self.process_codes
        if self.token is not None:
            result['Token'] = self.token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppTypes') is not None:
            self.app_types = m.get('AppTypes')
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('CreateFromTimeGMT') is not None:
            self.create_from_time_gmt = m.get('CreateFromTimeGMT')
        if m.get('CreateToTimeGMT') is not None:
            self.create_to_time_gmt = m.get('CreateToTimeGMT')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProcessCodes') is not None:
            self.process_codes = m.get('ProcessCodes')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        return self


class GetCorpAccomplishmentTasksResponseBodyData(TeaModel):
    def __init__(
        self,
        active_time_gmt: str = None,
        actual_actioner_id: str = None,
        app_type: str = None,
        create_time_gmt: str = None,
        finish_time_gmt: str = None,
        originator_email: str = None,
        originator_id: str = None,
        originator_name: str = None,
        originator_name_in_english: str = None,
        originator_nick_name: str = None,
        originator_nick_name_in_english: str = None,
        originator_photo: str = None,
        out_result: str = None,
        out_result_name: str = None,
        process_instance_id: str = None,
        title: str = None,
    ):
        self.active_time_gmt = active_time_gmt
        self.actual_actioner_id = actual_actioner_id
        self.app_type = app_type
        self.create_time_gmt = create_time_gmt
        self.finish_time_gmt = finish_time_gmt
        self.originator_email = originator_email
        self.originator_id = originator_id
        self.originator_name = originator_name
        self.originator_name_in_english = originator_name_in_english
        self.originator_nick_name = originator_nick_name
        self.originator_nick_name_in_english = originator_nick_name_in_english
        self.originator_photo = originator_photo
        self.out_result = out_result
        self.out_result_name = out_result_name
        self.process_instance_id = process_instance_id
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_time_gmt is not None:
            result['ActiveTimeGMT'] = self.active_time_gmt
        if self.actual_actioner_id is not None:
            result['ActualActionerId'] = self.actual_actioner_id
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.create_time_gmt is not None:
            result['CreateTimeGMT'] = self.create_time_gmt
        if self.finish_time_gmt is not None:
            result['FinishTimeGMT'] = self.finish_time_gmt
        if self.originator_email is not None:
            result['OriginatorEmail'] = self.originator_email
        if self.originator_id is not None:
            result['OriginatorId'] = self.originator_id
        if self.originator_name is not None:
            result['OriginatorName'] = self.originator_name
        if self.originator_name_in_english is not None:
            result['OriginatorNameInEnglish'] = self.originator_name_in_english
        if self.originator_nick_name is not None:
            result['OriginatorNickName'] = self.originator_nick_name
        if self.originator_nick_name_in_english is not None:
            result['OriginatorNickNameInEnglish'] = self.originator_nick_name_in_english
        if self.originator_photo is not None:
            result['OriginatorPhoto'] = self.originator_photo
        if self.out_result is not None:
            result['OutResult'] = self.out_result
        if self.out_result_name is not None:
            result['OutResultName'] = self.out_result_name
        if self.process_instance_id is not None:
            result['ProcessInstanceId'] = self.process_instance_id
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActiveTimeGMT') is not None:
            self.active_time_gmt = m.get('ActiveTimeGMT')
        if m.get('ActualActionerId') is not None:
            self.actual_actioner_id = m.get('ActualActionerId')
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('CreateTimeGMT') is not None:
            self.create_time_gmt = m.get('CreateTimeGMT')
        if m.get('FinishTimeGMT') is not None:
            self.finish_time_gmt = m.get('FinishTimeGMT')
        if m.get('OriginatorEmail') is not None:
            self.originator_email = m.get('OriginatorEmail')
        if m.get('OriginatorId') is not None:
            self.originator_id = m.get('OriginatorId')
        if m.get('OriginatorName') is not None:
            self.originator_name = m.get('OriginatorName')
        if m.get('OriginatorNameInEnglish') is not None:
            self.originator_name_in_english = m.get('OriginatorNameInEnglish')
        if m.get('OriginatorNickName') is not None:
            self.originator_nick_name = m.get('OriginatorNickName')
        if m.get('OriginatorNickNameInEnglish') is not None:
            self.originator_nick_name_in_english = m.get('OriginatorNickNameInEnglish')
        if m.get('OriginatorPhoto') is not None:
            self.originator_photo = m.get('OriginatorPhoto')
        if m.get('OutResult') is not None:
            self.out_result = m.get('OutResult')
        if m.get('OutResultName') is not None:
            self.out_result_name = m.get('OutResultName')
        if m.get('ProcessInstanceId') is not None:
            self.process_instance_id = m.get('ProcessInstanceId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class GetCorpAccomplishmentTasksResponseBody(TeaModel):
    def __init__(
        self,
        data: List[GetCorpAccomplishmentTasksResponseBodyData] = None,
        page_number: int = None,
        request_id: str = None,
        total_count: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.data = data
        self.page_number = page_number
        self.request_id = request_id
        self.total_count = total_count
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = GetCorpAccomplishmentTasksResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetCorpAccomplishmentTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCorpAccomplishmentTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCorpAccomplishmentTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCorpTasksHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetCorpTasksHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetCorpTasksHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetCorpTasksHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetCorpTasksShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetCorpTasksRequest(TeaModel):
    def __init__(
        self,
        app_types: str = None,
        corp_id: str = None,
        create_from_time_gmt: int = None,
        create_to_time_gmt: int = None,
        keyword: str = None,
        language: str = None,
        page_number: int = None,
        page_size: int = None,
        process_codes: str = None,
        token: str = None,
    ):
        # This parameter is required.
        self.app_types = app_types
        # This parameter is required.
        self.corp_id = corp_id
        self.create_from_time_gmt = create_from_time_gmt
        self.create_to_time_gmt = create_to_time_gmt
        self.keyword = keyword
        self.language = language
        self.page_number = page_number
        self.page_size = page_size
        self.process_codes = process_codes
        # This parameter is required.
        self.token = token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_types is not None:
            result['AppTypes'] = self.app_types
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.create_from_time_gmt is not None:
            result['CreateFromTimeGMT'] = self.create_from_time_gmt
        if self.create_to_time_gmt is not None:
            result['CreateToTimeGMT'] = self.create_to_time_gmt
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.language is not None:
            result['Language'] = self.language
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.process_codes is not None:
            result['ProcessCodes'] = self.process_codes
        if self.token is not None:
            result['Token'] = self.token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppTypes') is not None:
            self.app_types = m.get('AppTypes')
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('CreateFromTimeGMT') is not None:
            self.create_from_time_gmt = m.get('CreateFromTimeGMT')
        if m.get('CreateToTimeGMT') is not None:
            self.create_to_time_gmt = m.get('CreateToTimeGMT')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProcessCodes') is not None:
            self.process_codes = m.get('ProcessCodes')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        return self


class GetCorpTasksResponseBodyData(TeaModel):
    def __init__(
        self,
        active_time_gmt: str = None,
        actual_actioner_id: str = None,
        app_type: str = None,
        create_time_gmt: str = None,
        finish_time_gmt: str = None,
        originator_email: str = None,
        originator_id: str = None,
        originator_name: str = None,
        originator_name_in_english: str = None,
        originator_nick_name: str = None,
        originator_nick_name_en: str = None,
        originator_nick_name_in_english: str = None,
        originator_photo: str = None,
        out_result: str = None,
        out_result_name: str = None,
        process_instance_id: str = None,
        status: str = None,
        task_id: str = None,
        task_type: str = None,
        title: str = None,
        title_in_english: str = None,
    ):
        self.active_time_gmt = active_time_gmt
        self.actual_actioner_id = actual_actioner_id
        self.app_type = app_type
        self.create_time_gmt = create_time_gmt
        self.finish_time_gmt = finish_time_gmt
        self.originator_email = originator_email
        self.originator_id = originator_id
        self.originator_name = originator_name
        self.originator_name_in_english = originator_name_in_english
        self.originator_nick_name = originator_nick_name
        self.originator_nick_name_en = originator_nick_name_en
        self.originator_nick_name_in_english = originator_nick_name_in_english
        self.originator_photo = originator_photo
        self.out_result = out_result
        self.out_result_name = out_result_name
        self.process_instance_id = process_instance_id
        self.status = status
        self.task_id = task_id
        self.task_type = task_type
        self.title = title
        self.title_in_english = title_in_english

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_time_gmt is not None:
            result['ActiveTimeGMT'] = self.active_time_gmt
        if self.actual_actioner_id is not None:
            result['ActualActionerId'] = self.actual_actioner_id
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.create_time_gmt is not None:
            result['CreateTimeGMT'] = self.create_time_gmt
        if self.finish_time_gmt is not None:
            result['FinishTimeGMT'] = self.finish_time_gmt
        if self.originator_email is not None:
            result['OriginatorEmail'] = self.originator_email
        if self.originator_id is not None:
            result['OriginatorId'] = self.originator_id
        if self.originator_name is not None:
            result['OriginatorName'] = self.originator_name
        if self.originator_name_in_english is not None:
            result['OriginatorNameInEnglish'] = self.originator_name_in_english
        if self.originator_nick_name is not None:
            result['OriginatorNickName'] = self.originator_nick_name
        if self.originator_nick_name_en is not None:
            result['OriginatorNickNameEn'] = self.originator_nick_name_en
        if self.originator_nick_name_in_english is not None:
            result['OriginatorNickNameInEnglish'] = self.originator_nick_name_in_english
        if self.originator_photo is not None:
            result['OriginatorPhoto'] = self.originator_photo
        if self.out_result is not None:
            result['OutResult'] = self.out_result
        if self.out_result_name is not None:
            result['OutResultName'] = self.out_result_name
        if self.process_instance_id is not None:
            result['ProcessInstanceId'] = self.process_instance_id
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.title is not None:
            result['Title'] = self.title
        if self.title_in_english is not None:
            result['TitleInEnglish'] = self.title_in_english
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActiveTimeGMT') is not None:
            self.active_time_gmt = m.get('ActiveTimeGMT')
        if m.get('ActualActionerId') is not None:
            self.actual_actioner_id = m.get('ActualActionerId')
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('CreateTimeGMT') is not None:
            self.create_time_gmt = m.get('CreateTimeGMT')
        if m.get('FinishTimeGMT') is not None:
            self.finish_time_gmt = m.get('FinishTimeGMT')
        if m.get('OriginatorEmail') is not None:
            self.originator_email = m.get('OriginatorEmail')
        if m.get('OriginatorId') is not None:
            self.originator_id = m.get('OriginatorId')
        if m.get('OriginatorName') is not None:
            self.originator_name = m.get('OriginatorName')
        if m.get('OriginatorNameInEnglish') is not None:
            self.originator_name_in_english = m.get('OriginatorNameInEnglish')
        if m.get('OriginatorNickName') is not None:
            self.originator_nick_name = m.get('OriginatorNickName')
        if m.get('OriginatorNickNameEn') is not None:
            self.originator_nick_name_en = m.get('OriginatorNickNameEn')
        if m.get('OriginatorNickNameInEnglish') is not None:
            self.originator_nick_name_in_english = m.get('OriginatorNickNameInEnglish')
        if m.get('OriginatorPhoto') is not None:
            self.originator_photo = m.get('OriginatorPhoto')
        if m.get('OutResult') is not None:
            self.out_result = m.get('OutResult')
        if m.get('OutResultName') is not None:
            self.out_result_name = m.get('OutResultName')
        if m.get('ProcessInstanceId') is not None:
            self.process_instance_id = m.get('ProcessInstanceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('TitleInEnglish') is not None:
            self.title_in_english = m.get('TitleInEnglish')
        return self


class GetCorpTasksResponseBody(TeaModel):
    def __init__(
        self,
        data: List[GetCorpTasksResponseBodyData] = None,
        page_number: int = None,
        request_id: str = None,
        total_count: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.data = data
        self.page_number = page_number
        self.request_id = request_id
        self.total_count = total_count
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = GetCorpTasksResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetCorpTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCorpTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCorpTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDeptNoHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetDeptNoHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetDeptNoHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetDeptNoHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetDeptNoShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetDeptNoRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetDeptNoRequest(TeaModel):
    def __init__(
        self,
        tenant_context: GetDeptNoRequestTenantContext = None,
        dept_id: str = None,
    ):
        self.tenant_context = tenant_context
        # This parameter is required.
        self.dept_id = dept_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.dept_id is not None:
            result['deptId'] = self.dept_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = GetDeptNoRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('deptId') is not None:
            self.dept_id = m.get('deptId')
        return self


class GetDeptNoShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        dept_id: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.dept_id = dept_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.dept_id is not None:
            result['deptId'] = self.dept_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('deptId') is not None:
            self.dept_id = m.get('deptId')
        return self


class GetDeptNoResponseBody(TeaModel):
    def __init__(
        self,
        dept_no: str = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.dept_no = dept_no
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dept_no is not None:
            result['deptNo'] = self.dept_no
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('deptNo') is not None:
            self.dept_no = m.get('deptNo')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetDeptNoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDeptNoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDeptNoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDocContentHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetDocContentHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetDocContentHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetDocContentHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetDocContentShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetDocContentRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetDocContentRequest(TeaModel):
    def __init__(
        self,
        dentry_uuid: str = None,
        target_format: str = None,
        tenant_context: GetDocContentRequestTenantContext = None,
        user_token: str = None,
    ):
        # This parameter is required.
        self.dentry_uuid = dentry_uuid
        self.target_format = target_format
        self.tenant_context = tenant_context
        # This parameter is required.
        self.user_token = user_token

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        if self.target_format is not None:
            result['TargetFormat'] = self.target_format
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.user_token is not None:
            result['userToken'] = self.user_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        if m.get('TargetFormat') is not None:
            self.target_format = m.get('TargetFormat')
        if m.get('TenantContext') is not None:
            temp_model = GetDocContentRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('userToken') is not None:
            self.user_token = m.get('userToken')
        return self


class GetDocContentShrinkRequest(TeaModel):
    def __init__(
        self,
        dentry_uuid: str = None,
        target_format: str = None,
        tenant_context_shrink: str = None,
        user_token: str = None,
    ):
        # This parameter is required.
        self.dentry_uuid = dentry_uuid
        self.target_format = target_format
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.user_token = user_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        if self.target_format is not None:
            result['TargetFormat'] = self.target_format
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.user_token is not None:
            result['userToken'] = self.user_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        if m.get('TargetFormat') is not None:
            self.target_format = m.get('TargetFormat')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('userToken') is not None:
            self.user_token = m.get('userToken')
        return self


class GetDocContentResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.task_id = task_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.task_id is not None:
            result['taskId'] = self.task_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetDocContentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDocContentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDocContentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDocContentTakIdHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetDocContentTakIdHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetDocContentTakIdHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetDocContentTakIdHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetDocContentTakIdShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetDocContentTakIdRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetDocContentTakIdRequest(TeaModel):
    def __init__(
        self,
        dentry_uuid: str = None,
        generate_cp: bool = None,
        target_format: str = None,
        tenant_context: GetDocContentTakIdRequestTenantContext = None,
    ):
        # This parameter is required.
        self.dentry_uuid = dentry_uuid
        self.generate_cp = generate_cp
        self.target_format = target_format
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        if self.generate_cp is not None:
            result['GenerateCp'] = self.generate_cp
        if self.target_format is not None:
            result['TargetFormat'] = self.target_format
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        if m.get('GenerateCp') is not None:
            self.generate_cp = m.get('GenerateCp')
        if m.get('TargetFormat') is not None:
            self.target_format = m.get('TargetFormat')
        if m.get('TenantContext') is not None:
            temp_model = GetDocContentTakIdRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetDocContentTakIdShrinkRequest(TeaModel):
    def __init__(
        self,
        dentry_uuid: str = None,
        generate_cp: bool = None,
        target_format: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.dentry_uuid = dentry_uuid
        self.generate_cp = generate_cp
        self.target_format = target_format
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        if self.generate_cp is not None:
            result['GenerateCp'] = self.generate_cp
        if self.target_format is not None:
            result['TargetFormat'] = self.target_format
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        if m.get('GenerateCp') is not None:
            self.generate_cp = m.get('GenerateCp')
        if m.get('TargetFormat') is not None:
            self.target_format = m.get('TargetFormat')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetDocContentTakIdResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.task_id = task_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.task_id is not None:
            result['taskId'] = self.task_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetDocContentTakIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDocContentTakIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDocContentTakIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEventHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetEventHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetEventHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetEventHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetEventShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetEventRequest(TeaModel):
    def __init__(
        self,
        calendar_id: str = None,
        event_id: str = None,
        max_attendees: int = None,
    ):
        # This parameter is required.
        self.calendar_id = calendar_id
        # This parameter is required.
        self.event_id = event_id
        self.max_attendees = max_attendees

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.max_attendees is not None:
            result['MaxAttendees'] = self.max_attendees
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('MaxAttendees') is not None:
            self.max_attendees = m.get('MaxAttendees')
        return self


class GetEventResponseBodyAttendees(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        id: str = None,
        is_optional: bool = None,
        response_status: str = None,
        self_: bool = None,
    ):
        self.display_name = display_name
        self.id = id
        self.is_optional = is_optional
        self.response_status = response_status
        self.self_ = self_

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.id is not None:
            result['Id'] = self.id
        if self.is_optional is not None:
            result['IsOptional'] = self.is_optional
        if self.response_status is not None:
            result['ResponseStatus'] = self.response_status
        if self.self_ is not None:
            result['Self'] = self.self_
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsOptional') is not None:
            self.is_optional = m.get('IsOptional')
        if m.get('ResponseStatus') is not None:
            self.response_status = m.get('ResponseStatus')
        if m.get('Self') is not None:
            self.self_ = m.get('Self')
        return self


class GetEventResponseBodyCategories(TeaModel):
    def __init__(
        self,
        display_name: str = None,
    ):
        self.display_name = display_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        return self


class GetEventResponseBodyEnd(TeaModel):
    def __init__(
        self,
        date: str = None,
        date_time: str = None,
        time_zone: str = None,
    ):
        self.date = date
        self.date_time = date_time
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['Date'] = self.date
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.time_zone is not None:
            result['TimeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Date') is not None:
            self.date = m.get('Date')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('TimeZone') is not None:
            self.time_zone = m.get('TimeZone')
        return self


class GetEventResponseBodyExtendedPropertiesSharedProperties(TeaModel):
    def __init__(
        self,
        belong_corp_id: str = None,
        source_open_cid: str = None,
    ):
        self.belong_corp_id = belong_corp_id
        self.source_open_cid = source_open_cid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.belong_corp_id is not None:
            result['BelongCorpId'] = self.belong_corp_id
        if self.source_open_cid is not None:
            result['SourceOpenCid'] = self.source_open_cid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BelongCorpId') is not None:
            self.belong_corp_id = m.get('BelongCorpId')
        if m.get('SourceOpenCid') is not None:
            self.source_open_cid = m.get('SourceOpenCid')
        return self


class GetEventResponseBodyExtendedProperties(TeaModel):
    def __init__(
        self,
        shared_properties: GetEventResponseBodyExtendedPropertiesSharedProperties = None,
    ):
        self.shared_properties = shared_properties

    def validate(self):
        if self.shared_properties:
            self.shared_properties.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.shared_properties is not None:
            result['SharedProperties'] = self.shared_properties.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SharedProperties') is not None:
            temp_model = GetEventResponseBodyExtendedPropertiesSharedProperties()
            self.shared_properties = temp_model.from_map(m['SharedProperties'])
        return self


class GetEventResponseBodyLocation(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        meeting_rooms: List[str] = None,
    ):
        self.display_name = display_name
        # --\
        self.meeting_rooms = meeting_rooms

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.meeting_rooms is not None:
            result['MeetingRooms'] = self.meeting_rooms
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('MeetingRooms') is not None:
            self.meeting_rooms = m.get('MeetingRooms')
        return self


class GetEventResponseBodyMeetingRooms(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        response_status: str = None,
        room_id: str = None,
    ):
        self.display_name = display_name
        self.response_status = response_status
        self.room_id = room_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.response_status is not None:
            result['ResponseStatus'] = self.response_status
        if self.room_id is not None:
            result['RoomId'] = self.room_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('ResponseStatus') is not None:
            self.response_status = m.get('ResponseStatus')
        if m.get('RoomId') is not None:
            self.room_id = m.get('RoomId')
        return self


class GetEventResponseBodyOnlineMeetingInfo(TeaModel):
    def __init__(
        self,
        conference_id: str = None,
        extra_info: Dict[str, Any] = None,
        type: str = None,
        url: str = None,
    ):
        self.conference_id = conference_id
        self.extra_info = extra_info
        self.type = type
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conference_id is not None:
            result['ConferenceId'] = self.conference_id
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConferenceId') is not None:
            self.conference_id = m.get('ConferenceId')
        if m.get('ExtraInfo') is not None:
            self.extra_info = m.get('ExtraInfo')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetEventResponseBodyOrganizer(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        id: str = None,
        response_status: str = None,
        self_: bool = None,
    ):
        self.display_name = display_name
        self.id = id
        self.response_status = response_status
        self.self_ = self_

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.id is not None:
            result['Id'] = self.id
        if self.response_status is not None:
            result['ResponseStatus'] = self.response_status
        if self.self_ is not None:
            result['Self'] = self.self_
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ResponseStatus') is not None:
            self.response_status = m.get('ResponseStatus')
        if m.get('Self') is not None:
            self.self_ = m.get('Self')
        return self


class GetEventResponseBodyOriginStart(TeaModel):
    def __init__(
        self,
        date_time: str = None,
    ):
        self.date_time = date_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        return self


class GetEventResponseBodyRecurrencePattern(TeaModel):
    def __init__(
        self,
        day_of_month: int = None,
        days_of_week: str = None,
        index: str = None,
        interval: int = None,
        type: str = None,
    ):
        self.day_of_month = day_of_month
        self.days_of_week = days_of_week
        self.index = index
        self.interval = interval
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.day_of_month is not None:
            result['DayOfMonth'] = self.day_of_month
        if self.days_of_week is not None:
            result['DaysOfWeek'] = self.days_of_week
        if self.index is not None:
            result['Index'] = self.index
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DayOfMonth') is not None:
            self.day_of_month = m.get('DayOfMonth')
        if m.get('DaysOfWeek') is not None:
            self.days_of_week = m.get('DaysOfWeek')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetEventResponseBodyRecurrenceRange(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        number_of_occurrences: int = None,
        type: str = None,
    ):
        self.end_date = end_date
        self.number_of_occurrences = number_of_occurrences
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.number_of_occurrences is not None:
            result['NumberOfOccurrences'] = self.number_of_occurrences
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('NumberOfOccurrences') is not None:
            self.number_of_occurrences = m.get('NumberOfOccurrences')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetEventResponseBodyRecurrence(TeaModel):
    def __init__(
        self,
        pattern: GetEventResponseBodyRecurrencePattern = None,
        range: GetEventResponseBodyRecurrenceRange = None,
    ):
        self.pattern = pattern
        self.range = range

    def validate(self):
        if self.pattern:
            self.pattern.validate()
        if self.range:
            self.range.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pattern is not None:
            result['Pattern'] = self.pattern.to_map()
        if self.range is not None:
            result['Range'] = self.range.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pattern') is not None:
            temp_model = GetEventResponseBodyRecurrencePattern()
            self.pattern = temp_model.from_map(m['Pattern'])
        if m.get('Range') is not None:
            temp_model = GetEventResponseBodyRecurrenceRange()
            self.range = temp_model.from_map(m['Range'])
        return self


class GetEventResponseBodyReminders(TeaModel):
    def __init__(
        self,
        method: str = None,
        minutes: str = None,
    ):
        self.method = method
        self.minutes = minutes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.method is not None:
            result['Method'] = self.method
        if self.minutes is not None:
            result['Minutes'] = self.minutes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('Minutes') is not None:
            self.minutes = m.get('Minutes')
        return self


class GetEventResponseBodyRichTextDescription(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class GetEventResponseBodyStart(TeaModel):
    def __init__(
        self,
        date: str = None,
        date_time: str = None,
        time_zone: str = None,
    ):
        self.date = date
        self.date_time = date_time
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['Date'] = self.date
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.time_zone is not None:
            result['TimeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Date') is not None:
            self.date = m.get('Date')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('TimeZone') is not None:
            self.time_zone = m.get('TimeZone')
        return self


class GetEventResponseBody(TeaModel):
    def __init__(
        self,
        attendees: List[GetEventResponseBodyAttendees] = None,
        categories: List[GetEventResponseBodyCategories] = None,
        create_time: str = None,
        description: str = None,
        end: GetEventResponseBodyEnd = None,
        extended_properties: GetEventResponseBodyExtendedProperties = None,
        id: str = None,
        is_all_day: bool = None,
        location: GetEventResponseBodyLocation = None,
        meeting_rooms: List[GetEventResponseBodyMeetingRooms] = None,
        online_meeting_info: GetEventResponseBodyOnlineMeetingInfo = None,
        organizer: GetEventResponseBodyOrganizer = None,
        origin_start: GetEventResponseBodyOriginStart = None,
        recurrence: GetEventResponseBodyRecurrence = None,
        reminders: List[GetEventResponseBodyReminders] = None,
        request_id: str = None,
        rich_text_description: GetEventResponseBodyRichTextDescription = None,
        series_master_id: str = None,
        start: GetEventResponseBodyStart = None,
        status: str = None,
        summary: str = None,
        update_time: str = None,
    ):
        self.attendees = attendees
        self.categories = categories
        self.create_time = create_time
        self.description = description
        self.end = end
        self.extended_properties = extended_properties
        self.id = id
        self.is_all_day = is_all_day
        self.location = location
        self.meeting_rooms = meeting_rooms
        self.online_meeting_info = online_meeting_info
        self.organizer = organizer
        self.origin_start = origin_start
        self.recurrence = recurrence
        self.reminders = reminders
        # requestId
        self.request_id = request_id
        self.rich_text_description = rich_text_description
        self.series_master_id = series_master_id
        self.start = start
        self.status = status
        self.summary = summary
        self.update_time = update_time

    def validate(self):
        if self.attendees:
            for k in self.attendees:
                if k:
                    k.validate()
        if self.categories:
            for k in self.categories:
                if k:
                    k.validate()
        if self.end:
            self.end.validate()
        if self.extended_properties:
            self.extended_properties.validate()
        if self.location:
            self.location.validate()
        if self.meeting_rooms:
            for k in self.meeting_rooms:
                if k:
                    k.validate()
        if self.online_meeting_info:
            self.online_meeting_info.validate()
        if self.organizer:
            self.organizer.validate()
        if self.origin_start:
            self.origin_start.validate()
        if self.recurrence:
            self.recurrence.validate()
        if self.reminders:
            for k in self.reminders:
                if k:
                    k.validate()
        if self.rich_text_description:
            self.rich_text_description.validate()
        if self.start:
            self.start.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['attendees'] = []
        if self.attendees is not None:
            for k in self.attendees:
                result['attendees'].append(k.to_map() if k else None)
        result['categories'] = []
        if self.categories is not None:
            for k in self.categories:
                result['categories'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.description is not None:
            result['description'] = self.description
        if self.end is not None:
            result['end'] = self.end.to_map()
        if self.extended_properties is not None:
            result['extendedProperties'] = self.extended_properties.to_map()
        if self.id is not None:
            result['id'] = self.id
        if self.is_all_day is not None:
            result['isAllDay'] = self.is_all_day
        if self.location is not None:
            result['location'] = self.location.to_map()
        result['meetingRooms'] = []
        if self.meeting_rooms is not None:
            for k in self.meeting_rooms:
                result['meetingRooms'].append(k.to_map() if k else None)
        if self.online_meeting_info is not None:
            result['onlineMeetingInfo'] = self.online_meeting_info.to_map()
        if self.organizer is not None:
            result['organizer'] = self.organizer.to_map()
        if self.origin_start is not None:
            result['originStart'] = self.origin_start.to_map()
        if self.recurrence is not None:
            result['recurrence'] = self.recurrence.to_map()
        result['reminders'] = []
        if self.reminders is not None:
            for k in self.reminders:
                result['reminders'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.rich_text_description is not None:
            result['richTextDescription'] = self.rich_text_description.to_map()
        if self.series_master_id is not None:
            result['seriesMasterId'] = self.series_master_id
        if self.start is not None:
            result['start'] = self.start.to_map()
        if self.status is not None:
            result['status'] = self.status
        if self.summary is not None:
            result['summary'] = self.summary
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attendees = []
        if m.get('attendees') is not None:
            for k in m.get('attendees'):
                temp_model = GetEventResponseBodyAttendees()
                self.attendees.append(temp_model.from_map(k))
        self.categories = []
        if m.get('categories') is not None:
            for k in m.get('categories'):
                temp_model = GetEventResponseBodyCategories()
                self.categories.append(temp_model.from_map(k))
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('end') is not None:
            temp_model = GetEventResponseBodyEnd()
            self.end = temp_model.from_map(m['end'])
        if m.get('extendedProperties') is not None:
            temp_model = GetEventResponseBodyExtendedProperties()
            self.extended_properties = temp_model.from_map(m['extendedProperties'])
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('isAllDay') is not None:
            self.is_all_day = m.get('isAllDay')
        if m.get('location') is not None:
            temp_model = GetEventResponseBodyLocation()
            self.location = temp_model.from_map(m['location'])
        self.meeting_rooms = []
        if m.get('meetingRooms') is not None:
            for k in m.get('meetingRooms'):
                temp_model = GetEventResponseBodyMeetingRooms()
                self.meeting_rooms.append(temp_model.from_map(k))
        if m.get('onlineMeetingInfo') is not None:
            temp_model = GetEventResponseBodyOnlineMeetingInfo()
            self.online_meeting_info = temp_model.from_map(m['onlineMeetingInfo'])
        if m.get('organizer') is not None:
            temp_model = GetEventResponseBodyOrganizer()
            self.organizer = temp_model.from_map(m['organizer'])
        if m.get('originStart') is not None:
            temp_model = GetEventResponseBodyOriginStart()
            self.origin_start = temp_model.from_map(m['originStart'])
        if m.get('recurrence') is not None:
            temp_model = GetEventResponseBodyRecurrence()
            self.recurrence = temp_model.from_map(m['recurrence'])
        self.reminders = []
        if m.get('reminders') is not None:
            for k in m.get('reminders'):
                temp_model = GetEventResponseBodyReminders()
                self.reminders.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('richTextDescription') is not None:
            temp_model = GetEventResponseBodyRichTextDescription()
            self.rich_text_description = temp_model.from_map(m['richTextDescription'])
        if m.get('seriesMasterId') is not None:
            self.series_master_id = m.get('seriesMasterId')
        if m.get('start') is not None:
            temp_model = GetEventResponseBodyStart()
            self.start = temp_model.from_map(m['start'])
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('summary') is not None:
            self.summary = m.get('summary')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        return self


class GetEventResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetEventResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFieldDefByUuidHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetFieldDefByUuidHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetFieldDefByUuidHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetFieldDefByUuidHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetFieldDefByUuidShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetFieldDefByUuidRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        form_uuid: str = None,
        system_token: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        # This parameter is required.
        self.form_uuid = form_uuid
        # This parameter is required.
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class GetFieldDefByUuidResponseBodyResult(TeaModel):
    def __init__(
        self,
        behavior: str = None,
        children: str = None,
        component_name: str = None,
        field_id: str = None,
        label: Any = None,
        props: Any = None,
        success: bool = None,
    ):
        self.behavior = behavior
        self.children = children
        self.component_name = component_name
        self.field_id = field_id
        self.label = label
        self.props = props
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.behavior is not None:
            result['Behavior'] = self.behavior
        if self.children is not None:
            result['Children'] = self.children
        if self.component_name is not None:
            result['ComponentName'] = self.component_name
        if self.field_id is not None:
            result['FieldId'] = self.field_id
        if self.label is not None:
            result['Label'] = self.label
        if self.props is not None:
            result['Props'] = self.props
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Behavior') is not None:
            self.behavior = m.get('Behavior')
        if m.get('Children') is not None:
            self.children = m.get('Children')
        if m.get('ComponentName') is not None:
            self.component_name = m.get('ComponentName')
        if m.get('FieldId') is not None:
            self.field_id = m.get('FieldId')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Props') is not None:
            self.props = m.get('Props')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetFieldDefByUuidResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: List[GetFieldDefByUuidResponseBodyResult] = None,
        success: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.result = result
        self.success = success
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = GetFieldDefByUuidResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetFieldDefByUuidResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetFieldDefByUuidResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFieldDefByUuidResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFileDownloadInfoHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetFileDownloadInfoHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetFileDownloadInfoHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetFileDownloadInfoHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetFileDownloadInfoShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetFileDownloadInfoRequestOption(TeaModel):
    def __init__(
        self,
        prefer_intranet: bool = None,
        version: int = None,
    ):
        self.prefer_intranet = prefer_intranet
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prefer_intranet is not None:
            result['PreferIntranet'] = self.prefer_intranet
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PreferIntranet') is not None:
            self.prefer_intranet = m.get('PreferIntranet')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class GetFileDownloadInfoRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetFileDownloadInfoRequest(TeaModel):
    def __init__(
        self,
        dentry_id: str = None,
        option: GetFileDownloadInfoRequestOption = None,
        space_id: str = None,
        tenant_context: GetFileDownloadInfoRequestTenantContext = None,
    ):
        self.dentry_id = dentry_id
        self.option = option
        self.space_id = space_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.option:
            self.option.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_id is not None:
            result['DentryId'] = self.dentry_id
        if self.option is not None:
            result['Option'] = self.option.to_map()
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryId') is not None:
            self.dentry_id = m.get('DentryId')
        if m.get('Option') is not None:
            temp_model = GetFileDownloadInfoRequestOption()
            self.option = temp_model.from_map(m['Option'])
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('TenantContext') is not None:
            temp_model = GetFileDownloadInfoRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetFileDownloadInfoShrinkRequest(TeaModel):
    def __init__(
        self,
        dentry_id: str = None,
        option_shrink: str = None,
        space_id: str = None,
        tenant_context_shrink: str = None,
    ):
        self.dentry_id = dentry_id
        self.option_shrink = option_shrink
        self.space_id = space_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_id is not None:
            result['DentryId'] = self.dentry_id
        if self.option_shrink is not None:
            result['Option'] = self.option_shrink
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryId') is not None:
            self.dentry_id = m.get('DentryId')
        if m.get('Option') is not None:
            self.option_shrink = m.get('Option')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetFileDownloadInfoResponseBodyHeaderSignatureInfo(TeaModel):
    def __init__(
        self,
        expiration_seconds: int = None,
        headers: Dict[str, str] = None,
        internal_resource_urls: List[str] = None,
        region: str = None,
        resource_urls: List[str] = None,
    ):
        self.expiration_seconds = expiration_seconds
        self.headers = headers
        self.internal_resource_urls = internal_resource_urls
        self.region = region
        self.resource_urls = resource_urls

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expiration_seconds is not None:
            result['ExpirationSeconds'] = self.expiration_seconds
        if self.headers is not None:
            result['Headers'] = self.headers
        if self.internal_resource_urls is not None:
            result['InternalResourceUrls'] = self.internal_resource_urls
        if self.region is not None:
            result['Region'] = self.region
        if self.resource_urls is not None:
            result['ResourceUrls'] = self.resource_urls
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExpirationSeconds') is not None:
            self.expiration_seconds = m.get('ExpirationSeconds')
        if m.get('Headers') is not None:
            self.headers = m.get('Headers')
        if m.get('InternalResourceUrls') is not None:
            self.internal_resource_urls = m.get('InternalResourceUrls')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('ResourceUrls') is not None:
            self.resource_urls = m.get('ResourceUrls')
        return self


class GetFileDownloadInfoResponseBody(TeaModel):
    def __init__(
        self,
        header_signature_info: GetFileDownloadInfoResponseBodyHeaderSignatureInfo = None,
        protocol: str = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.header_signature_info = header_signature_info
        self.protocol = protocol
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.header_signature_info:
            self.header_signature_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header_signature_info is not None:
            result['headerSignatureInfo'] = self.header_signature_info.to_map()
        if self.protocol is not None:
            result['protocol'] = self.protocol
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headerSignatureInfo') is not None:
            temp_model = GetFileDownloadInfoResponseBodyHeaderSignatureInfo()
            self.header_signature_info = temp_model.from_map(m['headerSignatureInfo'])
        if m.get('protocol') is not None:
            self.protocol = m.get('protocol')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetFileDownloadInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetFileDownloadInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFileDownloadInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFileUploadInfoHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetFileUploadInfoHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetFileUploadInfoHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetFileUploadInfoHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetFileUploadInfoShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetFileUploadInfoRequestOptionPreCheckParam(TeaModel):
    def __init__(
        self,
        name: str = None,
        size: int = None,
    ):
        self.name = name
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class GetFileUploadInfoRequestOption(TeaModel):
    def __init__(
        self,
        pre_check_param: GetFileUploadInfoRequestOptionPreCheckParam = None,
        prefer_intranet: bool = None,
        prefer_region: str = None,
        storage_driver: str = None,
    ):
        self.pre_check_param = pre_check_param
        self.prefer_intranet = prefer_intranet
        self.prefer_region = prefer_region
        self.storage_driver = storage_driver

    def validate(self):
        if self.pre_check_param:
            self.pre_check_param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pre_check_param is not None:
            result['PreCheckParam'] = self.pre_check_param.to_map()
        if self.prefer_intranet is not None:
            result['PreferIntranet'] = self.prefer_intranet
        if self.prefer_region is not None:
            result['PreferRegion'] = self.prefer_region
        if self.storage_driver is not None:
            result['StorageDriver'] = self.storage_driver
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PreCheckParam') is not None:
            temp_model = GetFileUploadInfoRequestOptionPreCheckParam()
            self.pre_check_param = temp_model.from_map(m['PreCheckParam'])
        if m.get('PreferIntranet') is not None:
            self.prefer_intranet = m.get('PreferIntranet')
        if m.get('PreferRegion') is not None:
            self.prefer_region = m.get('PreferRegion')
        if m.get('StorageDriver') is not None:
            self.storage_driver = m.get('StorageDriver')
        return self


class GetFileUploadInfoRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetFileUploadInfoRequest(TeaModel):
    def __init__(
        self,
        option: GetFileUploadInfoRequestOption = None,
        parent_dentry_uuid: str = None,
        protocol: str = None,
        tenant_context: GetFileUploadInfoRequestTenantContext = None,
    ):
        self.option = option
        self.parent_dentry_uuid = parent_dentry_uuid
        self.protocol = protocol
        self.tenant_context = tenant_context

    def validate(self):
        if self.option:
            self.option.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.option is not None:
            result['Option'] = self.option.to_map()
        if self.parent_dentry_uuid is not None:
            result['ParentDentryUuid'] = self.parent_dentry_uuid
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Option') is not None:
            temp_model = GetFileUploadInfoRequestOption()
            self.option = temp_model.from_map(m['Option'])
        if m.get('ParentDentryUuid') is not None:
            self.parent_dentry_uuid = m.get('ParentDentryUuid')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('TenantContext') is not None:
            temp_model = GetFileUploadInfoRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetFileUploadInfoShrinkRequest(TeaModel):
    def __init__(
        self,
        option_shrink: str = None,
        parent_dentry_uuid: str = None,
        protocol: str = None,
        tenant_context_shrink: str = None,
    ):
        self.option_shrink = option_shrink
        self.parent_dentry_uuid = parent_dentry_uuid
        self.protocol = protocol
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.option_shrink is not None:
            result['Option'] = self.option_shrink
        if self.parent_dentry_uuid is not None:
            result['ParentDentryUuid'] = self.parent_dentry_uuid
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Option') is not None:
            self.option_shrink = m.get('Option')
        if m.get('ParentDentryUuid') is not None:
            self.parent_dentry_uuid = m.get('ParentDentryUuid')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetFileUploadInfoResponseBodyHeaderSignatureInfo(TeaModel):
    def __init__(
        self,
        expiration_seconds: int = None,
        headers: Dict[str, str] = None,
        internal_resource_urls: List[str] = None,
        region: str = None,
        resource_urls: List[str] = None,
    ):
        self.expiration_seconds = expiration_seconds
        self.headers = headers
        self.internal_resource_urls = internal_resource_urls
        self.region = region
        self.resource_urls = resource_urls

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expiration_seconds is not None:
            result['ExpirationSeconds'] = self.expiration_seconds
        if self.headers is not None:
            result['Headers'] = self.headers
        if self.internal_resource_urls is not None:
            result['InternalResourceUrls'] = self.internal_resource_urls
        if self.region is not None:
            result['Region'] = self.region
        if self.resource_urls is not None:
            result['ResourceUrls'] = self.resource_urls
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExpirationSeconds') is not None:
            self.expiration_seconds = m.get('ExpirationSeconds')
        if m.get('Headers') is not None:
            self.headers = m.get('Headers')
        if m.get('InternalResourceUrls') is not None:
            self.internal_resource_urls = m.get('InternalResourceUrls')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('ResourceUrls') is not None:
            self.resource_urls = m.get('ResourceUrls')
        return self


class GetFileUploadInfoResponseBody(TeaModel):
    def __init__(
        self,
        header_signature_info: GetFileUploadInfoResponseBodyHeaderSignatureInfo = None,
        protocol: str = None,
        request_id: str = None,
        storage_driver: str = None,
        upload_key: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.header_signature_info = header_signature_info
        self.protocol = protocol
        self.request_id = request_id
        self.storage_driver = storage_driver
        self.upload_key = upload_key
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.header_signature_info:
            self.header_signature_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header_signature_info is not None:
            result['headerSignatureInfo'] = self.header_signature_info.to_map()
        if self.protocol is not None:
            result['protocol'] = self.protocol
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.storage_driver is not None:
            result['storageDriver'] = self.storage_driver
        if self.upload_key is not None:
            result['uploadKey'] = self.upload_key
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headerSignatureInfo') is not None:
            temp_model = GetFileUploadInfoResponseBodyHeaderSignatureInfo()
            self.header_signature_info = temp_model.from_map(m['headerSignatureInfo'])
        if m.get('protocol') is not None:
            self.protocol = m.get('protocol')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('storageDriver') is not None:
            self.storage_driver = m.get('storageDriver')
        if m.get('uploadKey') is not None:
            self.upload_key = m.get('uploadKey')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetFileUploadInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetFileUploadInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFileUploadInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFormComponentDefinitionListHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetFormComponentDefinitionListHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetFormComponentDefinitionListHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetFormComponentDefinitionListHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetFormComponentDefinitionListShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetFormComponentDefinitionListRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        form_uuid: str = None,
        language: str = None,
        system_token: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        # This parameter is required.
        self.form_uuid = form_uuid
        self.language = language
        # This parameter is required.
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.language is not None:
            result['Language'] = self.language
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class GetFormComponentDefinitionListResponseBodyResult(TeaModel):
    def __init__(
        self,
        component_name: str = None,
        field_id: str = None,
        label: str = None,
        parent_id: str = None,
    ):
        self.component_name = component_name
        self.field_id = field_id
        self.label = label
        self.parent_id = parent_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.component_name is not None:
            result['ComponentName'] = self.component_name
        if self.field_id is not None:
            result['FieldId'] = self.field_id
        if self.label is not None:
            result['Label'] = self.label
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComponentName') is not None:
            self.component_name = m.get('ComponentName')
        if m.get('FieldId') is not None:
            self.field_id = m.get('FieldId')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        return self


class GetFormComponentDefinitionListResponseBody(TeaModel):
    def __init__(
        self,
        result: List[GetFormComponentDefinitionListResponseBodyResult] = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.result = result
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Result'] = []
        if self.result is not None:
            for k in self.result:
                result['Result'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.result = []
        if m.get('Result') is not None:
            for k in m.get('Result'):
                temp_model = GetFormComponentDefinitionListResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetFormComponentDefinitionListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetFormComponentDefinitionListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFormComponentDefinitionListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFormDataByIDHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetFormDataByIDHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetFormDataByIDHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetFormDataByIDHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetFormDataByIDShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetFormDataByIDRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        id: str = None,
        language: str = None,
        system_token: str = None,
    ):
        self.app_type = app_type
        self.id = id
        self.language = language
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.id is not None:
            result['Id'] = self.id
        if self.language is not None:
            result['Language'] = self.language
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class GetFormDataByIDResponseBodyOriginatorName(TeaModel):
    def __init__(
        self,
        name_in_chinese: str = None,
        name_in_english: str = None,
        type: str = None,
    ):
        self.name_in_chinese = name_in_chinese
        self.name_in_english = name_in_english
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_in_chinese is not None:
            result['NameInChinese'] = self.name_in_chinese
        if self.name_in_english is not None:
            result['NameInEnglish'] = self.name_in_english
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameInChinese') is not None:
            self.name_in_chinese = m.get('NameInChinese')
        if m.get('NameInEnglish') is not None:
            self.name_in_english = m.get('NameInEnglish')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetFormDataByIDResponseBodyOriginator(TeaModel):
    def __init__(
        self,
        department_name: str = None,
        email: str = None,
        name: GetFormDataByIDResponseBodyOriginatorName = None,
        user_id: str = None,
    ):
        self.department_name = department_name
        self.email = email
        self.name = name
        self.user_id = user_id

    def validate(self):
        if self.name:
            self.name.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.department_name is not None:
            result['DepartmentName'] = self.department_name
        if self.email is not None:
            result['Email'] = self.email
        if self.name is not None:
            result['Name'] = self.name.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DepartmentName') is not None:
            self.department_name = m.get('DepartmentName')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Name') is not None:
            temp_model = GetFormDataByIDResponseBodyOriginatorName()
            self.name = temp_model.from_map(m['Name'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetFormDataByIDResponseBody(TeaModel):
    def __init__(
        self,
        form_data: Dict[str, Any] = None,
        form_inst_id: str = None,
        modified_time_gmt: str = None,
        originator: GetFormDataByIDResponseBodyOriginator = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.form_data = form_data
        self.form_inst_id = form_inst_id
        self.modified_time_gmt = modified_time_gmt
        self.originator = originator
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.originator:
            self.originator.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.form_data is not None:
            result['formData'] = self.form_data
        if self.form_inst_id is not None:
            result['formInstId'] = self.form_inst_id
        if self.modified_time_gmt is not None:
            result['modifiedTimeGMT'] = self.modified_time_gmt
        if self.originator is not None:
            result['originator'] = self.originator.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('formData') is not None:
            self.form_data = m.get('formData')
        if m.get('formInstId') is not None:
            self.form_inst_id = m.get('formInstId')
        if m.get('modifiedTimeGMT') is not None:
            self.modified_time_gmt = m.get('modifiedTimeGMT')
        if m.get('originator') is not None:
            temp_model = GetFormDataByIDResponseBodyOriginator()
            self.originator = temp_model.from_map(m['originator'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetFormDataByIDResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetFormDataByIDResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFormDataByIDResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFormListInAppHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetFormListInAppHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetFormListInAppHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetFormListInAppHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetFormListInAppShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetFormListInAppRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        form_types: str = None,
        page_number: int = None,
        page_size: int = None,
        system_token: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        self.form_types = form_types
        self.page_number = page_number
        self.page_size = page_size
        # This parameter is required.
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.form_types is not None:
            result['FormTypes'] = self.form_types
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('FormTypes') is not None:
            self.form_types = m.get('FormTypes')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class GetFormListInAppResponseBodyDataTitle(TeaModel):
    def __init__(
        self,
        en_us: str = None,
        zh_cn: str = None,
    ):
        self.en_us = en_us
        self.zh_cn = zh_cn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.en_us is not None:
            result['EnUS'] = self.en_us
        if self.zh_cn is not None:
            result['ZhCN'] = self.zh_cn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnUS') is not None:
            self.en_us = m.get('EnUS')
        if m.get('ZhCN') is not None:
            self.zh_cn = m.get('ZhCN')
        return self


class GetFormListInAppResponseBodyData(TeaModel):
    def __init__(
        self,
        creator: str = None,
        form_type: str = None,
        form_uuid: str = None,
        gmt_create: str = None,
        title: GetFormListInAppResponseBodyDataTitle = None,
    ):
        self.creator = creator
        self.form_type = form_type
        self.form_uuid = form_uuid
        self.gmt_create = gmt_create
        self.title = title

    def validate(self):
        if self.title:
            self.title.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.form_type is not None:
            result['FormType'] = self.form_type
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.title is not None:
            result['Title'] = self.title.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('FormType') is not None:
            self.form_type = m.get('FormType')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('Title') is not None:
            temp_model = GetFormListInAppResponseBodyDataTitle()
            self.title = temp_model.from_map(m['Title'])
        return self


class GetFormListInAppResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        data: List[GetFormListInAppResponseBodyData] = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.current_page = current_page
        self.data = data
        self.request_id = request_id
        self.success = success
        self.total_count = total_count
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = GetFormListInAppResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetFormListInAppResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetFormListInAppResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFormListInAppResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetGroupLiveListHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetGroupLiveListHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetGroupLiveListHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetGroupLiveListHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetGroupLiveListShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetGroupLiveListRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetGroupLiveListRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        open_conversation_id: str = None,
        start_time: int = None,
        tenant_context: GetGroupLiveListRequestTenantContext = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        # This parameter is required.
        self.open_conversation_id = open_conversation_id
        # This parameter is required.
        self.start_time = start_time
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.open_conversation_id is not None:
            result['OpenConversationId'] = self.open_conversation_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OpenConversationId') is not None:
            self.open_conversation_id = m.get('OpenConversationId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            temp_model = GetGroupLiveListRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetGroupLiveListShrinkRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        open_conversation_id: str = None,
        start_time: int = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        # This parameter is required.
        self.open_conversation_id = open_conversation_id
        # This parameter is required.
        self.start_time = start_time
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.open_conversation_id is not None:
            result['OpenConversationId'] = self.open_conversation_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OpenConversationId') is not None:
            self.open_conversation_id = m.get('OpenConversationId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetGroupLiveListResponseBodyResultGroupLiveList(TeaModel):
    def __init__(
        self,
        anchor_nickname: str = None,
        anchor_union_id: str = None,
        live_end_time: int = None,
        live_start_time: int = None,
        live_uuid: str = None,
        title: str = None,
    ):
        self.anchor_nickname = anchor_nickname
        self.anchor_union_id = anchor_union_id
        self.live_end_time = live_end_time
        self.live_start_time = live_start_time
        self.live_uuid = live_uuid
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.anchor_nickname is not None:
            result['AnchorNickname'] = self.anchor_nickname
        if self.anchor_union_id is not None:
            result['AnchorUnionId'] = self.anchor_union_id
        if self.live_end_time is not None:
            result['LiveEndTime'] = self.live_end_time
        if self.live_start_time is not None:
            result['LiveStartTime'] = self.live_start_time
        if self.live_uuid is not None:
            result['LiveUuid'] = self.live_uuid
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnchorNickname') is not None:
            self.anchor_nickname = m.get('AnchorNickname')
        if m.get('AnchorUnionId') is not None:
            self.anchor_union_id = m.get('AnchorUnionId')
        if m.get('LiveEndTime') is not None:
            self.live_end_time = m.get('LiveEndTime')
        if m.get('LiveStartTime') is not None:
            self.live_start_time = m.get('LiveStartTime')
        if m.get('LiveUuid') is not None:
            self.live_uuid = m.get('LiveUuid')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class GetGroupLiveListResponseBodyResult(TeaModel):
    def __init__(
        self,
        group_live_list: List[GetGroupLiveListResponseBodyResultGroupLiveList] = None,
    ):
        self.group_live_list = group_live_list

    def validate(self):
        if self.group_live_list:
            for k in self.group_live_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['GroupLiveList'] = []
        if self.group_live_list is not None:
            for k in self.group_live_list:
                result['GroupLiveList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.group_live_list = []
        if m.get('GroupLiveList') is not None:
            for k in m.get('GroupLiveList'):
                temp_model = GetGroupLiveListResponseBodyResultGroupLiveList()
                self.group_live_list.append(temp_model.from_map(k))
        return self


class GetGroupLiveListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: GetGroupLiveListResponseBodyResult = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.result = result
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = GetGroupLiveListResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetGroupLiveListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetGroupLiveListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetGroupLiveListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInnerGroupMembersHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetInnerGroupMembersHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetInnerGroupMembersHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetInnerGroupMembersHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetInnerGroupMembersShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetInnerGroupMembersRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        open_conversation_id: str = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.open_conversation_id = open_conversation_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.open_conversation_id is not None:
            result['OpenConversationId'] = self.open_conversation_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OpenConversationId') is not None:
            self.open_conversation_id = m.get('OpenConversationId')
        return self


class GetInnerGroupMembersResponseBody(TeaModel):
    def __init__(
        self,
        has_more: bool = None,
        next_token: str = None,
        request_id: str = None,
        user_ids: List[str] = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.has_more = has_more
        self.next_token = next_token
        self.request_id = request_id
        self.user_ids = user_ids
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_more is not None:
            result['hasMore'] = self.has_more
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.user_ids is not None:
            result['userIds'] = self.user_ids
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('hasMore') is not None:
            self.has_more = m.get('hasMore')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('userIds') is not None:
            self.user_ids = m.get('userIds')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetInnerGroupMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetInnerGroupMembersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInnerGroupMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInstanceByIdHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetInstanceByIdHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetInstanceByIdHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetInstanceByIdHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetInstanceByIdShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetInstanceByIdRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        id: str = None,
        language: str = None,
        system_token: str = None,
    ):
        self.app_type = app_type
        self.id = id
        self.language = language
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.id is not None:
            result['Id'] = self.id
        if self.language is not None:
            result['Language'] = self.language
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class GetInstanceByIdResponseBodyActionExecutorName(TeaModel):
    def __init__(
        self,
        name_in_chinese: str = None,
        name_in_english: str = None,
        type: str = None,
    ):
        self.name_in_chinese = name_in_chinese
        self.name_in_english = name_in_english
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_in_chinese is not None:
            result['NameInChinese'] = self.name_in_chinese
        if self.name_in_english is not None:
            result['NameInEnglish'] = self.name_in_english
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameInChinese') is not None:
            self.name_in_chinese = m.get('NameInChinese')
        if m.get('NameInEnglish') is not None:
            self.name_in_english = m.get('NameInEnglish')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetInstanceByIdResponseBodyActionExecutor(TeaModel):
    def __init__(
        self,
        dept_name: str = None,
        email: str = None,
        name: GetInstanceByIdResponseBodyActionExecutorName = None,
        user_id: str = None,
    ):
        self.dept_name = dept_name
        self.email = email
        self.name = name
        self.user_id = user_id

    def validate(self):
        if self.name:
            self.name.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dept_name is not None:
            result['DeptName'] = self.dept_name
        if self.email is not None:
            result['Email'] = self.email
        if self.name is not None:
            result['Name'] = self.name.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeptName') is not None:
            self.dept_name = m.get('DeptName')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Name') is not None:
            temp_model = GetInstanceByIdResponseBodyActionExecutorName()
            self.name = temp_model.from_map(m['Name'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetInstanceByIdResponseBodyOriginatorName(TeaModel):
    def __init__(
        self,
        name_in_chinese: str = None,
        name_in_english: str = None,
        type: str = None,
    ):
        self.name_in_chinese = name_in_chinese
        self.name_in_english = name_in_english
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_in_chinese is not None:
            result['NameInChinese'] = self.name_in_chinese
        if self.name_in_english is not None:
            result['NameInEnglish'] = self.name_in_english
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameInChinese') is not None:
            self.name_in_chinese = m.get('NameInChinese')
        if m.get('NameInEnglish') is not None:
            self.name_in_english = m.get('NameInEnglish')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetInstanceByIdResponseBodyOriginator(TeaModel):
    def __init__(
        self,
        dept_name: str = None,
        email: str = None,
        name: GetInstanceByIdResponseBodyOriginatorName = None,
        user_id: str = None,
    ):
        self.dept_name = dept_name
        self.email = email
        self.name = name
        self.user_id = user_id

    def validate(self):
        if self.name:
            self.name.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dept_name is not None:
            result['DeptName'] = self.dept_name
        if self.email is not None:
            result['Email'] = self.email
        if self.name is not None:
            result['Name'] = self.name.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeptName') is not None:
            self.dept_name = m.get('DeptName')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Name') is not None:
            temp_model = GetInstanceByIdResponseBodyOriginatorName()
            self.name = temp_model.from_map(m['Name'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetInstanceByIdResponseBody(TeaModel):
    def __init__(
        self,
        action_executor: List[GetInstanceByIdResponseBodyActionExecutor] = None,
        approved_result: str = None,
        create_time_gmt: str = None,
        data: Dict[str, Any] = None,
        form_uuid: str = None,
        instance_status: str = None,
        modified_time_gmt: str = None,
        originator: GetInstanceByIdResponseBodyOriginator = None,
        process_code: str = None,
        process_instance_id: str = None,
        request_id: str = None,
        title: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
        version: int = None,
    ):
        self.action_executor = action_executor
        self.approved_result = approved_result
        self.create_time_gmt = create_time_gmt
        self.data = data
        self.form_uuid = form_uuid
        self.instance_status = instance_status
        self.modified_time_gmt = modified_time_gmt
        self.originator = originator
        self.process_code = process_code
        self.process_instance_id = process_instance_id
        self.request_id = request_id
        self.title = title
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type
        self.version = version

    def validate(self):
        if self.action_executor:
            for k in self.action_executor:
                if k:
                    k.validate()
        if self.originator:
            self.originator.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['actionExecutor'] = []
        if self.action_executor is not None:
            for k in self.action_executor:
                result['actionExecutor'].append(k.to_map() if k else None)
        if self.approved_result is not None:
            result['approvedResult'] = self.approved_result
        if self.create_time_gmt is not None:
            result['createTimeGMT'] = self.create_time_gmt
        if self.data is not None:
            result['data'] = self.data
        if self.form_uuid is not None:
            result['formUuid'] = self.form_uuid
        if self.instance_status is not None:
            result['instanceStatus'] = self.instance_status
        if self.modified_time_gmt is not None:
            result['modifiedTimeGMT'] = self.modified_time_gmt
        if self.originator is not None:
            result['originator'] = self.originator.to_map()
        if self.process_code is not None:
            result['processCode'] = self.process_code
        if self.process_instance_id is not None:
            result['processInstanceId'] = self.process_instance_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.title is not None:
            result['title'] = self.title
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.action_executor = []
        if m.get('actionExecutor') is not None:
            for k in m.get('actionExecutor'):
                temp_model = GetInstanceByIdResponseBodyActionExecutor()
                self.action_executor.append(temp_model.from_map(k))
        if m.get('approvedResult') is not None:
            self.approved_result = m.get('approvedResult')
        if m.get('createTimeGMT') is not None:
            self.create_time_gmt = m.get('createTimeGMT')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('formUuid') is not None:
            self.form_uuid = m.get('formUuid')
        if m.get('instanceStatus') is not None:
            self.instance_status = m.get('instanceStatus')
        if m.get('modifiedTimeGMT') is not None:
            self.modified_time_gmt = m.get('modifiedTimeGMT')
        if m.get('originator') is not None:
            temp_model = GetInstanceByIdResponseBodyOriginator()
            self.originator = temp_model.from_map(m['originator'])
        if m.get('processCode') is not None:
            self.process_code = m.get('processCode')
        if m.get('processInstanceId') is not None:
            self.process_instance_id = m.get('processInstanceId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class GetInstanceByIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetInstanceByIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInstanceByIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInstanceIdListHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetInstanceIdListHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetInstanceIdListHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetInstanceIdListHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetInstanceIdListShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetInstanceIdListRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        approved_result: str = None,
        create_from_time_gmt: str = None,
        create_to_time_gmt: str = None,
        form_uuid: str = None,
        instance_status: str = None,
        language: str = None,
        modified_from_time_gmt: str = None,
        modified_to_time_gmt: str = None,
        originator_id: str = None,
        page_number: int = None,
        page_size: int = None,
        search_field_json: str = None,
        system_token: str = None,
        task_id: str = None,
    ):
        self.app_type = app_type
        self.approved_result = approved_result
        self.create_from_time_gmt = create_from_time_gmt
        self.create_to_time_gmt = create_to_time_gmt
        self.form_uuid = form_uuid
        self.instance_status = instance_status
        self.language = language
        self.modified_from_time_gmt = modified_from_time_gmt
        self.modified_to_time_gmt = modified_to_time_gmt
        self.originator_id = originator_id
        self.page_number = page_number
        self.page_size = page_size
        self.search_field_json = search_field_json
        self.system_token = system_token
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.approved_result is not None:
            result['ApprovedResult'] = self.approved_result
        if self.create_from_time_gmt is not None:
            result['CreateFromTimeGMT'] = self.create_from_time_gmt
        if self.create_to_time_gmt is not None:
            result['CreateToTimeGMT'] = self.create_to_time_gmt
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.instance_status is not None:
            result['InstanceStatus'] = self.instance_status
        if self.language is not None:
            result['Language'] = self.language
        if self.modified_from_time_gmt is not None:
            result['ModifiedFromTimeGMT'] = self.modified_from_time_gmt
        if self.modified_to_time_gmt is not None:
            result['ModifiedToTimeGMT'] = self.modified_to_time_gmt
        if self.originator_id is not None:
            result['OriginatorId'] = self.originator_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_field_json is not None:
            result['SearchFieldJson'] = self.search_field_json
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('ApprovedResult') is not None:
            self.approved_result = m.get('ApprovedResult')
        if m.get('CreateFromTimeGMT') is not None:
            self.create_from_time_gmt = m.get('CreateFromTimeGMT')
        if m.get('CreateToTimeGMT') is not None:
            self.create_to_time_gmt = m.get('CreateToTimeGMT')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('InstanceStatus') is not None:
            self.instance_status = m.get('InstanceStatus')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('ModifiedFromTimeGMT') is not None:
            self.modified_from_time_gmt = m.get('ModifiedFromTimeGMT')
        if m.get('ModifiedToTimeGMT') is not None:
            self.modified_to_time_gmt = m.get('ModifiedToTimeGMT')
        if m.get('OriginatorId') is not None:
            self.originator_id = m.get('OriginatorId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchFieldJson') is not None:
            self.search_field_json = m.get('SearchFieldJson')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetInstanceIdListResponseBody(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
        page_number: int = None,
        request_id: str = None,
        total_count: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.data = data
        self.page_number = page_number
        self.request_id = request_id
        self.total_count = total_count
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetInstanceIdListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetInstanceIdListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInstanceIdListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInstancesHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetInstancesHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetInstancesHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetInstancesHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetInstancesShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetInstancesRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        approved_result: str = None,
        create_from_time_gmt: str = None,
        create_to_time_gmt: str = None,
        form_uuid: str = None,
        instance_status: str = None,
        language: str = None,
        modified_from_time_gmt: str = None,
        modified_to_time_gmt: str = None,
        order_config_json: str = None,
        originator_id: str = None,
        page_number: int = None,
        page_size: int = None,
        search_field_json: str = None,
        system_token: str = None,
        task_id: str = None,
    ):
        self.app_type = app_type
        self.approved_result = approved_result
        self.create_from_time_gmt = create_from_time_gmt
        self.create_to_time_gmt = create_to_time_gmt
        self.form_uuid = form_uuid
        self.instance_status = instance_status
        self.language = language
        self.modified_from_time_gmt = modified_from_time_gmt
        self.modified_to_time_gmt = modified_to_time_gmt
        self.order_config_json = order_config_json
        self.originator_id = originator_id
        self.page_number = page_number
        self.page_size = page_size
        self.search_field_json = search_field_json
        self.system_token = system_token
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.approved_result is not None:
            result['ApprovedResult'] = self.approved_result
        if self.create_from_time_gmt is not None:
            result['CreateFromTimeGMT'] = self.create_from_time_gmt
        if self.create_to_time_gmt is not None:
            result['CreateToTimeGMT'] = self.create_to_time_gmt
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.instance_status is not None:
            result['InstanceStatus'] = self.instance_status
        if self.language is not None:
            result['Language'] = self.language
        if self.modified_from_time_gmt is not None:
            result['ModifiedFromTimeGMT'] = self.modified_from_time_gmt
        if self.modified_to_time_gmt is not None:
            result['ModifiedToTimeGMT'] = self.modified_to_time_gmt
        if self.order_config_json is not None:
            result['OrderConfigJson'] = self.order_config_json
        if self.originator_id is not None:
            result['OriginatorId'] = self.originator_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_field_json is not None:
            result['SearchFieldJson'] = self.search_field_json
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('ApprovedResult') is not None:
            self.approved_result = m.get('ApprovedResult')
        if m.get('CreateFromTimeGMT') is not None:
            self.create_from_time_gmt = m.get('CreateFromTimeGMT')
        if m.get('CreateToTimeGMT') is not None:
            self.create_to_time_gmt = m.get('CreateToTimeGMT')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('InstanceStatus') is not None:
            self.instance_status = m.get('InstanceStatus')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('ModifiedFromTimeGMT') is not None:
            self.modified_from_time_gmt = m.get('ModifiedFromTimeGMT')
        if m.get('ModifiedToTimeGMT') is not None:
            self.modified_to_time_gmt = m.get('ModifiedToTimeGMT')
        if m.get('OrderConfigJson') is not None:
            self.order_config_json = m.get('OrderConfigJson')
        if m.get('OriginatorId') is not None:
            self.originator_id = m.get('OriginatorId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchFieldJson') is not None:
            self.search_field_json = m.get('SearchFieldJson')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetInstancesResponseBodyDataActionExecutorName(TeaModel):
    def __init__(
        self,
        name_in_chinese: str = None,
        name_in_english: str = None,
        type: str = None,
    ):
        self.name_in_chinese = name_in_chinese
        self.name_in_english = name_in_english
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_in_chinese is not None:
            result['NameInChinese'] = self.name_in_chinese
        if self.name_in_english is not None:
            result['NameInEnglish'] = self.name_in_english
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameInChinese') is not None:
            self.name_in_chinese = m.get('NameInChinese')
        if m.get('NameInEnglish') is not None:
            self.name_in_english = m.get('NameInEnglish')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetInstancesResponseBodyDataActionExecutor(TeaModel):
    def __init__(
        self,
        dept_name: str = None,
        email: str = None,
        name: GetInstancesResponseBodyDataActionExecutorName = None,
        user_id: str = None,
    ):
        self.dept_name = dept_name
        self.email = email
        self.name = name
        self.user_id = user_id

    def validate(self):
        if self.name:
            self.name.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dept_name is not None:
            result['DeptName'] = self.dept_name
        if self.email is not None:
            result['Email'] = self.email
        if self.name is not None:
            result['Name'] = self.name.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeptName') is not None:
            self.dept_name = m.get('DeptName')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Name') is not None:
            temp_model = GetInstancesResponseBodyDataActionExecutorName()
            self.name = temp_model.from_map(m['Name'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetInstancesResponseBodyDataOriginatorName(TeaModel):
    def __init__(
        self,
        name_in_chinese: str = None,
        name_in_english: str = None,
        type: str = None,
    ):
        self.name_in_chinese = name_in_chinese
        self.name_in_english = name_in_english
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_in_chinese is not None:
            result['NameInChinese'] = self.name_in_chinese
        if self.name_in_english is not None:
            result['NameInEnglish'] = self.name_in_english
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameInChinese') is not None:
            self.name_in_chinese = m.get('NameInChinese')
        if m.get('NameInEnglish') is not None:
            self.name_in_english = m.get('NameInEnglish')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetInstancesResponseBodyDataOriginator(TeaModel):
    def __init__(
        self,
        dept_name: str = None,
        email: str = None,
        name: GetInstancesResponseBodyDataOriginatorName = None,
        user_id: str = None,
    ):
        self.dept_name = dept_name
        self.email = email
        self.name = name
        self.user_id = user_id

    def validate(self):
        if self.name:
            self.name.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dept_name is not None:
            result['DeptName'] = self.dept_name
        if self.email is not None:
            result['Email'] = self.email
        if self.name is not None:
            result['Name'] = self.name.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeptName') is not None:
            self.dept_name = m.get('DeptName')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Name') is not None:
            temp_model = GetInstancesResponseBodyDataOriginatorName()
            self.name = temp_model.from_map(m['Name'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetInstancesResponseBodyData(TeaModel):
    def __init__(
        self,
        action_executor: List[GetInstancesResponseBodyDataActionExecutor] = None,
        approved_result: str = None,
        create_time_gmt: str = None,
        data: Dict[str, Any] = None,
        form_uuid: str = None,
        instance_status: str = None,
        modified_time_gmt: str = None,
        originator: GetInstancesResponseBodyDataOriginator = None,
        process_code: str = None,
        process_instance_id: str = None,
        title: str = None,
        version: int = None,
    ):
        self.action_executor = action_executor
        self.approved_result = approved_result
        self.create_time_gmt = create_time_gmt
        self.data = data
        self.form_uuid = form_uuid
        self.instance_status = instance_status
        self.modified_time_gmt = modified_time_gmt
        self.originator = originator
        self.process_code = process_code
        self.process_instance_id = process_instance_id
        self.title = title
        self.version = version

    def validate(self):
        if self.action_executor:
            for k in self.action_executor:
                if k:
                    k.validate()
        if self.originator:
            self.originator.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ActionExecutor'] = []
        if self.action_executor is not None:
            for k in self.action_executor:
                result['ActionExecutor'].append(k.to_map() if k else None)
        if self.approved_result is not None:
            result['ApprovedResult'] = self.approved_result
        if self.create_time_gmt is not None:
            result['CreateTimeGMT'] = self.create_time_gmt
        if self.data is not None:
            result['Data'] = self.data
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.instance_status is not None:
            result['InstanceStatus'] = self.instance_status
        if self.modified_time_gmt is not None:
            result['ModifiedTimeGMT'] = self.modified_time_gmt
        if self.originator is not None:
            result['Originator'] = self.originator.to_map()
        if self.process_code is not None:
            result['ProcessCode'] = self.process_code
        if self.process_instance_id is not None:
            result['ProcessInstanceId'] = self.process_instance_id
        if self.title is not None:
            result['Title'] = self.title
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.action_executor = []
        if m.get('ActionExecutor') is not None:
            for k in m.get('ActionExecutor'):
                temp_model = GetInstancesResponseBodyDataActionExecutor()
                self.action_executor.append(temp_model.from_map(k))
        if m.get('ApprovedResult') is not None:
            self.approved_result = m.get('ApprovedResult')
        if m.get('CreateTimeGMT') is not None:
            self.create_time_gmt = m.get('CreateTimeGMT')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('InstanceStatus') is not None:
            self.instance_status = m.get('InstanceStatus')
        if m.get('ModifiedTimeGMT') is not None:
            self.modified_time_gmt = m.get('ModifiedTimeGMT')
        if m.get('Originator') is not None:
            temp_model = GetInstancesResponseBodyDataOriginator()
            self.originator = temp_model.from_map(m['Originator'])
        if m.get('ProcessCode') is not None:
            self.process_code = m.get('ProcessCode')
        if m.get('ProcessInstanceId') is not None:
            self.process_instance_id = m.get('ProcessInstanceId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class GetInstancesResponseBody(TeaModel):
    def __init__(
        self,
        data: List[GetInstancesResponseBodyData] = None,
        page_number: int = None,
        request_id: str = None,
        total_count: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.data = data
        self.page_number = page_number
        self.request_id = request_id
        self.total_count = total_count
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = GetInstancesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInstancesByIdListHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetInstancesByIdListHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetInstancesByIdListHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetInstancesByIdListHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetInstancesByIdListShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetInstancesByIdListRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        language: str = None,
        process_instance_ids: str = None,
        system_token: str = None,
    ):
        self.app_type = app_type
        self.language = language
        self.process_instance_ids = process_instance_ids
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.language is not None:
            result['Language'] = self.language
        if self.process_instance_ids is not None:
            result['ProcessInstanceIds'] = self.process_instance_ids
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('ProcessInstanceIds') is not None:
            self.process_instance_ids = m.get('ProcessInstanceIds')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class GetInstancesByIdListResponseBodyResultActionExecutorName(TeaModel):
    def __init__(
        self,
        name_in_chinese: str = None,
        name_in_english: str = None,
        type: str = None,
    ):
        self.name_in_chinese = name_in_chinese
        self.name_in_english = name_in_english
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_in_chinese is not None:
            result['NameInChinese'] = self.name_in_chinese
        if self.name_in_english is not None:
            result['NameInEnglish'] = self.name_in_english
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameInChinese') is not None:
            self.name_in_chinese = m.get('NameInChinese')
        if m.get('NameInEnglish') is not None:
            self.name_in_english = m.get('NameInEnglish')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetInstancesByIdListResponseBodyResultActionExecutor(TeaModel):
    def __init__(
        self,
        department_name: str = None,
        email: str = None,
        name: GetInstancesByIdListResponseBodyResultActionExecutorName = None,
        user_id: str = None,
    ):
        self.department_name = department_name
        self.email = email
        self.name = name
        self.user_id = user_id

    def validate(self):
        if self.name:
            self.name.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.department_name is not None:
            result['DepartmentName'] = self.department_name
        if self.email is not None:
            result['Email'] = self.email
        if self.name is not None:
            result['Name'] = self.name.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DepartmentName') is not None:
            self.department_name = m.get('DepartmentName')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Name') is not None:
            temp_model = GetInstancesByIdListResponseBodyResultActionExecutorName()
            self.name = temp_model.from_map(m['Name'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetInstancesByIdListResponseBodyResultOriginatorName(TeaModel):
    def __init__(
        self,
        name_in_chinese: str = None,
        name_in_english: str = None,
        type: str = None,
    ):
        self.name_in_chinese = name_in_chinese
        self.name_in_english = name_in_english
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_in_chinese is not None:
            result['NameInChinese'] = self.name_in_chinese
        if self.name_in_english is not None:
            result['NameInEnglish'] = self.name_in_english
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameInChinese') is not None:
            self.name_in_chinese = m.get('NameInChinese')
        if m.get('NameInEnglish') is not None:
            self.name_in_english = m.get('NameInEnglish')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetInstancesByIdListResponseBodyResultOriginator(TeaModel):
    def __init__(
        self,
        department_name: str = None,
        email: str = None,
        name: GetInstancesByIdListResponseBodyResultOriginatorName = None,
        user_id: str = None,
    ):
        self.department_name = department_name
        self.email = email
        self.name = name
        self.user_id = user_id

    def validate(self):
        if self.name:
            self.name.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.department_name is not None:
            result['DepartmentName'] = self.department_name
        if self.email is not None:
            result['Email'] = self.email
        if self.name is not None:
            result['Name'] = self.name.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DepartmentName') is not None:
            self.department_name = m.get('DepartmentName')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Name') is not None:
            temp_model = GetInstancesByIdListResponseBodyResultOriginatorName()
            self.name = temp_model.from_map(m['Name'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetInstancesByIdListResponseBodyResult(TeaModel):
    def __init__(
        self,
        action_executor: List[GetInstancesByIdListResponseBodyResultActionExecutor] = None,
        approved_result: str = None,
        data: Dict[str, Any] = None,
        form_uuid: str = None,
        instance_status: str = None,
        originator: GetInstancesByIdListResponseBodyResultOriginator = None,
        process_code: str = None,
        process_instance_id: str = None,
        title: str = None,
    ):
        self.action_executor = action_executor
        self.approved_result = approved_result
        self.data = data
        self.form_uuid = form_uuid
        self.instance_status = instance_status
        self.originator = originator
        self.process_code = process_code
        self.process_instance_id = process_instance_id
        self.title = title

    def validate(self):
        if self.action_executor:
            for k in self.action_executor:
                if k:
                    k.validate()
        if self.originator:
            self.originator.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ActionExecutor'] = []
        if self.action_executor is not None:
            for k in self.action_executor:
                result['ActionExecutor'].append(k.to_map() if k else None)
        if self.approved_result is not None:
            result['ApprovedResult'] = self.approved_result
        if self.data is not None:
            result['Data'] = self.data
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.instance_status is not None:
            result['InstanceStatus'] = self.instance_status
        if self.originator is not None:
            result['Originator'] = self.originator.to_map()
        if self.process_code is not None:
            result['ProcessCode'] = self.process_code
        if self.process_instance_id is not None:
            result['ProcessInstanceId'] = self.process_instance_id
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.action_executor = []
        if m.get('ActionExecutor') is not None:
            for k in m.get('ActionExecutor'):
                temp_model = GetInstancesByIdListResponseBodyResultActionExecutor()
                self.action_executor.append(temp_model.from_map(k))
        if m.get('ApprovedResult') is not None:
            self.approved_result = m.get('ApprovedResult')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('InstanceStatus') is not None:
            self.instance_status = m.get('InstanceStatus')
        if m.get('Originator') is not None:
            temp_model = GetInstancesByIdListResponseBodyResultOriginator()
            self.originator = temp_model.from_map(m['Originator'])
        if m.get('ProcessCode') is not None:
            self.process_code = m.get('ProcessCode')
        if m.get('ProcessInstanceId') is not None:
            self.process_instance_id = m.get('ProcessInstanceId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class GetInstancesByIdListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: List[GetInstancesByIdListResponseBodyResult] = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.result = result
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = GetInstancesByIdListResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetInstancesByIdListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetInstancesByIdListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInstancesByIdListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLiveReplayUrlHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetLiveReplayUrlHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetLiveReplayUrlHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetLiveReplayUrlHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetLiveReplayUrlShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetLiveReplayUrlRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetLiveReplayUrlRequest(TeaModel):
    def __init__(
        self,
        live_id: str = None,
        tenant_context: GetLiveReplayUrlRequestTenantContext = None,
    ):
        # This parameter is required.
        self.live_id = live_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_id is not None:
            result['LiveId'] = self.live_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveId') is not None:
            self.live_id = m.get('LiveId')
        if m.get('TenantContext') is not None:
            temp_model = GetLiveReplayUrlRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetLiveReplayUrlShrinkRequest(TeaModel):
    def __init__(
        self,
        live_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.live_id = live_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_id is not None:
            result['LiveId'] = self.live_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveId') is not None:
            self.live_id = m.get('LiveId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetLiveReplayUrlResponseBody(TeaModel):
    def __init__(
        self,
        replay_url: str = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.replay_url = replay_url
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.replay_url is not None:
            result['replayUrl'] = self.replay_url
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('replayUrl') is not None:
            self.replay_url = m.get('replayUrl')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetLiveReplayUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLiveReplayUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLiveReplayUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMeCorpSubmissionHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetMeCorpSubmissionHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetMeCorpSubmissionHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetMeCorpSubmissionHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetMeCorpSubmissionShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetMeCorpSubmissionRequest(TeaModel):
    def __init__(
        self,
        app_types: str = None,
        corp_id: str = None,
        create_from_time_gmt: int = None,
        create_to_time_gmt: int = None,
        keyword: str = None,
        language: str = None,
        page_number: int = None,
        page_size: int = None,
        process_codes: str = None,
        token: str = None,
    ):
        self.app_types = app_types
        self.corp_id = corp_id
        self.create_from_time_gmt = create_from_time_gmt
        self.create_to_time_gmt = create_to_time_gmt
        self.keyword = keyword
        self.language = language
        self.page_number = page_number
        self.page_size = page_size
        self.process_codes = process_codes
        self.token = token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_types is not None:
            result['AppTypes'] = self.app_types
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.create_from_time_gmt is not None:
            result['CreateFromTimeGMT'] = self.create_from_time_gmt
        if self.create_to_time_gmt is not None:
            result['CreateToTimeGMT'] = self.create_to_time_gmt
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.language is not None:
            result['Language'] = self.language
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.process_codes is not None:
            result['ProcessCodes'] = self.process_codes
        if self.token is not None:
            result['Token'] = self.token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppTypes') is not None:
            self.app_types = m.get('AppTypes')
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('CreateFromTimeGMT') is not None:
            self.create_from_time_gmt = m.get('CreateFromTimeGMT')
        if m.get('CreateToTimeGMT') is not None:
            self.create_to_time_gmt = m.get('CreateToTimeGMT')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProcessCodes') is not None:
            self.process_codes = m.get('ProcessCodes')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        return self


class GetMeCorpSubmissionResponseBodyDataActioner(TeaModel):
    def __init__(
        self,
        bu_name: str = None,
        email: str = None,
        employee_type: str = None,
        employee_type_information: str = None,
        human_resource_group_work_number: str = None,
        is_system_admin: bool = None,
        level: str = None,
        name: str = None,
        nick_name: str = None,
        order_number: str = None,
        personal_photo: str = None,
        personal_photo_url: str = None,
        pinyin_name_all: str = None,
        pinyin_nick_name: str = None,
        state: str = None,
        super_user_id: str = None,
        tb_wang: str = None,
        user_id: str = None,
    ):
        self.bu_name = bu_name
        self.email = email
        self.employee_type = employee_type
        self.employee_type_information = employee_type_information
        self.human_resource_group_work_number = human_resource_group_work_number
        self.is_system_admin = is_system_admin
        self.level = level
        self.name = name
        self.nick_name = nick_name
        self.order_number = order_number
        self.personal_photo = personal_photo
        self.personal_photo_url = personal_photo_url
        self.pinyin_name_all = pinyin_name_all
        self.pinyin_nick_name = pinyin_nick_name
        self.state = state
        self.super_user_id = super_user_id
        self.tb_wang = tb_wang
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bu_name is not None:
            result['BuName'] = self.bu_name
        if self.email is not None:
            result['Email'] = self.email
        if self.employee_type is not None:
            result['EmployeeType'] = self.employee_type
        if self.employee_type_information is not None:
            result['EmployeeTypeInformation'] = self.employee_type_information
        if self.human_resource_group_work_number is not None:
            result['HumanResourceGroupWorkNumber'] = self.human_resource_group_work_number
        if self.is_system_admin is not None:
            result['IsSystemAdmin'] = self.is_system_admin
        if self.level is not None:
            result['Level'] = self.level
        if self.name is not None:
            result['Name'] = self.name
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.order_number is not None:
            result['OrderNumber'] = self.order_number
        if self.personal_photo is not None:
            result['PersonalPhoto'] = self.personal_photo
        if self.personal_photo_url is not None:
            result['PersonalPhotoUrl'] = self.personal_photo_url
        if self.pinyin_name_all is not None:
            result['PinyinNameAll'] = self.pinyin_name_all
        if self.pinyin_nick_name is not None:
            result['PinyinNickName'] = self.pinyin_nick_name
        if self.state is not None:
            result['State'] = self.state
        if self.super_user_id is not None:
            result['SuperUserId'] = self.super_user_id
        if self.tb_wang is not None:
            result['TbWang'] = self.tb_wang
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BuName') is not None:
            self.bu_name = m.get('BuName')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('EmployeeType') is not None:
            self.employee_type = m.get('EmployeeType')
        if m.get('EmployeeTypeInformation') is not None:
            self.employee_type_information = m.get('EmployeeTypeInformation')
        if m.get('HumanResourceGroupWorkNumber') is not None:
            self.human_resource_group_work_number = m.get('HumanResourceGroupWorkNumber')
        if m.get('IsSystemAdmin') is not None:
            self.is_system_admin = m.get('IsSystemAdmin')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('OrderNumber') is not None:
            self.order_number = m.get('OrderNumber')
        if m.get('PersonalPhoto') is not None:
            self.personal_photo = m.get('PersonalPhoto')
        if m.get('PersonalPhotoUrl') is not None:
            self.personal_photo_url = m.get('PersonalPhotoUrl')
        if m.get('PinyinNameAll') is not None:
            self.pinyin_name_all = m.get('PinyinNameAll')
        if m.get('PinyinNickName') is not None:
            self.pinyin_nick_name = m.get('PinyinNickName')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('SuperUserId') is not None:
            self.super_user_id = m.get('SuperUserId')
        if m.get('TbWang') is not None:
            self.tb_wang = m.get('TbWang')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetMeCorpSubmissionResponseBodyDataCurrentActivityInstances(TeaModel):
    def __init__(
        self,
        activity_id: str = None,
        activity_instance_status: str = None,
        activity_name: str = None,
        activity_name_en: str = None,
        id: int = None,
    ):
        self.activity_id = activity_id
        self.activity_instance_status = activity_instance_status
        self.activity_name = activity_name
        self.activity_name_en = activity_name_en
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_id is not None:
            result['ActivityId'] = self.activity_id
        if self.activity_instance_status is not None:
            result['ActivityInstanceStatus'] = self.activity_instance_status
        if self.activity_name is not None:
            result['ActivityName'] = self.activity_name
        if self.activity_name_en is not None:
            result['ActivityNameEn'] = self.activity_name_en
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityId') is not None:
            self.activity_id = m.get('ActivityId')
        if m.get('ActivityInstanceStatus') is not None:
            self.activity_instance_status = m.get('ActivityInstanceStatus')
        if m.get('ActivityName') is not None:
            self.activity_name = m.get('ActivityName')
        if m.get('ActivityNameEn') is not None:
            self.activity_name_en = m.get('ActivityNameEn')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetMeCorpSubmissionResponseBodyData(TeaModel):
    def __init__(
        self,
        actioner: List[GetMeCorpSubmissionResponseBodyDataActioner] = None,
        actioner_id: List[str] = None,
        actioner_name: List[str] = None,
        app_type: str = None,
        create_time_gmt: str = None,
        current_activity_instances: List[GetMeCorpSubmissionResponseBodyDataCurrentActivityInstances] = None,
        data_map: Dict[str, Any] = None,
        data_type: str = None,
        finish_time_gmt: str = None,
        form_instance_id: str = None,
        form_uuid: str = None,
        instance_value: str = None,
        modified_time_gmt: str = None,
        originator_avatar: str = None,
        originator_display_name: str = None,
        originator_id: str = None,
        process_approved_result: str = None,
        process_approved_result_text: str = None,
        process_code: str = None,
        process_id: int = None,
        process_instance_id: str = None,
        process_instance_status: str = None,
        process_instance_status_text: str = None,
        process_name: str = None,
        title: str = None,
        version: int = None,
    ):
        self.actioner = actioner
        self.actioner_id = actioner_id
        self.actioner_name = actioner_name
        self.app_type = app_type
        self.create_time_gmt = create_time_gmt
        self.current_activity_instances = current_activity_instances
        self.data_map = data_map
        self.data_type = data_type
        self.finish_time_gmt = finish_time_gmt
        self.form_instance_id = form_instance_id
        self.form_uuid = form_uuid
        self.instance_value = instance_value
        self.modified_time_gmt = modified_time_gmt
        self.originator_avatar = originator_avatar
        self.originator_display_name = originator_display_name
        self.originator_id = originator_id
        self.process_approved_result = process_approved_result
        self.process_approved_result_text = process_approved_result_text
        self.process_code = process_code
        self.process_id = process_id
        self.process_instance_id = process_instance_id
        self.process_instance_status = process_instance_status
        self.process_instance_status_text = process_instance_status_text
        self.process_name = process_name
        self.title = title
        self.version = version

    def validate(self):
        if self.actioner:
            for k in self.actioner:
                if k:
                    k.validate()
        if self.current_activity_instances:
            for k in self.current_activity_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Actioner'] = []
        if self.actioner is not None:
            for k in self.actioner:
                result['Actioner'].append(k.to_map() if k else None)
        if self.actioner_id is not None:
            result['ActionerId'] = self.actioner_id
        if self.actioner_name is not None:
            result['ActionerName'] = self.actioner_name
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.create_time_gmt is not None:
            result['CreateTimeGMT'] = self.create_time_gmt
        result['CurrentActivityInstances'] = []
        if self.current_activity_instances is not None:
            for k in self.current_activity_instances:
                result['CurrentActivityInstances'].append(k.to_map() if k else None)
        if self.data_map is not None:
            result['DataMap'] = self.data_map
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.finish_time_gmt is not None:
            result['FinishTimeGMT'] = self.finish_time_gmt
        if self.form_instance_id is not None:
            result['FormInstanceId'] = self.form_instance_id
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.instance_value is not None:
            result['InstanceValue'] = self.instance_value
        if self.modified_time_gmt is not None:
            result['ModifiedTimeGMT'] = self.modified_time_gmt
        if self.originator_avatar is not None:
            result['OriginatorAvatar'] = self.originator_avatar
        if self.originator_display_name is not None:
            result['OriginatorDisplayName'] = self.originator_display_name
        if self.originator_id is not None:
            result['OriginatorId'] = self.originator_id
        if self.process_approved_result is not None:
            result['ProcessApprovedResult'] = self.process_approved_result
        if self.process_approved_result_text is not None:
            result['ProcessApprovedResultText'] = self.process_approved_result_text
        if self.process_code is not None:
            result['ProcessCode'] = self.process_code
        if self.process_id is not None:
            result['ProcessId'] = self.process_id
        if self.process_instance_id is not None:
            result['ProcessInstanceId'] = self.process_instance_id
        if self.process_instance_status is not None:
            result['ProcessInstanceStatus'] = self.process_instance_status
        if self.process_instance_status_text is not None:
            result['ProcessInstanceStatusText'] = self.process_instance_status_text
        if self.process_name is not None:
            result['ProcessName'] = self.process_name
        if self.title is not None:
            result['Title'] = self.title
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.actioner = []
        if m.get('Actioner') is not None:
            for k in m.get('Actioner'):
                temp_model = GetMeCorpSubmissionResponseBodyDataActioner()
                self.actioner.append(temp_model.from_map(k))
        if m.get('ActionerId') is not None:
            self.actioner_id = m.get('ActionerId')
        if m.get('ActionerName') is not None:
            self.actioner_name = m.get('ActionerName')
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('CreateTimeGMT') is not None:
            self.create_time_gmt = m.get('CreateTimeGMT')
        self.current_activity_instances = []
        if m.get('CurrentActivityInstances') is not None:
            for k in m.get('CurrentActivityInstances'):
                temp_model = GetMeCorpSubmissionResponseBodyDataCurrentActivityInstances()
                self.current_activity_instances.append(temp_model.from_map(k))
        if m.get('DataMap') is not None:
            self.data_map = m.get('DataMap')
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('FinishTimeGMT') is not None:
            self.finish_time_gmt = m.get('FinishTimeGMT')
        if m.get('FormInstanceId') is not None:
            self.form_instance_id = m.get('FormInstanceId')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('InstanceValue') is not None:
            self.instance_value = m.get('InstanceValue')
        if m.get('ModifiedTimeGMT') is not None:
            self.modified_time_gmt = m.get('ModifiedTimeGMT')
        if m.get('OriginatorAvatar') is not None:
            self.originator_avatar = m.get('OriginatorAvatar')
        if m.get('OriginatorDisplayName') is not None:
            self.originator_display_name = m.get('OriginatorDisplayName')
        if m.get('OriginatorId') is not None:
            self.originator_id = m.get('OriginatorId')
        if m.get('ProcessApprovedResult') is not None:
            self.process_approved_result = m.get('ProcessApprovedResult')
        if m.get('ProcessApprovedResultText') is not None:
            self.process_approved_result_text = m.get('ProcessApprovedResultText')
        if m.get('ProcessCode') is not None:
            self.process_code = m.get('ProcessCode')
        if m.get('ProcessId') is not None:
            self.process_id = m.get('ProcessId')
        if m.get('ProcessInstanceId') is not None:
            self.process_instance_id = m.get('ProcessInstanceId')
        if m.get('ProcessInstanceStatus') is not None:
            self.process_instance_status = m.get('ProcessInstanceStatus')
        if m.get('ProcessInstanceStatusText') is not None:
            self.process_instance_status_text = m.get('ProcessInstanceStatusText')
        if m.get('ProcessName') is not None:
            self.process_name = m.get('ProcessName')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class GetMeCorpSubmissionResponseBody(TeaModel):
    def __init__(
        self,
        data: List[GetMeCorpSubmissionResponseBodyData] = None,
        page_number: int = None,
        request_id: str = None,
        total_count: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.data = data
        self.page_number = page_number
        self.request_id = request_id
        self.total_count = total_count
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = GetMeCorpSubmissionResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetMeCorpSubmissionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMeCorpSubmissionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMeCorpSubmissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMeetingRoomsScheduleHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetMeetingRoomsScheduleHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetMeetingRoomsScheduleHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetMeetingRoomsScheduleHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetMeetingRoomsScheduleShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetMeetingRoomsScheduleRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        room_ids: List[str] = None,
        start_time: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        # This parameter is required.
        self.room_ids = room_ids
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.room_ids is not None:
            result['RoomIds'] = self.room_ids
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RoomIds') is not None:
            self.room_ids = m.get('RoomIds')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetMeetingRoomsScheduleShrinkRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        room_ids_shrink: str = None,
        start_time: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        # This parameter is required.
        self.room_ids_shrink = room_ids_shrink
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.room_ids_shrink is not None:
            result['RoomIds'] = self.room_ids_shrink
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RoomIds') is not None:
            self.room_ids_shrink = m.get('RoomIds')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsEnd(TeaModel):
    def __init__(
        self,
        date_time: str = None,
        time_zone: str = None,
    ):
        self.date_time = date_time
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.time_zone is not None:
            result['TimeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('TimeZone') is not None:
            self.time_zone = m.get('TimeZone')
        return self


class GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsOrganizer(TeaModel):
    def __init__(
        self,
        id: str = None,
    ):
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsStart(TeaModel):
    def __init__(
        self,
        date_time: str = None,
        time_zone: str = None,
    ):
        self.date_time = date_time
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.time_zone is not None:
            result['TimeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('TimeZone') is not None:
            self.time_zone = m.get('TimeZone')
        return self


class GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItems(TeaModel):
    def __init__(
        self,
        end: GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsEnd = None,
        event_id: str = None,
        organizer: GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsOrganizer = None,
        start: GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsStart = None,
        status: str = None,
    ):
        self.end = end
        self.event_id = event_id
        self.organizer = organizer
        self.start = start
        self.status = status

    def validate(self):
        if self.end:
            self.end.validate()
        if self.organizer:
            self.organizer.validate()
        if self.start:
            self.start.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end.to_map()
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.organizer is not None:
            result['Organizer'] = self.organizer.to_map()
        if self.start is not None:
            result['Start'] = self.start.to_map()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('End') is not None:
            temp_model = GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsEnd()
            self.end = temp_model.from_map(m['End'])
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('Organizer') is not None:
            temp_model = GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsOrganizer()
            self.organizer = temp_model.from_map(m['Organizer'])
        if m.get('Start') is not None:
            temp_model = GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsStart()
            self.start = temp_model.from_map(m['Start'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetMeetingRoomsScheduleResponseBodyScheduleInformation(TeaModel):
    def __init__(
        self,
        error: str = None,
        room_id: str = None,
        schedule_items: List[GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItems] = None,
    ):
        self.error = error
        self.room_id = room_id
        self.schedule_items = schedule_items

    def validate(self):
        if self.schedule_items:
            for k in self.schedule_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error is not None:
            result['Error'] = self.error
        if self.room_id is not None:
            result['RoomId'] = self.room_id
        result['ScheduleItems'] = []
        if self.schedule_items is not None:
            for k in self.schedule_items:
                result['ScheduleItems'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Error') is not None:
            self.error = m.get('Error')
        if m.get('RoomId') is not None:
            self.room_id = m.get('RoomId')
        self.schedule_items = []
        if m.get('ScheduleItems') is not None:
            for k in m.get('ScheduleItems'):
                temp_model = GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItems()
                self.schedule_items.append(temp_model.from_map(k))
        return self


class GetMeetingRoomsScheduleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        schedule_information: List[GetMeetingRoomsScheduleResponseBodyScheduleInformation] = None,
    ):
        # requestId
        self.request_id = request_id
        self.schedule_information = schedule_information

    def validate(self):
        if self.schedule_information:
            for k in self.schedule_information:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['scheduleInformation'] = []
        if self.schedule_information is not None:
            for k in self.schedule_information:
                result['scheduleInformation'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.schedule_information = []
        if m.get('scheduleInformation') is not None:
            for k in m.get('scheduleInformation'):
                temp_model = GetMeetingRoomsScheduleResponseBodyScheduleInformation()
                self.schedule_information.append(temp_model.from_map(k))
        return self


class GetMeetingRoomsScheduleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMeetingRoomsScheduleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMeetingRoomsScheduleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMineWorkspaceHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetMineWorkspaceHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetMineWorkspaceHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetMineWorkspaceHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetMineWorkspaceShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetMineWorkspaceRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetMineWorkspaceRequest(TeaModel):
    def __init__(
        self,
        request: Dict[str, Any] = None,
        tenant_context: GetMineWorkspaceRequestTenantContext = None,
    ):
        self.request = request
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request is not None:
            result['Request'] = self.request
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Request') is not None:
            self.request = m.get('Request')
        if m.get('TenantContext') is not None:
            temp_model = GetMineWorkspaceRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetMineWorkspaceShrinkRequest(TeaModel):
    def __init__(
        self,
        request_shrink: str = None,
        tenant_context_shrink: str = None,
    ):
        self.request_shrink = request_shrink
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_shrink is not None:
            result['Request'] = self.request_shrink
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Request') is not None:
            self.request_shrink = m.get('Request')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetMineWorkspaceResponseBodyWorkspaceIcon(TeaModel):
    def __init__(
        self,
        type: str = None,
        value: str = None,
    ):
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetMineWorkspaceResponseBodyWorkspace(TeaModel):
    def __init__(
        self,
        corp_id: str = None,
        cover: str = None,
        create_time: str = None,
        creator_id: str = None,
        description: str = None,
        icon: GetMineWorkspaceResponseBodyWorkspaceIcon = None,
        modified_time: str = None,
        modifier_id: str = None,
        name: str = None,
        permission_role: str = None,
        root_node_id: str = None,
        team_id: str = None,
        type: str = None,
        url: str = None,
        workspace_id: str = None,
    ):
        self.corp_id = corp_id
        self.cover = cover
        self.create_time = create_time
        self.creator_id = creator_id
        self.description = description
        self.icon = icon
        self.modified_time = modified_time
        self.modifier_id = modifier_id
        self.name = name
        self.permission_role = permission_role
        self.root_node_id = root_node_id
        self.team_id = team_id
        self.type = type
        self.url = url
        self.workspace_id = workspace_id

    def validate(self):
        if self.icon:
            self.icon.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.cover is not None:
            result['Cover'] = self.cover
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.icon is not None:
            result['Icon'] = self.icon.to_map()
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.name is not None:
            result['Name'] = self.name
        if self.permission_role is not None:
            result['PermissionRole'] = self.permission_role
        if self.root_node_id is not None:
            result['RootNodeId'] = self.root_node_id
        if self.team_id is not None:
            result['TeamId'] = self.team_id
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('Cover') is not None:
            self.cover = m.get('Cover')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Icon') is not None:
            temp_model = GetMineWorkspaceResponseBodyWorkspaceIcon()
            self.icon = temp_model.from_map(m['Icon'])
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PermissionRole') is not None:
            self.permission_role = m.get('PermissionRole')
        if m.get('RootNodeId') is not None:
            self.root_node_id = m.get('RootNodeId')
        if m.get('TeamId') is not None:
            self.team_id = m.get('TeamId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetMineWorkspaceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        workspace: GetMineWorkspaceResponseBodyWorkspace = None,
    ):
        # requestId
        self.request_id = request_id
        self.workspace = workspace

    def validate(self):
        if self.workspace:
            self.workspace.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.workspace is not None:
            result['workspace'] = self.workspace.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('workspace') is not None:
            temp_model = GetMineWorkspaceResponseBodyWorkspace()
            self.workspace = temp_model.from_map(m['workspace'])
        return self


class GetMineWorkspaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMineWorkspaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMineWorkspaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMultiDimTableAllFieldsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetMultiDimTableAllFieldsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetMultiDimTableAllFieldsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetMultiDimTableAllFieldsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetMultiDimTableAllFieldsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetMultiDimTableAllFieldsRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetMultiDimTableAllFieldsRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        sheet_id_or_name: str = None,
        tenant_context: GetMultiDimTableAllFieldsRequestTenantContext = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            temp_model = GetMultiDimTableAllFieldsRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetMultiDimTableAllFieldsShrinkRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        sheet_id_or_name: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetMultiDimTableAllFieldsResponseBodyValue(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        property: Dict[str, Any] = None,
        type: str = None,
    ):
        self.id = id
        self.name = name
        self.property = property
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.property is not None:
            result['Property'] = self.property
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Property') is not None:
            self.property = m.get('Property')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetMultiDimTableAllFieldsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        value: List[GetMultiDimTableAllFieldsResponseBodyValue] = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.value = value
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.value:
            for k in self.value:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['value'] = []
        if self.value is not None:
            for k in self.value:
                result['value'].append(k.to_map() if k else None)
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.value = []
        if m.get('value') is not None:
            for k in m.get('value'):
                temp_model = GetMultiDimTableAllFieldsResponseBodyValue()
                self.value.append(temp_model.from_map(k))
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetMultiDimTableAllFieldsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMultiDimTableAllFieldsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMultiDimTableAllFieldsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMultiDimTableAllSheetsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetMultiDimTableAllSheetsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetMultiDimTableAllSheetsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetMultiDimTableAllSheetsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetMultiDimTableAllSheetsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetMultiDimTableAllSheetsRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetMultiDimTableAllSheetsRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        tenant_context: GetMultiDimTableAllSheetsRequestTenantContext = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('TenantContext') is not None:
            temp_model = GetMultiDimTableAllSheetsRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetMultiDimTableAllSheetsShrinkRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetMultiDimTableAllSheetsResponseBodyValue(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
    ):
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GetMultiDimTableAllSheetsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        value: List[GetMultiDimTableAllSheetsResponseBodyValue] = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.value = value
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.value:
            for k in self.value:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['value'] = []
        if self.value is not None:
            for k in self.value:
                result['value'].append(k.to_map() if k else None)
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.value = []
        if m.get('value') is not None:
            for k in m.get('value'):
                temp_model = GetMultiDimTableAllSheetsResponseBodyValue()
                self.value.append(temp_model.from_map(k))
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetMultiDimTableAllSheetsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMultiDimTableAllSheetsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMultiDimTableAllSheetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMultiDimTableRecordHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetMultiDimTableRecordHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetMultiDimTableRecordHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetMultiDimTableRecordHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetMultiDimTableRecordShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetMultiDimTableRecordRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetMultiDimTableRecordRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        record_id: str = None,
        sheet_id_or_name: str = None,
        tenant_context: GetMultiDimTableRecordRequestTenantContext = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.record_id = record_id
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            temp_model = GetMultiDimTableRecordRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetMultiDimTableRecordShrinkRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        record_id: str = None,
        sheet_id_or_name: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.record_id = record_id
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetMultiDimTableRecordResponseBodyCreatedBy(TeaModel):
    def __init__(
        self,
        user_id: str = None,
    ):
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetMultiDimTableRecordResponseBodyLastModifiedBy(TeaModel):
    def __init__(
        self,
        user_id: str = None,
    ):
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetMultiDimTableRecordResponseBody(TeaModel):
    def __init__(
        self,
        created_by: GetMultiDimTableRecordResponseBodyCreatedBy = None,
        created_time: int = None,
        fields: Dict[str, Any] = None,
        id: str = None,
        last_modified_by: GetMultiDimTableRecordResponseBodyLastModifiedBy = None,
        last_modified_time: int = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.created_by = created_by
        self.created_time = created_time
        self.fields = fields
        self.id = id
        self.last_modified_by = last_modified_by
        self.last_modified_time = last_modified_time
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.created_by:
            self.created_by.validate()
        if self.last_modified_by:
            self.last_modified_by.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_by is not None:
            result['CreatedBy'] = self.created_by.to_map()
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.fields is not None:
            result['Fields'] = self.fields
        if self.id is not None:
            result['Id'] = self.id
        if self.last_modified_by is not None:
            result['LastModifiedBy'] = self.last_modified_by.to_map()
        if self.last_modified_time is not None:
            result['LastModifiedTime'] = self.last_modified_time
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatedBy') is not None:
            temp_model = GetMultiDimTableRecordResponseBodyCreatedBy()
            self.created_by = temp_model.from_map(m['CreatedBy'])
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Fields') is not None:
            self.fields = m.get('Fields')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LastModifiedBy') is not None:
            temp_model = GetMultiDimTableRecordResponseBodyLastModifiedBy()
            self.last_modified_by = temp_model.from_map(m['LastModifiedBy'])
        if m.get('LastModifiedTime') is not None:
            self.last_modified_time = m.get('LastModifiedTime')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetMultiDimTableRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMultiDimTableRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMultiDimTableRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMultiDimTableSheetHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetMultiDimTableSheetHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetMultiDimTableSheetHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetMultiDimTableSheetHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetMultiDimTableSheetShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetMultiDimTableSheetRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetMultiDimTableSheetRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        sheet_id_or_name: str = None,
        tenant_context: GetMultiDimTableSheetRequestTenantContext = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            temp_model = GetMultiDimTableSheetRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetMultiDimTableSheetShrinkRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        sheet_id_or_name: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetMultiDimTableSheetResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.id = id
        self.name = name
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetMultiDimTableSheetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMultiDimTableSheetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMultiDimTableSheetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMultipartFileUploadInfosHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetMultipartFileUploadInfosHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetMultipartFileUploadInfosHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetMultipartFileUploadInfosHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetMultipartFileUploadInfosShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetMultipartFileUploadInfosRequestOption(TeaModel):
    def __init__(
        self,
        prefer_intranet: bool = None,
    ):
        self.prefer_intranet = prefer_intranet

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prefer_intranet is not None:
            result['PreferIntranet'] = self.prefer_intranet
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PreferIntranet') is not None:
            self.prefer_intranet = m.get('PreferIntranet')
        return self


class GetMultipartFileUploadInfosRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetMultipartFileUploadInfosRequest(TeaModel):
    def __init__(
        self,
        option: GetMultipartFileUploadInfosRequestOption = None,
        part_numbers: List[int] = None,
        tenant_context: GetMultipartFileUploadInfosRequestTenantContext = None,
        upload_key: str = None,
    ):
        self.option = option
        self.part_numbers = part_numbers
        self.tenant_context = tenant_context
        self.upload_key = upload_key

    def validate(self):
        if self.option:
            self.option.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.option is not None:
            result['Option'] = self.option.to_map()
        if self.part_numbers is not None:
            result['PartNumbers'] = self.part_numbers
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.upload_key is not None:
            result['UploadKey'] = self.upload_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Option') is not None:
            temp_model = GetMultipartFileUploadInfosRequestOption()
            self.option = temp_model.from_map(m['Option'])
        if m.get('PartNumbers') is not None:
            self.part_numbers = m.get('PartNumbers')
        if m.get('TenantContext') is not None:
            temp_model = GetMultipartFileUploadInfosRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('UploadKey') is not None:
            self.upload_key = m.get('UploadKey')
        return self


class GetMultipartFileUploadInfosShrinkRequest(TeaModel):
    def __init__(
        self,
        option_shrink: str = None,
        part_numbers_shrink: str = None,
        tenant_context_shrink: str = None,
        upload_key: str = None,
    ):
        self.option_shrink = option_shrink
        self.part_numbers_shrink = part_numbers_shrink
        self.tenant_context_shrink = tenant_context_shrink
        self.upload_key = upload_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.option_shrink is not None:
            result['Option'] = self.option_shrink
        if self.part_numbers_shrink is not None:
            result['PartNumbers'] = self.part_numbers_shrink
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.upload_key is not None:
            result['UploadKey'] = self.upload_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Option') is not None:
            self.option_shrink = m.get('Option')
        if m.get('PartNumbers') is not None:
            self.part_numbers_shrink = m.get('PartNumbers')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('UploadKey') is not None:
            self.upload_key = m.get('UploadKey')
        return self


class GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfosHeaderSignatureInfo(TeaModel):
    def __init__(
        self,
        expiration_seconds: int = None,
        headers: Dict[str, str] = None,
        internal_resource_urls: List[str] = None,
        region: str = None,
        resource_urls: List[str] = None,
    ):
        self.expiration_seconds = expiration_seconds
        self.headers = headers
        self.internal_resource_urls = internal_resource_urls
        self.region = region
        self.resource_urls = resource_urls

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expiration_seconds is not None:
            result['ExpirationSeconds'] = self.expiration_seconds
        if self.headers is not None:
            result['Headers'] = self.headers
        if self.internal_resource_urls is not None:
            result['InternalResourceUrls'] = self.internal_resource_urls
        if self.region is not None:
            result['Region'] = self.region
        if self.resource_urls is not None:
            result['ResourceUrls'] = self.resource_urls
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExpirationSeconds') is not None:
            self.expiration_seconds = m.get('ExpirationSeconds')
        if m.get('Headers') is not None:
            self.headers = m.get('Headers')
        if m.get('InternalResourceUrls') is not None:
            self.internal_resource_urls = m.get('InternalResourceUrls')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('ResourceUrls') is not None:
            self.resource_urls = m.get('ResourceUrls')
        return self


class GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfos(TeaModel):
    def __init__(
        self,
        header_signature_info: GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfosHeaderSignatureInfo = None,
        part_number: int = None,
    ):
        self.header_signature_info = header_signature_info
        self.part_number = part_number

    def validate(self):
        if self.header_signature_info:
            self.header_signature_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header_signature_info is not None:
            result['HeaderSignatureInfo'] = self.header_signature_info.to_map()
        if self.part_number is not None:
            result['PartNumber'] = self.part_number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HeaderSignatureInfo') is not None:
            temp_model = GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfosHeaderSignatureInfo()
            self.header_signature_info = temp_model.from_map(m['HeaderSignatureInfo'])
        if m.get('PartNumber') is not None:
            self.part_number = m.get('PartNumber')
        return self


class GetMultipartFileUploadInfosResponseBody(TeaModel):
    def __init__(
        self,
        multipart_header_signature_infos: List[GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfos] = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.multipart_header_signature_infos = multipart_header_signature_infos
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.multipart_header_signature_infos:
            for k in self.multipart_header_signature_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['multipartHeaderSignatureInfos'] = []
        if self.multipart_header_signature_infos is not None:
            for k in self.multipart_header_signature_infos:
                result['multipartHeaderSignatureInfos'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.multipart_header_signature_infos = []
        if m.get('multipartHeaderSignatureInfos') is not None:
            for k in m.get('multipartHeaderSignatureInfos'):
                temp_model = GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfos()
                self.multipart_header_signature_infos.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetMultipartFileUploadInfosResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMultipartFileUploadInfosResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMultipartFileUploadInfosResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetNewestInnerGroupsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetNewestInnerGroupsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetNewestInnerGroupsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetNewestInnerGroupsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetNewestInnerGroupsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetNewestInnerGroupsRequest(TeaModel):
    def __init__(
        self,
        request: Dict[str, Any] = None,
    ):
        self.request = request

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request is not None:
            result['Request'] = self.request
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Request') is not None:
            self.request = m.get('Request')
        return self


class GetNewestInnerGroupsShrinkRequest(TeaModel):
    def __init__(
        self,
        request_shrink: str = None,
    ):
        self.request_shrink = request_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_shrink is not None:
            result['Request'] = self.request_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Request') is not None:
            self.request_shrink = m.get('Request')
        return self


class GetNewestInnerGroupsResponseBodyGroupInfos(TeaModel):
    def __init__(
        self,
        icon: str = None,
        member_amount: str = None,
        open_conversation_id: str = None,
        title: str = None,
    ):
        self.icon = icon
        self.member_amount = member_amount
        self.open_conversation_id = open_conversation_id
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.member_amount is not None:
            result['MemberAmount'] = self.member_amount
        if self.open_conversation_id is not None:
            result['OpenConversationId'] = self.open_conversation_id
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('MemberAmount') is not None:
            self.member_amount = m.get('MemberAmount')
        if m.get('OpenConversationId') is not None:
            self.open_conversation_id = m.get('OpenConversationId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class GetNewestInnerGroupsResponseBody(TeaModel):
    def __init__(
        self,
        group_infos: List[GetNewestInnerGroupsResponseBodyGroupInfos] = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.group_infos = group_infos
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.group_infos:
            for k in self.group_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['groupInfos'] = []
        if self.group_infos is not None:
            for k in self.group_infos:
                result['groupInfos'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.group_infos = []
        if m.get('groupInfos') is not None:
            for k in m.get('groupInfos'):
                temp_model = GetNewestInnerGroupsResponseBodyGroupInfos()
                self.group_infos.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetNewestInnerGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetNewestInnerGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetNewestInnerGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetNodeHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetNodeHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetNodeHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetNodeHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetNodeShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetNodeRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetNodeRequest(TeaModel):
    def __init__(
        self,
        node_id: str = None,
        tenant_context: GetNodeRequestTenantContext = None,
        with_permission_role: bool = None,
        with_statistical_info: bool = None,
    ):
        # This parameter is required.
        self.node_id = node_id
        self.tenant_context = tenant_context
        self.with_permission_role = with_permission_role
        self.with_statistical_info = with_statistical_info

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.with_permission_role is not None:
            result['WithPermissionRole'] = self.with_permission_role
        if self.with_statistical_info is not None:
            result['WithStatisticalInfo'] = self.with_statistical_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('TenantContext') is not None:
            temp_model = GetNodeRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WithPermissionRole') is not None:
            self.with_permission_role = m.get('WithPermissionRole')
        if m.get('WithStatisticalInfo') is not None:
            self.with_statistical_info = m.get('WithStatisticalInfo')
        return self


class GetNodeShrinkRequest(TeaModel):
    def __init__(
        self,
        node_id: str = None,
        tenant_context_shrink: str = None,
        with_permission_role: bool = None,
        with_statistical_info: bool = None,
    ):
        # This parameter is required.
        self.node_id = node_id
        self.tenant_context_shrink = tenant_context_shrink
        self.with_permission_role = with_permission_role
        self.with_statistical_info = with_statistical_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.with_permission_role is not None:
            result['WithPermissionRole'] = self.with_permission_role
        if self.with_statistical_info is not None:
            result['WithStatisticalInfo'] = self.with_statistical_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WithPermissionRole') is not None:
            self.with_permission_role = m.get('WithPermissionRole')
        if m.get('WithStatisticalInfo') is not None:
            self.with_statistical_info = m.get('WithStatisticalInfo')
        return self


class GetNodeResponseBodyNodeStatisticalInfo(TeaModel):
    def __init__(
        self,
        word_count: int = None,
    ):
        self.word_count = word_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.word_count is not None:
            result['WordCount'] = self.word_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WordCount') is not None:
            self.word_count = m.get('WordCount')
        return self


class GetNodeResponseBodyNode(TeaModel):
    def __init__(
        self,
        category: str = None,
        create_time: str = None,
        creator_id: str = None,
        extension: str = None,
        has_children: bool = None,
        modified_time: str = None,
        modifier_id: str = None,
        name: str = None,
        node_id: str = None,
        permission_role: str = None,
        size: int = None,
        statistical_info: GetNodeResponseBodyNodeStatisticalInfo = None,
        type: str = None,
        url: str = None,
        workspace_id: str = None,
    ):
        self.category = category
        self.create_time = create_time
        self.creator_id = creator_id
        self.extension = extension
        self.has_children = has_children
        self.modified_time = modified_time
        self.modifier_id = modifier_id
        self.name = name
        self.node_id = node_id
        self.permission_role = permission_role
        self.size = size
        self.statistical_info = statistical_info
        self.type = type
        self.url = url
        self.workspace_id = workspace_id

    def validate(self):
        if self.statistical_info:
            self.statistical_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.has_children is not None:
            result['HasChildren'] = self.has_children
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.name is not None:
            result['Name'] = self.name
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.permission_role is not None:
            result['PermissionRole'] = self.permission_role
        if self.size is not None:
            result['Size'] = self.size
        if self.statistical_info is not None:
            result['StatisticalInfo'] = self.statistical_info.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('HasChildren') is not None:
            self.has_children = m.get('HasChildren')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('PermissionRole') is not None:
            self.permission_role = m.get('PermissionRole')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StatisticalInfo') is not None:
            temp_model = GetNodeResponseBodyNodeStatisticalInfo()
            self.statistical_info = temp_model.from_map(m['StatisticalInfo'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetNodeResponseBody(TeaModel):
    def __init__(
        self,
        node: GetNodeResponseBodyNode = None,
        request_id: str = None,
    ):
        self.node = node
        # requestId
        self.request_id = request_id

    def validate(self):
        if self.node:
            self.node.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node is not None:
            result['node'] = self.node.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('node') is not None:
            temp_model = GetNodeResponseBodyNode()
            self.node = temp_model.from_map(m['node'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetNodeByUrlHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetNodeByUrlHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetNodeByUrlHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetNodeByUrlHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetNodeByUrlShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetNodeByUrlRequestOption(TeaModel):
    def __init__(
        self,
        with_permission_role: bool = None,
        with_statistical_info: bool = None,
    ):
        self.with_permission_role = with_permission_role
        self.with_statistical_info = with_statistical_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.with_permission_role is not None:
            result['WithPermissionRole'] = self.with_permission_role
        if self.with_statistical_info is not None:
            result['WithStatisticalInfo'] = self.with_statistical_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WithPermissionRole') is not None:
            self.with_permission_role = m.get('WithPermissionRole')
        if m.get('WithStatisticalInfo') is not None:
            self.with_statistical_info = m.get('WithStatisticalInfo')
        return self


class GetNodeByUrlRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetNodeByUrlRequest(TeaModel):
    def __init__(
        self,
        option: GetNodeByUrlRequestOption = None,
        tenant_context: GetNodeByUrlRequestTenantContext = None,
        url: str = None,
    ):
        self.option = option
        self.tenant_context = tenant_context
        # This parameter is required.
        self.url = url

    def validate(self):
        if self.option:
            self.option.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.option is not None:
            result['Option'] = self.option.to_map()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Option') is not None:
            temp_model = GetNodeByUrlRequestOption()
            self.option = temp_model.from_map(m['Option'])
        if m.get('TenantContext') is not None:
            temp_model = GetNodeByUrlRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetNodeByUrlShrinkRequest(TeaModel):
    def __init__(
        self,
        option_shrink: str = None,
        tenant_context_shrink: str = None,
        url: str = None,
    ):
        self.option_shrink = option_shrink
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.option_shrink is not None:
            result['Option'] = self.option_shrink
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Option') is not None:
            self.option_shrink = m.get('Option')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetNodeByUrlResponseBodyNodeStatisticalInfo(TeaModel):
    def __init__(
        self,
        word_count: int = None,
    ):
        self.word_count = word_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.word_count is not None:
            result['WordCount'] = self.word_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WordCount') is not None:
            self.word_count = m.get('WordCount')
        return self


class GetNodeByUrlResponseBodyNode(TeaModel):
    def __init__(
        self,
        category: str = None,
        create_time: str = None,
        creator_id: str = None,
        extension: str = None,
        has_children: bool = None,
        modified_time: str = None,
        modifier_id: str = None,
        name: str = None,
        node_id: str = None,
        permission_role: str = None,
        size: int = None,
        statistical_info: GetNodeByUrlResponseBodyNodeStatisticalInfo = None,
        type: str = None,
        url: str = None,
        workspace_id: str = None,
    ):
        self.category = category
        self.create_time = create_time
        self.creator_id = creator_id
        self.extension = extension
        self.has_children = has_children
        self.modified_time = modified_time
        self.modifier_id = modifier_id
        self.name = name
        self.node_id = node_id
        self.permission_role = permission_role
        self.size = size
        self.statistical_info = statistical_info
        self.type = type
        self.url = url
        self.workspace_id = workspace_id

    def validate(self):
        if self.statistical_info:
            self.statistical_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.has_children is not None:
            result['HasChildren'] = self.has_children
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.name is not None:
            result['Name'] = self.name
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.permission_role is not None:
            result['PermissionRole'] = self.permission_role
        if self.size is not None:
            result['Size'] = self.size
        if self.statistical_info is not None:
            result['StatisticalInfo'] = self.statistical_info.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('HasChildren') is not None:
            self.has_children = m.get('HasChildren')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('PermissionRole') is not None:
            self.permission_role = m.get('PermissionRole')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StatisticalInfo') is not None:
            temp_model = GetNodeByUrlResponseBodyNodeStatisticalInfo()
            self.statistical_info = temp_model.from_map(m['StatisticalInfo'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetNodeByUrlResponseBody(TeaModel):
    def __init__(
        self,
        node: GetNodeByUrlResponseBodyNode = None,
        request_id: str = None,
    ):
        self.node = node
        # requestId
        self.request_id = request_id

    def validate(self):
        if self.node:
            self.node.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node is not None:
            result['node'] = self.node.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('node') is not None:
            temp_model = GetNodeByUrlResponseBodyNode()
            self.node = temp_model.from_map(m['node'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetNodeByUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetNodeByUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetNodeByUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetNodesHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetNodesHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetNodesHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetNodesHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetNodesShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetNodesRequestOption(TeaModel):
    def __init__(
        self,
        with_permission_role: bool = None,
        with_statistical_info: bool = None,
    ):
        self.with_permission_role = with_permission_role
        self.with_statistical_info = with_statistical_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.with_permission_role is not None:
            result['WithPermissionRole'] = self.with_permission_role
        if self.with_statistical_info is not None:
            result['WithStatisticalInfo'] = self.with_statistical_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WithPermissionRole') is not None:
            self.with_permission_role = m.get('WithPermissionRole')
        if m.get('WithStatisticalInfo') is not None:
            self.with_statistical_info = m.get('WithStatisticalInfo')
        return self


class GetNodesRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetNodesRequest(TeaModel):
    def __init__(
        self,
        node_ids: List[str] = None,
        option: GetNodesRequestOption = None,
        tenant_context: GetNodesRequestTenantContext = None,
    ):
        # This parameter is required.
        self.node_ids = node_ids
        self.option = option
        self.tenant_context = tenant_context

    def validate(self):
        if self.option:
            self.option.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_ids is not None:
            result['NodeIds'] = self.node_ids
        if self.option is not None:
            result['Option'] = self.option.to_map()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeIds') is not None:
            self.node_ids = m.get('NodeIds')
        if m.get('Option') is not None:
            temp_model = GetNodesRequestOption()
            self.option = temp_model.from_map(m['Option'])
        if m.get('TenantContext') is not None:
            temp_model = GetNodesRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetNodesShrinkRequest(TeaModel):
    def __init__(
        self,
        node_ids_shrink: str = None,
        option_shrink: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.node_ids_shrink = node_ids_shrink
        self.option_shrink = option_shrink
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_ids_shrink is not None:
            result['NodeIds'] = self.node_ids_shrink
        if self.option_shrink is not None:
            result['Option'] = self.option_shrink
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeIds') is not None:
            self.node_ids_shrink = m.get('NodeIds')
        if m.get('Option') is not None:
            self.option_shrink = m.get('Option')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetNodesResponseBodyNodesStatisticalInfo(TeaModel):
    def __init__(
        self,
        word_count: int = None,
    ):
        self.word_count = word_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.word_count is not None:
            result['WordCount'] = self.word_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WordCount') is not None:
            self.word_count = m.get('WordCount')
        return self


class GetNodesResponseBodyNodes(TeaModel):
    def __init__(
        self,
        category: str = None,
        create_time: str = None,
        creator_id: str = None,
        extension: str = None,
        has_children: bool = None,
        modified_time: str = None,
        modifier_id: str = None,
        name: str = None,
        node_id: str = None,
        permission_role: str = None,
        size: int = None,
        statistical_info: GetNodesResponseBodyNodesStatisticalInfo = None,
        type: str = None,
        url: str = None,
        workspace_id: str = None,
    ):
        self.category = category
        self.create_time = create_time
        self.creator_id = creator_id
        self.extension = extension
        self.has_children = has_children
        self.modified_time = modified_time
        self.modifier_id = modifier_id
        self.name = name
        self.node_id = node_id
        self.permission_role = permission_role
        self.size = size
        self.statistical_info = statistical_info
        self.type = type
        self.url = url
        self.workspace_id = workspace_id

    def validate(self):
        if self.statistical_info:
            self.statistical_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.has_children is not None:
            result['HasChildren'] = self.has_children
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.name is not None:
            result['Name'] = self.name
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.permission_role is not None:
            result['PermissionRole'] = self.permission_role
        if self.size is not None:
            result['Size'] = self.size
        if self.statistical_info is not None:
            result['StatisticalInfo'] = self.statistical_info.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('HasChildren') is not None:
            self.has_children = m.get('HasChildren')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('PermissionRole') is not None:
            self.permission_role = m.get('PermissionRole')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StatisticalInfo') is not None:
            temp_model = GetNodesResponseBodyNodesStatisticalInfo()
            self.statistical_info = temp_model.from_map(m['StatisticalInfo'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetNodesResponseBody(TeaModel):
    def __init__(
        self,
        nodes: List[GetNodesResponseBodyNodes] = None,
        request_id: str = None,
    ):
        self.nodes = nodes
        # requestId
        self.request_id = request_id

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['nodes'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nodes = []
        if m.get('nodes') is not None:
            for k in m.get('nodes'):
                temp_model = GetNodesResponseBodyNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetNodesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetNodesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetNodesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetNotifyMeHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetNotifyMeHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetNotifyMeHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetNotifyMeHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetNotifyMeShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetNotifyMeRequest(TeaModel):
    def __init__(
        self,
        app_types: str = None,
        corp_id: str = None,
        create_from_time_gmt: int = None,
        create_to_time_gmt: int = None,
        instance_create_from_time_gmt: int = None,
        instance_create_to_time_gmt: int = None,
        keyword: str = None,
        language: str = None,
        page_number: int = None,
        page_size: int = None,
        process_codes: str = None,
        token: str = None,
    ):
        self.app_types = app_types
        # This parameter is required.
        self.corp_id = corp_id
        self.create_from_time_gmt = create_from_time_gmt
        self.create_to_time_gmt = create_to_time_gmt
        self.instance_create_from_time_gmt = instance_create_from_time_gmt
        self.instance_create_to_time_gmt = instance_create_to_time_gmt
        self.keyword = keyword
        self.language = language
        self.page_number = page_number
        self.page_size = page_size
        self.process_codes = process_codes
        # This parameter is required.
        self.token = token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_types is not None:
            result['AppTypes'] = self.app_types
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.create_from_time_gmt is not None:
            result['CreateFromTimeGMT'] = self.create_from_time_gmt
        if self.create_to_time_gmt is not None:
            result['CreateToTimeGMT'] = self.create_to_time_gmt
        if self.instance_create_from_time_gmt is not None:
            result['InstanceCreateFromTimeGMT'] = self.instance_create_from_time_gmt
        if self.instance_create_to_time_gmt is not None:
            result['InstanceCreateToTimeGMT'] = self.instance_create_to_time_gmt
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.language is not None:
            result['Language'] = self.language
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.process_codes is not None:
            result['ProcessCodes'] = self.process_codes
        if self.token is not None:
            result['Token'] = self.token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppTypes') is not None:
            self.app_types = m.get('AppTypes')
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('CreateFromTimeGMT') is not None:
            self.create_from_time_gmt = m.get('CreateFromTimeGMT')
        if m.get('CreateToTimeGMT') is not None:
            self.create_to_time_gmt = m.get('CreateToTimeGMT')
        if m.get('InstanceCreateFromTimeGMT') is not None:
            self.instance_create_from_time_gmt = m.get('InstanceCreateFromTimeGMT')
        if m.get('InstanceCreateToTimeGMT') is not None:
            self.instance_create_to_time_gmt = m.get('InstanceCreateToTimeGMT')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProcessCodes') is not None:
            self.process_codes = m.get('ProcessCodes')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        return self


class GetNotifyMeResponseBodyData(TeaModel):
    def __init__(
        self,
        activity_id: str = None,
        app_type: str = None,
        corp_id: str = None,
        create_time_gmt: str = None,
        creator_user_id: str = None,
        form_instance_id: str = None,
        inst_status: str = None,
        mobile_url: str = None,
        modified_time_gmt: str = None,
    ):
        self.activity_id = activity_id
        self.app_type = app_type
        self.corp_id = corp_id
        self.create_time_gmt = create_time_gmt
        self.creator_user_id = creator_user_id
        self.form_instance_id = form_instance_id
        self.inst_status = inst_status
        self.mobile_url = mobile_url
        self.modified_time_gmt = modified_time_gmt

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_id is not None:
            result['ActivityId'] = self.activity_id
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.create_time_gmt is not None:
            result['CreateTimeGMT'] = self.create_time_gmt
        if self.creator_user_id is not None:
            result['CreatorUserId'] = self.creator_user_id
        if self.form_instance_id is not None:
            result['FormInstanceId'] = self.form_instance_id
        if self.inst_status is not None:
            result['InstStatus'] = self.inst_status
        if self.mobile_url is not None:
            result['MobileUrl'] = self.mobile_url
        if self.modified_time_gmt is not None:
            result['ModifiedTimeGMT'] = self.modified_time_gmt
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityId') is not None:
            self.activity_id = m.get('ActivityId')
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('CreateTimeGMT') is not None:
            self.create_time_gmt = m.get('CreateTimeGMT')
        if m.get('CreatorUserId') is not None:
            self.creator_user_id = m.get('CreatorUserId')
        if m.get('FormInstanceId') is not None:
            self.form_instance_id = m.get('FormInstanceId')
        if m.get('InstStatus') is not None:
            self.inst_status = m.get('InstStatus')
        if m.get('MobileUrl') is not None:
            self.mobile_url = m.get('MobileUrl')
        if m.get('ModifiedTimeGMT') is not None:
            self.modified_time_gmt = m.get('ModifiedTimeGMT')
        return self


class GetNotifyMeResponseBody(TeaModel):
    def __init__(
        self,
        data: List[GetNotifyMeResponseBodyData] = None,
        page_number: int = None,
        request_id: str = None,
        total_count: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.data = data
        self.page_number = page_number
        self.request_id = request_id
        self.total_count = total_count
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = GetNotifyMeResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetNotifyMeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetNotifyMeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetNotifyMeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOpenUrlHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetOpenUrlHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetOpenUrlHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetOpenUrlHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetOpenUrlShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetOpenUrlRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        file_url: str = None,
        language: str = None,
        system_token: str = None,
        timeout: int = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        # This parameter is required.
        self.file_url = file_url
        self.language = language
        # This parameter is required.
        self.system_token = system_token
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.language is not None:
            result['Language'] = self.language
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class GetOpenUrlResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: str = None,
    ):
        # requestId
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class GetOpenUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOpenUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOpenUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOperationRecordsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetOperationRecordsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetOperationRecordsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetOperationRecordsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetOperationRecordsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetOperationRecordsRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        language: str = None,
        process_instance_id: str = None,
        system_token: str = None,
    ):
        self.app_type = app_type
        self.language = language
        self.process_instance_id = process_instance_id
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.language is not None:
            result['Language'] = self.language
        if self.process_instance_id is not None:
            result['ProcessInstanceId'] = self.process_instance_id
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('ProcessInstanceId') is not None:
            self.process_instance_id = m.get('ProcessInstanceId')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class GetOperationRecordsResponseBodyResult(TeaModel):
    def __init__(
        self,
        action: str = None,
        action_exit: str = None,
        active_time_gmt: str = None,
        activity_id: str = None,
        data_id: int = None,
        digital_sign: str = None,
        files: str = None,
        operate_time_gmt: str = None,
        operate_type: str = None,
        operator_display_name: str = None,
        operator_name: str = None,
        operator_nick_name: str = None,
        operator_photo_url: str = None,
        operator_status: str = None,
        operator_user_id: str = None,
        process_instance_id: str = None,
        remark: str = None,
        show_name: str = None,
        size: int = None,
        task_execute_type: str = None,
        task_hold_time_gmt: int = None,
        task_id: str = None,
        task_type: str = None,
        type: str = None,
    ):
        self.action = action
        self.action_exit = action_exit
        self.active_time_gmt = active_time_gmt
        self.activity_id = activity_id
        self.data_id = data_id
        self.digital_sign = digital_sign
        self.files = files
        self.operate_time_gmt = operate_time_gmt
        self.operate_type = operate_type
        self.operator_display_name = operator_display_name
        self.operator_name = operator_name
        self.operator_nick_name = operator_nick_name
        self.operator_photo_url = operator_photo_url
        self.operator_status = operator_status
        self.operator_user_id = operator_user_id
        self.process_instance_id = process_instance_id
        self.remark = remark
        self.show_name = show_name
        self.size = size
        self.task_execute_type = task_execute_type
        self.task_hold_time_gmt = task_hold_time_gmt
        self.task_id = task_id
        self.task_type = task_type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.action_exit is not None:
            result['ActionExit'] = self.action_exit
        if self.active_time_gmt is not None:
            result['ActiveTimeGMT'] = self.active_time_gmt
        if self.activity_id is not None:
            result['ActivityId'] = self.activity_id
        if self.data_id is not None:
            result['DataId'] = self.data_id
        if self.digital_sign is not None:
            result['DigitalSign'] = self.digital_sign
        if self.files is not None:
            result['Files'] = self.files
        if self.operate_time_gmt is not None:
            result['OperateTimeGMT'] = self.operate_time_gmt
        if self.operate_type is not None:
            result['OperateType'] = self.operate_type
        if self.operator_display_name is not None:
            result['OperatorDisplayName'] = self.operator_display_name
        if self.operator_name is not None:
            result['OperatorName'] = self.operator_name
        if self.operator_nick_name is not None:
            result['OperatorNickName'] = self.operator_nick_name
        if self.operator_photo_url is not None:
            result['OperatorPhotoUrl'] = self.operator_photo_url
        if self.operator_status is not None:
            result['OperatorStatus'] = self.operator_status
        if self.operator_user_id is not None:
            result['OperatorUserId'] = self.operator_user_id
        if self.process_instance_id is not None:
            result['ProcessInstanceId'] = self.process_instance_id
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.show_name is not None:
            result['ShowName'] = self.show_name
        if self.size is not None:
            result['Size'] = self.size
        if self.task_execute_type is not None:
            result['TaskExecuteType'] = self.task_execute_type
        if self.task_hold_time_gmt is not None:
            result['TaskHoldTimeGMT'] = self.task_hold_time_gmt
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('ActionExit') is not None:
            self.action_exit = m.get('ActionExit')
        if m.get('ActiveTimeGMT') is not None:
            self.active_time_gmt = m.get('ActiveTimeGMT')
        if m.get('ActivityId') is not None:
            self.activity_id = m.get('ActivityId')
        if m.get('DataId') is not None:
            self.data_id = m.get('DataId')
        if m.get('DigitalSign') is not None:
            self.digital_sign = m.get('DigitalSign')
        if m.get('Files') is not None:
            self.files = m.get('Files')
        if m.get('OperateTimeGMT') is not None:
            self.operate_time_gmt = m.get('OperateTimeGMT')
        if m.get('OperateType') is not None:
            self.operate_type = m.get('OperateType')
        if m.get('OperatorDisplayName') is not None:
            self.operator_display_name = m.get('OperatorDisplayName')
        if m.get('OperatorName') is not None:
            self.operator_name = m.get('OperatorName')
        if m.get('OperatorNickName') is not None:
            self.operator_nick_name = m.get('OperatorNickName')
        if m.get('OperatorPhotoUrl') is not None:
            self.operator_photo_url = m.get('OperatorPhotoUrl')
        if m.get('OperatorStatus') is not None:
            self.operator_status = m.get('OperatorStatus')
        if m.get('OperatorUserId') is not None:
            self.operator_user_id = m.get('OperatorUserId')
        if m.get('ProcessInstanceId') is not None:
            self.process_instance_id = m.get('ProcessInstanceId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('ShowName') is not None:
            self.show_name = m.get('ShowName')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('TaskExecuteType') is not None:
            self.task_execute_type = m.get('TaskExecuteType')
        if m.get('TaskHoldTimeGMT') is not None:
            self.task_hold_time_gmt = m.get('TaskHoldTimeGMT')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetOperationRecordsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: List[GetOperationRecordsResponseBodyResult] = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.result = result
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = GetOperationRecordsResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetOperationRecordsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOperationRecordsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOperationRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOrgLiveListHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetOrgLiveListHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetOrgLiveListHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetOrgLiveListHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetOrgLiveListShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetOrgLiveListRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetOrgLiveListRequest(TeaModel):
    def __init__(
        self,
        corp_id: str = None,
        end_time: int = None,
        page_number: int = None,
        page_size: int = None,
        start_time: int = None,
        tenant_context: GetOrgLiveListRequestTenantContext = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.corp_id = corp_id
        self.end_time = end_time
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.start_time = start_time
        self.tenant_context = tenant_context
        self.user_id = user_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            temp_model = GetOrgLiveListRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetOrgLiveListShrinkRequest(TeaModel):
    def __init__(
        self,
        corp_id: str = None,
        end_time: int = None,
        page_number: int = None,
        page_size: int = None,
        start_time: int = None,
        tenant_context_shrink: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.corp_id = corp_id
        self.end_time = end_time
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.start_time = start_time
        self.tenant_context_shrink = tenant_context_shrink
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetOrgLiveListResponseBodyResultNewLiveLiveList(TeaModel):
    def __init__(
        self,
        anchor_nickname: str = None,
        anchor_union_id: str = None,
        anchor_user_id: str = None,
        live_end_time: int = None,
        live_start_time: int = None,
        live_uuid: str = None,
        share_open_conversation_ids: List[str] = None,
        title: str = None,
    ):
        self.anchor_nickname = anchor_nickname
        self.anchor_union_id = anchor_union_id
        self.anchor_user_id = anchor_user_id
        self.live_end_time = live_end_time
        self.live_start_time = live_start_time
        self.live_uuid = live_uuid
        self.share_open_conversation_ids = share_open_conversation_ids
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.anchor_nickname is not None:
            result['AnchorNickname'] = self.anchor_nickname
        if self.anchor_union_id is not None:
            result['AnchorUnionId'] = self.anchor_union_id
        if self.anchor_user_id is not None:
            result['AnchorUserId'] = self.anchor_user_id
        if self.live_end_time is not None:
            result['LiveEndTime'] = self.live_end_time
        if self.live_start_time is not None:
            result['LiveStartTime'] = self.live_start_time
        if self.live_uuid is not None:
            result['LiveUuid'] = self.live_uuid
        if self.share_open_conversation_ids is not None:
            result['ShareOpenConversationIds'] = self.share_open_conversation_ids
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnchorNickname') is not None:
            self.anchor_nickname = m.get('AnchorNickname')
        if m.get('AnchorUnionId') is not None:
            self.anchor_union_id = m.get('AnchorUnionId')
        if m.get('AnchorUserId') is not None:
            self.anchor_user_id = m.get('AnchorUserId')
        if m.get('LiveEndTime') is not None:
            self.live_end_time = m.get('LiveEndTime')
        if m.get('LiveStartTime') is not None:
            self.live_start_time = m.get('LiveStartTime')
        if m.get('LiveUuid') is not None:
            self.live_uuid = m.get('LiveUuid')
        if m.get('ShareOpenConversationIds') is not None:
            self.share_open_conversation_ids = m.get('ShareOpenConversationIds')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class GetOrgLiveListResponseBodyResultNewLive(TeaModel):
    def __init__(
        self,
        has_more: bool = None,
        live_list: List[GetOrgLiveListResponseBodyResultNewLiveLiveList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.has_more = has_more
        self.live_list = live_list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.live_list:
            for k in self.live_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_more is not None:
            result['HasMore'] = self.has_more
        result['LiveList'] = []
        if self.live_list is not None:
            for k in self.live_list:
                result['LiveList'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HasMore') is not None:
            self.has_more = m.get('HasMore')
        self.live_list = []
        if m.get('LiveList') is not None:
            for k in m.get('LiveList'):
                temp_model = GetOrgLiveListResponseBodyResultNewLiveLiveList()
                self.live_list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetOrgLiveListResponseBodyResultUpdateLiveLiveList(TeaModel):
    def __init__(
        self,
        anchor_nickname: str = None,
        anchor_union_id: str = None,
        anchor_user_id: str = None,
        live_end_time: int = None,
        live_start_time: int = None,
        live_uuid: str = None,
        title: str = None,
    ):
        self.anchor_nickname = anchor_nickname
        self.anchor_union_id = anchor_union_id
        self.anchor_user_id = anchor_user_id
        self.live_end_time = live_end_time
        self.live_start_time = live_start_time
        self.live_uuid = live_uuid
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.anchor_nickname is not None:
            result['AnchorNickname'] = self.anchor_nickname
        if self.anchor_union_id is not None:
            result['AnchorUnionId'] = self.anchor_union_id
        if self.anchor_user_id is not None:
            result['AnchorUserId'] = self.anchor_user_id
        if self.live_end_time is not None:
            result['LiveEndTime'] = self.live_end_time
        if self.live_start_time is not None:
            result['LiveStartTime'] = self.live_start_time
        if self.live_uuid is not None:
            result['LiveUuid'] = self.live_uuid
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnchorNickname') is not None:
            self.anchor_nickname = m.get('AnchorNickname')
        if m.get('AnchorUnionId') is not None:
            self.anchor_union_id = m.get('AnchorUnionId')
        if m.get('AnchorUserId') is not None:
            self.anchor_user_id = m.get('AnchorUserId')
        if m.get('LiveEndTime') is not None:
            self.live_end_time = m.get('LiveEndTime')
        if m.get('LiveStartTime') is not None:
            self.live_start_time = m.get('LiveStartTime')
        if m.get('LiveUuid') is not None:
            self.live_uuid = m.get('LiveUuid')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class GetOrgLiveListResponseBodyResultUpdateLive(TeaModel):
    def __init__(
        self,
        has_more: bool = None,
        live_list: List[GetOrgLiveListResponseBodyResultUpdateLiveLiveList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.has_more = has_more
        self.live_list = live_list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.live_list:
            for k in self.live_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_more is not None:
            result['HasMore'] = self.has_more
        result['LiveList'] = []
        if self.live_list is not None:
            for k in self.live_list:
                result['LiveList'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HasMore') is not None:
            self.has_more = m.get('HasMore')
        self.live_list = []
        if m.get('LiveList') is not None:
            for k in m.get('LiveList'):
                temp_model = GetOrgLiveListResponseBodyResultUpdateLiveLiveList()
                self.live_list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetOrgLiveListResponseBodyResult(TeaModel):
    def __init__(
        self,
        new_live: GetOrgLiveListResponseBodyResultNewLive = None,
        update_live: GetOrgLiveListResponseBodyResultUpdateLive = None,
    ):
        self.new_live = new_live
        self.update_live = update_live

    def validate(self):
        if self.new_live:
            self.new_live.validate()
        if self.update_live:
            self.update_live.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.new_live is not None:
            result['NewLive'] = self.new_live.to_map()
        if self.update_live is not None:
            result['UpdateLive'] = self.update_live.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NewLive') is not None:
            temp_model = GetOrgLiveListResponseBodyResultNewLive()
            self.new_live = temp_model.from_map(m['NewLive'])
        if m.get('UpdateLive') is not None:
            temp_model = GetOrgLiveListResponseBodyResultUpdateLive()
            self.update_live = temp_model.from_map(m['UpdateLive'])
        return self


class GetOrgLiveListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: GetOrgLiveListResponseBodyResult = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.result = result
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = GetOrgLiveListResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetOrgLiveListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOrgLiveListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOrgLiveListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOrgOrWebOpenDocContentTaskIdHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetOrgOrWebOpenDocContentTaskIdHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetOrgOrWebOpenDocContentTaskIdHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetOrgOrWebOpenDocContentTaskIdHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetOrgOrWebOpenDocContentTaskIdShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetOrgOrWebOpenDocContentTaskIdRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetOrgOrWebOpenDocContentTaskIdRequest(TeaModel):
    def __init__(
        self,
        dentry_uuid: str = None,
        generate_cp: bool = None,
        scope_type: int = None,
        target_format: str = None,
        tenant_context: GetOrgOrWebOpenDocContentTaskIdRequestTenantContext = None,
    ):
        # This parameter is required.
        self.dentry_uuid = dentry_uuid
        self.generate_cp = generate_cp
        self.scope_type = scope_type
        self.target_format = target_format
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        if self.generate_cp is not None:
            result['GenerateCp'] = self.generate_cp
        if self.scope_type is not None:
            result['ScopeType'] = self.scope_type
        if self.target_format is not None:
            result['TargetFormat'] = self.target_format
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        if m.get('GenerateCp') is not None:
            self.generate_cp = m.get('GenerateCp')
        if m.get('ScopeType') is not None:
            self.scope_type = m.get('ScopeType')
        if m.get('TargetFormat') is not None:
            self.target_format = m.get('TargetFormat')
        if m.get('TenantContext') is not None:
            temp_model = GetOrgOrWebOpenDocContentTaskIdRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetOrgOrWebOpenDocContentTaskIdShrinkRequest(TeaModel):
    def __init__(
        self,
        dentry_uuid: str = None,
        generate_cp: bool = None,
        scope_type: int = None,
        target_format: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.dentry_uuid = dentry_uuid
        self.generate_cp = generate_cp
        self.scope_type = scope_type
        self.target_format = target_format
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        if self.generate_cp is not None:
            result['GenerateCp'] = self.generate_cp
        if self.scope_type is not None:
            result['ScopeType'] = self.scope_type
        if self.target_format is not None:
            result['TargetFormat'] = self.target_format
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        if m.get('GenerateCp') is not None:
            self.generate_cp = m.get('GenerateCp')
        if m.get('ScopeType') is not None:
            self.scope_type = m.get('ScopeType')
        if m.get('TargetFormat') is not None:
            self.target_format = m.get('TargetFormat')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetOrgOrWebOpenDocContentTaskIdResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.task_id = task_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.task_id is not None:
            result['taskId'] = self.task_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetOrgOrWebOpenDocContentTaskIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOrgOrWebOpenDocContentTaskIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOrgOrWebOpenDocContentTaskIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetProcessDefinitionHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetProcessDefinitionHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetProcessDefinitionHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetProcessDefinitionHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetProcessDefinitionShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetProcessDefinitionRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        corp_id: str = None,
        group_id: str = None,
        language: str = None,
        name_space: str = None,
        order_number: str = None,
        process_instance_id: str = None,
        system_token: str = None,
        system_type: str = None,
    ):
        self.app_type = app_type
        self.corp_id = corp_id
        self.group_id = group_id
        self.language = language
        self.name_space = name_space
        self.order_number = order_number
        self.process_instance_id = process_instance_id
        self.system_token = system_token
        self.system_type = system_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.language is not None:
            result['Language'] = self.language
        if self.name_space is not None:
            result['NameSpace'] = self.name_space
        if self.order_number is not None:
            result['OrderNumber'] = self.order_number
        if self.process_instance_id is not None:
            result['ProcessInstanceId'] = self.process_instance_id
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        if self.system_type is not None:
            result['SystemType'] = self.system_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('NameSpace') is not None:
            self.name_space = m.get('NameSpace')
        if m.get('OrderNumber') is not None:
            self.order_number = m.get('OrderNumber')
        if m.get('ProcessInstanceId') is not None:
            self.process_instance_id = m.get('ProcessInstanceId')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        if m.get('SystemType') is not None:
            self.system_type = m.get('SystemType')
        return self


class GetProcessDefinitionResponseBodyOriginatorMasterDataDepartments(TeaModel):
    def __init__(
        self,
        dept_name: str = None,
        dept_name_in_english: str = None,
        dept_no: str = None,
        dept_path: str = None,
        human_source_group_order_number: str = None,
        human_source_group_work_no: str = None,
        id: int = None,
        master_work_no: str = None,
    ):
        self.dept_name = dept_name
        self.dept_name_in_english = dept_name_in_english
        self.dept_no = dept_no
        self.dept_path = dept_path
        self.human_source_group_order_number = human_source_group_order_number
        self.human_source_group_work_no = human_source_group_work_no
        self.id = id
        self.master_work_no = master_work_no

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dept_name is not None:
            result['DeptName'] = self.dept_name
        if self.dept_name_in_english is not None:
            result['DeptNameInEnglish'] = self.dept_name_in_english
        if self.dept_no is not None:
            result['DeptNo'] = self.dept_no
        if self.dept_path is not None:
            result['DeptPath'] = self.dept_path
        if self.human_source_group_order_number is not None:
            result['HumanSourceGroupOrderNumber'] = self.human_source_group_order_number
        if self.human_source_group_work_no is not None:
            result['HumanSourceGroupWorkNo'] = self.human_source_group_work_no
        if self.id is not None:
            result['Id'] = self.id
        if self.master_work_no is not None:
            result['MasterWorkNo'] = self.master_work_no
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeptName') is not None:
            self.dept_name = m.get('DeptName')
        if m.get('DeptNameInEnglish') is not None:
            self.dept_name_in_english = m.get('DeptNameInEnglish')
        if m.get('DeptNo') is not None:
            self.dept_no = m.get('DeptNo')
        if m.get('DeptPath') is not None:
            self.dept_path = m.get('DeptPath')
        if m.get('HumanSourceGroupOrderNumber') is not None:
            self.human_source_group_order_number = m.get('HumanSourceGroupOrderNumber')
        if m.get('HumanSourceGroupWorkNo') is not None:
            self.human_source_group_work_no = m.get('HumanSourceGroupWorkNo')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MasterWorkNo') is not None:
            self.master_work_no = m.get('MasterWorkNo')
        return self


class GetProcessDefinitionResponseBodyOriginator(TeaModel):
    def __init__(
        self,
        department_description: str = None,
        display_en_name: str = None,
        display_name: str = None,
        master_data_departments: List[GetProcessDefinitionResponseBodyOriginatorMasterDataDepartments] = None,
        order_number: str = None,
        personal_photo: str = None,
        status: str = None,
        tb_wang: str = None,
        user_id: str = None,
        user_info: str = None,
    ):
        self.department_description = department_description
        self.display_en_name = display_en_name
        self.display_name = display_name
        self.master_data_departments = master_data_departments
        self.order_number = order_number
        self.personal_photo = personal_photo
        self.status = status
        self.tb_wang = tb_wang
        self.user_id = user_id
        self.user_info = user_info

    def validate(self):
        if self.master_data_departments:
            for k in self.master_data_departments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.department_description is not None:
            result['DepartmentDescription'] = self.department_description
        if self.display_en_name is not None:
            result['DisplayEnName'] = self.display_en_name
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        result['MasterDataDepartments'] = []
        if self.master_data_departments is not None:
            for k in self.master_data_departments:
                result['MasterDataDepartments'].append(k.to_map() if k else None)
        if self.order_number is not None:
            result['OrderNumber'] = self.order_number
        if self.personal_photo is not None:
            result['PersonalPhoto'] = self.personal_photo
        if self.status is not None:
            result['Status'] = self.status
        if self.tb_wang is not None:
            result['TbWang'] = self.tb_wang
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_info is not None:
            result['UserInfo'] = self.user_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DepartmentDescription') is not None:
            self.department_description = m.get('DepartmentDescription')
        if m.get('DisplayEnName') is not None:
            self.display_en_name = m.get('DisplayEnName')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        self.master_data_departments = []
        if m.get('MasterDataDepartments') is not None:
            for k in m.get('MasterDataDepartments'):
                temp_model = GetProcessDefinitionResponseBodyOriginatorMasterDataDepartments()
                self.master_data_departments.append(temp_model.from_map(k))
        if m.get('OrderNumber') is not None:
            self.order_number = m.get('OrderNumber')
        if m.get('PersonalPhoto') is not None:
            self.personal_photo = m.get('PersonalPhoto')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TbWang') is not None:
            self.tb_wang = m.get('TbWang')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserInfo') is not None:
            self.user_info = m.get('UserInfo')
        return self


class GetProcessDefinitionResponseBodyOwnersMasterDataDepartments(TeaModel):
    def __init__(
        self,
        dept_name: str = None,
        dept_name_in_english: str = None,
        dept_no: str = None,
        dept_path: str = None,
        human_source_group_order_number: str = None,
        human_source_group_work_no: str = None,
        id: int = None,
        master_work_no: str = None,
    ):
        self.dept_name = dept_name
        self.dept_name_in_english = dept_name_in_english
        self.dept_no = dept_no
        self.dept_path = dept_path
        self.human_source_group_order_number = human_source_group_order_number
        self.human_source_group_work_no = human_source_group_work_no
        self.id = id
        self.master_work_no = master_work_no

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dept_name is not None:
            result['DeptName'] = self.dept_name
        if self.dept_name_in_english is not None:
            result['DeptNameInEnglish'] = self.dept_name_in_english
        if self.dept_no is not None:
            result['DeptNo'] = self.dept_no
        if self.dept_path is not None:
            result['DeptPath'] = self.dept_path
        if self.human_source_group_order_number is not None:
            result['HumanSourceGroupOrderNumber'] = self.human_source_group_order_number
        if self.human_source_group_work_no is not None:
            result['HumanSourceGroupWorkNo'] = self.human_source_group_work_no
        if self.id is not None:
            result['Id'] = self.id
        if self.master_work_no is not None:
            result['MasterWorkNo'] = self.master_work_no
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeptName') is not None:
            self.dept_name = m.get('DeptName')
        if m.get('DeptNameInEnglish') is not None:
            self.dept_name_in_english = m.get('DeptNameInEnglish')
        if m.get('DeptNo') is not None:
            self.dept_no = m.get('DeptNo')
        if m.get('DeptPath') is not None:
            self.dept_path = m.get('DeptPath')
        if m.get('HumanSourceGroupOrderNumber') is not None:
            self.human_source_group_order_number = m.get('HumanSourceGroupOrderNumber')
        if m.get('HumanSourceGroupWorkNo') is not None:
            self.human_source_group_work_no = m.get('HumanSourceGroupWorkNo')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MasterWorkNo') is not None:
            self.master_work_no = m.get('MasterWorkNo')
        return self


class GetProcessDefinitionResponseBodyOwners(TeaModel):
    def __init__(
        self,
        department_description: str = None,
        display_en_name: str = None,
        display_name: str = None,
        master_data_departments: List[GetProcessDefinitionResponseBodyOwnersMasterDataDepartments] = None,
        order_number: str = None,
        personal_photo: str = None,
        status: str = None,
        tb_wang: str = None,
        user_id: str = None,
        user_info: str = None,
    ):
        self.department_description = department_description
        self.display_en_name = display_en_name
        self.display_name = display_name
        self.master_data_departments = master_data_departments
        self.order_number = order_number
        self.personal_photo = personal_photo
        self.status = status
        self.tb_wang = tb_wang
        self.user_id = user_id
        self.user_info = user_info

    def validate(self):
        if self.master_data_departments:
            for k in self.master_data_departments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.department_description is not None:
            result['DepartmentDescription'] = self.department_description
        if self.display_en_name is not None:
            result['DisplayEnName'] = self.display_en_name
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        result['MasterDataDepartments'] = []
        if self.master_data_departments is not None:
            for k in self.master_data_departments:
                result['MasterDataDepartments'].append(k.to_map() if k else None)
        if self.order_number is not None:
            result['OrderNumber'] = self.order_number
        if self.personal_photo is not None:
            result['PersonalPhoto'] = self.personal_photo
        if self.status is not None:
            result['Status'] = self.status
        if self.tb_wang is not None:
            result['TbWang'] = self.tb_wang
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_info is not None:
            result['UserInfo'] = self.user_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DepartmentDescription') is not None:
            self.department_description = m.get('DepartmentDescription')
        if m.get('DisplayEnName') is not None:
            self.display_en_name = m.get('DisplayEnName')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        self.master_data_departments = []
        if m.get('MasterDataDepartments') is not None:
            for k in m.get('MasterDataDepartments'):
                temp_model = GetProcessDefinitionResponseBodyOwnersMasterDataDepartments()
                self.master_data_departments.append(temp_model.from_map(k))
        if m.get('OrderNumber') is not None:
            self.order_number = m.get('OrderNumber')
        if m.get('PersonalPhoto') is not None:
            self.personal_photo = m.get('PersonalPhoto')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TbWang') is not None:
            self.tb_wang = m.get('TbWang')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserInfo') is not None:
            self.user_info = m.get('UserInfo')
        return self


class GetProcessDefinitionResponseBodyTasksActivity(TeaModel):
    def __init__(
        self,
        activity_id: str = None,
        activity_instance_status: str = None,
        activity_name: str = None,
        activity_name_in_english: str = None,
        id: int = None,
    ):
        self.activity_id = activity_id
        self.activity_instance_status = activity_instance_status
        self.activity_name = activity_name
        self.activity_name_in_english = activity_name_in_english
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_id is not None:
            result['ActivityId'] = self.activity_id
        if self.activity_instance_status is not None:
            result['ActivityInstanceStatus'] = self.activity_instance_status
        if self.activity_name is not None:
            result['ActivityName'] = self.activity_name
        if self.activity_name_in_english is not None:
            result['ActivityNameInEnglish'] = self.activity_name_in_english
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityId') is not None:
            self.activity_id = m.get('ActivityId')
        if m.get('ActivityInstanceStatus') is not None:
            self.activity_instance_status = m.get('ActivityInstanceStatus')
        if m.get('ActivityName') is not None:
            self.activity_name = m.get('ActivityName')
        if m.get('ActivityNameInEnglish') is not None:
            self.activity_name_in_english = m.get('ActivityNameInEnglish')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetProcessDefinitionResponseBodyTasks(TeaModel):
    def __init__(
        self,
        actioner_id: str = None,
        activity: GetProcessDefinitionResponseBodyTasksActivity = None,
        status: str = None,
        task_id: int = None,
    ):
        self.actioner_id = actioner_id
        self.activity = activity
        self.status = status
        self.task_id = task_id

    def validate(self):
        if self.activity:
            self.activity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actioner_id is not None:
            result['ActionerId'] = self.actioner_id
        if self.activity is not None:
            result['Activity'] = self.activity.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionerId') is not None:
            self.actioner_id = m.get('ActionerId')
        if m.get('Activity') is not None:
            temp_model = GetProcessDefinitionResponseBodyTasksActivity()
            self.activity = temp_model.from_map(m['Activity'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetProcessDefinitionResponseBody(TeaModel):
    def __init__(
        self,
        form_uuid: str = None,
        originator: GetProcessDefinitionResponseBodyOriginator = None,
        out_result: str = None,
        owners: List[GetProcessDefinitionResponseBodyOwners] = None,
        process_id: str = None,
        process_instance_id: str = None,
        request_id: str = None,
        status: str = None,
        tasks: List[GetProcessDefinitionResponseBodyTasks] = None,
        title: str = None,
        variables: Dict[str, Any] = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.form_uuid = form_uuid
        self.originator = originator
        self.out_result = out_result
        self.owners = owners
        self.process_id = process_id
        self.process_instance_id = process_instance_id
        self.request_id = request_id
        self.status = status
        self.tasks = tasks
        self.title = title
        self.variables = variables
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.originator:
            self.originator.validate()
        if self.owners:
            for k in self.owners:
                if k:
                    k.validate()
        if self.tasks:
            for k in self.tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.form_uuid is not None:
            result['formUuid'] = self.form_uuid
        if self.originator is not None:
            result['originator'] = self.originator.to_map()
        if self.out_result is not None:
            result['outResult'] = self.out_result
        result['owners'] = []
        if self.owners is not None:
            for k in self.owners:
                result['owners'].append(k.to_map() if k else None)
        if self.process_id is not None:
            result['processId'] = self.process_id
        if self.process_instance_id is not None:
            result['processInstanceId'] = self.process_instance_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.status is not None:
            result['status'] = self.status
        result['tasks'] = []
        if self.tasks is not None:
            for k in self.tasks:
                result['tasks'].append(k.to_map() if k else None)
        if self.title is not None:
            result['title'] = self.title
        if self.variables is not None:
            result['variables'] = self.variables
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('formUuid') is not None:
            self.form_uuid = m.get('formUuid')
        if m.get('originator') is not None:
            temp_model = GetProcessDefinitionResponseBodyOriginator()
            self.originator = temp_model.from_map(m['originator'])
        if m.get('outResult') is not None:
            self.out_result = m.get('outResult')
        self.owners = []
        if m.get('owners') is not None:
            for k in m.get('owners'):
                temp_model = GetProcessDefinitionResponseBodyOwners()
                self.owners.append(temp_model.from_map(k))
        if m.get('processId') is not None:
            self.process_id = m.get('processId')
        if m.get('processInstanceId') is not None:
            self.process_instance_id = m.get('processInstanceId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('status') is not None:
            self.status = m.get('status')
        self.tasks = []
        if m.get('tasks') is not None:
            for k in m.get('tasks'):
                temp_model = GetProcessDefinitionResponseBodyTasks()
                self.tasks.append(temp_model.from_map(k))
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('variables') is not None:
            self.variables = m.get('variables')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetProcessDefinitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetProcessDefinitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetProcessDefinitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRangeHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetRangeHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetRangeHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetRangeHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetRangeShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetRangeRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetRangeRequest(TeaModel):
    def __init__(
        self,
        range_address: str = None,
        select: str = None,
        sheet_id: str = None,
        tenant_context: GetRangeRequestTenantContext = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.range_address = range_address
        self.select = select
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context = tenant_context
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.range_address is not None:
            result['RangeAddress'] = self.range_address
        if self.select is not None:
            result['Select'] = self.select
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RangeAddress') is not None:
            self.range_address = m.get('RangeAddress')
        if m.get('Select') is not None:
            self.select = m.get('Select')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            temp_model = GetRangeRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class GetRangeShrinkRequest(TeaModel):
    def __init__(
        self,
        range_address: str = None,
        select: str = None,
        sheet_id: str = None,
        tenant_context_shrink: str = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.range_address = range_address
        self.select = select
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.range_address is not None:
            result['RangeAddress'] = self.range_address
        if self.select is not None:
            result['Select'] = self.select
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RangeAddress') is not None:
            self.range_address = m.get('RangeAddress')
        if m.get('Select') is not None:
            self.select = m.get('Select')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class GetRangeResponseBodyBackgroundColors(TeaModel):
    def __init__(
        self,
        red: int = None,
        green: int = None,
        blue: int = None,
        hex_string: str = None,
    ):
        # red
        self.red = red
        # green
        self.green = green
        # blue
        self.blue = blue
        # hexString
        self.hex_string = hex_string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.red is not None:
            result['Red'] = self.red
        if self.green is not None:
            result['Green'] = self.green
        if self.blue is not None:
            result['Blue'] = self.blue
        if self.hex_string is not None:
            result['HexString'] = self.hex_string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Red') is not None:
            self.red = m.get('Red')
        if m.get('Green') is not None:
            self.green = m.get('Green')
        if m.get('Blue') is not None:
            self.blue = m.get('Blue')
        if m.get('HexString') is not None:
            self.hex_string = m.get('HexString')
        return self


class GetRangeResponseBodyHyperlinks(TeaModel):
    def __init__(
        self,
        type: str = None,
        link: str = None,
        text: str = None,
    ):
        self.type = type
        self.link = link
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['type'] = self.type
        if self.link is not None:
            result['link'] = self.link
        if self.text is not None:
            result['text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('link') is not None:
            self.link = m.get('link')
        if m.get('text') is not None:
            self.text = m.get('text')
        return self


class GetRangeResponseBody(TeaModel):
    def __init__(
        self,
        background_colors: List[List[GetRangeResponseBodyBackgroundColors]] = None,
        display_values: List[List[str]] = None,
        formulas: List[List[str]] = None,
        hyperlinks: List[List[GetRangeResponseBodyHyperlinks]] = None,
        request_id: str = None,
        values: List[List[Any]] = None,
    ):
        self.background_colors = background_colors
        self.display_values = display_values
        self.formulas = formulas
        self.hyperlinks = hyperlinks
        # requestId
        self.request_id = request_id
        self.values = values

    def validate(self):
        if self.background_colors:
            for k in self.background_colors:
                for k1 in k:
                    if k1:
                        k1.validate()
        if self.hyperlinks:
            for k in self.hyperlinks:
                for k1 in k:
                    if k1:
                        k1.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['backgroundColors'] = []
        if self.background_colors is not None:
            for k in self.background_colors:
                l1 = []
                for k1 in k:
                    l1.append(k1.to_map() if k1 else None)
                result['backgroundColors'].append(l1)
        if self.display_values is not None:
            result['displayValues'] = self.display_values
        if self.formulas is not None:
            result['formulas'] = self.formulas
        result['hyperlinks'] = []
        if self.hyperlinks is not None:
            for k in self.hyperlinks:
                l1 = []
                for k1 in k:
                    l1.append(k1.to_map() if k1 else None)
                result['hyperlinks'].append(l1)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.values is not None:
            result['values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.background_colors = []
        if m.get('backgroundColors') is not None:
            for k in m.get('backgroundColors'):
                l1 = []
                for k1 in k:
                    temp_model = GetRangeResponseBodyBackgroundColors()
                    l1.append(temp_model.from_map(k1))
                self.background_colors.append(l1)
        if m.get('displayValues') is not None:
            self.display_values = m.get('displayValues')
        if m.get('formulas') is not None:
            self.formulas = m.get('formulas')
        self.hyperlinks = []
        if m.get('hyperlinks') is not None:
            for k in m.get('hyperlinks'):
                l1 = []
                for k1 in k:
                    temp_model = GetRangeResponseBodyHyperlinks()
                    l1.append(temp_model.from_map(k1))
                self.hyperlinks.append(l1)
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('values') is not None:
            self.values = m.get('values')
        return self


class GetRangeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRangeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRangeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRelatedWorkspacesHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetRelatedWorkspacesHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetRelatedWorkspacesHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetRelatedWorkspacesHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetRelatedWorkspacesShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetRelatedWorkspacesRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetRelatedWorkspacesRequest(TeaModel):
    def __init__(
        self,
        include_recent: bool = None,
        tenant_context: GetRelatedWorkspacesRequestTenantContext = None,
    ):
        self.include_recent = include_recent
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.include_recent is not None:
            result['IncludeRecent'] = self.include_recent
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IncludeRecent') is not None:
            self.include_recent = m.get('IncludeRecent')
        if m.get('TenantContext') is not None:
            temp_model = GetRelatedWorkspacesRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetRelatedWorkspacesShrinkRequest(TeaModel):
    def __init__(
        self,
        include_recent: bool = None,
        tenant_context_shrink: str = None,
    ):
        self.include_recent = include_recent
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.include_recent is not None:
            result['IncludeRecent'] = self.include_recent
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IncludeRecent') is not None:
            self.include_recent = m.get('IncludeRecent')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetRelatedWorkspacesResponseBodyWorkspacesRecentList(TeaModel):
    def __init__(
        self,
        last_edit_time: int = None,
        name: str = None,
        node_id: str = None,
        url: str = None,
    ):
        self.last_edit_time = last_edit_time
        self.name = name
        self.node_id = node_id
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.last_edit_time is not None:
            result['LastEditTime'] = self.last_edit_time
        if self.name is not None:
            result['Name'] = self.name
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LastEditTime') is not None:
            self.last_edit_time = m.get('LastEditTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetRelatedWorkspacesResponseBodyWorkspaces(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        deleted: bool = None,
        name: str = None,
        owner: str = None,
        recent_list: List[GetRelatedWorkspacesResponseBodyWorkspacesRecentList] = None,
        role: str = None,
        url: str = None,
        workspace_id: str = None,
    ):
        self.create_time = create_time
        self.deleted = deleted
        self.name = name
        self.owner = owner
        self.recent_list = recent_list
        self.role = role
        self.url = url
        self.workspace_id = workspace_id

    def validate(self):
        if self.recent_list:
            for k in self.recent_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deleted is not None:
            result['Deleted'] = self.deleted
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        result['RecentList'] = []
        if self.recent_list is not None:
            for k in self.recent_list:
                result['RecentList'].append(k.to_map() if k else None)
        if self.role is not None:
            result['Role'] = self.role
        if self.url is not None:
            result['Url'] = self.url
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Deleted') is not None:
            self.deleted = m.get('Deleted')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        self.recent_list = []
        if m.get('RecentList') is not None:
            for k in m.get('RecentList'):
                temp_model = GetRelatedWorkspacesResponseBodyWorkspacesRecentList()
                self.recent_list.append(temp_model.from_map(k))
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetRelatedWorkspacesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
        workspaces: List[GetRelatedWorkspacesResponseBodyWorkspaces] = None,
    ):
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type
        self.workspaces = workspaces

    def validate(self):
        if self.workspaces:
            for k in self.workspaces:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        result['workspaces'] = []
        if self.workspaces is not None:
            for k in self.workspaces:
                result['workspaces'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        self.workspaces = []
        if m.get('workspaces') is not None:
            for k in m.get('workspaces'):
                temp_model = GetRelatedWorkspacesResponseBodyWorkspaces()
                self.workspaces.append(temp_model.from_map(k))
        return self


class GetRelatedWorkspacesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRelatedWorkspacesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRelatedWorkspacesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetReportTemplateByNameHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetReportTemplateByNameHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetReportTemplateByNameHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetReportTemplateByNameHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetReportTemplateByNameShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetReportTemplateByNameRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetReportTemplateByNameRequest(TeaModel):
    def __init__(
        self,
        template_name: str = None,
        tenant_context: GetReportTemplateByNameRequestTenantContext = None,
    ):
        # This parameter is required.
        self.template_name = template_name
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('TenantContext') is not None:
            temp_model = GetReportTemplateByNameRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetReportTemplateByNameShrinkRequest(TeaModel):
    def __init__(
        self,
        template_name: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.template_name = template_name
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetReportTemplateByNameResponseBodyDefaultReceivedConvs(TeaModel):
    def __init__(
        self,
        conversation_id: str = None,
        title: str = None,
    ):
        self.conversation_id = conversation_id
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conversation_id is not None:
            result['ConversationId'] = self.conversation_id
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConversationId') is not None:
            self.conversation_id = m.get('ConversationId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class GetReportTemplateByNameResponseBodyDefaultReceivers(TeaModel):
    def __init__(
        self,
        user_name: str = None,
        userid: str = None,
    ):
        self.user_name = user_name
        self.userid = userid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.userid is not None:
            result['Userid'] = self.userid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('Userid') is not None:
            self.userid = m.get('Userid')
        return self


class GetReportTemplateByNameResponseBodyFields(TeaModel):
    def __init__(
        self,
        field_name: str = None,
        sort: int = None,
        type: int = None,
    ):
        self.field_name = field_name
        self.sort = sort
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_name is not None:
            result['FieldName'] = self.field_name
        if self.sort is not None:
            result['Sort'] = self.sort
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FieldName') is not None:
            self.field_name = m.get('FieldName')
        if m.get('Sort') is not None:
            self.sort = m.get('Sort')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetReportTemplateByNameResponseBody(TeaModel):
    def __init__(
        self,
        default_received_convs: List[GetReportTemplateByNameResponseBodyDefaultReceivedConvs] = None,
        default_receivers: List[GetReportTemplateByNameResponseBodyDefaultReceivers] = None,
        fields: List[GetReportTemplateByNameResponseBodyFields] = None,
        id: str = None,
        name: str = None,
        request_id: str = None,
        user_name: str = None,
        userid: str = None,
    ):
        self.default_received_convs = default_received_convs
        self.default_receivers = default_receivers
        self.fields = fields
        self.id = id
        self.name = name
        # requestId
        self.request_id = request_id
        self.user_name = user_name
        self.userid = userid

    def validate(self):
        if self.default_received_convs:
            for k in self.default_received_convs:
                if k:
                    k.validate()
        if self.default_receivers:
            for k in self.default_receivers:
                if k:
                    k.validate()
        if self.fields:
            for k in self.fields:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['defaultReceivedConvs'] = []
        if self.default_received_convs is not None:
            for k in self.default_received_convs:
                result['defaultReceivedConvs'].append(k.to_map() if k else None)
        result['defaultReceivers'] = []
        if self.default_receivers is not None:
            for k in self.default_receivers:
                result['defaultReceivers'].append(k.to_map() if k else None)
        result['fields'] = []
        if self.fields is not None:
            for k in self.fields:
                result['fields'].append(k.to_map() if k else None)
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.user_name is not None:
            result['userName'] = self.user_name
        if self.userid is not None:
            result['userid'] = self.userid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.default_received_convs = []
        if m.get('defaultReceivedConvs') is not None:
            for k in m.get('defaultReceivedConvs'):
                temp_model = GetReportTemplateByNameResponseBodyDefaultReceivedConvs()
                self.default_received_convs.append(temp_model.from_map(k))
        self.default_receivers = []
        if m.get('defaultReceivers') is not None:
            for k in m.get('defaultReceivers'):
                temp_model = GetReportTemplateByNameResponseBodyDefaultReceivers()
                self.default_receivers.append(temp_model.from_map(k))
        self.fields = []
        if m.get('fields') is not None:
            for k in m.get('fields'):
                temp_model = GetReportTemplateByNameResponseBodyFields()
                self.fields.append(temp_model.from_map(k))
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('userName') is not None:
            self.user_name = m.get('userName')
        if m.get('userid') is not None:
            self.userid = m.get('userid')
        return self


class GetReportTemplateByNameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetReportTemplateByNameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetReportTemplateByNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetReportUnReadCountHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetReportUnReadCountHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetReportUnReadCountHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetReportUnReadCountHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetReportUnReadCountShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetReportUnReadCountRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetReportUnReadCountRequest(TeaModel):
    def __init__(
        self,
        request: Dict[str, Any] = None,
        tenant_context: GetReportUnReadCountRequestTenantContext = None,
    ):
        self.request = request
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request is not None:
            result['Request'] = self.request
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Request') is not None:
            self.request = m.get('Request')
        if m.get('TenantContext') is not None:
            temp_model = GetReportUnReadCountRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetReportUnReadCountShrinkRequest(TeaModel):
    def __init__(
        self,
        request_shrink: str = None,
        tenant_context_shrink: str = None,
    ):
        self.request_shrink = request_shrink
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_shrink is not None:
            result['Request'] = self.request_shrink
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Request') is not None:
            self.request_shrink = m.get('Request')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetReportUnReadCountResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        request_id: str = None,
    ):
        self.count = count
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['count'] = self.count
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('count') is not None:
            self.count = m.get('count')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetReportUnReadCountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetReportUnReadCountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetReportUnReadCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRunningTasksHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetRunningTasksHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetRunningTasksHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetRunningTasksHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetRunningTasksShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetRunningTasksRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        language: str = None,
        process_codes: str = None,
        process_instance_id: str = None,
        system_token: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        self.language = language
        self.process_codes = process_codes
        self.process_instance_id = process_instance_id
        # This parameter is required.
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.language is not None:
            result['Language'] = self.language
        if self.process_codes is not None:
            result['ProcessCodes'] = self.process_codes
        if self.process_instance_id is not None:
            result['ProcessInstanceId'] = self.process_instance_id
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('ProcessCodes') is not None:
            self.process_codes = m.get('ProcessCodes')
        if m.get('ProcessInstanceId') is not None:
            self.process_instance_id = m.get('ProcessInstanceId')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class GetRunningTasksResponseBodyResult(TeaModel):
    def __init__(
        self,
        active_time_gmt: str = None,
        activity_id: str = None,
        actual_actioner_id: str = None,
        create_time_gmt: str = None,
        finish_time_gmt: str = None,
        originator_id: str = None,
        process_instance_id: str = None,
        status: str = None,
        task_id: str = None,
        task_type: str = None,
        title: str = None,
        title_in_english: str = None,
    ):
        self.active_time_gmt = active_time_gmt
        self.activity_id = activity_id
        self.actual_actioner_id = actual_actioner_id
        self.create_time_gmt = create_time_gmt
        self.finish_time_gmt = finish_time_gmt
        self.originator_id = originator_id
        self.process_instance_id = process_instance_id
        self.status = status
        self.task_id = task_id
        self.task_type = task_type
        self.title = title
        self.title_in_english = title_in_english

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_time_gmt is not None:
            result['ActiveTimeGMT'] = self.active_time_gmt
        if self.activity_id is not None:
            result['ActivityId'] = self.activity_id
        if self.actual_actioner_id is not None:
            result['ActualActionerId'] = self.actual_actioner_id
        if self.create_time_gmt is not None:
            result['CreateTimeGMT'] = self.create_time_gmt
        if self.finish_time_gmt is not None:
            result['FinishTimeGMT'] = self.finish_time_gmt
        if self.originator_id is not None:
            result['OriginatorId'] = self.originator_id
        if self.process_instance_id is not None:
            result['ProcessInstanceId'] = self.process_instance_id
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.title is not None:
            result['Title'] = self.title
        if self.title_in_english is not None:
            result['TitleInEnglish'] = self.title_in_english
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActiveTimeGMT') is not None:
            self.active_time_gmt = m.get('ActiveTimeGMT')
        if m.get('ActivityId') is not None:
            self.activity_id = m.get('ActivityId')
        if m.get('ActualActionerId') is not None:
            self.actual_actioner_id = m.get('ActualActionerId')
        if m.get('CreateTimeGMT') is not None:
            self.create_time_gmt = m.get('CreateTimeGMT')
        if m.get('FinishTimeGMT') is not None:
            self.finish_time_gmt = m.get('FinishTimeGMT')
        if m.get('OriginatorId') is not None:
            self.originator_id = m.get('OriginatorId')
        if m.get('ProcessInstanceId') is not None:
            self.process_instance_id = m.get('ProcessInstanceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('TitleInEnglish') is not None:
            self.title_in_english = m.get('TitleInEnglish')
        return self


class GetRunningTasksResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: List[GetRunningTasksResponseBodyResult] = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.result = result
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = GetRunningTasksResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetRunningTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRunningTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRunningTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetScheduleHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetScheduleHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetScheduleHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetScheduleHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetScheduleShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetScheduleRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetScheduleRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        start_time: str = None,
        tenant_context: GetScheduleRequestTenantContext = None,
        user_ids: List[str] = None,
    ):
        self.end_time = end_time
        self.start_time = start_time
        self.tenant_context = tenant_context
        self.user_ids = user_ids

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            temp_model = GetScheduleRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        return self


class GetScheduleShrinkRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        start_time: str = None,
        tenant_context_shrink: str = None,
        user_ids_shrink: str = None,
    ):
        self.end_time = end_time
        self.start_time = start_time
        self.tenant_context_shrink = tenant_context_shrink
        self.user_ids_shrink = user_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.user_ids_shrink is not None:
            result['UserIds'] = self.user_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('UserIds') is not None:
            self.user_ids_shrink = m.get('UserIds')
        return self


class GetScheduleResponseBodyScheduleInformationScheduleItemsEnd(TeaModel):
    def __init__(
        self,
        date: str = None,
        date_time: str = None,
        time_zone: str = None,
    ):
        self.date = date
        self.date_time = date_time
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['Date'] = self.date
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.time_zone is not None:
            result['TimeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Date') is not None:
            self.date = m.get('Date')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('TimeZone') is not None:
            self.time_zone = m.get('TimeZone')
        return self


class GetScheduleResponseBodyScheduleInformationScheduleItemsStart(TeaModel):
    def __init__(
        self,
        date: str = None,
        date_time: str = None,
        time_zone: str = None,
    ):
        self.date = date
        self.date_time = date_time
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['Date'] = self.date
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.time_zone is not None:
            result['TimeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Date') is not None:
            self.date = m.get('Date')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('TimeZone') is not None:
            self.time_zone = m.get('TimeZone')
        return self


class GetScheduleResponseBodyScheduleInformationScheduleItems(TeaModel):
    def __init__(
        self,
        end: GetScheduleResponseBodyScheduleInformationScheduleItemsEnd = None,
        start: GetScheduleResponseBodyScheduleInformationScheduleItemsStart = None,
        status: str = None,
    ):
        self.end = end
        self.start = start
        self.status = status

    def validate(self):
        if self.end:
            self.end.validate()
        if self.start:
            self.start.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end.to_map()
        if self.start is not None:
            result['Start'] = self.start.to_map()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('End') is not None:
            temp_model = GetScheduleResponseBodyScheduleInformationScheduleItemsEnd()
            self.end = temp_model.from_map(m['End'])
        if m.get('Start') is not None:
            temp_model = GetScheduleResponseBodyScheduleInformationScheduleItemsStart()
            self.start = temp_model.from_map(m['Start'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetScheduleResponseBodyScheduleInformation(TeaModel):
    def __init__(
        self,
        error: str = None,
        schedule_items: List[GetScheduleResponseBodyScheduleInformationScheduleItems] = None,
        user_id: str = None,
    ):
        self.error = error
        self.schedule_items = schedule_items
        self.user_id = user_id

    def validate(self):
        if self.schedule_items:
            for k in self.schedule_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error is not None:
            result['Error'] = self.error
        result['ScheduleItems'] = []
        if self.schedule_items is not None:
            for k in self.schedule_items:
                result['ScheduleItems'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Error') is not None:
            self.error = m.get('Error')
        self.schedule_items = []
        if m.get('ScheduleItems') is not None:
            for k in m.get('ScheduleItems'):
                temp_model = GetScheduleResponseBodyScheduleInformationScheduleItems()
                self.schedule_items.append(temp_model.from_map(k))
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetScheduleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        schedule_information: List[GetScheduleResponseBodyScheduleInformation] = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.schedule_information = schedule_information
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.schedule_information:
            for k in self.schedule_information:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['scheduleInformation'] = []
        if self.schedule_information is not None:
            for k in self.schedule_information:
                result['scheduleInformation'].append(k.to_map() if k else None)
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.schedule_information = []
        if m.get('scheduleInformation') is not None:
            for k in m.get('scheduleInformation'):
                temp_model = GetScheduleResponseBodyScheduleInformation()
                self.schedule_information.append(temp_model.from_map(k))
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetScheduleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetScheduleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetScheduleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSheetHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetSheetHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetSheetHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetSheetHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetSheetShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetSheetRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetSheetRequest(TeaModel):
    def __init__(
        self,
        sheet_id: str = None,
        tenant_context: GetSheetRequestTenantContext = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context = tenant_context
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            temp_model = GetSheetRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class GetSheetShrinkRequest(TeaModel):
    def __init__(
        self,
        sheet_id: str = None,
        tenant_context_shrink: str = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class GetSheetResponseBody(TeaModel):
    def __init__(
        self,
        column_count: int = None,
        id: str = None,
        last_non_empty_column: int = None,
        last_non_empty_row: int = None,
        name: str = None,
        request_id: str = None,
        row_count: int = None,
        visibility: str = None,
    ):
        self.column_count = column_count
        self.id = id
        self.last_non_empty_column = last_non_empty_column
        self.last_non_empty_row = last_non_empty_row
        self.name = name
        # requestId
        self.request_id = request_id
        self.row_count = row_count
        self.visibility = visibility

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_count is not None:
            result['columnCount'] = self.column_count
        if self.id is not None:
            result['id'] = self.id
        if self.last_non_empty_column is not None:
            result['lastNonEmptyColumn'] = self.last_non_empty_column
        if self.last_non_empty_row is not None:
            result['lastNonEmptyRow'] = self.last_non_empty_row
        if self.name is not None:
            result['name'] = self.name
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.row_count is not None:
            result['rowCount'] = self.row_count
        if self.visibility is not None:
            result['visibility'] = self.visibility
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('columnCount') is not None:
            self.column_count = m.get('columnCount')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('lastNonEmptyColumn') is not None:
            self.last_non_empty_column = m.get('lastNonEmptyColumn')
        if m.get('lastNonEmptyRow') is not None:
            self.last_non_empty_row = m.get('lastNonEmptyRow')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('rowCount') is not None:
            self.row_count = m.get('rowCount')
        if m.get('visibility') is not None:
            self.visibility = m.get('visibility')
        return self


class GetSheetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSheetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSheetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSheetContentJobIdHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetSheetContentJobIdHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetSheetContentJobIdHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetSheetContentJobIdHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetSheetContentJobIdShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetSheetContentJobIdRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetSheetContentJobIdRequest(TeaModel):
    def __init__(
        self,
        dentry_uuid: str = None,
        export_type: str = None,
        tenant_context: GetSheetContentJobIdRequestTenantContext = None,
    ):
        self.dentry_uuid = dentry_uuid
        self.export_type = export_type
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        if self.export_type is not None:
            result['ExportType'] = self.export_type
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        if m.get('ExportType') is not None:
            self.export_type = m.get('ExportType')
        if m.get('TenantContext') is not None:
            temp_model = GetSheetContentJobIdRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetSheetContentJobIdShrinkRequest(TeaModel):
    def __init__(
        self,
        dentry_uuid: str = None,
        export_type: str = None,
        tenant_context_shrink: str = None,
    ):
        self.dentry_uuid = dentry_uuid
        self.export_type = export_type
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        if self.export_type is not None:
            result['ExportType'] = self.export_type
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        if m.get('ExportType') is not None:
            self.export_type = m.get('ExportType')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetSheetContentJobIdResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
        status: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.job_id = job_id
        self.request_id = request_id
        self.status = status
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['jobId'] = self.job_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.status is not None:
            result['status'] = self.status
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('jobId') is not None:
            self.job_id = m.get('jobId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetSheetContentJobIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSheetContentJobIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSheetContentJobIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSpaceDirectoriesHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetSpaceDirectoriesHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetSpaceDirectoriesHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetSpaceDirectoriesHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetSpaceDirectoriesShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetSpaceDirectoriesRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetSpaceDirectoriesRequest(TeaModel):
    def __init__(
        self,
        dentry_id: str = None,
        max_results: int = None,
        next_token: str = None,
        space_id: str = None,
        tenant_context: GetSpaceDirectoriesRequestTenantContext = None,
    ):
        self.dentry_id = dentry_id
        # This parameter is required.
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.space_id = space_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_id is not None:
            result['DentryId'] = self.dentry_id
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryId') is not None:
            self.dentry_id = m.get('DentryId')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('TenantContext') is not None:
            temp_model = GetSpaceDirectoriesRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetSpaceDirectoriesShrinkRequest(TeaModel):
    def __init__(
        self,
        dentry_id: str = None,
        max_results: int = None,
        next_token: str = None,
        space_id: str = None,
        tenant_context_shrink: str = None,
    ):
        self.dentry_id = dentry_id
        # This parameter is required.
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.space_id = space_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_id is not None:
            result['DentryId'] = self.dentry_id
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryId') is not None:
            self.dentry_id = m.get('DentryId')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetSpaceDirectoriesResponseBodyChildrenCreator(TeaModel):
    def __init__(
        self,
        name: str = None,
        user_id: str = None,
    ):
        self.name = name
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl(TeaModel):
    def __init__(
        self,
        line: str = None,
        small: str = None,
    ):
        self.line = line
        self.small = small

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.line is not None:
            result['Line'] = self.line
        if self.small is not None:
            result['Small'] = self.small
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Line') is not None:
            self.line = m.get('Line')
        if m.get('Small') is not None:
            self.small = m.get('Small')
        return self


class GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo(TeaModel):
    def __init__(
        self,
        extension: str = None,
        icon_url: GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl = None,
        id: str = None,
        link_type: int = None,
        space_id: str = None,
    ):
        self.extension = extension
        self.icon_url = icon_url
        self.id = id
        self.link_type = link_type
        self.space_id = space_id

    def validate(self):
        if self.icon_url:
            self.icon_url.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.icon_url is not None:
            result['IconUrl'] = self.icon_url.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.link_type is not None:
            result['LinkType'] = self.link_type
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('IconUrl') is not None:
            temp_model = GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl()
            self.icon_url = temp_model.from_map(m['IconUrl'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LinkType') is not None:
            self.link_type = m.get('LinkType')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        return self


class GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO(TeaModel):
    def __init__(
        self,
        icon: str = None,
        type: str = None,
    ):
        self.icon = icon
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO(TeaModel):
    def __init__(
        self,
        icon: str = None,
        type: str = None,
    ):
        self.icon = icon
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetSpaceDirectoriesResponseBodyChildrenSpaceOwner(TeaModel):
    def __init__(
        self,
        name: str = None,
        user_id: str = None,
    ):
        self.name = name
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo(TeaModel):
    def __init__(
        self,
        dentry_actions: List[str] = None,
        role_code: str = None,
        space_actions: List[str] = None,
    ):
        self.dentry_actions = dentry_actions
        self.role_code = role_code
        self.space_actions = space_actions

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_actions is not None:
            result['DentryActions'] = self.dentry_actions
        if self.role_code is not None:
            result['RoleCode'] = self.role_code
        if self.space_actions is not None:
            result['SpaceActions'] = self.space_actions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryActions') is not None:
            self.dentry_actions = m.get('DentryActions')
        if m.get('RoleCode') is not None:
            self.role_code = m.get('RoleCode')
        if m.get('SpaceActions') is not None:
            self.space_actions = m.get('SpaceActions')
        return self


class GetSpaceDirectoriesResponseBodyChildrenSpace(TeaModel):
    def __init__(
        self,
        cover: str = None,
        description: str = None,
        hd_icon_vo: GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO = None,
        icon_vo: GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO = None,
        id: str = None,
        name: str = None,
        owner: GetSpaceDirectoriesResponseBodyChildrenSpaceOwner = None,
        recent_list: List[Any] = None,
        type: int = None,
        url: str = None,
        visitor_info: GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo = None,
    ):
        self.cover = cover
        self.description = description
        self.hd_icon_vo = hd_icon_vo
        self.icon_vo = icon_vo
        self.id = id
        self.name = name
        self.owner = owner
        self.recent_list = recent_list
        self.type = type
        self.url = url
        self.visitor_info = visitor_info

    def validate(self):
        if self.hd_icon_vo:
            self.hd_icon_vo.validate()
        if self.icon_vo:
            self.icon_vo.validate()
        if self.owner:
            self.owner.validate()
        if self.visitor_info:
            self.visitor_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cover is not None:
            result['Cover'] = self.cover
        if self.description is not None:
            result['Description'] = self.description
        if self.hd_icon_vo is not None:
            result['HdIconVO'] = self.hd_icon_vo.to_map()
        if self.icon_vo is not None:
            result['IconVO'] = self.icon_vo.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner.to_map()
        if self.recent_list is not None:
            result['RecentList'] = self.recent_list
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        if self.visitor_info is not None:
            result['VisitorInfo'] = self.visitor_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cover') is not None:
            self.cover = m.get('Cover')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('HdIconVO') is not None:
            temp_model = GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO()
            self.hd_icon_vo = temp_model.from_map(m['HdIconVO'])
        if m.get('IconVO') is not None:
            temp_model = GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO()
            self.icon_vo = temp_model.from_map(m['IconVO'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            temp_model = GetSpaceDirectoriesResponseBodyChildrenSpaceOwner()
            self.owner = temp_model.from_map(m['Owner'])
        if m.get('RecentList') is not None:
            self.recent_list = m.get('RecentList')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('VisitorInfo') is not None:
            temp_model = GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo()
            self.visitor_info = temp_model.from_map(m['VisitorInfo'])
        return self


class GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo(TeaModel):
    def __init__(
        self,
        word_count: int = None,
    ):
        # WordCount
        self.word_count = word_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.word_count is not None:
            result['WordCount'] = self.word_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WordCount') is not None:
            self.word_count = m.get('WordCount')
        return self


class GetSpaceDirectoriesResponseBodyChildrenUpdater(TeaModel):
    def __init__(
        self,
        name: str = None,
        user_id: str = None,
    ):
        self.name = name
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetSpaceDirectoriesResponseBodyChildrenVisitorInfo(TeaModel):
    def __init__(
        self,
        dentry_actions: List[str] = None,
        role_code: str = None,
        space_actions: List[str] = None,
    ):
        self.dentry_actions = dentry_actions
        self.role_code = role_code
        self.space_actions = space_actions

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_actions is not None:
            result['DentryActions'] = self.dentry_actions
        if self.role_code is not None:
            result['RoleCode'] = self.role_code
        if self.space_actions is not None:
            result['SpaceActions'] = self.space_actions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryActions') is not None:
            self.dentry_actions = m.get('DentryActions')
        if m.get('RoleCode') is not None:
            self.role_code = m.get('RoleCode')
        if m.get('SpaceActions') is not None:
            self.space_actions = m.get('SpaceActions')
        return self


class GetSpaceDirectoriesResponseBodyChildren(TeaModel):
    def __init__(
        self,
        content_type: str = None,
        created_time: int = None,
        creator: GetSpaceDirectoriesResponseBodyChildrenCreator = None,
        dentry_id: str = None,
        dentry_type: str = None,
        dentry_uuid: str = None,
        doc_key: str = None,
        extension: str = None,
        has_children: bool = None,
        link_source_info: GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo = None,
        name: str = None,
        path: str = None,
        space: GetSpaceDirectoriesResponseBodyChildrenSpace = None,
        space_id: str = None,
        statistical_info: GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo = None,
        updated_time: int = None,
        updater: GetSpaceDirectoriesResponseBodyChildrenUpdater = None,
        url: str = None,
        visitor_info: GetSpaceDirectoriesResponseBodyChildrenVisitorInfo = None,
    ):
        self.content_type = content_type
        self.created_time = created_time
        self.creator = creator
        self.dentry_id = dentry_id
        self.dentry_type = dentry_type
        self.dentry_uuid = dentry_uuid
        self.doc_key = doc_key
        self.extension = extension
        self.has_children = has_children
        self.link_source_info = link_source_info
        self.name = name
        self.path = path
        self.space = space
        self.space_id = space_id
        self.statistical_info = statistical_info
        self.updated_time = updated_time
        self.updater = updater
        self.url = url
        self.visitor_info = visitor_info

    def validate(self):
        if self.creator:
            self.creator.validate()
        if self.link_source_info:
            self.link_source_info.validate()
        if self.space:
            self.space.validate()
        if self.statistical_info:
            self.statistical_info.validate()
        if self.updater:
            self.updater.validate()
        if self.visitor_info:
            self.visitor_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['ContentType'] = self.content_type
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.creator is not None:
            result['Creator'] = self.creator.to_map()
        if self.dentry_id is not None:
            result['DentryId'] = self.dentry_id
        if self.dentry_type is not None:
            result['DentryType'] = self.dentry_type
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        if self.doc_key is not None:
            result['DocKey'] = self.doc_key
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.has_children is not None:
            result['HasChildren'] = self.has_children
        if self.link_source_info is not None:
            result['LinkSourceInfo'] = self.link_source_info.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.path is not None:
            result['Path'] = self.path
        if self.space is not None:
            result['Space'] = self.space.to_map()
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.statistical_info is not None:
            result['StatisticalInfo'] = self.statistical_info.to_map()
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        if self.updater is not None:
            result['Updater'] = self.updater.to_map()
        if self.url is not None:
            result['Url'] = self.url
        if self.visitor_info is not None:
            result['VisitorInfo'] = self.visitor_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContentType') is not None:
            self.content_type = m.get('ContentType')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Creator') is not None:
            temp_model = GetSpaceDirectoriesResponseBodyChildrenCreator()
            self.creator = temp_model.from_map(m['Creator'])
        if m.get('DentryId') is not None:
            self.dentry_id = m.get('DentryId')
        if m.get('DentryType') is not None:
            self.dentry_type = m.get('DentryType')
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        if m.get('DocKey') is not None:
            self.doc_key = m.get('DocKey')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('HasChildren') is not None:
            self.has_children = m.get('HasChildren')
        if m.get('LinkSourceInfo') is not None:
            temp_model = GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo()
            self.link_source_info = temp_model.from_map(m['LinkSourceInfo'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Space') is not None:
            temp_model = GetSpaceDirectoriesResponseBodyChildrenSpace()
            self.space = temp_model.from_map(m['Space'])
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('StatisticalInfo') is not None:
            temp_model = GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo()
            self.statistical_info = temp_model.from_map(m['StatisticalInfo'])
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        if m.get('Updater') is not None:
            temp_model = GetSpaceDirectoriesResponseBodyChildrenUpdater()
            self.updater = temp_model.from_map(m['Updater'])
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('VisitorInfo') is not None:
            temp_model = GetSpaceDirectoriesResponseBodyChildrenVisitorInfo()
            self.visitor_info = temp_model.from_map(m['VisitorInfo'])
        return self


class GetSpaceDirectoriesResponseBody(TeaModel):
    def __init__(
        self,
        children: List[GetSpaceDirectoriesResponseBodyChildren] = None,
        has_more: bool = None,
        next_token: str = None,
        request_id: str = None,
    ):
        self.children = children
        self.has_more = has_more
        self.next_token = next_token
        # requestId
        self.request_id = request_id

    def validate(self):
        if self.children:
            for k in self.children:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['children'] = []
        if self.children is not None:
            for k in self.children:
                result['children'].append(k.to_map() if k else None)
        if self.has_more is not None:
            result['hasMore'] = self.has_more
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.children = []
        if m.get('children') is not None:
            for k in m.get('children'):
                temp_model = GetSpaceDirectoriesResponseBodyChildren()
                self.children.append(temp_model.from_map(k))
        if m.get('hasMore') is not None:
            self.has_more = m.get('hasMore')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetSpaceDirectoriesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSpaceDirectoriesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSpaceDirectoriesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSubscribedCalendarHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetSubscribedCalendarHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetSubscribedCalendarHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetSubscribedCalendarHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetSubscribedCalendarShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetSubscribedCalendarRequest(TeaModel):
    def __init__(
        self,
        calendar_id: str = None,
    ):
        # This parameter is required.
        self.calendar_id = calendar_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        return self


class GetSubscribedCalendarResponseBodySubscribeScope(TeaModel):
    def __init__(
        self,
        corp_ids: List[str] = None,
        open_conversation_ids: List[str] = None,
        user_ids: List[str] = None,
    ):
        self.corp_ids = corp_ids
        self.open_conversation_ids = open_conversation_ids
        self.user_ids = user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.corp_ids is not None:
            result['CorpIds'] = self.corp_ids
        if self.open_conversation_ids is not None:
            result['OpenConversationIds'] = self.open_conversation_ids
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CorpIds') is not None:
            self.corp_ids = m.get('CorpIds')
        if m.get('OpenConversationIds') is not None:
            self.open_conversation_ids = m.get('OpenConversationIds')
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        return self


class GetSubscribedCalendarResponseBody(TeaModel):
    def __init__(
        self,
        author: str = None,
        calendar_id: str = None,
        description: str = None,
        managers: List[str] = None,
        name: str = None,
        request_id: str = None,
        subscribe_scope: GetSubscribedCalendarResponseBodySubscribeScope = None,
    ):
        self.author = author
        self.calendar_id = calendar_id
        self.description = description
        self.managers = managers
        self.name = name
        # requestId
        self.request_id = request_id
        self.subscribe_scope = subscribe_scope

    def validate(self):
        if self.subscribe_scope:
            self.subscribe_scope.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['author'] = self.author
        if self.calendar_id is not None:
            result['calendarId'] = self.calendar_id
        if self.description is not None:
            result['description'] = self.description
        if self.managers is not None:
            result['managers'] = self.managers
        if self.name is not None:
            result['name'] = self.name
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.subscribe_scope is not None:
            result['subscribeScope'] = self.subscribe_scope.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('author') is not None:
            self.author = m.get('author')
        if m.get('calendarId') is not None:
            self.calendar_id = m.get('calendarId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('managers') is not None:
            self.managers = m.get('managers')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('subscribeScope') is not None:
            temp_model = GetSubscribedCalendarResponseBodySubscribeScope()
            self.subscribe_scope = temp_model.from_map(m['subscribeScope'])
        return self


class GetSubscribedCalendarResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSubscribedCalendarResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSubscribedCalendarResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskCopiesHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetTaskCopiesHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetTaskCopiesHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetTaskCopiesHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetTaskCopiesShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetTaskCopiesRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        create_from_time_gmt: int = None,
        create_to_time_gmt: int = None,
        keyword: str = None,
        language: str = None,
        page_number: int = None,
        page_size: int = None,
        process_codes: str = None,
        system_token: str = None,
    ):
        self.app_type = app_type
        self.create_from_time_gmt = create_from_time_gmt
        self.create_to_time_gmt = create_to_time_gmt
        self.keyword = keyword
        self.language = language
        self.page_number = page_number
        self.page_size = page_size
        self.process_codes = process_codes
        # This parameter is required.
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.create_from_time_gmt is not None:
            result['CreateFromTimeGMT'] = self.create_from_time_gmt
        if self.create_to_time_gmt is not None:
            result['CreateToTimeGMT'] = self.create_to_time_gmt
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.language is not None:
            result['Language'] = self.language
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.process_codes is not None:
            result['ProcessCodes'] = self.process_codes
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('CreateFromTimeGMT') is not None:
            self.create_from_time_gmt = m.get('CreateFromTimeGMT')
        if m.get('CreateToTimeGMT') is not None:
            self.create_to_time_gmt = m.get('CreateToTimeGMT')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProcessCodes') is not None:
            self.process_codes = m.get('ProcessCodes')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class GetTaskCopiesResponseBodyDataCurrentActivityInstances(TeaModel):
    def __init__(
        self,
        activity_id: str = None,
        activity_instance_status: str = None,
        activity_name: str = None,
        activity_name_in_english: str = None,
        id: int = None,
    ):
        self.activity_id = activity_id
        self.activity_instance_status = activity_instance_status
        self.activity_name = activity_name
        self.activity_name_in_english = activity_name_in_english
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_id is not None:
            result['ActivityId'] = self.activity_id
        if self.activity_instance_status is not None:
            result['ActivityInstanceStatus'] = self.activity_instance_status
        if self.activity_name is not None:
            result['ActivityName'] = self.activity_name
        if self.activity_name_in_english is not None:
            result['ActivityNameInEnglish'] = self.activity_name_in_english
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityId') is not None:
            self.activity_id = m.get('ActivityId')
        if m.get('ActivityInstanceStatus') is not None:
            self.activity_instance_status = m.get('ActivityInstanceStatus')
        if m.get('ActivityName') is not None:
            self.activity_name = m.get('ActivityName')
        if m.get('ActivityNameInEnglish') is not None:
            self.activity_name_in_english = m.get('ActivityNameInEnglish')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetTaskCopiesResponseBodyData(TeaModel):
    def __init__(
        self,
        action_executor_id: List[str] = None,
        action_executor_name: List[str] = None,
        app_type: str = None,
        carbon_activity_id: str = None,
        create_time_gmt: str = None,
        current_activity_instances: List[GetTaskCopiesResponseBodyDataCurrentActivityInstances] = None,
        data_map: Dict[str, Any] = None,
        data_type: str = None,
        finish_time_gmt: str = None,
        form_instance_id: str = None,
        form_uuid: str = None,
        instance_value: str = None,
        modified_time_gmt: str = None,
        originator_avatar: str = None,
        originator_display_name: str = None,
        originator_id: str = None,
        process_approved_result: str = None,
        process_approved_result_text: str = None,
        process_code: str = None,
        process_id: int = None,
        process_instance_id: str = None,
        process_instance_status: str = None,
        process_instance_status_text: str = None,
        process_name: str = None,
        serial_number: str = None,
        title: str = None,
        version: int = None,
    ):
        self.action_executor_id = action_executor_id
        self.action_executor_name = action_executor_name
        self.app_type = app_type
        self.carbon_activity_id = carbon_activity_id
        self.create_time_gmt = create_time_gmt
        self.current_activity_instances = current_activity_instances
        self.data_map = data_map
        self.data_type = data_type
        self.finish_time_gmt = finish_time_gmt
        self.form_instance_id = form_instance_id
        self.form_uuid = form_uuid
        self.instance_value = instance_value
        self.modified_time_gmt = modified_time_gmt
        self.originator_avatar = originator_avatar
        self.originator_display_name = originator_display_name
        self.originator_id = originator_id
        self.process_approved_result = process_approved_result
        self.process_approved_result_text = process_approved_result_text
        self.process_code = process_code
        self.process_id = process_id
        self.process_instance_id = process_instance_id
        self.process_instance_status = process_instance_status
        self.process_instance_status_text = process_instance_status_text
        self.process_name = process_name
        self.serial_number = serial_number
        self.title = title
        self.version = version

    def validate(self):
        if self.current_activity_instances:
            for k in self.current_activity_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_executor_id is not None:
            result['ActionExecutorId'] = self.action_executor_id
        if self.action_executor_name is not None:
            result['ActionExecutorName'] = self.action_executor_name
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.carbon_activity_id is not None:
            result['CarbonActivityId'] = self.carbon_activity_id
        if self.create_time_gmt is not None:
            result['CreateTimeGMT'] = self.create_time_gmt
        result['CurrentActivityInstances'] = []
        if self.current_activity_instances is not None:
            for k in self.current_activity_instances:
                result['CurrentActivityInstances'].append(k.to_map() if k else None)
        if self.data_map is not None:
            result['DataMap'] = self.data_map
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.finish_time_gmt is not None:
            result['FinishTimeGMT'] = self.finish_time_gmt
        if self.form_instance_id is not None:
            result['FormInstanceId'] = self.form_instance_id
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.instance_value is not None:
            result['InstanceValue'] = self.instance_value
        if self.modified_time_gmt is not None:
            result['ModifiedTimeGMT'] = self.modified_time_gmt
        if self.originator_avatar is not None:
            result['OriginatorAvatar'] = self.originator_avatar
        if self.originator_display_name is not None:
            result['OriginatorDisplayName'] = self.originator_display_name
        if self.originator_id is not None:
            result['OriginatorId'] = self.originator_id
        if self.process_approved_result is not None:
            result['ProcessApprovedResult'] = self.process_approved_result
        if self.process_approved_result_text is not None:
            result['ProcessApprovedResultText'] = self.process_approved_result_text
        if self.process_code is not None:
            result['ProcessCode'] = self.process_code
        if self.process_id is not None:
            result['ProcessId'] = self.process_id
        if self.process_instance_id is not None:
            result['ProcessInstanceId'] = self.process_instance_id
        if self.process_instance_status is not None:
            result['ProcessInstanceStatus'] = self.process_instance_status
        if self.process_instance_status_text is not None:
            result['ProcessInstanceStatusText'] = self.process_instance_status_text
        if self.process_name is not None:
            result['ProcessName'] = self.process_name
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        if self.title is not None:
            result['Title'] = self.title
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionExecutorId') is not None:
            self.action_executor_id = m.get('ActionExecutorId')
        if m.get('ActionExecutorName') is not None:
            self.action_executor_name = m.get('ActionExecutorName')
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('CarbonActivityId') is not None:
            self.carbon_activity_id = m.get('CarbonActivityId')
        if m.get('CreateTimeGMT') is not None:
            self.create_time_gmt = m.get('CreateTimeGMT')
        self.current_activity_instances = []
        if m.get('CurrentActivityInstances') is not None:
            for k in m.get('CurrentActivityInstances'):
                temp_model = GetTaskCopiesResponseBodyDataCurrentActivityInstances()
                self.current_activity_instances.append(temp_model.from_map(k))
        if m.get('DataMap') is not None:
            self.data_map = m.get('DataMap')
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('FinishTimeGMT') is not None:
            self.finish_time_gmt = m.get('FinishTimeGMT')
        if m.get('FormInstanceId') is not None:
            self.form_instance_id = m.get('FormInstanceId')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('InstanceValue') is not None:
            self.instance_value = m.get('InstanceValue')
        if m.get('ModifiedTimeGMT') is not None:
            self.modified_time_gmt = m.get('ModifiedTimeGMT')
        if m.get('OriginatorAvatar') is not None:
            self.originator_avatar = m.get('OriginatorAvatar')
        if m.get('OriginatorDisplayName') is not None:
            self.originator_display_name = m.get('OriginatorDisplayName')
        if m.get('OriginatorId') is not None:
            self.originator_id = m.get('OriginatorId')
        if m.get('ProcessApprovedResult') is not None:
            self.process_approved_result = m.get('ProcessApprovedResult')
        if m.get('ProcessApprovedResultText') is not None:
            self.process_approved_result_text = m.get('ProcessApprovedResultText')
        if m.get('ProcessCode') is not None:
            self.process_code = m.get('ProcessCode')
        if m.get('ProcessId') is not None:
            self.process_id = m.get('ProcessId')
        if m.get('ProcessInstanceId') is not None:
            self.process_instance_id = m.get('ProcessInstanceId')
        if m.get('ProcessInstanceStatus') is not None:
            self.process_instance_status = m.get('ProcessInstanceStatus')
        if m.get('ProcessInstanceStatusText') is not None:
            self.process_instance_status_text = m.get('ProcessInstanceStatusText')
        if m.get('ProcessName') is not None:
            self.process_name = m.get('ProcessName')
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class GetTaskCopiesResponseBody(TeaModel):
    def __init__(
        self,
        data: List[GetTaskCopiesResponseBodyData] = None,
        page_number: int = None,
        request_id: str = None,
        total_count: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.data = data
        self.page_number = page_number
        self.request_id = request_id
        self.total_count = total_count
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = GetTaskCopiesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetTaskCopiesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTaskCopiesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTaskCopiesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTemplateListByUserIdHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetTemplateListByUserIdHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetTemplateListByUserIdHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetTemplateListByUserIdHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetTemplateListByUserIdShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetTemplateListByUserIdRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetTemplateListByUserIdRequest(TeaModel):
    def __init__(
        self,
        offset: int = None,
        size: int = None,
        tenant_context: GetTemplateListByUserIdRequestTenantContext = None,
    ):
        # This parameter is required.
        self.offset = offset
        # This parameter is required.
        self.size = size
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.offset is not None:
            result['Offset'] = self.offset
        if self.size is not None:
            result['Size'] = self.size
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('TenantContext') is not None:
            temp_model = GetTemplateListByUserIdRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetTemplateListByUserIdShrinkRequest(TeaModel):
    def __init__(
        self,
        offset: int = None,
        size: int = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.offset = offset
        # This parameter is required.
        self.size = size
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.offset is not None:
            result['Offset'] = self.offset
        if self.size is not None:
            result['Size'] = self.size
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetTemplateListByUserIdResponseBodyTemplateList(TeaModel):
    def __init__(
        self,
        icon_url: str = None,
        name: str = None,
        report_code: str = None,
        url: str = None,
    ):
        self.icon_url = icon_url
        self.name = name
        self.report_code = report_code
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.icon_url is not None:
            result['IconUrl'] = self.icon_url
        if self.name is not None:
            result['Name'] = self.name
        if self.report_code is not None:
            result['ReportCode'] = self.report_code
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IconUrl') is not None:
            self.icon_url = m.get('IconUrl')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ReportCode') is not None:
            self.report_code = m.get('ReportCode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetTemplateListByUserIdResponseBody(TeaModel):
    def __init__(
        self,
        next_cursor: int = None,
        request_id: str = None,
        template_list: List[GetTemplateListByUserIdResponseBodyTemplateList] = None,
    ):
        self.next_cursor = next_cursor
        # requestId
        self.request_id = request_id
        self.template_list = template_list

    def validate(self):
        if self.template_list:
            for k in self.template_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_cursor is not None:
            result['nextCursor'] = self.next_cursor
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['templateList'] = []
        if self.template_list is not None:
            for k in self.template_list:
                result['templateList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('nextCursor') is not None:
            self.next_cursor = m.get('nextCursor')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.template_list = []
        if m.get('templateList') is not None:
            for k in m.get('templateList'):
                temp_model = GetTemplateListByUserIdResponseBodyTemplateList()
                self.template_list.append(temp_model.from_map(k))
        return self


class GetTemplateListByUserIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTemplateListByUserIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTemplateListByUserIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTicketHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetTicketHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetTicketHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetTicketHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetTicketShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetTicketRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetTicketRequest(TeaModel):
    def __init__(
        self,
        open_team_id: str = None,
        open_ticket_id: str = None,
        tenant_context: GetTicketRequestTenantContext = None,
    ):
        # This parameter is required.
        self.open_team_id = open_team_id
        # This parameter is required.
        self.open_ticket_id = open_ticket_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.open_team_id is not None:
            result['OpenTeamId'] = self.open_team_id
        if self.open_ticket_id is not None:
            result['OpenTicketId'] = self.open_ticket_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OpenTeamId') is not None:
            self.open_team_id = m.get('OpenTeamId')
        if m.get('OpenTicketId') is not None:
            self.open_ticket_id = m.get('OpenTicketId')
        if m.get('TenantContext') is not None:
            temp_model = GetTicketRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetTicketShrinkRequest(TeaModel):
    def __init__(
        self,
        open_team_id: str = None,
        open_ticket_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.open_team_id = open_team_id
        # This parameter is required.
        self.open_ticket_id = open_ticket_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.open_team_id is not None:
            result['OpenTeamId'] = self.open_team_id
        if self.open_ticket_id is not None:
            result['OpenTicketId'] = self.open_ticket_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OpenTeamId') is not None:
            self.open_team_id = m.get('OpenTeamId')
        if m.get('OpenTicketId') is not None:
            self.open_ticket_id = m.get('OpenTicketId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetTicketResponseBodyCreator(TeaModel):
    def __init__(
        self,
        nick_name: str = None,
        union_id: str = None,
    ):
        self.nick_name = nick_name
        self.union_id = union_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.union_id is not None:
            result['UnionId'] = self.union_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('UnionId') is not None:
            self.union_id = m.get('UnionId')
        return self


class GetTicketResponseBodyProcessor(TeaModel):
    def __init__(
        self,
        nick_name: str = None,
        union_id: str = None,
    ):
        self.nick_name = nick_name
        self.union_id = union_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.union_id is not None:
            result['UnionId'] = self.union_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('UnionId') is not None:
            self.union_id = m.get('UnionId')
        return self


class GetTicketResponseBodyTakers(TeaModel):
    def __init__(
        self,
        nick_name: str = None,
        union_id: str = None,
    ):
        self.nick_name = nick_name
        self.union_id = union_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.union_id is not None:
            result['UnionId'] = self.union_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('UnionId') is not None:
            self.union_id = m.get('UnionId')
        return self


class GetTicketResponseBodyTemplate(TeaModel):
    def __init__(
        self,
        open_template_biz_id: str = None,
        open_template_id: str = None,
        template_name: str = None,
    ):
        # OpenTemplateBizId
        self.open_template_biz_id = open_template_biz_id
        # OpenTemplateBizId
        self.open_template_id = open_template_id
        self.template_name = template_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.open_template_biz_id is not None:
            result['OpenTemplateBizId'] = self.open_template_biz_id
        if self.open_template_id is not None:
            result['OpenTemplateId'] = self.open_template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OpenTemplateBizId') is not None:
            self.open_template_biz_id = m.get('OpenTemplateBizId')
        if m.get('OpenTemplateId') is not None:
            self.open_template_id = m.get('OpenTemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        return self


class GetTicketResponseBody(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        creator: GetTicketResponseBodyCreator = None,
        custom_fields: str = None,
        open_conversation_id: str = None,
        open_ticket_id: str = None,
        processor: GetTicketResponseBodyProcessor = None,
        request_id: str = None,
        scene: str = None,
        scene_context: str = None,
        stage: str = None,
        takers: List[GetTicketResponseBodyTakers] = None,
        template: GetTicketResponseBodyTemplate = None,
        title: str = None,
        update_time: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.create_time = create_time
        self.creator = creator
        self.custom_fields = custom_fields
        self.open_conversation_id = open_conversation_id
        self.open_ticket_id = open_ticket_id
        self.processor = processor
        self.request_id = request_id
        self.scene = scene
        self.scene_context = scene_context
        self.stage = stage
        self.takers = takers
        self.template = template
        self.title = title
        self.update_time = update_time
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.creator:
            self.creator.validate()
        if self.processor:
            self.processor.validate()
        if self.takers:
            for k in self.takers:
                if k:
                    k.validate()
        if self.template:
            self.template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.creator is not None:
            result['creator'] = self.creator.to_map()
        if self.custom_fields is not None:
            result['customFields'] = self.custom_fields
        if self.open_conversation_id is not None:
            result['openConversationId'] = self.open_conversation_id
        if self.open_ticket_id is not None:
            result['openTicketId'] = self.open_ticket_id
        if self.processor is not None:
            result['processor'] = self.processor.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.scene is not None:
            result['scene'] = self.scene
        if self.scene_context is not None:
            result['sceneContext'] = self.scene_context
        if self.stage is not None:
            result['stage'] = self.stage
        result['takers'] = []
        if self.takers is not None:
            for k in self.takers:
                result['takers'].append(k.to_map() if k else None)
        if self.template is not None:
            result['template'] = self.template.to_map()
        if self.title is not None:
            result['title'] = self.title
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('creator') is not None:
            temp_model = GetTicketResponseBodyCreator()
            self.creator = temp_model.from_map(m['creator'])
        if m.get('customFields') is not None:
            self.custom_fields = m.get('customFields')
        if m.get('openConversationId') is not None:
            self.open_conversation_id = m.get('openConversationId')
        if m.get('openTicketId') is not None:
            self.open_ticket_id = m.get('openTicketId')
        if m.get('processor') is not None:
            temp_model = GetTicketResponseBodyProcessor()
            self.processor = temp_model.from_map(m['processor'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        if m.get('sceneContext') is not None:
            self.scene_context = m.get('sceneContext')
        if m.get('stage') is not None:
            self.stage = m.get('stage')
        self.takers = []
        if m.get('takers') is not None:
            for k in m.get('takers'):
                temp_model = GetTicketResponseBodyTakers()
                self.takers.append(temp_model.from_map(k))
        if m.get('template') is not None:
            temp_model = GetTicketResponseBodyTemplate()
            self.template = temp_model.from_map(m['template'])
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetTicketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTicketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTicketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTodoTaskHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetTodoTaskHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetTodoTaskHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetTodoTaskHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetTodoTaskShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetTodoTaskRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetTodoTaskRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        tenant_context: GetTodoTaskRequestTenantContext = None,
    ):
        # This parameter is required.
        self.task_id = task_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TenantContext') is not None:
            temp_model = GetTodoTaskRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetTodoTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.task_id = task_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetTodoTaskResponseBodyDetailUrl(TeaModel):
    def __init__(
        self,
        app_url: str = None,
        pc_url: str = None,
    ):
        self.app_url = app_url
        self.pc_url = pc_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_url is not None:
            result['AppUrl'] = self.app_url
        if self.pc_url is not None:
            result['PcUrl'] = self.pc_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppUrl') is not None:
            self.app_url = m.get('AppUrl')
        if m.get('PcUrl') is not None:
            self.pc_url = m.get('PcUrl')
        return self


class GetTodoTaskResponseBody(TeaModel):
    def __init__(
        self,
        biz_tag: str = None,
        card_type_id: str = None,
        created_time: int = None,
        creator_id: str = None,
        description: str = None,
        detail_url: GetTodoTaskResponseBodyDetailUrl = None,
        done: bool = None,
        due_time: int = None,
        executor_ids: List[str] = None,
        finish_time: int = None,
        id: str = None,
        is_only_show_executor: bool = None,
        modified_time: int = None,
        modifier_id: str = None,
        participant_ids: List[str] = None,
        priority: int = None,
        request_id: str = None,
        source: str = None,
        source_id: str = None,
        start_time: int = None,
        subject: str = None,
        tenant_id: str = None,
        tenant_type: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.biz_tag = biz_tag
        self.card_type_id = card_type_id
        self.created_time = created_time
        self.creator_id = creator_id
        self.description = description
        self.detail_url = detail_url
        self.done = done
        self.due_time = due_time
        self.executor_ids = executor_ids
        self.finish_time = finish_time
        self.id = id
        self.is_only_show_executor = is_only_show_executor
        self.modified_time = modified_time
        self.modifier_id = modifier_id
        self.participant_ids = participant_ids
        self.priority = priority
        self.request_id = request_id
        self.source = source
        self.source_id = source_id
        self.start_time = start_time
        self.subject = subject
        self.tenant_id = tenant_id
        self.tenant_type = tenant_type
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.detail_url:
            self.detail_url.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_tag is not None:
            result['bizTag'] = self.biz_tag
        if self.card_type_id is not None:
            result['cardTypeId'] = self.card_type_id
        if self.created_time is not None:
            result['createdTime'] = self.created_time
        if self.creator_id is not None:
            result['creatorId'] = self.creator_id
        if self.description is not None:
            result['description'] = self.description
        if self.detail_url is not None:
            result['detailUrl'] = self.detail_url.to_map()
        if self.done is not None:
            result['done'] = self.done
        if self.due_time is not None:
            result['dueTime'] = self.due_time
        if self.executor_ids is not None:
            result['executorIds'] = self.executor_ids
        if self.finish_time is not None:
            result['finishTime'] = self.finish_time
        if self.id is not None:
            result['id'] = self.id
        if self.is_only_show_executor is not None:
            result['isOnlyShowExecutor'] = self.is_only_show_executor
        if self.modified_time is not None:
            result['modifiedTime'] = self.modified_time
        if self.modifier_id is not None:
            result['modifierId'] = self.modifier_id
        if self.participant_ids is not None:
            result['participantIds'] = self.participant_ids
        if self.priority is not None:
            result['priority'] = self.priority
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.source is not None:
            result['source'] = self.source
        if self.source_id is not None:
            result['sourceId'] = self.source_id
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.subject is not None:
            result['subject'] = self.subject
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        if self.tenant_type is not None:
            result['tenantType'] = self.tenant_type
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bizTag') is not None:
            self.biz_tag = m.get('bizTag')
        if m.get('cardTypeId') is not None:
            self.card_type_id = m.get('cardTypeId')
        if m.get('createdTime') is not None:
            self.created_time = m.get('createdTime')
        if m.get('creatorId') is not None:
            self.creator_id = m.get('creatorId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('detailUrl') is not None:
            temp_model = GetTodoTaskResponseBodyDetailUrl()
            self.detail_url = temp_model.from_map(m['detailUrl'])
        if m.get('done') is not None:
            self.done = m.get('done')
        if m.get('dueTime') is not None:
            self.due_time = m.get('dueTime')
        if m.get('executorIds') is not None:
            self.executor_ids = m.get('executorIds')
        if m.get('finishTime') is not None:
            self.finish_time = m.get('finishTime')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('isOnlyShowExecutor') is not None:
            self.is_only_show_executor = m.get('isOnlyShowExecutor')
        if m.get('modifiedTime') is not None:
            self.modified_time = m.get('modifiedTime')
        if m.get('modifierId') is not None:
            self.modifier_id = m.get('modifierId')
        if m.get('participantIds') is not None:
            self.participant_ids = m.get('participantIds')
        if m.get('priority') is not None:
            self.priority = m.get('priority')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('sourceId') is not None:
            self.source_id = m.get('sourceId')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        if m.get('tenantType') is not None:
            self.tenant_type = m.get('tenantType')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetTodoTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTodoTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTodoTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUserHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetUserHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetUserHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetUserHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetUserShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetUserRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetUserRequest(TeaModel):
    def __init__(
        self,
        tenant_context: GetUserRequestTenantContext = None,
        language: str = None,
    ):
        self.tenant_context = tenant_context
        self.language = language

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.language is not None:
            result['language'] = self.language
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = GetUserRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('language') is not None:
            self.language = m.get('language')
        return self


class GetUserShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        language: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        self.language = language

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.language is not None:
            result['language'] = self.language
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('language') is not None:
            self.language = m.get('language')
        return self


class GetUserResponseBodyDeptOrderList(TeaModel):
    def __init__(
        self,
        dept_id: int = None,
        order: int = None,
    ):
        self.dept_id = dept_id
        self.order = order

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dept_id is not None:
            result['deptId'] = self.dept_id
        if self.order is not None:
            result['order'] = self.order
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('deptId') is not None:
            self.dept_id = m.get('deptId')
        if m.get('order') is not None:
            self.order = m.get('order')
        return self


class GetUserResponseBodyLeaderInDept(TeaModel):
    def __init__(
        self,
        dept_id: int = None,
        leader: bool = None,
    ):
        self.dept_id = dept_id
        self.leader = leader

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dept_id is not None:
            result['deptId'] = self.dept_id
        if self.leader is not None:
            result['leader'] = self.leader
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('deptId') is not None:
            self.dept_id = m.get('deptId')
        if m.get('leader') is not None:
            self.leader = m.get('leader')
        return self


class GetUserResponseBodyRoleList(TeaModel):
    def __init__(
        self,
        group_name: str = None,
        id: int = None,
        name: str = None,
    ):
        self.group_name = group_name
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_name is not None:
            result['groupName'] = self.group_name
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('groupName') is not None:
            self.group_name = m.get('groupName')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetUserResponseBodyUnionEmpExtUnionEmpMapList(TeaModel):
    def __init__(
        self,
        crop_id: str = None,
        userid: str = None,
    ):
        self.crop_id = crop_id
        self.userid = userid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.crop_id is not None:
            result['cropId'] = self.crop_id
        if self.userid is not None:
            result['userid'] = self.userid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cropId') is not None:
            self.crop_id = m.get('cropId')
        if m.get('userid') is not None:
            self.userid = m.get('userid')
        return self


class GetUserResponseBodyUnionEmpExt(TeaModel):
    def __init__(
        self,
        corp_id: str = None,
        union_emp_map_list: List[GetUserResponseBodyUnionEmpExtUnionEmpMapList] = None,
        userid: str = None,
    ):
        self.corp_id = corp_id
        self.union_emp_map_list = union_emp_map_list
        self.userid = userid

    def validate(self):
        if self.union_emp_map_list:
            for k in self.union_emp_map_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.corp_id is not None:
            result['corpId'] = self.corp_id
        result['unionEmpMapList'] = []
        if self.union_emp_map_list is not None:
            for k in self.union_emp_map_list:
                result['unionEmpMapList'].append(k.to_map() if k else None)
        if self.userid is not None:
            result['userid'] = self.userid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('corpId') is not None:
            self.corp_id = m.get('corpId')
        self.union_emp_map_list = []
        if m.get('unionEmpMapList') is not None:
            for k in m.get('unionEmpMapList'):
                temp_model = GetUserResponseBodyUnionEmpExtUnionEmpMapList()
                self.union_emp_map_list.append(temp_model.from_map(k))
        if m.get('userid') is not None:
            self.userid = m.get('userid')
        return self


class GetUserResponseBody(TeaModel):
    def __init__(
        self,
        active: bool = None,
        admin: bool = None,
        avatar: str = None,
        boss: bool = None,
        dept_id_list: List[int] = None,
        dept_order_list: List[GetUserResponseBodyDeptOrderList] = None,
        email: str = None,
        exclusive_account: bool = None,
        exclusive_account_corp_id: str = None,
        exclusive_account_corp_name: str = None,
        exclusive_account_type: str = None,
        extension: str = None,
        hide_mobile: bool = None,
        hired_date: int = None,
        job_number: str = None,
        leader_in_dept: List[GetUserResponseBodyLeaderInDept] = None,
        login_id: str = None,
        manager_userid: str = None,
        mobile: str = None,
        name: str = None,
        nickname: str = None,
        org_email: str = None,
        real_authed: bool = None,
        remark: str = None,
        request_id: str = None,
        role_list: List[GetUserResponseBodyRoleList] = None,
        senior: bool = None,
        state_code: str = None,
        telephone: str = None,
        title: str = None,
        union_emp_ext: GetUserResponseBodyUnionEmpExt = None,
        unionid: str = None,
        userid: str = None,
        work_place: str = None,
    ):
        self.active = active
        self.admin = admin
        self.avatar = avatar
        self.boss = boss
        self.dept_id_list = dept_id_list
        self.dept_order_list = dept_order_list
        self.email = email
        self.exclusive_account = exclusive_account
        self.exclusive_account_corp_id = exclusive_account_corp_id
        self.exclusive_account_corp_name = exclusive_account_corp_name
        self.exclusive_account_type = exclusive_account_type
        self.extension = extension
        self.hide_mobile = hide_mobile
        self.hired_date = hired_date
        self.job_number = job_number
        self.leader_in_dept = leader_in_dept
        self.login_id = login_id
        self.manager_userid = manager_userid
        self.mobile = mobile
        self.name = name
        self.nickname = nickname
        self.org_email = org_email
        self.real_authed = real_authed
        self.remark = remark
        self.request_id = request_id
        self.role_list = role_list
        self.senior = senior
        self.state_code = state_code
        self.telephone = telephone
        self.title = title
        self.union_emp_ext = union_emp_ext
        self.unionid = unionid
        self.userid = userid
        self.work_place = work_place

    def validate(self):
        if self.dept_order_list:
            for k in self.dept_order_list:
                if k:
                    k.validate()
        if self.leader_in_dept:
            for k in self.leader_in_dept:
                if k:
                    k.validate()
        if self.role_list:
            for k in self.role_list:
                if k:
                    k.validate()
        if self.union_emp_ext:
            self.union_emp_ext.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active is not None:
            result['active'] = self.active
        if self.admin is not None:
            result['admin'] = self.admin
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.boss is not None:
            result['boss'] = self.boss
        if self.dept_id_list is not None:
            result['deptIdList'] = self.dept_id_list
        result['deptOrderList'] = []
        if self.dept_order_list is not None:
            for k in self.dept_order_list:
                result['deptOrderList'].append(k.to_map() if k else None)
        if self.email is not None:
            result['email'] = self.email
        if self.exclusive_account is not None:
            result['exclusiveAccount'] = self.exclusive_account
        if self.exclusive_account_corp_id is not None:
            result['exclusiveAccountCorpId'] = self.exclusive_account_corp_id
        if self.exclusive_account_corp_name is not None:
            result['exclusiveAccountCorpName'] = self.exclusive_account_corp_name
        if self.exclusive_account_type is not None:
            result['exclusiveAccountType'] = self.exclusive_account_type
        if self.extension is not None:
            result['extension'] = self.extension
        if self.hide_mobile is not None:
            result['hideMobile'] = self.hide_mobile
        if self.hired_date is not None:
            result['hiredDate'] = self.hired_date
        if self.job_number is not None:
            result['jobNumber'] = self.job_number
        result['leaderInDept'] = []
        if self.leader_in_dept is not None:
            for k in self.leader_in_dept:
                result['leaderInDept'].append(k.to_map() if k else None)
        if self.login_id is not None:
            result['loginId'] = self.login_id
        if self.manager_userid is not None:
            result['managerUserid'] = self.manager_userid
        if self.mobile is not None:
            result['mobile'] = self.mobile
        if self.name is not None:
            result['name'] = self.name
        if self.nickname is not None:
            result['nickname'] = self.nickname
        if self.org_email is not None:
            result['orgEmail'] = self.org_email
        if self.real_authed is not None:
            result['realAuthed'] = self.real_authed
        if self.remark is not None:
            result['remark'] = self.remark
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['roleList'] = []
        if self.role_list is not None:
            for k in self.role_list:
                result['roleList'].append(k.to_map() if k else None)
        if self.senior is not None:
            result['senior'] = self.senior
        if self.state_code is not None:
            result['stateCode'] = self.state_code
        if self.telephone is not None:
            result['telephone'] = self.telephone
        if self.title is not None:
            result['title'] = self.title
        if self.union_emp_ext is not None:
            result['unionEmpExt'] = self.union_emp_ext.to_map()
        if self.unionid is not None:
            result['unionid'] = self.unionid
        if self.userid is not None:
            result['userid'] = self.userid
        if self.work_place is not None:
            result['workPlace'] = self.work_place
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('active') is not None:
            self.active = m.get('active')
        if m.get('admin') is not None:
            self.admin = m.get('admin')
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('boss') is not None:
            self.boss = m.get('boss')
        if m.get('deptIdList') is not None:
            self.dept_id_list = m.get('deptIdList')
        self.dept_order_list = []
        if m.get('deptOrderList') is not None:
            for k in m.get('deptOrderList'):
                temp_model = GetUserResponseBodyDeptOrderList()
                self.dept_order_list.append(temp_model.from_map(k))
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('exclusiveAccount') is not None:
            self.exclusive_account = m.get('exclusiveAccount')
        if m.get('exclusiveAccountCorpId') is not None:
            self.exclusive_account_corp_id = m.get('exclusiveAccountCorpId')
        if m.get('exclusiveAccountCorpName') is not None:
            self.exclusive_account_corp_name = m.get('exclusiveAccountCorpName')
        if m.get('exclusiveAccountType') is not None:
            self.exclusive_account_type = m.get('exclusiveAccountType')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('hideMobile') is not None:
            self.hide_mobile = m.get('hideMobile')
        if m.get('hiredDate') is not None:
            self.hired_date = m.get('hiredDate')
        if m.get('jobNumber') is not None:
            self.job_number = m.get('jobNumber')
        self.leader_in_dept = []
        if m.get('leaderInDept') is not None:
            for k in m.get('leaderInDept'):
                temp_model = GetUserResponseBodyLeaderInDept()
                self.leader_in_dept.append(temp_model.from_map(k))
        if m.get('loginId') is not None:
            self.login_id = m.get('loginId')
        if m.get('managerUserid') is not None:
            self.manager_userid = m.get('managerUserid')
        if m.get('mobile') is not None:
            self.mobile = m.get('mobile')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nickname') is not None:
            self.nickname = m.get('nickname')
        if m.get('orgEmail') is not None:
            self.org_email = m.get('orgEmail')
        if m.get('realAuthed') is not None:
            self.real_authed = m.get('realAuthed')
        if m.get('remark') is not None:
            self.remark = m.get('remark')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.role_list = []
        if m.get('roleList') is not None:
            for k in m.get('roleList'):
                temp_model = GetUserResponseBodyRoleList()
                self.role_list.append(temp_model.from_map(k))
        if m.get('senior') is not None:
            self.senior = m.get('senior')
        if m.get('stateCode') is not None:
            self.state_code = m.get('stateCode')
        if m.get('telephone') is not None:
            self.telephone = m.get('telephone')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('unionEmpExt') is not None:
            temp_model = GetUserResponseBodyUnionEmpExt()
            self.union_emp_ext = temp_model.from_map(m['unionEmpExt'])
        if m.get('unionid') is not None:
            self.unionid = m.get('unionid')
        if m.get('userid') is not None:
            self.userid = m.get('userid')
        if m.get('workPlace') is not None:
            self.work_place = m.get('workPlace')
        return self


class GetUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUserIdHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetUserIdHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetUserIdHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetUserIdHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetUserIdShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetUserIdRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetUserIdRequest(TeaModel):
    def __init__(
        self,
        tenant_context: GetUserIdRequestTenantContext = None,
        union_id: str = None,
    ):
        self.tenant_context = tenant_context
        # unionId
        self.union_id = union_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.union_id is not None:
            result['UnionId'] = self.union_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = GetUserIdRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('UnionId') is not None:
            self.union_id = m.get('UnionId')
        return self


class GetUserIdShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        union_id: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        # unionId
        self.union_id = union_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.union_id is not None:
            result['UnionId'] = self.union_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('UnionId') is not None:
            self.union_id = m.get('UnionId')
        return self


class GetUserIdResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        user_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.user_id = user_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetUserIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetUserIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUserIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUserIdByOrgIdAndStaffIdHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetUserIdByOrgIdAndStaffIdHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetUserIdByOrgIdAndStaffIdHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetUserIdByOrgIdAndStaffIdHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetUserIdByOrgIdAndStaffIdShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetUserIdByOrgIdAndStaffIdRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetUserIdByOrgIdAndStaffIdRequest(TeaModel):
    def __init__(
        self,
        org_id: int = None,
        tenant_context: GetUserIdByOrgIdAndStaffIdRequestTenantContext = None,
    ):
        self.org_id = org_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.org_id is not None:
            result['OrgId'] = self.org_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrgId') is not None:
            self.org_id = m.get('OrgId')
        if m.get('TenantContext') is not None:
            temp_model = GetUserIdByOrgIdAndStaffIdRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetUserIdByOrgIdAndStaffIdShrinkRequest(TeaModel):
    def __init__(
        self,
        org_id: int = None,
        tenant_context_shrink: str = None,
    ):
        self.org_id = org_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.org_id is not None:
            result['OrgId'] = self.org_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrgId') is not None:
            self.org_id = m.get('OrgId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetUserIdByOrgIdAndStaffIdResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        user_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.user_id = user_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetUserIdByOrgIdAndStaffIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetUserIdByOrgIdAndStaffIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUserIdByOrgIdAndStaffIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUserLatestPlanHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetUserLatestPlanHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetUserLatestPlanHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetUserLatestPlanHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetUserLatestPlanShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetUserLatestPlanRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetUserLatestPlanRequest(TeaModel):
    def __init__(
        self,
        tenant_context: GetUserLatestPlanRequestTenantContext = None,
    ):
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = GetUserLatestPlanRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class GetUserLatestPlanShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class GetUserLatestPlanResponseBody(TeaModel):
    def __init__(
        self,
        account_handle_status: int = None,
        account_handle_time: str = None,
        account_type: int = None,
        agreement_first_sign_time: str = None,
        agreement_last_sign_time: str = None,
        agreement_status: int = None,
        data_handle_end_time: str = None,
        data_handle_start_time: str = None,
        data_handle_status: int = None,
        exclusive_plan: int = None,
        new_account_uid: int = None,
        request_id: str = None,
        status: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.account_handle_status = account_handle_status
        self.account_handle_time = account_handle_time
        self.account_type = account_type
        self.agreement_first_sign_time = agreement_first_sign_time
        self.agreement_last_sign_time = agreement_last_sign_time
        self.agreement_status = agreement_status
        self.data_handle_end_time = data_handle_end_time
        self.data_handle_start_time = data_handle_start_time
        self.data_handle_status = data_handle_status
        self.exclusive_plan = exclusive_plan
        self.new_account_uid = new_account_uid
        self.request_id = request_id
        self.status = status
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_handle_status is not None:
            result['accountHandleStatus'] = self.account_handle_status
        if self.account_handle_time is not None:
            result['accountHandleTime'] = self.account_handle_time
        if self.account_type is not None:
            result['accountType'] = self.account_type
        if self.agreement_first_sign_time is not None:
            result['agreementFirstSignTime'] = self.agreement_first_sign_time
        if self.agreement_last_sign_time is not None:
            result['agreementLastSignTime'] = self.agreement_last_sign_time
        if self.agreement_status is not None:
            result['agreementStatus'] = self.agreement_status
        if self.data_handle_end_time is not None:
            result['dataHandleEndTime'] = self.data_handle_end_time
        if self.data_handle_start_time is not None:
            result['dataHandleStartTime'] = self.data_handle_start_time
        if self.data_handle_status is not None:
            result['dataHandleStatus'] = self.data_handle_status
        if self.exclusive_plan is not None:
            result['exclusivePlan'] = self.exclusive_plan
        if self.new_account_uid is not None:
            result['newAccountUid'] = self.new_account_uid
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.status is not None:
            result['status'] = self.status
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountHandleStatus') is not None:
            self.account_handle_status = m.get('accountHandleStatus')
        if m.get('accountHandleTime') is not None:
            self.account_handle_time = m.get('accountHandleTime')
        if m.get('accountType') is not None:
            self.account_type = m.get('accountType')
        if m.get('agreementFirstSignTime') is not None:
            self.agreement_first_sign_time = m.get('agreementFirstSignTime')
        if m.get('agreementLastSignTime') is not None:
            self.agreement_last_sign_time = m.get('agreementLastSignTime')
        if m.get('agreementStatus') is not None:
            self.agreement_status = m.get('agreementStatus')
        if m.get('dataHandleEndTime') is not None:
            self.data_handle_end_time = m.get('dataHandleEndTime')
        if m.get('dataHandleStartTime') is not None:
            self.data_handle_start_time = m.get('dataHandleStartTime')
        if m.get('dataHandleStatus') is not None:
            self.data_handle_status = m.get('dataHandleStatus')
        if m.get('exclusivePlan') is not None:
            self.exclusive_plan = m.get('exclusivePlan')
        if m.get('newAccountUid') is not None:
            self.new_account_uid = m.get('newAccountUid')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class GetUserLatestPlanResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetUserLatestPlanResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUserLatestPlanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWorkspaceHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetWorkspaceHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetWorkspaceHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetWorkspaceHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetWorkspaceShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetWorkspaceRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetWorkspaceRequest(TeaModel):
    def __init__(
        self,
        tenant_context: GetWorkspaceRequestTenantContext = None,
        with_permission_role: bool = None,
        workspace_id: str = None,
    ):
        self.tenant_context = tenant_context
        self.with_permission_role = with_permission_role
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.with_permission_role is not None:
            result['WithPermissionRole'] = self.with_permission_role
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = GetWorkspaceRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WithPermissionRole') is not None:
            self.with_permission_role = m.get('WithPermissionRole')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetWorkspaceShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        with_permission_role: bool = None,
        workspace_id: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        self.with_permission_role = with_permission_role
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.with_permission_role is not None:
            result['WithPermissionRole'] = self.with_permission_role
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WithPermissionRole') is not None:
            self.with_permission_role = m.get('WithPermissionRole')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetWorkspaceResponseBodyWorkspaceIcon(TeaModel):
    def __init__(
        self,
        type: str = None,
        value: str = None,
    ):
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetWorkspaceResponseBodyWorkspace(TeaModel):
    def __init__(
        self,
        corp_id: str = None,
        cover: str = None,
        create_time: str = None,
        creator_id: str = None,
        description: str = None,
        icon: GetWorkspaceResponseBodyWorkspaceIcon = None,
        modified_time: str = None,
        modifier_id: str = None,
        name: str = None,
        permission_role: str = None,
        root_node_id: str = None,
        team_id: str = None,
        type: str = None,
        url: str = None,
        workspace_id: str = None,
    ):
        self.corp_id = corp_id
        self.cover = cover
        self.create_time = create_time
        self.creator_id = creator_id
        self.description = description
        self.icon = icon
        self.modified_time = modified_time
        self.modifier_id = modifier_id
        self.name = name
        self.permission_role = permission_role
        self.root_node_id = root_node_id
        self.team_id = team_id
        self.type = type
        self.url = url
        self.workspace_id = workspace_id

    def validate(self):
        if self.icon:
            self.icon.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.cover is not None:
            result['Cover'] = self.cover
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.icon is not None:
            result['Icon'] = self.icon.to_map()
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.name is not None:
            result['Name'] = self.name
        if self.permission_role is not None:
            result['PermissionRole'] = self.permission_role
        if self.root_node_id is not None:
            result['RootNodeId'] = self.root_node_id
        if self.team_id is not None:
            result['TeamId'] = self.team_id
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('Cover') is not None:
            self.cover = m.get('Cover')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Icon') is not None:
            temp_model = GetWorkspaceResponseBodyWorkspaceIcon()
            self.icon = temp_model.from_map(m['Icon'])
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PermissionRole') is not None:
            self.permission_role = m.get('PermissionRole')
        if m.get('RootNodeId') is not None:
            self.root_node_id = m.get('RootNodeId')
        if m.get('TeamId') is not None:
            self.team_id = m.get('TeamId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetWorkspaceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        workspace: GetWorkspaceResponseBodyWorkspace = None,
    ):
        # requestId
        self.request_id = request_id
        self.workspace = workspace

    def validate(self):
        if self.workspace:
            self.workspace.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.workspace is not None:
            result['workspace'] = self.workspace.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('workspace') is not None:
            temp_model = GetWorkspaceResponseBodyWorkspace()
            self.workspace = temp_model.from_map(m['workspace'])
        return self


class GetWorkspaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWorkspaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWorkspaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWorkspacesHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GetWorkspacesHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GetWorkspacesHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GetWorkspacesHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GetWorkspacesShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GetWorkspacesRequestOption(TeaModel):
    def __init__(
        self,
        with_permission_role: bool = None,
    ):
        self.with_permission_role = with_permission_role

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.with_permission_role is not None:
            result['WithPermissionRole'] = self.with_permission_role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WithPermissionRole') is not None:
            self.with_permission_role = m.get('WithPermissionRole')
        return self


class GetWorkspacesRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GetWorkspacesRequest(TeaModel):
    def __init__(
        self,
        option: GetWorkspacesRequestOption = None,
        tenant_context: GetWorkspacesRequestTenantContext = None,
        workspace_ids: List[str] = None,
    ):
        self.option = option
        self.tenant_context = tenant_context
        # This parameter is required.
        self.workspace_ids = workspace_ids

    def validate(self):
        if self.option:
            self.option.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.option is not None:
            result['Option'] = self.option.to_map()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workspace_ids is not None:
            result['WorkspaceIds'] = self.workspace_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Option') is not None:
            temp_model = GetWorkspacesRequestOption()
            self.option = temp_model.from_map(m['Option'])
        if m.get('TenantContext') is not None:
            temp_model = GetWorkspacesRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkspaceIds') is not None:
            self.workspace_ids = m.get('WorkspaceIds')
        return self


class GetWorkspacesShrinkRequest(TeaModel):
    def __init__(
        self,
        option_shrink: str = None,
        tenant_context_shrink: str = None,
        workspace_ids_shrink: str = None,
    ):
        self.option_shrink = option_shrink
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.workspace_ids_shrink = workspace_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.option_shrink is not None:
            result['Option'] = self.option_shrink
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workspace_ids_shrink is not None:
            result['WorkspaceIds'] = self.workspace_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Option') is not None:
            self.option_shrink = m.get('Option')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkspaceIds') is not None:
            self.workspace_ids_shrink = m.get('WorkspaceIds')
        return self


class GetWorkspacesResponseBodyWorkspaceIcon(TeaModel):
    def __init__(
        self,
        type: str = None,
        value: str = None,
    ):
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetWorkspacesResponseBodyWorkspace(TeaModel):
    def __init__(
        self,
        corp_id: str = None,
        cover: str = None,
        create_time: str = None,
        creator_id: str = None,
        description: str = None,
        icon: GetWorkspacesResponseBodyWorkspaceIcon = None,
        modified_time: str = None,
        modifier_id: str = None,
        name: str = None,
        permission_role: str = None,
        root_node_id: str = None,
        team_id: str = None,
        type: str = None,
        url: str = None,
        workspace_id: str = None,
    ):
        self.corp_id = corp_id
        self.cover = cover
        self.create_time = create_time
        self.creator_id = creator_id
        self.description = description
        self.icon = icon
        self.modified_time = modified_time
        self.modifier_id = modifier_id
        self.name = name
        self.permission_role = permission_role
        self.root_node_id = root_node_id
        self.team_id = team_id
        self.type = type
        self.url = url
        self.workspace_id = workspace_id

    def validate(self):
        if self.icon:
            self.icon.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.cover is not None:
            result['Cover'] = self.cover
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.icon is not None:
            result['Icon'] = self.icon.to_map()
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.name is not None:
            result['Name'] = self.name
        if self.permission_role is not None:
            result['PermissionRole'] = self.permission_role
        if self.root_node_id is not None:
            result['RootNodeId'] = self.root_node_id
        if self.team_id is not None:
            result['TeamId'] = self.team_id
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('Cover') is not None:
            self.cover = m.get('Cover')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Icon') is not None:
            temp_model = GetWorkspacesResponseBodyWorkspaceIcon()
            self.icon = temp_model.from_map(m['Icon'])
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PermissionRole') is not None:
            self.permission_role = m.get('PermissionRole')
        if m.get('RootNodeId') is not None:
            self.root_node_id = m.get('RootNodeId')
        if m.get('TeamId') is not None:
            self.team_id = m.get('TeamId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetWorkspacesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        workspace: List[GetWorkspacesResponseBodyWorkspace] = None,
    ):
        # requestId
        self.request_id = request_id
        self.workspace = workspace

    def validate(self):
        if self.workspace:
            for k in self.workspace:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['workspace'] = []
        if self.workspace is not None:
            for k in self.workspace:
                result['workspace'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.workspace = []
        if m.get('workspace') is not None:
            for k in m.get('workspace'):
                temp_model = GetWorkspacesResponseBodyWorkspace()
                self.workspace.append(temp_model.from_map(k))
        return self


class GetWorkspacesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWorkspacesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWorkspacesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GrantHonorHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class GrantHonorHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: GrantHonorHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = GrantHonorHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class GrantHonorShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class GrantHonorRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class GrantHonorRequest(TeaModel):
    def __init__(
        self,
        tenant_context: GrantHonorRequestTenantContext = None,
        expiration_time: int = None,
        grant_reason: str = None,
        granter_name: str = None,
        honor_id: str = None,
        notice_announcer: bool = None,
        notice_single: bool = None,
        open_conversation_ids: List[str] = None,
        org_id: int = None,
        receiver_user_ids: List[str] = None,
        sender_user_id: str = None,
    ):
        self.tenant_context = tenant_context
        self.expiration_time = expiration_time
        # This parameter is required.
        self.grant_reason = grant_reason
        # This parameter is required.
        self.granter_name = granter_name
        # This parameter is required.
        self.honor_id = honor_id
        self.notice_announcer = notice_announcer
        self.notice_single = notice_single
        self.open_conversation_ids = open_conversation_ids
        # This parameter is required.
        self.org_id = org_id
        # This parameter is required.
        self.receiver_user_ids = receiver_user_ids
        # This parameter is required.
        self.sender_user_id = sender_user_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.expiration_time is not None:
            result['expirationTime'] = self.expiration_time
        if self.grant_reason is not None:
            result['grantReason'] = self.grant_reason
        if self.granter_name is not None:
            result['granterName'] = self.granter_name
        if self.honor_id is not None:
            result['honorId'] = self.honor_id
        if self.notice_announcer is not None:
            result['noticeAnnouncer'] = self.notice_announcer
        if self.notice_single is not None:
            result['noticeSingle'] = self.notice_single
        if self.open_conversation_ids is not None:
            result['openConversationIds'] = self.open_conversation_ids
        if self.org_id is not None:
            result['orgId'] = self.org_id
        if self.receiver_user_ids is not None:
            result['receiverUserIds'] = self.receiver_user_ids
        if self.sender_user_id is not None:
            result['senderUserId'] = self.sender_user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = GrantHonorRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('expirationTime') is not None:
            self.expiration_time = m.get('expirationTime')
        if m.get('grantReason') is not None:
            self.grant_reason = m.get('grantReason')
        if m.get('granterName') is not None:
            self.granter_name = m.get('granterName')
        if m.get('honorId') is not None:
            self.honor_id = m.get('honorId')
        if m.get('noticeAnnouncer') is not None:
            self.notice_announcer = m.get('noticeAnnouncer')
        if m.get('noticeSingle') is not None:
            self.notice_single = m.get('noticeSingle')
        if m.get('openConversationIds') is not None:
            self.open_conversation_ids = m.get('openConversationIds')
        if m.get('orgId') is not None:
            self.org_id = m.get('orgId')
        if m.get('receiverUserIds') is not None:
            self.receiver_user_ids = m.get('receiverUserIds')
        if m.get('senderUserId') is not None:
            self.sender_user_id = m.get('senderUserId')
        return self


class GrantHonorShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        expiration_time: int = None,
        grant_reason: str = None,
        granter_name: str = None,
        honor_id: str = None,
        notice_announcer: bool = None,
        notice_single: bool = None,
        open_conversation_ids_shrink: str = None,
        org_id: int = None,
        receiver_user_ids_shrink: str = None,
        sender_user_id: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        self.expiration_time = expiration_time
        # This parameter is required.
        self.grant_reason = grant_reason
        # This parameter is required.
        self.granter_name = granter_name
        # This parameter is required.
        self.honor_id = honor_id
        self.notice_announcer = notice_announcer
        self.notice_single = notice_single
        self.open_conversation_ids_shrink = open_conversation_ids_shrink
        # This parameter is required.
        self.org_id = org_id
        # This parameter is required.
        self.receiver_user_ids_shrink = receiver_user_ids_shrink
        # This parameter is required.
        self.sender_user_id = sender_user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.expiration_time is not None:
            result['expirationTime'] = self.expiration_time
        if self.grant_reason is not None:
            result['grantReason'] = self.grant_reason
        if self.granter_name is not None:
            result['granterName'] = self.granter_name
        if self.honor_id is not None:
            result['honorId'] = self.honor_id
        if self.notice_announcer is not None:
            result['noticeAnnouncer'] = self.notice_announcer
        if self.notice_single is not None:
            result['noticeSingle'] = self.notice_single
        if self.open_conversation_ids_shrink is not None:
            result['openConversationIds'] = self.open_conversation_ids_shrink
        if self.org_id is not None:
            result['orgId'] = self.org_id
        if self.receiver_user_ids_shrink is not None:
            result['receiverUserIds'] = self.receiver_user_ids_shrink
        if self.sender_user_id is not None:
            result['senderUserId'] = self.sender_user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('expirationTime') is not None:
            self.expiration_time = m.get('expirationTime')
        if m.get('grantReason') is not None:
            self.grant_reason = m.get('grantReason')
        if m.get('granterName') is not None:
            self.granter_name = m.get('granterName')
        if m.get('honorId') is not None:
            self.honor_id = m.get('honorId')
        if m.get('noticeAnnouncer') is not None:
            self.notice_announcer = m.get('noticeAnnouncer')
        if m.get('noticeSingle') is not None:
            self.notice_single = m.get('noticeSingle')
        if m.get('openConversationIds') is not None:
            self.open_conversation_ids_shrink = m.get('openConversationIds')
        if m.get('orgId') is not None:
            self.org_id = m.get('orgId')
        if m.get('receiverUserIds') is not None:
            self.receiver_user_ids_shrink = m.get('receiverUserIds')
        if m.get('senderUserId') is not None:
            self.sender_user_id = m.get('senderUserId')
        return self


class GrantHonorResponseBody(TeaModel):
    def __init__(
        self,
        failed_user_ids: List[str] = None,
        request_id: str = None,
        success_user_ids: List[str] = None,
    ):
        self.failed_user_ids = failed_user_ids
        # requestId
        self.request_id = request_id
        self.success_user_ids = success_user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_user_ids is not None:
            result['failedUserIds'] = self.failed_user_ids
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success_user_ids is not None:
            result['successUserIds'] = self.success_user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('failedUserIds') is not None:
            self.failed_user_ids = m.get('failedUserIds')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('successUserIds') is not None:
            self.success_user_ids = m.get('successUserIds')
        return self


class GrantHonorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GrantHonorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GrantHonorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InitMultipartFileUploadHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class InitMultipartFileUploadHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: InitMultipartFileUploadHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = InitMultipartFileUploadHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class InitMultipartFileUploadShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class InitMultipartFileUploadRequestOptionPreCheckParam(TeaModel):
    def __init__(
        self,
        md_5: str = None,
        name: str = None,
        parent_id: str = None,
        size: int = None,
    ):
        self.md_5 = md_5
        self.name = name
        self.parent_id = parent_id
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.md_5 is not None:
            result['Md5'] = self.md_5
        if self.name is not None:
            result['Name'] = self.name
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Md5') is not None:
            self.md_5 = m.get('Md5')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class InitMultipartFileUploadRequestOption(TeaModel):
    def __init__(
        self,
        pre_check_param: InitMultipartFileUploadRequestOptionPreCheckParam = None,
        prefer_region: str = None,
        storage_driver: str = None,
    ):
        self.pre_check_param = pre_check_param
        self.prefer_region = prefer_region
        self.storage_driver = storage_driver

    def validate(self):
        if self.pre_check_param:
            self.pre_check_param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pre_check_param is not None:
            result['PreCheckParam'] = self.pre_check_param.to_map()
        if self.prefer_region is not None:
            result['PreferRegion'] = self.prefer_region
        if self.storage_driver is not None:
            result['StorageDriver'] = self.storage_driver
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PreCheckParam') is not None:
            temp_model = InitMultipartFileUploadRequestOptionPreCheckParam()
            self.pre_check_param = temp_model.from_map(m['PreCheckParam'])
        if m.get('PreferRegion') is not None:
            self.prefer_region = m.get('PreferRegion')
        if m.get('StorageDriver') is not None:
            self.storage_driver = m.get('StorageDriver')
        return self


class InitMultipartFileUploadRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class InitMultipartFileUploadRequest(TeaModel):
    def __init__(
        self,
        option: InitMultipartFileUploadRequestOption = None,
        parent_dentry_uuid: str = None,
        tenant_context: InitMultipartFileUploadRequestTenantContext = None,
    ):
        self.option = option
        self.parent_dentry_uuid = parent_dentry_uuid
        self.tenant_context = tenant_context

    def validate(self):
        if self.option:
            self.option.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.option is not None:
            result['Option'] = self.option.to_map()
        if self.parent_dentry_uuid is not None:
            result['ParentDentryUuid'] = self.parent_dentry_uuid
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Option') is not None:
            temp_model = InitMultipartFileUploadRequestOption()
            self.option = temp_model.from_map(m['Option'])
        if m.get('ParentDentryUuid') is not None:
            self.parent_dentry_uuid = m.get('ParentDentryUuid')
        if m.get('TenantContext') is not None:
            temp_model = InitMultipartFileUploadRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class InitMultipartFileUploadShrinkRequest(TeaModel):
    def __init__(
        self,
        option_shrink: str = None,
        parent_dentry_uuid: str = None,
        tenant_context_shrink: str = None,
    ):
        self.option_shrink = option_shrink
        self.parent_dentry_uuid = parent_dentry_uuid
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.option_shrink is not None:
            result['Option'] = self.option_shrink
        if self.parent_dentry_uuid is not None:
            result['ParentDentryUuid'] = self.parent_dentry_uuid
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Option') is not None:
            self.option_shrink = m.get('Option')
        if m.get('ParentDentryUuid') is not None:
            self.parent_dentry_uuid = m.get('ParentDentryUuid')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class InitMultipartFileUploadResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        storage_driver: str = None,
        upload_key: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.storage_driver = storage_driver
        self.upload_key = upload_key
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.storage_driver is not None:
            result['storageDriver'] = self.storage_driver
        if self.upload_key is not None:
            result['uploadKey'] = self.upload_key
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('storageDriver') is not None:
            self.storage_driver = m.get('storageDriver')
        if m.get('uploadKey') is not None:
            self.upload_key = m.get('uploadKey')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class InitMultipartFileUploadResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InitMultipartFileUploadResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InitMultipartFileUploadResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InsertColumnsBeforeHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class InsertColumnsBeforeHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: InsertColumnsBeforeHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = InsertColumnsBeforeHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class InsertColumnsBeforeShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class InsertColumnsBeforeRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class InsertColumnsBeforeRequest(TeaModel):
    def __init__(
        self,
        column: int = None,
        column_count: int = None,
        sheet_id: str = None,
        tenant_context: InsertColumnsBeforeRequestTenantContext = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.column = column
        # This parameter is required.
        self.column_count = column_count
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context = tenant_context
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column is not None:
            result['Column'] = self.column
        if self.column_count is not None:
            result['ColumnCount'] = self.column_count
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Column') is not None:
            self.column = m.get('Column')
        if m.get('ColumnCount') is not None:
            self.column_count = m.get('ColumnCount')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            temp_model = InsertColumnsBeforeRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class InsertColumnsBeforeShrinkRequest(TeaModel):
    def __init__(
        self,
        column: int = None,
        column_count: int = None,
        sheet_id: str = None,
        tenant_context_shrink: str = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.column = column
        # This parameter is required.
        self.column_count = column_count
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column is not None:
            result['Column'] = self.column
        if self.column_count is not None:
            result['ColumnCount'] = self.column_count
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Column') is not None:
            self.column = m.get('Column')
        if m.get('ColumnCount') is not None:
            self.column_count = m.get('ColumnCount')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class InsertColumnsBeforeResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
    ):
        self.id = id
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class InsertColumnsBeforeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InsertColumnsBeforeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InsertColumnsBeforeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InsertContentWithOptionsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class InsertContentWithOptionsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: InsertContentWithOptionsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = InsertContentWithOptionsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class InsertContentWithOptionsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class InsertContentWithOptionsRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class InsertContentWithOptionsRequest(TeaModel):
    def __init__(
        self,
        content: Dict[str, Any] = None,
        document_id: str = None,
        index: int = None,
        operator_id: str = None,
        path: List[int] = None,
        tenant_context: InsertContentWithOptionsRequestTenantContext = None,
    ):
        # This parameter is required.
        self.content = content
        # This parameter is required.
        self.document_id = document_id
        self.index = index
        # This parameter is required.
        self.operator_id = operator_id
        self.path = path
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.document_id is not None:
            result['DocumentId'] = self.document_id
        if self.index is not None:
            result['Index'] = self.index
        if self.operator_id is not None:
            result['OperatorId'] = self.operator_id
        if self.path is not None:
            result['Path'] = self.path
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocumentId') is not None:
            self.document_id = m.get('DocumentId')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('OperatorId') is not None:
            self.operator_id = m.get('OperatorId')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('TenantContext') is not None:
            temp_model = InsertContentWithOptionsRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class InsertContentWithOptionsShrinkRequest(TeaModel):
    def __init__(
        self,
        content_shrink: str = None,
        document_id: str = None,
        index: int = None,
        operator_id: str = None,
        path_shrink: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.content_shrink = content_shrink
        # This parameter is required.
        self.document_id = document_id
        self.index = index
        # This parameter is required.
        self.operator_id = operator_id
        self.path_shrink = path_shrink
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_shrink is not None:
            result['Content'] = self.content_shrink
        if self.document_id is not None:
            result['DocumentId'] = self.document_id
        if self.index is not None:
            result['Index'] = self.index
        if self.operator_id is not None:
            result['OperatorId'] = self.operator_id
        if self.path_shrink is not None:
            result['Path'] = self.path_shrink
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content_shrink = m.get('Content')
        if m.get('DocumentId') is not None:
            self.document_id = m.get('DocumentId')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('OperatorId') is not None:
            self.operator_id = m.get('OperatorId')
        if m.get('Path') is not None:
            self.path_shrink = m.get('Path')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class InsertContentWithOptionsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.success = success
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class InsertContentWithOptionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InsertContentWithOptionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InsertContentWithOptionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InsertMultiDimTableRecordHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class InsertMultiDimTableRecordHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: InsertMultiDimTableRecordHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = InsertMultiDimTableRecordHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class InsertMultiDimTableRecordShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class InsertMultiDimTableRecordRequestRecords(TeaModel):
    def __init__(
        self,
        fields: Dict[str, Any] = None,
    ):
        # This parameter is required.
        self.fields = fields

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fields is not None:
            result['Fields'] = self.fields
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Fields') is not None:
            self.fields = m.get('Fields')
        return self


class InsertMultiDimTableRecordRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class InsertMultiDimTableRecordRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        records: List[InsertMultiDimTableRecordRequestRecords] = None,
        sheet_id_or_name: str = None,
        tenant_context: InsertMultiDimTableRecordRequestTenantContext = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.records = records
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context = tenant_context

    def validate(self):
        if self.records:
            for k in self.records:
                if k:
                    k.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        result['Records'] = []
        if self.records is not None:
            for k in self.records:
                result['Records'].append(k.to_map() if k else None)
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        self.records = []
        if m.get('Records') is not None:
            for k in m.get('Records'):
                temp_model = InsertMultiDimTableRecordRequestRecords()
                self.records.append(temp_model.from_map(k))
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            temp_model = InsertMultiDimTableRecordRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class InsertMultiDimTableRecordShrinkRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        records_shrink: str = None,
        sheet_id_or_name: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.records_shrink = records_shrink
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.records_shrink is not None:
            result['Records'] = self.records_shrink
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('Records') is not None:
            self.records_shrink = m.get('Records')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class InsertMultiDimTableRecordResponseBodyValue(TeaModel):
    def __init__(
        self,
        id: str = None,
    ):
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class InsertMultiDimTableRecordResponseBody(TeaModel):
    def __init__(
        self,
        value: List[InsertMultiDimTableRecordResponseBodyValue] = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.value = value
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.value:
            for k in self.value:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Value'] = []
        if self.value is not None:
            for k in self.value:
                result['Value'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.value = []
        if m.get('Value') is not None:
            for k in m.get('Value'):
                temp_model = InsertMultiDimTableRecordResponseBodyValue()
                self.value.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class InsertMultiDimTableRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InsertMultiDimTableRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InsertMultiDimTableRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InsertRowsBeforeHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class InsertRowsBeforeHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: InsertRowsBeforeHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = InsertRowsBeforeHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class InsertRowsBeforeShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class InsertRowsBeforeRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class InsertRowsBeforeRequest(TeaModel):
    def __init__(
        self,
        row: int = None,
        row_count: int = None,
        sheet_id: str = None,
        tenant_context: InsertRowsBeforeRequestTenantContext = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.row = row
        # This parameter is required.
        self.row_count = row_count
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context = tenant_context
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.row is not None:
            result['Row'] = self.row
        if self.row_count is not None:
            result['RowCount'] = self.row_count
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Row') is not None:
            self.row = m.get('Row')
        if m.get('RowCount') is not None:
            self.row_count = m.get('RowCount')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            temp_model = InsertRowsBeforeRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class InsertRowsBeforeShrinkRequest(TeaModel):
    def __init__(
        self,
        row: int = None,
        row_count: int = None,
        sheet_id: str = None,
        tenant_context_shrink: str = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.row = row
        # This parameter is required.
        self.row_count = row_count
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.row is not None:
            result['Row'] = self.row
        if self.row_count is not None:
            result['RowCount'] = self.row_count
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Row') is not None:
            self.row = m.get('Row')
        if m.get('RowCount') is not None:
            self.row_count = m.get('RowCount')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class InsertRowsBeforeResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
    ):
        self.id = id
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class InsertRowsBeforeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InsertRowsBeforeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InsertRowsBeforeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InviteUsersHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class InviteUsersHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: InviteUsersHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = InviteUsersHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class InviteUsersShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class InviteUsersRequestInviteeList(TeaModel):
    def __init__(
        self,
        nick: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.nick = nick
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nick is not None:
            result['Nick'] = self.nick
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Nick') is not None:
            self.nick = m.get('Nick')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class InviteUsersRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class InviteUsersRequestPhoneInviteeList(TeaModel):
    def __init__(
        self,
        invite_client: bool = None,
        nick: str = None,
        phone_number: str = None,
        status_code: str = None,
    ):
        self.invite_client = invite_client
        self.nick = nick
        self.phone_number = phone_number
        self.status_code = status_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.invite_client is not None:
            result['InviteClient'] = self.invite_client
        if self.nick is not None:
            result['Nick'] = self.nick
        if self.phone_number is not None:
            result['PhoneNumber'] = self.phone_number
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InviteClient') is not None:
            self.invite_client = m.get('InviteClient')
        if m.get('Nick') is not None:
            self.nick = m.get('Nick')
        if m.get('PhoneNumber') is not None:
            self.phone_number = m.get('PhoneNumber')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class InviteUsersRequest(TeaModel):
    def __init__(
        self,
        invitee_list: List[InviteUsersRequestInviteeList] = None,
        tenant_context: InviteUsersRequestTenantContext = None,
        conference_id: str = None,
        phone_invitee_list: List[InviteUsersRequestPhoneInviteeList] = None,
    ):
        self.invitee_list = invitee_list
        self.tenant_context = tenant_context
        # This parameter is required.
        self.conference_id = conference_id
        self.phone_invitee_list = phone_invitee_list

    def validate(self):
        if self.invitee_list:
            for k in self.invitee_list:
                if k:
                    k.validate()
        if self.tenant_context:
            self.tenant_context.validate()
        if self.phone_invitee_list:
            for k in self.phone_invitee_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InviteeList'] = []
        if self.invitee_list is not None:
            for k in self.invitee_list:
                result['InviteeList'].append(k.to_map() if k else None)
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        result['phoneInviteeList'] = []
        if self.phone_invitee_list is not None:
            for k in self.phone_invitee_list:
                result['phoneInviteeList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.invitee_list = []
        if m.get('InviteeList') is not None:
            for k in m.get('InviteeList'):
                temp_model = InviteUsersRequestInviteeList()
                self.invitee_list.append(temp_model.from_map(k))
        if m.get('TenantContext') is not None:
            temp_model = InviteUsersRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        self.phone_invitee_list = []
        if m.get('phoneInviteeList') is not None:
            for k in m.get('phoneInviteeList'):
                temp_model = InviteUsersRequestPhoneInviteeList()
                self.phone_invitee_list.append(temp_model.from_map(k))
        return self


class InviteUsersShrinkRequest(TeaModel):
    def __init__(
        self,
        invitee_list_shrink: str = None,
        tenant_context_shrink: str = None,
        conference_id: str = None,
        phone_invitee_list_shrink: str = None,
    ):
        self.invitee_list_shrink = invitee_list_shrink
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.conference_id = conference_id
        self.phone_invitee_list_shrink = phone_invitee_list_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.invitee_list_shrink is not None:
            result['InviteeList'] = self.invitee_list_shrink
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        if self.phone_invitee_list_shrink is not None:
            result['phoneInviteeList'] = self.phone_invitee_list_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InviteeList') is not None:
            self.invitee_list_shrink = m.get('InviteeList')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        if m.get('phoneInviteeList') is not None:
            self.phone_invitee_list_shrink = m.get('phoneInviteeList')
        return self


class InviteUsersResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        # requestId
        self.request_id = request_id
        self.success = success
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class InviteUsersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InviteUsersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InviteUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InvokeAssistantHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_id: str = None,
    ):
        self.common_headers = common_headers
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class InvokeAssistantRequestMessagesContentCardCallback(TeaModel):
    def __init__(
        self,
        content: str = None,
        related_message_id: str = None,
    ):
        # This parameter is required.
        self.content = content
        # This parameter is required.
        self.related_message_id = related_message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.related_message_id is not None:
            result['relatedMessageId'] = self.related_message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('relatedMessageId') is not None:
            self.related_message_id = m.get('relatedMessageId')
        return self


class InvokeAssistantRequestMessagesContentDingCard(TeaModel):
    def __init__(
        self,
        content: str = None,
        content_type: str = None,
        finished: bool = None,
        template_id: str = None,
    ):
        self.content = content
        # This parameter is required.
        self.content_type = content_type
        self.finished = finished
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.content_type is not None:
            result['contentType'] = self.content_type
        if self.finished is not None:
            result['finished'] = self.finished
        if self.template_id is not None:
            result['templateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('contentType') is not None:
            self.content_type = m.get('contentType')
        if m.get('finished') is not None:
            self.finished = m.get('finished')
        if m.get('templateId') is not None:
            self.template_id = m.get('templateId')
        return self


class InvokeAssistantRequestMessagesContentDingNormalCardCardData(TeaModel):
    def __init__(
        self,
        card_param_map: Dict[str, Any] = None,
    ):
        self.card_param_map = card_param_map

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_param_map is not None:
            result['cardParamMap'] = self.card_param_map
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardParamMap') is not None:
            self.card_param_map = m.get('cardParamMap')
        return self


class InvokeAssistantRequestMessagesContentDingNormalCardCardUpdateOptions(TeaModel):
    def __init__(
        self,
        update_card_data_by_key: bool = None,
        update_private_data_by_key: bool = None,
    ):
        self.update_card_data_by_key = update_card_data_by_key
        self.update_private_data_by_key = update_private_data_by_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.update_card_data_by_key is not None:
            result['updateCardDataByKey'] = self.update_card_data_by_key
        if self.update_private_data_by_key is not None:
            result['updatePrivateDataByKey'] = self.update_private_data_by_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('updateCardDataByKey') is not None:
            self.update_card_data_by_key = m.get('updateCardDataByKey')
        if m.get('updatePrivateDataByKey') is not None:
            self.update_private_data_by_key = m.get('updatePrivateDataByKey')
        return self


class InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig(TeaModel):
    def __init__(
        self,
        interval: int = None,
        pull_strategy: str = None,
        time_unit: str = None,
    ):
        self.interval = interval
        self.pull_strategy = pull_strategy
        self.time_unit = time_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interval is not None:
            result['interval'] = self.interval
        if self.pull_strategy is not None:
            result['pullStrategy'] = self.pull_strategy
        if self.time_unit is not None:
            result['timeUnit'] = self.time_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('pullStrategy') is not None:
            self.pull_strategy = m.get('pullStrategy')
        if m.get('timeUnit') is not None:
            self.time_unit = m.get('timeUnit')
        return self


class InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigs(TeaModel):
    def __init__(
        self,
        const_params: Dict[str, Any] = None,
        dynamic_data_source_id: str = None,
        pull_config: InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig = None,
    ):
        self.const_params = const_params
        self.dynamic_data_source_id = dynamic_data_source_id
        self.pull_config = pull_config

    def validate(self):
        if self.pull_config:
            self.pull_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.const_params is not None:
            result['constParams'] = self.const_params
        if self.dynamic_data_source_id is not None:
            result['dynamicDataSourceId'] = self.dynamic_data_source_id
        if self.pull_config is not None:
            result['pullConfig'] = self.pull_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('constParams') is not None:
            self.const_params = m.get('constParams')
        if m.get('dynamicDataSourceId') is not None:
            self.dynamic_data_source_id = m.get('dynamicDataSourceId')
        if m.get('pullConfig') is not None:
            temp_model = InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig()
            self.pull_config = temp_model.from_map(m['pullConfig'])
        return self


class InvokeAssistantRequestMessagesContentDingNormalCard(TeaModel):
    def __init__(
        self,
        card_data: InvokeAssistantRequestMessagesContentDingNormalCardCardData = None,
        card_template_id: str = None,
        card_update_options: InvokeAssistantRequestMessagesContentDingNormalCardCardUpdateOptions = None,
        dynamic_data_source_configs: List[InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigs] = None,
        private_data: Dict[str, dict] = None,
    ):
        self.card_data = card_data
        self.card_template_id = card_template_id
        self.card_update_options = card_update_options
        self.dynamic_data_source_configs = dynamic_data_source_configs
        self.private_data = private_data

    def validate(self):
        if self.card_data:
            self.card_data.validate()
        if self.card_update_options:
            self.card_update_options.validate()
        if self.dynamic_data_source_configs:
            for k in self.dynamic_data_source_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_data is not None:
            result['cardData'] = self.card_data.to_map()
        if self.card_template_id is not None:
            result['cardTemplateId'] = self.card_template_id
        if self.card_update_options is not None:
            result['cardUpdateOptions'] = self.card_update_options.to_map()
        result['dynamicDataSourceConfigs'] = []
        if self.dynamic_data_source_configs is not None:
            for k in self.dynamic_data_source_configs:
                result['dynamicDataSourceConfigs'].append(k.to_map() if k else None)
        if self.private_data is not None:
            result['privateData'] = self.private_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardData') is not None:
            temp_model = InvokeAssistantRequestMessagesContentDingNormalCardCardData()
            self.card_data = temp_model.from_map(m['cardData'])
        if m.get('cardTemplateId') is not None:
            self.card_template_id = m.get('cardTemplateId')
        if m.get('cardUpdateOptions') is not None:
            temp_model = InvokeAssistantRequestMessagesContentDingNormalCardCardUpdateOptions()
            self.card_update_options = temp_model.from_map(m['cardUpdateOptions'])
        self.dynamic_data_source_configs = []
        if m.get('dynamicDataSourceConfigs') is not None:
            for k in m.get('dynamicDataSourceConfigs'):
                temp_model = InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigs()
                self.dynamic_data_source_configs.append(temp_model.from_map(k))
        if m.get('privateData') is not None:
            self.private_data = m.get('privateData')
        return self


class InvokeAssistantRequestMessagesContentMarkdown(TeaModel):
    def __init__(
        self,
        value: str = None,
    ):
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class InvokeAssistantRequestMessagesContentStructViewPartsDataPart(TeaModel):
    def __init__(
        self,
        data: Any = None,
    ):
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class InvokeAssistantRequestMessagesContentStructViewPartsReasonPart(TeaModel):
    def __init__(
        self,
        reason: str = None,
    ):
        self.reason = reason

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reason is not None:
            result['reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        return self


class InvokeAssistantRequestMessagesContentStructViewPartsRecommendPartRecommends(TeaModel):
    def __init__(
        self,
        mobile_url: str = None,
        text: str = None,
        url: str = None,
    ):
        self.mobile_url = mobile_url
        self.text = text
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mobile_url is not None:
            result['mobileUrl'] = self.mobile_url
        if self.text is not None:
            result['text'] = self.text
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('mobileUrl') is not None:
            self.mobile_url = m.get('mobileUrl')
        if m.get('text') is not None:
            self.text = m.get('text')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class InvokeAssistantRequestMessagesContentStructViewPartsRecommendPart(TeaModel):
    def __init__(
        self,
        recommends: List[InvokeAssistantRequestMessagesContentStructViewPartsRecommendPartRecommends] = None,
    ):
        self.recommends = recommends

    def validate(self):
        if self.recommends:
            for k in self.recommends:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['recommends'] = []
        if self.recommends is not None:
            for k in self.recommends:
                result['recommends'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.recommends = []
        if m.get('recommends') is not None:
            for k in m.get('recommends'):
                temp_model = InvokeAssistantRequestMessagesContentStructViewPartsRecommendPartRecommends()
                self.recommends.append(temp_model.from_map(k))
        return self


class InvokeAssistantRequestMessagesContentStructViewPartsReferencePartReferences(TeaModel):
    def __init__(
        self,
        index: str = None,
        name: str = None,
        source_code: str = None,
        source_icon: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.index = index
        self.name = name
        self.source_code = source_code
        self.source_icon = source_icon
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['index'] = self.index
        if self.name is not None:
            result['name'] = self.name
        if self.source_code is not None:
            result['sourceCode'] = self.source_code
        if self.source_icon is not None:
            result['sourceIcon'] = self.source_icon
        if self.summary is not None:
            result['summary'] = self.summary
        if self.title is not None:
            result['title'] = self.title
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('sourceCode') is not None:
            self.source_code = m.get('sourceCode')
        if m.get('sourceIcon') is not None:
            self.source_icon = m.get('sourceIcon')
        if m.get('summary') is not None:
            self.summary = m.get('summary')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class InvokeAssistantRequestMessagesContentStructViewPartsReferencePart(TeaModel):
    def __init__(
        self,
        references: List[InvokeAssistantRequestMessagesContentStructViewPartsReferencePartReferences] = None,
    ):
        self.references = references

    def validate(self):
        if self.references:
            for k in self.references:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['references'] = []
        if self.references is not None:
            for k in self.references:
                result['references'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.references = []
        if m.get('references') is not None:
            for k in m.get('references'):
                temp_model = InvokeAssistantRequestMessagesContentStructViewPartsReferencePartReferences()
                self.references.append(temp_model.from_map(k))
        return self


class InvokeAssistantRequestMessagesContentStructViewPartsTextPart(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('text') is not None:
            self.text = m.get('text')
        return self


class InvokeAssistantRequestMessagesContentStructViewParts(TeaModel):
    def __init__(
        self,
        append: bool = None,
        data_part: InvokeAssistantRequestMessagesContentStructViewPartsDataPart = None,
        finish: bool = None,
        part_desc: str = None,
        part_id: str = None,
        reason_part: InvokeAssistantRequestMessagesContentStructViewPartsReasonPart = None,
        recommend_part: InvokeAssistantRequestMessagesContentStructViewPartsRecommendPart = None,
        reference_part: InvokeAssistantRequestMessagesContentStructViewPartsReferencePart = None,
        text_part: InvokeAssistantRequestMessagesContentStructViewPartsTextPart = None,
        type: str = None,
    ):
        self.append = append
        self.data_part = data_part
        self.finish = finish
        self.part_desc = part_desc
        self.part_id = part_id
        self.reason_part = reason_part
        self.recommend_part = recommend_part
        self.reference_part = reference_part
        self.text_part = text_part
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.data_part:
            self.data_part.validate()
        if self.reason_part:
            self.reason_part.validate()
        if self.recommend_part:
            self.recommend_part.validate()
        if self.reference_part:
            self.reference_part.validate()
        if self.text_part:
            self.text_part.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.append is not None:
            result['append'] = self.append
        if self.data_part is not None:
            result['dataPart'] = self.data_part.to_map()
        if self.finish is not None:
            result['finish'] = self.finish
        if self.part_desc is not None:
            result['partDesc'] = self.part_desc
        if self.part_id is not None:
            result['partId'] = self.part_id
        if self.reason_part is not None:
            result['reasonPart'] = self.reason_part.to_map()
        if self.recommend_part is not None:
            result['recommendPart'] = self.recommend_part.to_map()
        if self.reference_part is not None:
            result['referencePart'] = self.reference_part.to_map()
        if self.text_part is not None:
            result['textPart'] = self.text_part.to_map()
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('append') is not None:
            self.append = m.get('append')
        if m.get('dataPart') is not None:
            temp_model = InvokeAssistantRequestMessagesContentStructViewPartsDataPart()
            self.data_part = temp_model.from_map(m['dataPart'])
        if m.get('finish') is not None:
            self.finish = m.get('finish')
        if m.get('partDesc') is not None:
            self.part_desc = m.get('partDesc')
        if m.get('partId') is not None:
            self.part_id = m.get('partId')
        if m.get('reasonPart') is not None:
            temp_model = InvokeAssistantRequestMessagesContentStructViewPartsReasonPart()
            self.reason_part = temp_model.from_map(m['reasonPart'])
        if m.get('recommendPart') is not None:
            temp_model = InvokeAssistantRequestMessagesContentStructViewPartsRecommendPart()
            self.recommend_part = temp_model.from_map(m['recommendPart'])
        if m.get('referencePart') is not None:
            temp_model = InvokeAssistantRequestMessagesContentStructViewPartsReferencePart()
            self.reference_part = temp_model.from_map(m['referencePart'])
        if m.get('textPart') is not None:
            temp_model = InvokeAssistantRequestMessagesContentStructViewPartsTextPart()
            self.text_part = temp_model.from_map(m['textPart'])
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class InvokeAssistantRequestMessagesContentStructView(TeaModel):
    def __init__(
        self,
        parts: List[InvokeAssistantRequestMessagesContentStructViewParts] = None,
    ):
        self.parts = parts

    def validate(self):
        if self.parts:
            for k in self.parts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['parts'] = []
        if self.parts is not None:
            for k in self.parts:
                result['parts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.parts = []
        if m.get('parts') is not None:
            for k in m.get('parts'):
                temp_model = InvokeAssistantRequestMessagesContentStructViewParts()
                self.parts.append(temp_model.from_map(k))
        return self


class InvokeAssistantRequestMessagesContentText(TeaModel):
    def __init__(
        self,
        value: str = None,
    ):
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class InvokeAssistantRequestMessagesContent(TeaModel):
    def __init__(
        self,
        card_callback: InvokeAssistantRequestMessagesContentCardCallback = None,
        ding_card: InvokeAssistantRequestMessagesContentDingCard = None,
        ding_normal_card: InvokeAssistantRequestMessagesContentDingNormalCard = None,
        markdown: InvokeAssistantRequestMessagesContentMarkdown = None,
        struct_view: InvokeAssistantRequestMessagesContentStructView = None,
        text: InvokeAssistantRequestMessagesContentText = None,
        type: str = None,
    ):
        self.card_callback = card_callback
        self.ding_card = ding_card
        self.ding_normal_card = ding_normal_card
        self.markdown = markdown
        self.struct_view = struct_view
        self.text = text
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.card_callback:
            self.card_callback.validate()
        if self.ding_card:
            self.ding_card.validate()
        if self.ding_normal_card:
            self.ding_normal_card.validate()
        if self.markdown:
            self.markdown.validate()
        if self.struct_view:
            self.struct_view.validate()
        if self.text:
            self.text.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_callback is not None:
            result['cardCallback'] = self.card_callback.to_map()
        if self.ding_card is not None:
            result['dingCard'] = self.ding_card.to_map()
        if self.ding_normal_card is not None:
            result['dingNormalCard'] = self.ding_normal_card.to_map()
        if self.markdown is not None:
            result['markdown'] = self.markdown.to_map()
        if self.struct_view is not None:
            result['structView'] = self.struct_view.to_map()
        if self.text is not None:
            result['text'] = self.text.to_map()
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardCallback') is not None:
            temp_model = InvokeAssistantRequestMessagesContentCardCallback()
            self.card_callback = temp_model.from_map(m['cardCallback'])
        if m.get('dingCard') is not None:
            temp_model = InvokeAssistantRequestMessagesContentDingCard()
            self.ding_card = temp_model.from_map(m['dingCard'])
        if m.get('dingNormalCard') is not None:
            temp_model = InvokeAssistantRequestMessagesContentDingNormalCard()
            self.ding_normal_card = temp_model.from_map(m['dingNormalCard'])
        if m.get('markdown') is not None:
            temp_model = InvokeAssistantRequestMessagesContentMarkdown()
            self.markdown = temp_model.from_map(m['markdown'])
        if m.get('structView') is not None:
            temp_model = InvokeAssistantRequestMessagesContentStructView()
            self.struct_view = temp_model.from_map(m['structView'])
        if m.get('text') is not None:
            temp_model = InvokeAssistantRequestMessagesContentText()
            self.text = temp_model.from_map(m['text'])
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class InvokeAssistantRequestMessages(TeaModel):
    def __init__(
        self,
        content: InvokeAssistantRequestMessagesContent = None,
        content_desc: str = None,
        create_at: int = None,
        role: str = None,
    ):
        self.content = content
        self.content_desc = content_desc
        self.create_at = create_at
        self.role = role

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content.to_map()
        if self.content_desc is not None:
            result['contentDesc'] = self.content_desc
        if self.create_at is not None:
            result['createAt'] = self.create_at
        if self.role is not None:
            result['role'] = self.role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            temp_model = InvokeAssistantRequestMessagesContent()
            self.content = temp_model.from_map(m['content'])
        if m.get('contentDesc') is not None:
            self.content_desc = m.get('contentDesc')
        if m.get('createAt') is not None:
            self.create_at = m.get('createAt')
        if m.get('role') is not None:
            self.role = m.get('role')
        return self


class InvokeAssistantRequest(TeaModel):
    def __init__(
        self,
        assistant_id: str = None,
        messages: List[InvokeAssistantRequestMessages] = None,
        original_assistant_id: str = None,
        session_id: str = None,
        source_id_of_original_assistant_id: str = None,
        source_type_of_original_assistant_id: str = None,
        stream: bool = None,
    ):
        # This parameter is required.
        self.assistant_id = assistant_id
        # This parameter is required.
        self.messages = messages
        self.original_assistant_id = original_assistant_id
        self.session_id = session_id
        self.source_id_of_original_assistant_id = source_id_of_original_assistant_id
        self.source_type_of_original_assistant_id = source_type_of_original_assistant_id
        self.stream = stream

    def validate(self):
        if self.messages:
            for k in self.messages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assistant_id is not None:
            result['assistantId'] = self.assistant_id
        result['messages'] = []
        if self.messages is not None:
            for k in self.messages:
                result['messages'].append(k.to_map() if k else None)
        if self.original_assistant_id is not None:
            result['originalAssistantId'] = self.original_assistant_id
        if self.session_id is not None:
            result['sessionId'] = self.session_id
        if self.source_id_of_original_assistant_id is not None:
            result['sourceIdOfOriginalAssistantId'] = self.source_id_of_original_assistant_id
        if self.source_type_of_original_assistant_id is not None:
            result['sourceTypeOfOriginalAssistantId'] = self.source_type_of_original_assistant_id
        if self.stream is not None:
            result['stream'] = self.stream
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assistantId') is not None:
            self.assistant_id = m.get('assistantId')
        self.messages = []
        if m.get('messages') is not None:
            for k in m.get('messages'):
                temp_model = InvokeAssistantRequestMessages()
                self.messages.append(temp_model.from_map(k))
        if m.get('originalAssistantId') is not None:
            self.original_assistant_id = m.get('originalAssistantId')
        if m.get('sessionId') is not None:
            self.session_id = m.get('sessionId')
        if m.get('sourceIdOfOriginalAssistantId') is not None:
            self.source_id_of_original_assistant_id = m.get('sourceIdOfOriginalAssistantId')
        if m.get('sourceTypeOfOriginalAssistantId') is not None:
            self.source_type_of_original_assistant_id = m.get('sourceTypeOfOriginalAssistantId')
        if m.get('stream') is not None:
            self.stream = m.get('stream')
        return self


class InvokeAssistantResponseBodyMessagesContentCardCallback(TeaModel):
    def __init__(
        self,
        content: str = None,
        related_message_id: str = None,
    ):
        self.content = content
        self.related_message_id = related_message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.related_message_id is not None:
            result['relatedMessageId'] = self.related_message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('relatedMessageId') is not None:
            self.related_message_id = m.get('relatedMessageId')
        return self


class InvokeAssistantResponseBodyMessagesContentDingCard(TeaModel):
    def __init__(
        self,
        content: str = None,
        content_type: str = None,
        finished: bool = None,
        template_id: str = None,
    ):
        self.content = content
        # This parameter is required.
        self.content_type = content_type
        self.finished = finished
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.content_type is not None:
            result['contentType'] = self.content_type
        if self.finished is not None:
            result['finished'] = self.finished
        if self.template_id is not None:
            result['templateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('contentType') is not None:
            self.content_type = m.get('contentType')
        if m.get('finished') is not None:
            self.finished = m.get('finished')
        if m.get('templateId') is not None:
            self.template_id = m.get('templateId')
        return self


class InvokeAssistantResponseBodyMessagesContentDingNormalCardCardData(TeaModel):
    def __init__(
        self,
        card_param_map: Dict[str, Any] = None,
    ):
        self.card_param_map = card_param_map

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_param_map is not None:
            result['cardParamMap'] = self.card_param_map
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardParamMap') is not None:
            self.card_param_map = m.get('cardParamMap')
        return self


class InvokeAssistantResponseBodyMessagesContentDingNormalCardCardUpdateOptions(TeaModel):
    def __init__(
        self,
        update_card_data_by_key: bool = None,
        update_private_data_by_key: bool = None,
    ):
        self.update_card_data_by_key = update_card_data_by_key
        self.update_private_data_by_key = update_private_data_by_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.update_card_data_by_key is not None:
            result['updateCardDataByKey'] = self.update_card_data_by_key
        if self.update_private_data_by_key is not None:
            result['updatePrivateDataByKey'] = self.update_private_data_by_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('updateCardDataByKey') is not None:
            self.update_card_data_by_key = m.get('updateCardDataByKey')
        if m.get('updatePrivateDataByKey') is not None:
            self.update_private_data_by_key = m.get('updatePrivateDataByKey')
        return self


class InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig(TeaModel):
    def __init__(
        self,
        interval: int = None,
        pull_strategy: str = None,
        time_unit: str = None,
    ):
        self.interval = interval
        self.pull_strategy = pull_strategy
        self.time_unit = time_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interval is not None:
            result['interval'] = self.interval
        if self.pull_strategy is not None:
            result['pullStrategy'] = self.pull_strategy
        if self.time_unit is not None:
            result['timeUnit'] = self.time_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('pullStrategy') is not None:
            self.pull_strategy = m.get('pullStrategy')
        if m.get('timeUnit') is not None:
            self.time_unit = m.get('timeUnit')
        return self


class InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs(TeaModel):
    def __init__(
        self,
        const_params: Dict[str, Any] = None,
        dynamic_data_source_id: str = None,
        pull_config: InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig = None,
    ):
        self.const_params = const_params
        self.dynamic_data_source_id = dynamic_data_source_id
        self.pull_config = pull_config

    def validate(self):
        if self.pull_config:
            self.pull_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.const_params is not None:
            result['constParams'] = self.const_params
        if self.dynamic_data_source_id is not None:
            result['dynamicDataSourceId'] = self.dynamic_data_source_id
        if self.pull_config is not None:
            result['pullConfig'] = self.pull_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('constParams') is not None:
            self.const_params = m.get('constParams')
        if m.get('dynamicDataSourceId') is not None:
            self.dynamic_data_source_id = m.get('dynamicDataSourceId')
        if m.get('pullConfig') is not None:
            temp_model = InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig()
            self.pull_config = temp_model.from_map(m['pullConfig'])
        return self


class InvokeAssistantResponseBodyMessagesContentDingNormalCard(TeaModel):
    def __init__(
        self,
        card_data: InvokeAssistantResponseBodyMessagesContentDingNormalCardCardData = None,
        card_template_id: str = None,
        card_update_options: InvokeAssistantResponseBodyMessagesContentDingNormalCardCardUpdateOptions = None,
        dynamic_data_source_configs: List[InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs] = None,
        private_data: Dict[str, dict] = None,
    ):
        self.card_data = card_data
        self.card_template_id = card_template_id
        self.card_update_options = card_update_options
        self.dynamic_data_source_configs = dynamic_data_source_configs
        self.private_data = private_data

    def validate(self):
        if self.card_data:
            self.card_data.validate()
        if self.card_update_options:
            self.card_update_options.validate()
        if self.dynamic_data_source_configs:
            for k in self.dynamic_data_source_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_data is not None:
            result['cardData'] = self.card_data.to_map()
        if self.card_template_id is not None:
            result['cardTemplateId'] = self.card_template_id
        if self.card_update_options is not None:
            result['cardUpdateOptions'] = self.card_update_options.to_map()
        result['dynamicDataSourceConfigs'] = []
        if self.dynamic_data_source_configs is not None:
            for k in self.dynamic_data_source_configs:
                result['dynamicDataSourceConfigs'].append(k.to_map() if k else None)
        if self.private_data is not None:
            result['privateData'] = self.private_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardData') is not None:
            temp_model = InvokeAssistantResponseBodyMessagesContentDingNormalCardCardData()
            self.card_data = temp_model.from_map(m['cardData'])
        if m.get('cardTemplateId') is not None:
            self.card_template_id = m.get('cardTemplateId')
        if m.get('cardUpdateOptions') is not None:
            temp_model = InvokeAssistantResponseBodyMessagesContentDingNormalCardCardUpdateOptions()
            self.card_update_options = temp_model.from_map(m['cardUpdateOptions'])
        self.dynamic_data_source_configs = []
        if m.get('dynamicDataSourceConfigs') is not None:
            for k in m.get('dynamicDataSourceConfigs'):
                temp_model = InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs()
                self.dynamic_data_source_configs.append(temp_model.from_map(k))
        if m.get('privateData') is not None:
            self.private_data = m.get('privateData')
        return self


class InvokeAssistantResponseBodyMessagesContentMarkdown(TeaModel):
    def __init__(
        self,
        value: str = None,
    ):
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class InvokeAssistantResponseBodyMessagesContentStructViewPartsDataPart(TeaModel):
    def __init__(
        self,
        data: Any = None,
    ):
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class InvokeAssistantResponseBodyMessagesContentStructViewPartsReasonPart(TeaModel):
    def __init__(
        self,
        reason: str = None,
    ):
        self.reason = reason

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reason is not None:
            result['reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        return self


class InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPartRecommends(TeaModel):
    def __init__(
        self,
        mobile_url: str = None,
        text: str = None,
        url: str = None,
    ):
        self.mobile_url = mobile_url
        self.text = text
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mobile_url is not None:
            result['mobileUrl'] = self.mobile_url
        if self.text is not None:
            result['text'] = self.text
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('mobileUrl') is not None:
            self.mobile_url = m.get('mobileUrl')
        if m.get('text') is not None:
            self.text = m.get('text')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPart(TeaModel):
    def __init__(
        self,
        recommends: List[InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPartRecommends] = None,
    ):
        self.recommends = recommends

    def validate(self):
        if self.recommends:
            for k in self.recommends:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['recommends'] = []
        if self.recommends is not None:
            for k in self.recommends:
                result['recommends'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.recommends = []
        if m.get('recommends') is not None:
            for k in m.get('recommends'):
                temp_model = InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPartRecommends()
                self.recommends.append(temp_model.from_map(k))
        return self


class InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePartReferences(TeaModel):
    def __init__(
        self,
        index: str = None,
        name: str = None,
        source_code: str = None,
        source_icon: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.index = index
        self.name = name
        self.source_code = source_code
        self.source_icon = source_icon
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['index'] = self.index
        if self.name is not None:
            result['name'] = self.name
        if self.source_code is not None:
            result['sourceCode'] = self.source_code
        if self.source_icon is not None:
            result['sourceIcon'] = self.source_icon
        if self.summary is not None:
            result['summary'] = self.summary
        if self.title is not None:
            result['title'] = self.title
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('sourceCode') is not None:
            self.source_code = m.get('sourceCode')
        if m.get('sourceIcon') is not None:
            self.source_icon = m.get('sourceIcon')
        if m.get('summary') is not None:
            self.summary = m.get('summary')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePart(TeaModel):
    def __init__(
        self,
        references: List[InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePartReferences] = None,
    ):
        self.references = references

    def validate(self):
        if self.references:
            for k in self.references:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['references'] = []
        if self.references is not None:
            for k in self.references:
                result['references'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.references = []
        if m.get('references') is not None:
            for k in m.get('references'):
                temp_model = InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePartReferences()
                self.references.append(temp_model.from_map(k))
        return self


class InvokeAssistantResponseBodyMessagesContentStructViewPartsTextPart(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('text') is not None:
            self.text = m.get('text')
        return self


class InvokeAssistantResponseBodyMessagesContentStructViewParts(TeaModel):
    def __init__(
        self,
        append: bool = None,
        data_part: InvokeAssistantResponseBodyMessagesContentStructViewPartsDataPart = None,
        finish: bool = None,
        part_desc: str = None,
        part_id: str = None,
        reason_part: InvokeAssistantResponseBodyMessagesContentStructViewPartsReasonPart = None,
        recommend_part: InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPart = None,
        reference_part: InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePart = None,
        text_part: InvokeAssistantResponseBodyMessagesContentStructViewPartsTextPart = None,
        type: str = None,
    ):
        self.append = append
        self.data_part = data_part
        self.finish = finish
        self.part_desc = part_desc
        self.part_id = part_id
        self.reason_part = reason_part
        self.recommend_part = recommend_part
        self.reference_part = reference_part
        self.text_part = text_part
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.data_part:
            self.data_part.validate()
        if self.reason_part:
            self.reason_part.validate()
        if self.recommend_part:
            self.recommend_part.validate()
        if self.reference_part:
            self.reference_part.validate()
        if self.text_part:
            self.text_part.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.append is not None:
            result['append'] = self.append
        if self.data_part is not None:
            result['dataPart'] = self.data_part.to_map()
        if self.finish is not None:
            result['finish'] = self.finish
        if self.part_desc is not None:
            result['partDesc'] = self.part_desc
        if self.part_id is not None:
            result['partId'] = self.part_id
        if self.reason_part is not None:
            result['reasonPart'] = self.reason_part.to_map()
        if self.recommend_part is not None:
            result['recommendPart'] = self.recommend_part.to_map()
        if self.reference_part is not None:
            result['referencePart'] = self.reference_part.to_map()
        if self.text_part is not None:
            result['textPart'] = self.text_part.to_map()
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('append') is not None:
            self.append = m.get('append')
        if m.get('dataPart') is not None:
            temp_model = InvokeAssistantResponseBodyMessagesContentStructViewPartsDataPart()
            self.data_part = temp_model.from_map(m['dataPart'])
        if m.get('finish') is not None:
            self.finish = m.get('finish')
        if m.get('partDesc') is not None:
            self.part_desc = m.get('partDesc')
        if m.get('partId') is not None:
            self.part_id = m.get('partId')
        if m.get('reasonPart') is not None:
            temp_model = InvokeAssistantResponseBodyMessagesContentStructViewPartsReasonPart()
            self.reason_part = temp_model.from_map(m['reasonPart'])
        if m.get('recommendPart') is not None:
            temp_model = InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPart()
            self.recommend_part = temp_model.from_map(m['recommendPart'])
        if m.get('referencePart') is not None:
            temp_model = InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePart()
            self.reference_part = temp_model.from_map(m['referencePart'])
        if m.get('textPart') is not None:
            temp_model = InvokeAssistantResponseBodyMessagesContentStructViewPartsTextPart()
            self.text_part = temp_model.from_map(m['textPart'])
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class InvokeAssistantResponseBodyMessagesContentStructView(TeaModel):
    def __init__(
        self,
        parts: List[InvokeAssistantResponseBodyMessagesContentStructViewParts] = None,
    ):
        self.parts = parts

    def validate(self):
        if self.parts:
            for k in self.parts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['parts'] = []
        if self.parts is not None:
            for k in self.parts:
                result['parts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.parts = []
        if m.get('parts') is not None:
            for k in m.get('parts'):
                temp_model = InvokeAssistantResponseBodyMessagesContentStructViewParts()
                self.parts.append(temp_model.from_map(k))
        return self


class InvokeAssistantResponseBodyMessagesContentText(TeaModel):
    def __init__(
        self,
        value: str = None,
    ):
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class InvokeAssistantResponseBodyMessagesContent(TeaModel):
    def __init__(
        self,
        card_callback: InvokeAssistantResponseBodyMessagesContentCardCallback = None,
        ding_card: InvokeAssistantResponseBodyMessagesContentDingCard = None,
        ding_normal_card: InvokeAssistantResponseBodyMessagesContentDingNormalCard = None,
        markdown: InvokeAssistantResponseBodyMessagesContentMarkdown = None,
        struct_view: InvokeAssistantResponseBodyMessagesContentStructView = None,
        text: InvokeAssistantResponseBodyMessagesContentText = None,
        type: str = None,
    ):
        self.card_callback = card_callback
        self.ding_card = ding_card
        self.ding_normal_card = ding_normal_card
        self.markdown = markdown
        self.struct_view = struct_view
        self.text = text
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.card_callback:
            self.card_callback.validate()
        if self.ding_card:
            self.ding_card.validate()
        if self.ding_normal_card:
            self.ding_normal_card.validate()
        if self.markdown:
            self.markdown.validate()
        if self.struct_view:
            self.struct_view.validate()
        if self.text:
            self.text.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_callback is not None:
            result['cardCallback'] = self.card_callback.to_map()
        if self.ding_card is not None:
            result['dingCard'] = self.ding_card.to_map()
        if self.ding_normal_card is not None:
            result['dingNormalCard'] = self.ding_normal_card.to_map()
        if self.markdown is not None:
            result['markdown'] = self.markdown.to_map()
        if self.struct_view is not None:
            result['structView'] = self.struct_view.to_map()
        if self.text is not None:
            result['text'] = self.text.to_map()
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardCallback') is not None:
            temp_model = InvokeAssistantResponseBodyMessagesContentCardCallback()
            self.card_callback = temp_model.from_map(m['cardCallback'])
        if m.get('dingCard') is not None:
            temp_model = InvokeAssistantResponseBodyMessagesContentDingCard()
            self.ding_card = temp_model.from_map(m['dingCard'])
        if m.get('dingNormalCard') is not None:
            temp_model = InvokeAssistantResponseBodyMessagesContentDingNormalCard()
            self.ding_normal_card = temp_model.from_map(m['dingNormalCard'])
        if m.get('markdown') is not None:
            temp_model = InvokeAssistantResponseBodyMessagesContentMarkdown()
            self.markdown = temp_model.from_map(m['markdown'])
        if m.get('structView') is not None:
            temp_model = InvokeAssistantResponseBodyMessagesContentStructView()
            self.struct_view = temp_model.from_map(m['structView'])
        if m.get('text') is not None:
            temp_model = InvokeAssistantResponseBodyMessagesContentText()
            self.text = temp_model.from_map(m['text'])
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class InvokeAssistantResponseBodyMessages(TeaModel):
    def __init__(
        self,
        content: InvokeAssistantResponseBodyMessagesContent = None,
        content_desc: str = None,
        create_at: int = None,
        role: str = None,
    ):
        self.content = content
        self.content_desc = content_desc
        self.create_at = create_at
        self.role = role

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content.to_map()
        if self.content_desc is not None:
            result['contentDesc'] = self.content_desc
        if self.create_at is not None:
            result['createAt'] = self.create_at
        if self.role is not None:
            result['role'] = self.role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            temp_model = InvokeAssistantResponseBodyMessagesContent()
            self.content = temp_model.from_map(m['content'])
        if m.get('contentDesc') is not None:
            self.content_desc = m.get('contentDesc')
        if m.get('createAt') is not None:
            self.create_at = m.get('createAt')
        if m.get('role') is not None:
            self.role = m.get('role')
        return self


class InvokeAssistantResponseBody(TeaModel):
    def __init__(
        self,
        messages: List[InvokeAssistantResponseBodyMessages] = None,
        request_id: str = None,
        session_id: str = None,
        stream_end: bool = None,
    ):
        self.messages = messages
        self.request_id = request_id
        self.session_id = session_id
        self.stream_end = stream_end

    def validate(self):
        if self.messages:
            for k in self.messages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['messages'] = []
        if self.messages is not None:
            for k in self.messages:
                result['messages'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.session_id is not None:
            result['sessionId'] = self.session_id
        if self.stream_end is not None:
            result['streamEnd'] = self.stream_end
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.messages = []
        if m.get('messages') is not None:
            for k in m.get('messages'):
                temp_model = InvokeAssistantResponseBodyMessages()
                self.messages.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('sessionId') is not None:
            self.session_id = m.get('sessionId')
        if m.get('streamEnd') is not None:
            self.stream_end = m.get('streamEnd')
        return self


class InvokeAssistantResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InvokeAssistantResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InvokeAssistantResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InvokeSkillHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class InvokeSkillHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: InvokeSkillHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = InvokeSkillHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class InvokeSkillShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class InvokeSkillRequest(TeaModel):
    def __init__(
        self,
        params: Dict[str, Any] = None,
        skill_id: str = None,
    ):
        self.params = params
        self.skill_id = skill_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.params is not None:
            result['Params'] = self.params
        if self.skill_id is not None:
            result['SkillId'] = self.skill_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('SkillId') is not None:
            self.skill_id = m.get('SkillId')
        return self


class InvokeSkillShrinkRequest(TeaModel):
    def __init__(
        self,
        params_shrink: str = None,
        skill_id: str = None,
    ):
        self.params_shrink = params_shrink
        self.skill_id = skill_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.params_shrink is not None:
            result['Params'] = self.params_shrink
        if self.skill_id is not None:
            result['SkillId'] = self.skill_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Params') is not None:
            self.params_shrink = m.get('Params')
        if m.get('SkillId') is not None:
            self.skill_id = m.get('SkillId')
        return self


class InvokeSkillResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        data: Dict[str, Any] = None,
    ):
        # RequestId
        self.request_id = request_id
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class InvokeSkillResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InvokeSkillResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InvokeSkillResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListApplicationHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ListApplicationHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ListApplicationHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ListApplicationHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ListApplicationShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ListApplicationRequest(TeaModel):
    def __init__(
        self,
        app_filter: str = None,
        app_name_search_keyword: str = None,
        corp_id: str = None,
        page_number: int = None,
        page_size: int = None,
        token: str = None,
    ):
        self.app_filter = app_filter
        self.app_name_search_keyword = app_name_search_keyword
        # This parameter is required.
        self.corp_id = corp_id
        self.page_number = page_number
        self.page_size = page_size
        # This parameter is required.
        self.token = token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_filter is not None:
            result['AppFilter'] = self.app_filter
        if self.app_name_search_keyword is not None:
            result['AppNameSearchKeyword'] = self.app_name_search_keyword
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.token is not None:
            result['Token'] = self.token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppFilter') is not None:
            self.app_filter = m.get('AppFilter')
        if m.get('AppNameSearchKeyword') is not None:
            self.app_name_search_keyword = m.get('AppNameSearchKeyword')
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        return self


class ListApplicationResponseBodyData(TeaModel):
    def __init__(
        self,
        app_config: str = None,
        app_type: str = None,
        application_status: str = None,
        corp_id: str = None,
        creator_user_id: str = None,
        description: str = None,
        icon: str = None,
        inexistence: str = None,
        name: str = None,
        sub_corp_id: str = None,
    ):
        self.app_config = app_config
        self.app_type = app_type
        self.application_status = application_status
        self.corp_id = corp_id
        self.creator_user_id = creator_user_id
        self.description = description
        self.icon = icon
        self.inexistence = inexistence
        self.name = name
        self.sub_corp_id = sub_corp_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_config is not None:
            result['AppConfig'] = self.app_config
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.application_status is not None:
            result['ApplicationStatus'] = self.application_status
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.creator_user_id is not None:
            result['CreatorUserId'] = self.creator_user_id
        if self.description is not None:
            result['Description'] = self.description
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.inexistence is not None:
            result['Inexistence'] = self.inexistence
        if self.name is not None:
            result['Name'] = self.name
        if self.sub_corp_id is not None:
            result['SubCorpId'] = self.sub_corp_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppConfig') is not None:
            self.app_config = m.get('AppConfig')
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('ApplicationStatus') is not None:
            self.application_status = m.get('ApplicationStatus')
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('CreatorUserId') is not None:
            self.creator_user_id = m.get('CreatorUserId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Inexistence') is not None:
            self.inexistence = m.get('Inexistence')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SubCorpId') is not None:
            self.sub_corp_id = m.get('SubCorpId')
        return self


class ListApplicationResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListApplicationResponseBodyData] = None,
        page_number: int = None,
        request_id: str = None,
        total_count: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.data = data
        self.page_number = page_number
        self.request_id = request_id
        self.total_count = total_count
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ListApplicationResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class ListApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCalendarsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ListCalendarsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ListCalendarsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ListCalendarsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ListCalendarsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ListCalendarsRequest(TeaModel):
    def __init__(
        self,
        request: Dict[str, Any] = None,
    ):
        self.request = request

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request is not None:
            result['Request'] = self.request
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Request') is not None:
            self.request = m.get('Request')
        return self


class ListCalendarsShrinkRequest(TeaModel):
    def __init__(
        self,
        request_shrink: str = None,
    ):
        self.request_shrink = request_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_shrink is not None:
            result['Request'] = self.request_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Request') is not None:
            self.request_shrink = m.get('Request')
        return self


class ListCalendarsResponseBodyResponseCalendars(TeaModel):
    def __init__(
        self,
        description: str = None,
        etag: str = None,
        id: str = None,
        privilege: str = None,
        summary: str = None,
        time_zone: str = None,
        type: str = None,
    ):
        self.description = description
        self.etag = etag
        self.id = id
        self.privilege = privilege
        self.summary = summary
        self.time_zone = time_zone
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.etag is not None:
            result['ETag'] = self.etag
        if self.id is not None:
            result['Id'] = self.id
        if self.privilege is not None:
            result['Privilege'] = self.privilege
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.time_zone is not None:
            result['TimeZone'] = self.time_zone
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ETag') is not None:
            self.etag = m.get('ETag')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Privilege') is not None:
            self.privilege = m.get('Privilege')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('TimeZone') is not None:
            self.time_zone = m.get('TimeZone')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListCalendarsResponseBodyResponse(TeaModel):
    def __init__(
        self,
        calendars: List[ListCalendarsResponseBodyResponseCalendars] = None,
    ):
        self.calendars = calendars

    def validate(self):
        if self.calendars:
            for k in self.calendars:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Calendars'] = []
        if self.calendars is not None:
            for k in self.calendars:
                result['Calendars'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.calendars = []
        if m.get('Calendars') is not None:
            for k in m.get('Calendars'):
                temp_model = ListCalendarsResponseBodyResponseCalendars()
                self.calendars.append(temp_model.from_map(k))
        return self


class ListCalendarsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        response: ListCalendarsResponseBodyResponse = None,
    ):
        # requestId
        self.request_id = request_id
        self.response = response

    def validate(self):
        if self.response:
            self.response.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.response is not None:
            result['response'] = self.response.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('response') is not None:
            temp_model = ListCalendarsResponseBodyResponse()
            self.response = temp_model.from_map(m['response'])
        return self


class ListCalendarsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCalendarsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCalendarsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDentriesHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ListDentriesHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ListDentriesHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ListDentriesHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ListDentriesShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ListDentriesRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class ListDentriesRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        order: str = None,
        order_by: str = None,
        parent_id: str = None,
        space_id: str = None,
        tenant_context: ListDentriesRequestTenantContext = None,
        with_thumbnail: bool = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.order = order
        self.order_by = order_by
        # This parameter is required.
        self.parent_id = parent_id
        # This parameter is required.
        self.space_id = space_id
        self.tenant_context = tenant_context
        self.with_thumbnail = with_thumbnail

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.order is not None:
            result['Order'] = self.order
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.with_thumbnail is not None:
            result['WithThumbnail'] = self.with_thumbnail
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('TenantContext') is not None:
            temp_model = ListDentriesRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WithThumbnail') is not None:
            self.with_thumbnail = m.get('WithThumbnail')
        return self


class ListDentriesShrinkRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        order: str = None,
        order_by: str = None,
        parent_id: str = None,
        space_id: str = None,
        tenant_context_shrink: str = None,
        with_thumbnail: bool = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.order = order
        self.order_by = order_by
        # This parameter is required.
        self.parent_id = parent_id
        # This parameter is required.
        self.space_id = space_id
        self.tenant_context_shrink = tenant_context_shrink
        self.with_thumbnail = with_thumbnail

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.order is not None:
            result['Order'] = self.order
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.with_thumbnail is not None:
            result['WithThumbnail'] = self.with_thumbnail
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WithThumbnail') is not None:
            self.with_thumbnail = m.get('WithThumbnail')
        return self


class ListDentriesResponseBodyDentriesProperties(TeaModel):
    def __init__(
        self,
        read_only: bool = None,
    ):
        self.read_only = read_only

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.read_only is not None:
            result['ReadOnly'] = self.read_only
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReadOnly') is not None:
            self.read_only = m.get('ReadOnly')
        return self


class ListDentriesResponseBodyDentriesThumbnail(TeaModel):
    def __init__(
        self,
        height: int = None,
        url: str = None,
        width: int = None,
    ):
        self.height = height
        self.url = url
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListDentriesResponseBodyDentries(TeaModel):
    def __init__(
        self,
        app_properties: Dict[str, List[DentriesAppPropertiesValue]] = None,
        create_time: str = None,
        creator_id: str = None,
        extension: str = None,
        id: str = None,
        modified_time: str = None,
        modifier_id: str = None,
        name: str = None,
        parent_id: str = None,
        partition_type: str = None,
        path: str = None,
        properties: ListDentriesResponseBodyDentriesProperties = None,
        size: int = None,
        space_id: str = None,
        status: str = None,
        storage_driver: str = None,
        thumbnail: ListDentriesResponseBodyDentriesThumbnail = None,
        type: str = None,
        uuid: str = None,
        version: int = None,
    ):
        self.app_properties = app_properties
        self.create_time = create_time
        self.creator_id = creator_id
        self.extension = extension
        self.id = id
        self.modified_time = modified_time
        self.modifier_id = modifier_id
        self.name = name
        self.parent_id = parent_id
        self.partition_type = partition_type
        self.path = path
        self.properties = properties
        self.size = size
        self.space_id = space_id
        self.status = status
        self.storage_driver = storage_driver
        self.thumbnail = thumbnail
        self.type = type
        self.uuid = uuid
        self.version = version

    def validate(self):
        if self.app_properties:
            for v in self.app_properties.values():
                for k1 in v:
                    if k1:
                        k1.validate()
        if self.properties:
            self.properties.validate()
        if self.thumbnail:
            self.thumbnail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AppProperties'] = {}
        if self.app_properties is not None:
            for k, v in self.app_properties.items():
                l1 = []
                for k1 in v:
                    l1.append(k1.to_map() if k1 else None)
                result['AppProperties'][k] = l1
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.id is not None:
            result['Id'] = self.id
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.name is not None:
            result['Name'] = self.name
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.partition_type is not None:
            result['PartitionType'] = self.partition_type
        if self.path is not None:
            result['Path'] = self.path
        if self.properties is not None:
            result['Properties'] = self.properties.to_map()
        if self.size is not None:
            result['Size'] = self.size
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.status is not None:
            result['Status'] = self.status
        if self.storage_driver is not None:
            result['StorageDriver'] = self.storage_driver
        if self.thumbnail is not None:
            result['Thumbnail'] = self.thumbnail.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.app_properties = {}
        if m.get('AppProperties') is not None:
            for k, v in m.get('AppProperties').items():
                l1 = []
                for k1 in v:
                    temp_model = DentriesAppPropertiesValue()
                    l1.append(temp_model.from_map(k1))
                self.app_properties['k'] = l1
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('PartitionType') is not None:
            self.partition_type = m.get('PartitionType')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Properties') is not None:
            temp_model = ListDentriesResponseBodyDentriesProperties()
            self.properties = temp_model.from_map(m['Properties'])
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StorageDriver') is not None:
            self.storage_driver = m.get('StorageDriver')
        if m.get('Thumbnail') is not None:
            temp_model = ListDentriesResponseBodyDentriesThumbnail()
            self.thumbnail = temp_model.from_map(m['Thumbnail'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListDentriesResponseBody(TeaModel):
    def __init__(
        self,
        dentries: List[ListDentriesResponseBodyDentries] = None,
        next_token: str = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.dentries = dentries
        self.next_token = next_token
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.dentries:
            for k in self.dentries:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['dentries'] = []
        if self.dentries is not None:
            for k in self.dentries:
                result['dentries'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dentries = []
        if m.get('dentries') is not None:
            for k in m.get('dentries'):
                temp_model = ListDentriesResponseBodyDentries()
                self.dentries.append(temp_model.from_map(k))
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class ListDentriesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDentriesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDentriesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDriveSpacesHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ListDriveSpacesHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ListDriveSpacesHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        # This parameter is required.
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ListDriveSpacesHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ListDriveSpacesShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        # This parameter is required.
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ListDriveSpacesRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class ListDriveSpacesRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        space_type: str = None,
        tenant_context: ListDriveSpacesRequestTenantContext = None,
    ):
        # This parameter is required.
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.space_type = space_type
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.space_type is not None:
            result['SpaceType'] = self.space_type
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('SpaceType') is not None:
            self.space_type = m.get('SpaceType')
        if m.get('TenantContext') is not None:
            temp_model = ListDriveSpacesRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class ListDriveSpacesShrinkRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        space_type: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.space_type = space_type
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.space_type is not None:
            result['SpaceType'] = self.space_type
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('SpaceType') is not None:
            self.space_type = m.get('SpaceType')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class ListDriveSpacesResponseBodySpaces(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        modify_time: str = None,
        permission_mode: str = None,
        quota: int = None,
        space_id: str = None,
        space_name: str = None,
        space_type: str = None,
        used_quota: int = None,
    ):
        self.create_time = create_time
        self.modify_time = modify_time
        self.permission_mode = permission_mode
        self.quota = quota
        self.space_id = space_id
        self.space_name = space_name
        self.space_type = space_type
        self.used_quota = used_quota

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.permission_mode is not None:
            result['PermissionMode'] = self.permission_mode
        if self.quota is not None:
            result['Quota'] = self.quota
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.space_name is not None:
            result['SpaceName'] = self.space_name
        if self.space_type is not None:
            result['SpaceType'] = self.space_type
        if self.used_quota is not None:
            result['UsedQuota'] = self.used_quota
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('PermissionMode') is not None:
            self.permission_mode = m.get('PermissionMode')
        if m.get('Quota') is not None:
            self.quota = m.get('Quota')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('SpaceName') is not None:
            self.space_name = m.get('SpaceName')
        if m.get('SpaceType') is not None:
            self.space_type = m.get('SpaceType')
        if m.get('UsedQuota') is not None:
            self.used_quota = m.get('UsedQuota')
        return self


class ListDriveSpacesResponseBody(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        request_id: str = None,
        spaces: List[ListDriveSpacesResponseBodySpaces] = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.next_token = next_token
        self.request_id = request_id
        self.spaces = spaces
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.spaces:
            for k in self.spaces:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['spaces'] = []
        if self.spaces is not None:
            for k in self.spaces:
                result['spaces'].append(k.to_map() if k else None)
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.spaces = []
        if m.get('spaces') is not None:
            for k in m.get('spaces'):
                temp_model = ListDriveSpacesResponseBodySpaces()
                self.spaces.append(temp_model.from_map(k))
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class ListDriveSpacesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDriveSpacesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDriveSpacesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEventsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ListEventsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ListEventsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ListEventsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ListEventsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ListEventsRequest(TeaModel):
    def __init__(
        self,
        calendar_id: str = None,
        max_attendees: int = None,
        max_results: int = None,
        next_token: str = None,
        series_master_id: str = None,
        show_deleted: bool = None,
        sync_token: str = None,
        time_max: str = None,
        time_min: str = None,
    ):
        # This parameter is required.
        self.calendar_id = calendar_id
        self.max_attendees = max_attendees
        self.max_results = max_results
        self.next_token = next_token
        self.series_master_id = series_master_id
        self.show_deleted = show_deleted
        self.sync_token = sync_token
        self.time_max = time_max
        self.time_min = time_min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        if self.max_attendees is not None:
            result['MaxAttendees'] = self.max_attendees
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.series_master_id is not None:
            result['SeriesMasterId'] = self.series_master_id
        if self.show_deleted is not None:
            result['ShowDeleted'] = self.show_deleted
        if self.sync_token is not None:
            result['SyncToken'] = self.sync_token
        if self.time_max is not None:
            result['TimeMax'] = self.time_max
        if self.time_min is not None:
            result['TimeMin'] = self.time_min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        if m.get('MaxAttendees') is not None:
            self.max_attendees = m.get('MaxAttendees')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('SeriesMasterId') is not None:
            self.series_master_id = m.get('SeriesMasterId')
        if m.get('ShowDeleted') is not None:
            self.show_deleted = m.get('ShowDeleted')
        if m.get('SyncToken') is not None:
            self.sync_token = m.get('SyncToken')
        if m.get('TimeMax') is not None:
            self.time_max = m.get('TimeMax')
        if m.get('TimeMin') is not None:
            self.time_min = m.get('TimeMin')
        return self


class ListEventsResponseBodyEventsAttendees(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        is_optional: bool = None,
        response_status: str = None,
        self_: bool = None,
    ):
        self.display_name = display_name
        self.is_optional = is_optional
        self.response_status = response_status
        self.self_ = self_

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.is_optional is not None:
            result['IsOptional'] = self.is_optional
        if self.response_status is not None:
            result['ResponseStatus'] = self.response_status
        if self.self_ is not None:
            result['Self'] = self.self_
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('IsOptional') is not None:
            self.is_optional = m.get('IsOptional')
        if m.get('ResponseStatus') is not None:
            self.response_status = m.get('ResponseStatus')
        if m.get('Self') is not None:
            self.self_ = m.get('Self')
        return self


class ListEventsResponseBodyEventsCategories(TeaModel):
    def __init__(
        self,
        display_name: str = None,
    ):
        self.display_name = display_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        return self


class ListEventsResponseBodyEventsEnd(TeaModel):
    def __init__(
        self,
        date: str = None,
        date_time: str = None,
        time_zone: str = None,
    ):
        self.date = date
        self.date_time = date_time
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['Date'] = self.date
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.time_zone is not None:
            result['TimeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Date') is not None:
            self.date = m.get('Date')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('TimeZone') is not None:
            self.time_zone = m.get('TimeZone')
        return self


class ListEventsResponseBodyEventsExtendedPropertiesSharedProperties(TeaModel):
    def __init__(
        self,
        belong_corp_id: str = None,
        source_open_cid: str = None,
    ):
        self.belong_corp_id = belong_corp_id
        self.source_open_cid = source_open_cid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.belong_corp_id is not None:
            result['BelongCorpId'] = self.belong_corp_id
        if self.source_open_cid is not None:
            result['SourceOpenCid'] = self.source_open_cid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BelongCorpId') is not None:
            self.belong_corp_id = m.get('BelongCorpId')
        if m.get('SourceOpenCid') is not None:
            self.source_open_cid = m.get('SourceOpenCid')
        return self


class ListEventsResponseBodyEventsExtendedProperties(TeaModel):
    def __init__(
        self,
        shared_properties: ListEventsResponseBodyEventsExtendedPropertiesSharedProperties = None,
    ):
        self.shared_properties = shared_properties

    def validate(self):
        if self.shared_properties:
            self.shared_properties.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.shared_properties is not None:
            result['SharedProperties'] = self.shared_properties.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SharedProperties') is not None:
            temp_model = ListEventsResponseBodyEventsExtendedPropertiesSharedProperties()
            self.shared_properties = temp_model.from_map(m['SharedProperties'])
        return self


class ListEventsResponseBodyEventsLocation(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        meeting_rooms: List[str] = None,
    ):
        self.display_name = display_name
        self.meeting_rooms = meeting_rooms

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.meeting_rooms is not None:
            result['MeetingRooms'] = self.meeting_rooms
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('MeetingRooms') is not None:
            self.meeting_rooms = m.get('MeetingRooms')
        return self


class ListEventsResponseBodyEventsMeetingRooms(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        response_status: str = None,
        room_id: str = None,
    ):
        self.display_name = display_name
        self.response_status = response_status
        self.room_id = room_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.response_status is not None:
            result['ResponseStatus'] = self.response_status
        if self.room_id is not None:
            result['RoomId'] = self.room_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('ResponseStatus') is not None:
            self.response_status = m.get('ResponseStatus')
        if m.get('RoomId') is not None:
            self.room_id = m.get('RoomId')
        return self


class ListEventsResponseBodyEventsOnlineMeetingInfo(TeaModel):
    def __init__(
        self,
        conference_id: str = None,
        extra_info: Dict[str, Any] = None,
        type: str = None,
        url: str = None,
    ):
        self.conference_id = conference_id
        self.extra_info = extra_info
        self.type = type
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conference_id is not None:
            result['ConferenceId'] = self.conference_id
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConferenceId') is not None:
            self.conference_id = m.get('ConferenceId')
        if m.get('ExtraInfo') is not None:
            self.extra_info = m.get('ExtraInfo')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ListEventsResponseBodyEventsOrganizer(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        response_status: str = None,
        self_: bool = None,
    ):
        self.display_name = display_name
        self.response_status = response_status
        self.self_ = self_

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.response_status is not None:
            result['ResponseStatus'] = self.response_status
        if self.self_ is not None:
            result['Self'] = self.self_
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('ResponseStatus') is not None:
            self.response_status = m.get('ResponseStatus')
        if m.get('Self') is not None:
            self.self_ = m.get('Self')
        return self


class ListEventsResponseBodyEventsOriginStart(TeaModel):
    def __init__(
        self,
        date_time: str = None,
    ):
        self.date_time = date_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        return self


class ListEventsResponseBodyEventsRecurrencePattern(TeaModel):
    def __init__(
        self,
        day_of_month: int = None,
        days_of_week: str = None,
        index: str = None,
        interval: int = None,
        type: str = None,
    ):
        self.day_of_month = day_of_month
        self.days_of_week = days_of_week
        self.index = index
        self.interval = interval
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.day_of_month is not None:
            result['DayOfMonth'] = self.day_of_month
        if self.days_of_week is not None:
            result['DaysOfWeek'] = self.days_of_week
        if self.index is not None:
            result['Index'] = self.index
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DayOfMonth') is not None:
            self.day_of_month = m.get('DayOfMonth')
        if m.get('DaysOfWeek') is not None:
            self.days_of_week = m.get('DaysOfWeek')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListEventsResponseBodyEventsRecurrenceRange(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        number_of_occurrences: int = None,
        type: str = None,
    ):
        self.end_date = end_date
        self.number_of_occurrences = number_of_occurrences
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.number_of_occurrences is not None:
            result['NumberOfOccurrences'] = self.number_of_occurrences
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('NumberOfOccurrences') is not None:
            self.number_of_occurrences = m.get('NumberOfOccurrences')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListEventsResponseBodyEventsRecurrence(TeaModel):
    def __init__(
        self,
        pattern: ListEventsResponseBodyEventsRecurrencePattern = None,
        range: ListEventsResponseBodyEventsRecurrenceRange = None,
    ):
        self.pattern = pattern
        self.range = range

    def validate(self):
        if self.pattern:
            self.pattern.validate()
        if self.range:
            self.range.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pattern is not None:
            result['Pattern'] = self.pattern.to_map()
        if self.range is not None:
            result['Range'] = self.range.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pattern') is not None:
            temp_model = ListEventsResponseBodyEventsRecurrencePattern()
            self.pattern = temp_model.from_map(m['Pattern'])
        if m.get('Range') is not None:
            temp_model = ListEventsResponseBodyEventsRecurrenceRange()
            self.range = temp_model.from_map(m['Range'])
        return self


class ListEventsResponseBodyEventsReminders(TeaModel):
    def __init__(
        self,
        method: str = None,
        minutes: str = None,
    ):
        self.method = method
        self.minutes = minutes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.method is not None:
            result['Method'] = self.method
        if self.minutes is not None:
            result['Minutes'] = self.minutes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('Minutes') is not None:
            self.minutes = m.get('Minutes')
        return self


class ListEventsResponseBodyEventsRichTextDescription(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class ListEventsResponseBodyEventsStart(TeaModel):
    def __init__(
        self,
        date: str = None,
        date_time: str = None,
        time_zone: str = None,
    ):
        self.date = date
        self.date_time = date_time
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['Date'] = self.date
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.time_zone is not None:
            result['TimeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Date') is not None:
            self.date = m.get('Date')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('TimeZone') is not None:
            self.time_zone = m.get('TimeZone')
        return self


class ListEventsResponseBodyEvents(TeaModel):
    def __init__(
        self,
        attendees: List[ListEventsResponseBodyEventsAttendees] = None,
        categories: List[ListEventsResponseBodyEventsCategories] = None,
        create_time: str = None,
        description: str = None,
        end: ListEventsResponseBodyEventsEnd = None,
        extended_properties: ListEventsResponseBodyEventsExtendedProperties = None,
        id: str = None,
        is_all_day: bool = None,
        location: ListEventsResponseBodyEventsLocation = None,
        meeting_rooms: List[ListEventsResponseBodyEventsMeetingRooms] = None,
        online_meeting_info: ListEventsResponseBodyEventsOnlineMeetingInfo = None,
        organizer: ListEventsResponseBodyEventsOrganizer = None,
        origin_start: ListEventsResponseBodyEventsOriginStart = None,
        recurrence: ListEventsResponseBodyEventsRecurrence = None,
        reminders: List[ListEventsResponseBodyEventsReminders] = None,
        rich_text_description: ListEventsResponseBodyEventsRichTextDescription = None,
        series_master_id: str = None,
        start: ListEventsResponseBodyEventsStart = None,
        status: str = None,
        summary: str = None,
        update_time: str = None,
    ):
        self.attendees = attendees
        self.categories = categories
        self.create_time = create_time
        self.description = description
        self.end = end
        self.extended_properties = extended_properties
        self.id = id
        self.is_all_day = is_all_day
        self.location = location
        self.meeting_rooms = meeting_rooms
        self.online_meeting_info = online_meeting_info
        self.organizer = organizer
        self.origin_start = origin_start
        self.recurrence = recurrence
        self.reminders = reminders
        self.rich_text_description = rich_text_description
        self.series_master_id = series_master_id
        self.start = start
        self.status = status
        self.summary = summary
        self.update_time = update_time

    def validate(self):
        if self.attendees:
            for k in self.attendees:
                if k:
                    k.validate()
        if self.categories:
            for k in self.categories:
                if k:
                    k.validate()
        if self.end:
            self.end.validate()
        if self.extended_properties:
            self.extended_properties.validate()
        if self.location:
            self.location.validate()
        if self.meeting_rooms:
            for k in self.meeting_rooms:
                if k:
                    k.validate()
        if self.online_meeting_info:
            self.online_meeting_info.validate()
        if self.organizer:
            self.organizer.validate()
        if self.origin_start:
            self.origin_start.validate()
        if self.recurrence:
            self.recurrence.validate()
        if self.reminders:
            for k in self.reminders:
                if k:
                    k.validate()
        if self.rich_text_description:
            self.rich_text_description.validate()
        if self.start:
            self.start.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Attendees'] = []
        if self.attendees is not None:
            for k in self.attendees:
                result['Attendees'].append(k.to_map() if k else None)
        result['Categories'] = []
        if self.categories is not None:
            for k in self.categories:
                result['Categories'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.end is not None:
            result['End'] = self.end.to_map()
        if self.extended_properties is not None:
            result['ExtendedProperties'] = self.extended_properties.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.is_all_day is not None:
            result['IsAllDay'] = self.is_all_day
        if self.location is not None:
            result['Location'] = self.location.to_map()
        result['MeetingRooms'] = []
        if self.meeting_rooms is not None:
            for k in self.meeting_rooms:
                result['MeetingRooms'].append(k.to_map() if k else None)
        if self.online_meeting_info is not None:
            result['OnlineMeetingInfo'] = self.online_meeting_info.to_map()
        if self.organizer is not None:
            result['Organizer'] = self.organizer.to_map()
        if self.origin_start is not None:
            result['OriginStart'] = self.origin_start.to_map()
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence.to_map()
        result['Reminders'] = []
        if self.reminders is not None:
            for k in self.reminders:
                result['Reminders'].append(k.to_map() if k else None)
        if self.rich_text_description is not None:
            result['RichTextDescription'] = self.rich_text_description.to_map()
        if self.series_master_id is not None:
            result['SeriesMasterId'] = self.series_master_id
        if self.start is not None:
            result['Start'] = self.start.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attendees = []
        if m.get('Attendees') is not None:
            for k in m.get('Attendees'):
                temp_model = ListEventsResponseBodyEventsAttendees()
                self.attendees.append(temp_model.from_map(k))
        self.categories = []
        if m.get('Categories') is not None:
            for k in m.get('Categories'):
                temp_model = ListEventsResponseBodyEventsCategories()
                self.categories.append(temp_model.from_map(k))
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('End') is not None:
            temp_model = ListEventsResponseBodyEventsEnd()
            self.end = temp_model.from_map(m['End'])
        if m.get('ExtendedProperties') is not None:
            temp_model = ListEventsResponseBodyEventsExtendedProperties()
            self.extended_properties = temp_model.from_map(m['ExtendedProperties'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsAllDay') is not None:
            self.is_all_day = m.get('IsAllDay')
        if m.get('Location') is not None:
            temp_model = ListEventsResponseBodyEventsLocation()
            self.location = temp_model.from_map(m['Location'])
        self.meeting_rooms = []
        if m.get('MeetingRooms') is not None:
            for k in m.get('MeetingRooms'):
                temp_model = ListEventsResponseBodyEventsMeetingRooms()
                self.meeting_rooms.append(temp_model.from_map(k))
        if m.get('OnlineMeetingInfo') is not None:
            temp_model = ListEventsResponseBodyEventsOnlineMeetingInfo()
            self.online_meeting_info = temp_model.from_map(m['OnlineMeetingInfo'])
        if m.get('Organizer') is not None:
            temp_model = ListEventsResponseBodyEventsOrganizer()
            self.organizer = temp_model.from_map(m['Organizer'])
        if m.get('OriginStart') is not None:
            temp_model = ListEventsResponseBodyEventsOriginStart()
            self.origin_start = temp_model.from_map(m['OriginStart'])
        if m.get('Recurrence') is not None:
            temp_model = ListEventsResponseBodyEventsRecurrence()
            self.recurrence = temp_model.from_map(m['Recurrence'])
        self.reminders = []
        if m.get('Reminders') is not None:
            for k in m.get('Reminders'):
                temp_model = ListEventsResponseBodyEventsReminders()
                self.reminders.append(temp_model.from_map(k))
        if m.get('RichTextDescription') is not None:
            temp_model = ListEventsResponseBodyEventsRichTextDescription()
            self.rich_text_description = temp_model.from_map(m['RichTextDescription'])
        if m.get('SeriesMasterId') is not None:
            self.series_master_id = m.get('SeriesMasterId')
        if m.get('Start') is not None:
            temp_model = ListEventsResponseBodyEventsStart()
            self.start = temp_model.from_map(m['Start'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class ListEventsResponseBody(TeaModel):
    def __init__(
        self,
        events: List[ListEventsResponseBodyEvents] = None,
        next_token: str = None,
        request_id: str = None,
        sync_token: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.events = events
        self.next_token = next_token
        # requestId
        self.request_id = request_id
        self.sync_token = sync_token
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.events:
            for k in self.events:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['events'] = []
        if self.events is not None:
            for k in self.events:
                result['events'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.sync_token is not None:
            result['syncToken'] = self.sync_token
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.events = []
        if m.get('events') is not None:
            for k in m.get('events'):
                temp_model = ListEventsResponseBodyEvents()
                self.events.append(temp_model.from_map(k))
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('syncToken') is not None:
            self.sync_token = m.get('syncToken')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class ListEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEventsViewHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ListEventsViewHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ListEventsViewHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ListEventsViewHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ListEventsViewShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ListEventsViewRequest(TeaModel):
    def __init__(
        self,
        calendar_id: str = None,
        max_attendees: int = None,
        max_results: int = None,
        next_token: str = None,
        time_max: str = None,
        time_min: str = None,
    ):
        # This parameter is required.
        self.calendar_id = calendar_id
        self.max_attendees = max_attendees
        self.max_results = max_results
        self.next_token = next_token
        self.time_max = time_max
        self.time_min = time_min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        if self.max_attendees is not None:
            result['MaxAttendees'] = self.max_attendees
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.time_max is not None:
            result['TimeMax'] = self.time_max
        if self.time_min is not None:
            result['TimeMin'] = self.time_min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        if m.get('MaxAttendees') is not None:
            self.max_attendees = m.get('MaxAttendees')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('TimeMax') is not None:
            self.time_max = m.get('TimeMax')
        if m.get('TimeMin') is not None:
            self.time_min = m.get('TimeMin')
        return self


class ListEventsViewResponseBodyEventsAttendees(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        id: str = None,
        is_optional: bool = None,
        response_status: str = None,
        self_: bool = None,
    ):
        self.display_name = display_name
        self.id = id
        self.is_optional = is_optional
        self.response_status = response_status
        self.self_ = self_

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.id is not None:
            result['Id'] = self.id
        if self.is_optional is not None:
            result['IsOptional'] = self.is_optional
        if self.response_status is not None:
            result['ResponseStatus'] = self.response_status
        if self.self_ is not None:
            result['Self'] = self.self_
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsOptional') is not None:
            self.is_optional = m.get('IsOptional')
        if m.get('ResponseStatus') is not None:
            self.response_status = m.get('ResponseStatus')
        if m.get('Self') is not None:
            self.self_ = m.get('Self')
        return self


class ListEventsViewResponseBodyEventsCategories(TeaModel):
    def __init__(
        self,
        display_name: str = None,
    ):
        self.display_name = display_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        return self


class ListEventsViewResponseBodyEventsEnd(TeaModel):
    def __init__(
        self,
        date: str = None,
        date_time: str = None,
        time_zone: str = None,
    ):
        self.date = date
        self.date_time = date_time
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['Date'] = self.date
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.time_zone is not None:
            result['TimeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Date') is not None:
            self.date = m.get('Date')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('TimeZone') is not None:
            self.time_zone = m.get('TimeZone')
        return self


class ListEventsViewResponseBodyEventsExtendedPropertiesSharedProperties(TeaModel):
    def __init__(
        self,
        belong_corp_id: str = None,
        source_open_cid: str = None,
    ):
        self.belong_corp_id = belong_corp_id
        self.source_open_cid = source_open_cid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.belong_corp_id is not None:
            result['BelongCorpId'] = self.belong_corp_id
        if self.source_open_cid is not None:
            result['SourceOpenCid'] = self.source_open_cid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BelongCorpId') is not None:
            self.belong_corp_id = m.get('BelongCorpId')
        if m.get('SourceOpenCid') is not None:
            self.source_open_cid = m.get('SourceOpenCid')
        return self


class ListEventsViewResponseBodyEventsExtendedProperties(TeaModel):
    def __init__(
        self,
        shared_properties: ListEventsViewResponseBodyEventsExtendedPropertiesSharedProperties = None,
    ):
        self.shared_properties = shared_properties

    def validate(self):
        if self.shared_properties:
            self.shared_properties.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.shared_properties is not None:
            result['SharedProperties'] = self.shared_properties.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SharedProperties') is not None:
            temp_model = ListEventsViewResponseBodyEventsExtendedPropertiesSharedProperties()
            self.shared_properties = temp_model.from_map(m['SharedProperties'])
        return self


class ListEventsViewResponseBodyEventsLocation(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        meeting_rooms: List[str] = None,
    ):
        self.display_name = display_name
        self.meeting_rooms = meeting_rooms

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.meeting_rooms is not None:
            result['MeetingRooms'] = self.meeting_rooms
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('MeetingRooms') is not None:
            self.meeting_rooms = m.get('MeetingRooms')
        return self


class ListEventsViewResponseBodyEventsMeetingRooms(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        response_status: str = None,
        room_id: str = None,
    ):
        self.display_name = display_name
        self.response_status = response_status
        self.room_id = room_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.response_status is not None:
            result['ResponseStatus'] = self.response_status
        if self.room_id is not None:
            result['RoomId'] = self.room_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('ResponseStatus') is not None:
            self.response_status = m.get('ResponseStatus')
        if m.get('RoomId') is not None:
            self.room_id = m.get('RoomId')
        return self


class ListEventsViewResponseBodyEventsOnlineMeetingInfo(TeaModel):
    def __init__(
        self,
        conference_id: str = None,
        extra_info: Dict[str, Any] = None,
        type: str = None,
        url: str = None,
    ):
        self.conference_id = conference_id
        self.extra_info = extra_info
        self.type = type
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conference_id is not None:
            result['ConferenceId'] = self.conference_id
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConferenceId') is not None:
            self.conference_id = m.get('ConferenceId')
        if m.get('ExtraInfo') is not None:
            self.extra_info = m.get('ExtraInfo')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ListEventsViewResponseBodyEventsOrganizer(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        id: str = None,
        response_status: str = None,
        self_: bool = None,
    ):
        self.display_name = display_name
        self.id = id
        self.response_status = response_status
        self.self_ = self_

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.id is not None:
            result['Id'] = self.id
        if self.response_status is not None:
            result['ResponseStatus'] = self.response_status
        if self.self_ is not None:
            result['Self'] = self.self_
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ResponseStatus') is not None:
            self.response_status = m.get('ResponseStatus')
        if m.get('Self') is not None:
            self.self_ = m.get('Self')
        return self


class ListEventsViewResponseBodyEventsOriginStart(TeaModel):
    def __init__(
        self,
        date_time: str = None,
    ):
        self.date_time = date_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        return self


class ListEventsViewResponseBodyEventsRecurrencePattern(TeaModel):
    def __init__(
        self,
        day_of_month: int = None,
        days_of_week: str = None,
        index: str = None,
        interval: int = None,
        type: str = None,
    ):
        self.day_of_month = day_of_month
        self.days_of_week = days_of_week
        self.index = index
        self.interval = interval
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.day_of_month is not None:
            result['DayOfMonth'] = self.day_of_month
        if self.days_of_week is not None:
            result['DaysOfWeek'] = self.days_of_week
        if self.index is not None:
            result['Index'] = self.index
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DayOfMonth') is not None:
            self.day_of_month = m.get('DayOfMonth')
        if m.get('DaysOfWeek') is not None:
            self.days_of_week = m.get('DaysOfWeek')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListEventsViewResponseBodyEventsRecurrenceRange(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        number_of_occurrences: int = None,
        type: str = None,
    ):
        self.end_date = end_date
        self.number_of_occurrences = number_of_occurrences
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.number_of_occurrences is not None:
            result['NumberOfOccurrences'] = self.number_of_occurrences
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('NumberOfOccurrences') is not None:
            self.number_of_occurrences = m.get('NumberOfOccurrences')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListEventsViewResponseBodyEventsRecurrence(TeaModel):
    def __init__(
        self,
        pattern: ListEventsViewResponseBodyEventsRecurrencePattern = None,
        range: ListEventsViewResponseBodyEventsRecurrenceRange = None,
    ):
        self.pattern = pattern
        self.range = range

    def validate(self):
        if self.pattern:
            self.pattern.validate()
        if self.range:
            self.range.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pattern is not None:
            result['Pattern'] = self.pattern.to_map()
        if self.range is not None:
            result['Range'] = self.range.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pattern') is not None:
            temp_model = ListEventsViewResponseBodyEventsRecurrencePattern()
            self.pattern = temp_model.from_map(m['Pattern'])
        if m.get('Range') is not None:
            temp_model = ListEventsViewResponseBodyEventsRecurrenceRange()
            self.range = temp_model.from_map(m['Range'])
        return self


class ListEventsViewResponseBodyEventsRichTextDescription(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class ListEventsViewResponseBodyEventsStart(TeaModel):
    def __init__(
        self,
        date: str = None,
        date_time: str = None,
        time_zone: str = None,
    ):
        self.date = date
        self.date_time = date_time
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['Date'] = self.date
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.time_zone is not None:
            result['TimeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Date') is not None:
            self.date = m.get('Date')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('TimeZone') is not None:
            self.time_zone = m.get('TimeZone')
        return self


class ListEventsViewResponseBodyEvents(TeaModel):
    def __init__(
        self,
        attendees: List[ListEventsViewResponseBodyEventsAttendees] = None,
        categories: List[ListEventsViewResponseBodyEventsCategories] = None,
        create_time: str = None,
        description: str = None,
        end: ListEventsViewResponseBodyEventsEnd = None,
        extended_properties: ListEventsViewResponseBodyEventsExtendedProperties = None,
        id: str = None,
        is_all_day: bool = None,
        location: ListEventsViewResponseBodyEventsLocation = None,
        meeting_rooms: List[ListEventsViewResponseBodyEventsMeetingRooms] = None,
        online_meeting_info: ListEventsViewResponseBodyEventsOnlineMeetingInfo = None,
        organizer: ListEventsViewResponseBodyEventsOrganizer = None,
        origin_start: ListEventsViewResponseBodyEventsOriginStart = None,
        recurrence: ListEventsViewResponseBodyEventsRecurrence = None,
        rich_text_description: ListEventsViewResponseBodyEventsRichTextDescription = None,
        series_master_id: str = None,
        start: ListEventsViewResponseBodyEventsStart = None,
        status: str = None,
        summary: str = None,
        update_time: str = None,
    ):
        self.attendees = attendees
        self.categories = categories
        self.create_time = create_time
        self.description = description
        self.end = end
        self.extended_properties = extended_properties
        self.id = id
        self.is_all_day = is_all_day
        self.location = location
        self.meeting_rooms = meeting_rooms
        self.online_meeting_info = online_meeting_info
        self.organizer = organizer
        self.origin_start = origin_start
        self.recurrence = recurrence
        self.rich_text_description = rich_text_description
        self.series_master_id = series_master_id
        self.start = start
        self.status = status
        self.summary = summary
        self.update_time = update_time

    def validate(self):
        if self.attendees:
            for k in self.attendees:
                if k:
                    k.validate()
        if self.categories:
            for k in self.categories:
                if k:
                    k.validate()
        if self.end:
            self.end.validate()
        if self.extended_properties:
            self.extended_properties.validate()
        if self.location:
            self.location.validate()
        if self.meeting_rooms:
            for k in self.meeting_rooms:
                if k:
                    k.validate()
        if self.online_meeting_info:
            self.online_meeting_info.validate()
        if self.organizer:
            self.organizer.validate()
        if self.origin_start:
            self.origin_start.validate()
        if self.recurrence:
            self.recurrence.validate()
        if self.rich_text_description:
            self.rich_text_description.validate()
        if self.start:
            self.start.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Attendees'] = []
        if self.attendees is not None:
            for k in self.attendees:
                result['Attendees'].append(k.to_map() if k else None)
        result['Categories'] = []
        if self.categories is not None:
            for k in self.categories:
                result['Categories'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.end is not None:
            result['End'] = self.end.to_map()
        if self.extended_properties is not None:
            result['ExtendedProperties'] = self.extended_properties.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.is_all_day is not None:
            result['IsAllDay'] = self.is_all_day
        if self.location is not None:
            result['Location'] = self.location.to_map()
        result['MeetingRooms'] = []
        if self.meeting_rooms is not None:
            for k in self.meeting_rooms:
                result['MeetingRooms'].append(k.to_map() if k else None)
        if self.online_meeting_info is not None:
            result['OnlineMeetingInfo'] = self.online_meeting_info.to_map()
        if self.organizer is not None:
            result['Organizer'] = self.organizer.to_map()
        if self.origin_start is not None:
            result['OriginStart'] = self.origin_start.to_map()
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence.to_map()
        if self.rich_text_description is not None:
            result['RichTextDescription'] = self.rich_text_description.to_map()
        if self.series_master_id is not None:
            result['SeriesMasterId'] = self.series_master_id
        if self.start is not None:
            result['Start'] = self.start.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attendees = []
        if m.get('Attendees') is not None:
            for k in m.get('Attendees'):
                temp_model = ListEventsViewResponseBodyEventsAttendees()
                self.attendees.append(temp_model.from_map(k))
        self.categories = []
        if m.get('Categories') is not None:
            for k in m.get('Categories'):
                temp_model = ListEventsViewResponseBodyEventsCategories()
                self.categories.append(temp_model.from_map(k))
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('End') is not None:
            temp_model = ListEventsViewResponseBodyEventsEnd()
            self.end = temp_model.from_map(m['End'])
        if m.get('ExtendedProperties') is not None:
            temp_model = ListEventsViewResponseBodyEventsExtendedProperties()
            self.extended_properties = temp_model.from_map(m['ExtendedProperties'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsAllDay') is not None:
            self.is_all_day = m.get('IsAllDay')
        if m.get('Location') is not None:
            temp_model = ListEventsViewResponseBodyEventsLocation()
            self.location = temp_model.from_map(m['Location'])
        self.meeting_rooms = []
        if m.get('MeetingRooms') is not None:
            for k in m.get('MeetingRooms'):
                temp_model = ListEventsViewResponseBodyEventsMeetingRooms()
                self.meeting_rooms.append(temp_model.from_map(k))
        if m.get('OnlineMeetingInfo') is not None:
            temp_model = ListEventsViewResponseBodyEventsOnlineMeetingInfo()
            self.online_meeting_info = temp_model.from_map(m['OnlineMeetingInfo'])
        if m.get('Organizer') is not None:
            temp_model = ListEventsViewResponseBodyEventsOrganizer()
            self.organizer = temp_model.from_map(m['Organizer'])
        if m.get('OriginStart') is not None:
            temp_model = ListEventsViewResponseBodyEventsOriginStart()
            self.origin_start = temp_model.from_map(m['OriginStart'])
        if m.get('Recurrence') is not None:
            temp_model = ListEventsViewResponseBodyEventsRecurrence()
            self.recurrence = temp_model.from_map(m['Recurrence'])
        if m.get('RichTextDescription') is not None:
            temp_model = ListEventsViewResponseBodyEventsRichTextDescription()
            self.rich_text_description = temp_model.from_map(m['RichTextDescription'])
        if m.get('SeriesMasterId') is not None:
            self.series_master_id = m.get('SeriesMasterId')
        if m.get('Start') is not None:
            temp_model = ListEventsViewResponseBodyEventsStart()
            self.start = temp_model.from_map(m['Start'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class ListEventsViewResponseBody(TeaModel):
    def __init__(
        self,
        events: List[ListEventsViewResponseBodyEvents] = None,
        next_token: str = None,
        request_id: str = None,
    ):
        self.events = events
        self.next_token = next_token
        # requestId
        self.request_id = request_id

    def validate(self):
        if self.events:
            for k in self.events:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['events'] = []
        if self.events is not None:
            for k in self.events:
                result['events'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.events = []
        if m.get('events') is not None:
            for k in m.get('events'):
                temp_model = ListEventsViewResponseBodyEvents()
                self.events.append(temp_model.from_map(k))
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListEventsViewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEventsViewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEventsViewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListFormRemarksHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ListFormRemarksHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ListFormRemarksHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ListFormRemarksHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ListFormRemarksShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ListFormRemarksRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        form_instance_id_list: List[str] = None,
        form_uuid: str = None,
        system_token: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        # This parameter is required.
        self.form_instance_id_list = form_instance_id_list
        # This parameter is required.
        self.form_uuid = form_uuid
        # This parameter is required.
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.form_instance_id_list is not None:
            result['FormInstanceIdList'] = self.form_instance_id_list
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('FormInstanceIdList') is not None:
            self.form_instance_id_list = m.get('FormInstanceIdList')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class ListFormRemarksShrinkRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        form_instance_id_list_shrink: str = None,
        form_uuid: str = None,
        system_token: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        # This parameter is required.
        self.form_instance_id_list_shrink = form_instance_id_list_shrink
        # This parameter is required.
        self.form_uuid = form_uuid
        # This parameter is required.
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.form_instance_id_list_shrink is not None:
            result['FormInstanceIdList'] = self.form_instance_id_list_shrink
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('FormInstanceIdList') is not None:
            self.form_instance_id_list_shrink = m.get('FormInstanceIdList')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class ListFormRemarksResponseBody(TeaModel):
    def __init__(
        self,
        form_remark_vo_map: Dict[str, Any] = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.form_remark_vo_map = form_remark_vo_map
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.form_remark_vo_map is not None:
            result['formRemarkVoMap'] = self.form_remark_vo_map
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('formRemarkVoMap') is not None:
            self.form_remark_vo_map = m.get('formRemarkVoMap')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class ListFormRemarksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListFormRemarksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListFormRemarksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMessageHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_id: str = None,
    ):
        self.common_headers = common_headers
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ListMessageRequest(TeaModel):
    def __init__(
        self,
        assistant_id: str = None,
        limit: int = None,
        order: str = None,
        original_assistant_id: str = None,
        run_id: str = None,
        source_id_of_original_assistant_id: str = None,
        source_type_of_original_assistant_id: str = None,
        thread_id: str = None,
    ):
        # This parameter is required.
        self.assistant_id = assistant_id
        self.limit = limit
        self.order = order
        self.original_assistant_id = original_assistant_id
        self.run_id = run_id
        self.source_id_of_original_assistant_id = source_id_of_original_assistant_id
        self.source_type_of_original_assistant_id = source_type_of_original_assistant_id
        # This parameter is required.
        self.thread_id = thread_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assistant_id is not None:
            result['assistantId'] = self.assistant_id
        if self.limit is not None:
            result['limit'] = self.limit
        if self.order is not None:
            result['order'] = self.order
        if self.original_assistant_id is not None:
            result['originalAssistantId'] = self.original_assistant_id
        if self.run_id is not None:
            result['runId'] = self.run_id
        if self.source_id_of_original_assistant_id is not None:
            result['sourceIdOfOriginalAssistantId'] = self.source_id_of_original_assistant_id
        if self.source_type_of_original_assistant_id is not None:
            result['sourceTypeOfOriginalAssistantId'] = self.source_type_of_original_assistant_id
        if self.thread_id is not None:
            result['threadId'] = self.thread_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assistantId') is not None:
            self.assistant_id = m.get('assistantId')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('order') is not None:
            self.order = m.get('order')
        if m.get('originalAssistantId') is not None:
            self.original_assistant_id = m.get('originalAssistantId')
        if m.get('runId') is not None:
            self.run_id = m.get('runId')
        if m.get('sourceIdOfOriginalAssistantId') is not None:
            self.source_id_of_original_assistant_id = m.get('sourceIdOfOriginalAssistantId')
        if m.get('sourceTypeOfOriginalAssistantId') is not None:
            self.source_type_of_original_assistant_id = m.get('sourceTypeOfOriginalAssistantId')
        if m.get('threadId') is not None:
            self.thread_id = m.get('threadId')
        return self


class ListMessageResponseBodyMessagesContentCardCallback(TeaModel):
    def __init__(
        self,
        content: str = None,
        related_message_id: str = None,
    ):
        self.content = content
        self.related_message_id = related_message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.related_message_id is not None:
            result['relatedMessageId'] = self.related_message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('relatedMessageId') is not None:
            self.related_message_id = m.get('relatedMessageId')
        return self


class ListMessageResponseBodyMessagesContentDingCard(TeaModel):
    def __init__(
        self,
        content: str = None,
        content_type: str = None,
        finished: bool = None,
        template_id: str = None,
    ):
        self.content = content
        # This parameter is required.
        self.content_type = content_type
        self.finished = finished
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.content_type is not None:
            result['contentType'] = self.content_type
        if self.finished is not None:
            result['finished'] = self.finished
        if self.template_id is not None:
            result['templateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('contentType') is not None:
            self.content_type = m.get('contentType')
        if m.get('finished') is not None:
            self.finished = m.get('finished')
        if m.get('templateId') is not None:
            self.template_id = m.get('templateId')
        return self


class ListMessageResponseBodyMessagesContentDingNormalCardCardData(TeaModel):
    def __init__(
        self,
        card_param_map: Dict[str, Any] = None,
    ):
        self.card_param_map = card_param_map

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_param_map is not None:
            result['cardParamMap'] = self.card_param_map
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardParamMap') is not None:
            self.card_param_map = m.get('cardParamMap')
        return self


class ListMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions(TeaModel):
    def __init__(
        self,
        update_card_data_by_key: bool = None,
        update_private_data_by_key: bool = None,
    ):
        self.update_card_data_by_key = update_card_data_by_key
        self.update_private_data_by_key = update_private_data_by_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.update_card_data_by_key is not None:
            result['updateCardDataByKey'] = self.update_card_data_by_key
        if self.update_private_data_by_key is not None:
            result['updatePrivateDataByKey'] = self.update_private_data_by_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('updateCardDataByKey') is not None:
            self.update_card_data_by_key = m.get('updateCardDataByKey')
        if m.get('updatePrivateDataByKey') is not None:
            self.update_private_data_by_key = m.get('updatePrivateDataByKey')
        return self


class ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig(TeaModel):
    def __init__(
        self,
        interval: int = None,
        pull_strategy: str = None,
        time_unit: str = None,
    ):
        self.interval = interval
        self.pull_strategy = pull_strategy
        self.time_unit = time_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interval is not None:
            result['interval'] = self.interval
        if self.pull_strategy is not None:
            result['pullStrategy'] = self.pull_strategy
        if self.time_unit is not None:
            result['timeUnit'] = self.time_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('pullStrategy') is not None:
            self.pull_strategy = m.get('pullStrategy')
        if m.get('timeUnit') is not None:
            self.time_unit = m.get('timeUnit')
        return self


class ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs(TeaModel):
    def __init__(
        self,
        const_params: Dict[str, Any] = None,
        dynamic_data_source_id: str = None,
        pull_config: ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig = None,
    ):
        self.const_params = const_params
        self.dynamic_data_source_id = dynamic_data_source_id
        self.pull_config = pull_config

    def validate(self):
        if self.pull_config:
            self.pull_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.const_params is not None:
            result['constParams'] = self.const_params
        if self.dynamic_data_source_id is not None:
            result['dynamicDataSourceId'] = self.dynamic_data_source_id
        if self.pull_config is not None:
            result['pullConfig'] = self.pull_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('constParams') is not None:
            self.const_params = m.get('constParams')
        if m.get('dynamicDataSourceId') is not None:
            self.dynamic_data_source_id = m.get('dynamicDataSourceId')
        if m.get('pullConfig') is not None:
            temp_model = ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig()
            self.pull_config = temp_model.from_map(m['pullConfig'])
        return self


class ListMessageResponseBodyMessagesContentDingNormalCard(TeaModel):
    def __init__(
        self,
        card_data: ListMessageResponseBodyMessagesContentDingNormalCardCardData = None,
        card_template_id: str = None,
        card_update_options: ListMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions = None,
        dynamic_data_source_configs: List[ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs] = None,
        private_data: Dict[str, dict] = None,
    ):
        self.card_data = card_data
        self.card_template_id = card_template_id
        self.card_update_options = card_update_options
        self.dynamic_data_source_configs = dynamic_data_source_configs
        self.private_data = private_data

    def validate(self):
        if self.card_data:
            self.card_data.validate()
        if self.card_update_options:
            self.card_update_options.validate()
        if self.dynamic_data_source_configs:
            for k in self.dynamic_data_source_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_data is not None:
            result['cardData'] = self.card_data.to_map()
        if self.card_template_id is not None:
            result['cardTemplateId'] = self.card_template_id
        if self.card_update_options is not None:
            result['cardUpdateOptions'] = self.card_update_options.to_map()
        result['dynamicDataSourceConfigs'] = []
        if self.dynamic_data_source_configs is not None:
            for k in self.dynamic_data_source_configs:
                result['dynamicDataSourceConfigs'].append(k.to_map() if k else None)
        if self.private_data is not None:
            result['privateData'] = self.private_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardData') is not None:
            temp_model = ListMessageResponseBodyMessagesContentDingNormalCardCardData()
            self.card_data = temp_model.from_map(m['cardData'])
        if m.get('cardTemplateId') is not None:
            self.card_template_id = m.get('cardTemplateId')
        if m.get('cardUpdateOptions') is not None:
            temp_model = ListMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions()
            self.card_update_options = temp_model.from_map(m['cardUpdateOptions'])
        self.dynamic_data_source_configs = []
        if m.get('dynamicDataSourceConfigs') is not None:
            for k in m.get('dynamicDataSourceConfigs'):
                temp_model = ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs()
                self.dynamic_data_source_configs.append(temp_model.from_map(k))
        if m.get('privateData') is not None:
            self.private_data = m.get('privateData')
        return self


class ListMessageResponseBodyMessagesContentMarkdown(TeaModel):
    def __init__(
        self,
        value: str = None,
    ):
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListMessageResponseBodyMessagesContentStructViewPartsDataPart(TeaModel):
    def __init__(
        self,
        data: Any = None,
    ):
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class ListMessageResponseBodyMessagesContentStructViewPartsReasonPart(TeaModel):
    def __init__(
        self,
        reason: str = None,
    ):
        self.reason = reason

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reason is not None:
            result['reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        return self


class ListMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends(TeaModel):
    def __init__(
        self,
        mobile_url: str = None,
        text: str = None,
        url: str = None,
    ):
        self.mobile_url = mobile_url
        self.text = text
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mobile_url is not None:
            result['mobileUrl'] = self.mobile_url
        if self.text is not None:
            result['text'] = self.text
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('mobileUrl') is not None:
            self.mobile_url = m.get('mobileUrl')
        if m.get('text') is not None:
            self.text = m.get('text')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class ListMessageResponseBodyMessagesContentStructViewPartsRecommendPart(TeaModel):
    def __init__(
        self,
        recommends: List[ListMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends] = None,
    ):
        self.recommends = recommends

    def validate(self):
        if self.recommends:
            for k in self.recommends:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['recommends'] = []
        if self.recommends is not None:
            for k in self.recommends:
                result['recommends'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.recommends = []
        if m.get('recommends') is not None:
            for k in m.get('recommends'):
                temp_model = ListMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends()
                self.recommends.append(temp_model.from_map(k))
        return self


class ListMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences(TeaModel):
    def __init__(
        self,
        index: str = None,
        name: str = None,
        source_code: str = None,
        source_icon: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.index = index
        self.name = name
        self.source_code = source_code
        self.source_icon = source_icon
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['index'] = self.index
        if self.name is not None:
            result['name'] = self.name
        if self.source_code is not None:
            result['sourceCode'] = self.source_code
        if self.source_icon is not None:
            result['sourceIcon'] = self.source_icon
        if self.summary is not None:
            result['summary'] = self.summary
        if self.title is not None:
            result['title'] = self.title
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('sourceCode') is not None:
            self.source_code = m.get('sourceCode')
        if m.get('sourceIcon') is not None:
            self.source_icon = m.get('sourceIcon')
        if m.get('summary') is not None:
            self.summary = m.get('summary')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class ListMessageResponseBodyMessagesContentStructViewPartsReferencePart(TeaModel):
    def __init__(
        self,
        references: List[ListMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences] = None,
    ):
        self.references = references

    def validate(self):
        if self.references:
            for k in self.references:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['references'] = []
        if self.references is not None:
            for k in self.references:
                result['references'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.references = []
        if m.get('references') is not None:
            for k in m.get('references'):
                temp_model = ListMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences()
                self.references.append(temp_model.from_map(k))
        return self


class ListMessageResponseBodyMessagesContentStructViewPartsTextPart(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('text') is not None:
            self.text = m.get('text')
        return self


class ListMessageResponseBodyMessagesContentStructViewParts(TeaModel):
    def __init__(
        self,
        append: bool = None,
        data_part: ListMessageResponseBodyMessagesContentStructViewPartsDataPart = None,
        finish: bool = None,
        part_desc: str = None,
        part_id: str = None,
        reason_part: ListMessageResponseBodyMessagesContentStructViewPartsReasonPart = None,
        recommend_part: ListMessageResponseBodyMessagesContentStructViewPartsRecommendPart = None,
        reference_part: ListMessageResponseBodyMessagesContentStructViewPartsReferencePart = None,
        text_part: ListMessageResponseBodyMessagesContentStructViewPartsTextPart = None,
        type: str = None,
    ):
        self.append = append
        self.data_part = data_part
        self.finish = finish
        self.part_desc = part_desc
        self.part_id = part_id
        self.reason_part = reason_part
        self.recommend_part = recommend_part
        self.reference_part = reference_part
        self.text_part = text_part
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.data_part:
            self.data_part.validate()
        if self.reason_part:
            self.reason_part.validate()
        if self.recommend_part:
            self.recommend_part.validate()
        if self.reference_part:
            self.reference_part.validate()
        if self.text_part:
            self.text_part.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.append is not None:
            result['append'] = self.append
        if self.data_part is not None:
            result['dataPart'] = self.data_part.to_map()
        if self.finish is not None:
            result['finish'] = self.finish
        if self.part_desc is not None:
            result['partDesc'] = self.part_desc
        if self.part_id is not None:
            result['partId'] = self.part_id
        if self.reason_part is not None:
            result['reasonPart'] = self.reason_part.to_map()
        if self.recommend_part is not None:
            result['recommendPart'] = self.recommend_part.to_map()
        if self.reference_part is not None:
            result['referencePart'] = self.reference_part.to_map()
        if self.text_part is not None:
            result['textPart'] = self.text_part.to_map()
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('append') is not None:
            self.append = m.get('append')
        if m.get('dataPart') is not None:
            temp_model = ListMessageResponseBodyMessagesContentStructViewPartsDataPart()
            self.data_part = temp_model.from_map(m['dataPart'])
        if m.get('finish') is not None:
            self.finish = m.get('finish')
        if m.get('partDesc') is not None:
            self.part_desc = m.get('partDesc')
        if m.get('partId') is not None:
            self.part_id = m.get('partId')
        if m.get('reasonPart') is not None:
            temp_model = ListMessageResponseBodyMessagesContentStructViewPartsReasonPart()
            self.reason_part = temp_model.from_map(m['reasonPart'])
        if m.get('recommendPart') is not None:
            temp_model = ListMessageResponseBodyMessagesContentStructViewPartsRecommendPart()
            self.recommend_part = temp_model.from_map(m['recommendPart'])
        if m.get('referencePart') is not None:
            temp_model = ListMessageResponseBodyMessagesContentStructViewPartsReferencePart()
            self.reference_part = temp_model.from_map(m['referencePart'])
        if m.get('textPart') is not None:
            temp_model = ListMessageResponseBodyMessagesContentStructViewPartsTextPart()
            self.text_part = temp_model.from_map(m['textPart'])
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListMessageResponseBodyMessagesContentStructView(TeaModel):
    def __init__(
        self,
        parts: List[ListMessageResponseBodyMessagesContentStructViewParts] = None,
    ):
        self.parts = parts

    def validate(self):
        if self.parts:
            for k in self.parts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['parts'] = []
        if self.parts is not None:
            for k in self.parts:
                result['parts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.parts = []
        if m.get('parts') is not None:
            for k in m.get('parts'):
                temp_model = ListMessageResponseBodyMessagesContentStructViewParts()
                self.parts.append(temp_model.from_map(k))
        return self


class ListMessageResponseBodyMessagesContentText(TeaModel):
    def __init__(
        self,
        value: str = None,
    ):
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListMessageResponseBodyMessagesContent(TeaModel):
    def __init__(
        self,
        card_callback: ListMessageResponseBodyMessagesContentCardCallback = None,
        ding_card: ListMessageResponseBodyMessagesContentDingCard = None,
        ding_normal_card: ListMessageResponseBodyMessagesContentDingNormalCard = None,
        markdown: ListMessageResponseBodyMessagesContentMarkdown = None,
        struct_view: ListMessageResponseBodyMessagesContentStructView = None,
        text: ListMessageResponseBodyMessagesContentText = None,
        type: str = None,
    ):
        self.card_callback = card_callback
        self.ding_card = ding_card
        self.ding_normal_card = ding_normal_card
        self.markdown = markdown
        self.struct_view = struct_view
        self.text = text
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.card_callback:
            self.card_callback.validate()
        if self.ding_card:
            self.ding_card.validate()
        if self.ding_normal_card:
            self.ding_normal_card.validate()
        if self.markdown:
            self.markdown.validate()
        if self.struct_view:
            self.struct_view.validate()
        if self.text:
            self.text.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_callback is not None:
            result['cardCallback'] = self.card_callback.to_map()
        if self.ding_card is not None:
            result['dingCard'] = self.ding_card.to_map()
        if self.ding_normal_card is not None:
            result['dingNormalCard'] = self.ding_normal_card.to_map()
        if self.markdown is not None:
            result['markdown'] = self.markdown.to_map()
        if self.struct_view is not None:
            result['structView'] = self.struct_view.to_map()
        if self.text is not None:
            result['text'] = self.text.to_map()
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cardCallback') is not None:
            temp_model = ListMessageResponseBodyMessagesContentCardCallback()
            self.card_callback = temp_model.from_map(m['cardCallback'])
        if m.get('dingCard') is not None:
            temp_model = ListMessageResponseBodyMessagesContentDingCard()
            self.ding_card = temp_model.from_map(m['dingCard'])
        if m.get('dingNormalCard') is not None:
            temp_model = ListMessageResponseBodyMessagesContentDingNormalCard()
            self.ding_normal_card = temp_model.from_map(m['dingNormalCard'])
        if m.get('markdown') is not None:
            temp_model = ListMessageResponseBodyMessagesContentMarkdown()
            self.markdown = temp_model.from_map(m['markdown'])
        if m.get('structView') is not None:
            temp_model = ListMessageResponseBodyMessagesContentStructView()
            self.struct_view = temp_model.from_map(m['structView'])
        if m.get('text') is not None:
            temp_model = ListMessageResponseBodyMessagesContentText()
            self.text = temp_model.from_map(m['text'])
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListMessageResponseBodyMessages(TeaModel):
    def __init__(
        self,
        content: ListMessageResponseBodyMessagesContent = None,
        content_desc: str = None,
        create_at: int = None,
        id: str = None,
        role: str = None,
        run_id: str = None,
        thread_id: str = None,
    ):
        self.content = content
        self.content_desc = content_desc
        self.create_at = create_at
        self.id = id
        self.role = role
        self.run_id = run_id
        self.thread_id = thread_id

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content.to_map()
        if self.content_desc is not None:
            result['contentDesc'] = self.content_desc
        if self.create_at is not None:
            result['createAt'] = self.create_at
        if self.id is not None:
            result['id'] = self.id
        if self.role is not None:
            result['role'] = self.role
        if self.run_id is not None:
            result['runId'] = self.run_id
        if self.thread_id is not None:
            result['threadId'] = self.thread_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            temp_model = ListMessageResponseBodyMessagesContent()
            self.content = temp_model.from_map(m['content'])
        if m.get('contentDesc') is not None:
            self.content_desc = m.get('contentDesc')
        if m.get('createAt') is not None:
            self.create_at = m.get('createAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('role') is not None:
            self.role = m.get('role')
        if m.get('runId') is not None:
            self.run_id = m.get('runId')
        if m.get('threadId') is not None:
            self.thread_id = m.get('threadId')
        return self


class ListMessageResponseBody(TeaModel):
    def __init__(
        self,
        messages: List[ListMessageResponseBodyMessages] = None,
        request_id: str = None,
    ):
        self.messages = messages
        self.request_id = request_id

    def validate(self):
        if self.messages:
            for k in self.messages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['messages'] = []
        if self.messages is not None:
            for k in self.messages:
                result['messages'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.messages = []
        if m.get('messages') is not None:
            for k in m.get('messages'):
                temp_model = ListMessageResponseBodyMessages()
                self.messages.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListMessageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMessageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMessageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMultiDimTableRecordsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ListMultiDimTableRecordsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ListMultiDimTableRecordsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ListMultiDimTableRecordsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ListMultiDimTableRecordsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ListMultiDimTableRecordsRequestFilterConditions(TeaModel):
    def __init__(
        self,
        field: str = None,
        operator: str = None,
        value: List[Any] = None,
    ):
        self.field = field
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field is not None:
            result['Field'] = self.field
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Field') is not None:
            self.field = m.get('Field')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListMultiDimTableRecordsRequestFilter(TeaModel):
    def __init__(
        self,
        combination: str = None,
        conditions: List[ListMultiDimTableRecordsRequestFilterConditions] = None,
    ):
        self.combination = combination
        self.conditions = conditions

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.combination is not None:
            result['Combination'] = self.combination
        result['Conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['Conditions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Combination') is not None:
            self.combination = m.get('Combination')
        self.conditions = []
        if m.get('Conditions') is not None:
            for k in m.get('Conditions'):
                temp_model = ListMultiDimTableRecordsRequestFilterConditions()
                self.conditions.append(temp_model.from_map(k))
        return self


class ListMultiDimTableRecordsRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class ListMultiDimTableRecordsRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        filter: ListMultiDimTableRecordsRequestFilter = None,
        max_results: int = None,
        next_token: str = None,
        sheet_id_or_name: str = None,
        tenant_context: ListMultiDimTableRecordsRequestTenantContext = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        self.filter = filter
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context = tenant_context

    def validate(self):
        if self.filter:
            self.filter.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.filter is not None:
            result['Filter'] = self.filter.to_map()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('Filter') is not None:
            temp_model = ListMultiDimTableRecordsRequestFilter()
            self.filter = temp_model.from_map(m['Filter'])
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            temp_model = ListMultiDimTableRecordsRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class ListMultiDimTableRecordsShrinkRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        filter_shrink: str = None,
        max_results: int = None,
        next_token: str = None,
        sheet_id_or_name: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        self.filter_shrink = filter_shrink
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.filter_shrink is not None:
            result['Filter'] = self.filter_shrink
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('Filter') is not None:
            self.filter_shrink = m.get('Filter')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class ListMultiDimTableRecordsResponseBodyRecordsCreatedBy(TeaModel):
    def __init__(
        self,
        user_id: str = None,
    ):
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListMultiDimTableRecordsResponseBodyRecordsLastModifiedBy(TeaModel):
    def __init__(
        self,
        user_id: str = None,
    ):
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListMultiDimTableRecordsResponseBodyRecords(TeaModel):
    def __init__(
        self,
        created_by: ListMultiDimTableRecordsResponseBodyRecordsCreatedBy = None,
        created_time: int = None,
        fields: Dict[str, Any] = None,
        id: str = None,
        last_modified_by: ListMultiDimTableRecordsResponseBodyRecordsLastModifiedBy = None,
        last_modified_time: int = None,
    ):
        self.created_by = created_by
        self.created_time = created_time
        self.fields = fields
        self.id = id
        self.last_modified_by = last_modified_by
        self.last_modified_time = last_modified_time

    def validate(self):
        if self.created_by:
            self.created_by.validate()
        if self.last_modified_by:
            self.last_modified_by.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_by is not None:
            result['CreatedBy'] = self.created_by.to_map()
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.fields is not None:
            result['Fields'] = self.fields
        if self.id is not None:
            result['Id'] = self.id
        if self.last_modified_by is not None:
            result['LastModifiedBy'] = self.last_modified_by.to_map()
        if self.last_modified_time is not None:
            result['LastModifiedTime'] = self.last_modified_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatedBy') is not None:
            temp_model = ListMultiDimTableRecordsResponseBodyRecordsCreatedBy()
            self.created_by = temp_model.from_map(m['CreatedBy'])
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Fields') is not None:
            self.fields = m.get('Fields')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LastModifiedBy') is not None:
            temp_model = ListMultiDimTableRecordsResponseBodyRecordsLastModifiedBy()
            self.last_modified_by = temp_model.from_map(m['LastModifiedBy'])
        if m.get('LastModifiedTime') is not None:
            self.last_modified_time = m.get('LastModifiedTime')
        return self


class ListMultiDimTableRecordsResponseBody(TeaModel):
    def __init__(
        self,
        has_more: bool = None,
        next_token: str = None,
        records: List[ListMultiDimTableRecordsResponseBodyRecords] = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.has_more = has_more
        self.next_token = next_token
        self.records = records
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.records:
            for k in self.records:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_more is not None:
            result['hasMore'] = self.has_more
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['records'] = []
        if self.records is not None:
            for k in self.records:
                result['records'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('hasMore') is not None:
            self.has_more = m.get('hasMore')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.records = []
        if m.get('records') is not None:
            for k in m.get('records'):
                temp_model = ListMultiDimTableRecordsResponseBodyRecords()
                self.records.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class ListMultiDimTableRecordsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMultiDimTableRecordsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMultiDimTableRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListNavigationByFormTypeHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ListNavigationByFormTypeHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ListNavigationByFormTypeHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ListNavigationByFormTypeHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ListNavigationByFormTypeShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ListNavigationByFormTypeRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        form_type: str = None,
        language: str = None,
        system_token: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        # This parameter is required.
        self.form_type = form_type
        self.language = language
        # This parameter is required.
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.form_type is not None:
            result['FormType'] = self.form_type
        if self.language is not None:
            result['Language'] = self.language
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('FormType') is not None:
            self.form_type = m.get('FormType')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class ListNavigationByFormTypeResponseBodyResultTitle(TeaModel):
    def __init__(
        self,
        name_in_chinese: str = None,
        name_in_english: str = None,
        type: str = None,
    ):
        self.name_in_chinese = name_in_chinese
        self.name_in_english = name_in_english
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_in_chinese is not None:
            result['NameInChinese'] = self.name_in_chinese
        if self.name_in_english is not None:
            result['NameInEnglish'] = self.name_in_english
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameInChinese') is not None:
            self.name_in_chinese = m.get('NameInChinese')
        if m.get('NameInEnglish') is not None:
            self.name_in_english = m.get('NameInEnglish')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListNavigationByFormTypeResponseBodyResult(TeaModel):
    def __init__(
        self,
        form_uuid: str = None,
        process_code: str = None,
        title: ListNavigationByFormTypeResponseBodyResultTitle = None,
    ):
        self.form_uuid = form_uuid
        self.process_code = process_code
        self.title = title

    def validate(self):
        if self.title:
            self.title.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.process_code is not None:
            result['ProcessCode'] = self.process_code
        if self.title is not None:
            result['Title'] = self.title.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('ProcessCode') is not None:
            self.process_code = m.get('ProcessCode')
        if m.get('Title') is not None:
            temp_model = ListNavigationByFormTypeResponseBodyResultTitle()
            self.title = temp_model.from_map(m['Title'])
        return self


class ListNavigationByFormTypeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: List[ListNavigationByFormTypeResponseBodyResult] = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.result = result
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListNavigationByFormTypeResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class ListNavigationByFormTypeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListNavigationByFormTypeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListNavigationByFormTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListNodesHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ListNodesHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ListNodesHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ListNodesHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ListNodesShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ListNodesRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class ListNodesRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        parent_node_id: str = None,
        tenant_context: ListNodesRequestTenantContext = None,
        with_permission_role: bool = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.parent_node_id = parent_node_id
        self.tenant_context = tenant_context
        self.with_permission_role = with_permission_role

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.parent_node_id is not None:
            result['ParentNodeId'] = self.parent_node_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.with_permission_role is not None:
            result['WithPermissionRole'] = self.with_permission_role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('ParentNodeId') is not None:
            self.parent_node_id = m.get('ParentNodeId')
        if m.get('TenantContext') is not None:
            temp_model = ListNodesRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WithPermissionRole') is not None:
            self.with_permission_role = m.get('WithPermissionRole')
        return self


class ListNodesShrinkRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        parent_node_id: str = None,
        tenant_context_shrink: str = None,
        with_permission_role: bool = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.parent_node_id = parent_node_id
        self.tenant_context_shrink = tenant_context_shrink
        self.with_permission_role = with_permission_role

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.parent_node_id is not None:
            result['ParentNodeId'] = self.parent_node_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.with_permission_role is not None:
            result['WithPermissionRole'] = self.with_permission_role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('ParentNodeId') is not None:
            self.parent_node_id = m.get('ParentNodeId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WithPermissionRole') is not None:
            self.with_permission_role = m.get('WithPermissionRole')
        return self


class ListNodesResponseBodyNodesStatisticalInfo(TeaModel):
    def __init__(
        self,
        word_count: int = None,
    ):
        self.word_count = word_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.word_count is not None:
            result['WordCount'] = self.word_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WordCount') is not None:
            self.word_count = m.get('WordCount')
        return self


class ListNodesResponseBodyNodes(TeaModel):
    def __init__(
        self,
        category: str = None,
        create_time: str = None,
        creator_id: str = None,
        extension: str = None,
        has_children: bool = None,
        modified_time: str = None,
        modifier_id: str = None,
        name: str = None,
        node_id: str = None,
        permission_role: str = None,
        size: int = None,
        statistical_info: ListNodesResponseBodyNodesStatisticalInfo = None,
        type: str = None,
        url: str = None,
        workspace_id: str = None,
    ):
        self.category = category
        self.create_time = create_time
        self.creator_id = creator_id
        self.extension = extension
        self.has_children = has_children
        self.modified_time = modified_time
        self.modifier_id = modifier_id
        self.name = name
        self.node_id = node_id
        self.permission_role = permission_role
        self.size = size
        self.statistical_info = statistical_info
        self.type = type
        self.url = url
        self.workspace_id = workspace_id

    def validate(self):
        if self.statistical_info:
            self.statistical_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.has_children is not None:
            result['HasChildren'] = self.has_children
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.name is not None:
            result['Name'] = self.name
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.permission_role is not None:
            result['PermissionRole'] = self.permission_role
        if self.size is not None:
            result['Size'] = self.size
        if self.statistical_info is not None:
            result['StatisticalInfo'] = self.statistical_info.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('HasChildren') is not None:
            self.has_children = m.get('HasChildren')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('PermissionRole') is not None:
            self.permission_role = m.get('PermissionRole')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StatisticalInfo') is not None:
            temp_model = ListNodesResponseBodyNodesStatisticalInfo()
            self.statistical_info = temp_model.from_map(m['StatisticalInfo'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListNodesResponseBody(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        nodes: List[ListNodesResponseBodyNodes] = None,
        request_id: str = None,
    ):
        self.next_token = next_token
        self.nodes = nodes
        # requestId
        self.request_id = request_id

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['nodes'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.nodes = []
        if m.get('nodes') is not None:
            for k in m.get('nodes'):
                temp_model = ListNodesResponseBodyNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListNodesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListNodesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListNodesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPermissionsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ListPermissionsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ListPermissionsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ListPermissionsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ListPermissionsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ListPermissionsRequestOption(TeaModel):
    def __init__(
        self,
        filter_role_ids: List[str] = None,
        max_results: int = None,
        next_token: str = None,
    ):
        self.filter_role_ids = filter_role_ids
        self.max_results = max_results
        self.next_token = next_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter_role_ids is not None:
            result['FilterRoleIds'] = self.filter_role_ids
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FilterRoleIds') is not None:
            self.filter_role_ids = m.get('FilterRoleIds')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        return self


class ListPermissionsRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class ListPermissionsRequest(TeaModel):
    def __init__(
        self,
        dentry_uuid: str = None,
        option: ListPermissionsRequestOption = None,
        tenant_context: ListPermissionsRequestTenantContext = None,
    ):
        # This parameter is required.
        self.dentry_uuid = dentry_uuid
        self.option = option
        self.tenant_context = tenant_context

    def validate(self):
        if self.option:
            self.option.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        if self.option is not None:
            result['Option'] = self.option.to_map()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        if m.get('Option') is not None:
            temp_model = ListPermissionsRequestOption()
            self.option = temp_model.from_map(m['Option'])
        if m.get('TenantContext') is not None:
            temp_model = ListPermissionsRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class ListPermissionsShrinkRequest(TeaModel):
    def __init__(
        self,
        dentry_uuid: str = None,
        option_shrink: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.dentry_uuid = dentry_uuid
        self.option_shrink = option_shrink
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        if self.option_shrink is not None:
            result['Option'] = self.option_shrink
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        if m.get('Option') is not None:
            self.option_shrink = m.get('Option')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class ListPermissionsResponseBodyPermissionsMember(TeaModel):
    def __init__(
        self,
        corp_id: str = None,
        id: str = None,
        type: str = None,
    ):
        self.corp_id = corp_id
        self.id = id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.id is not None:
            result['Id'] = self.id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListPermissionsResponseBodyPermissionsRole(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
    ):
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListPermissionsResponseBodyPermissions(TeaModel):
    def __init__(
        self,
        dentry_uuid: str = None,
        member: ListPermissionsResponseBodyPermissionsMember = None,
        role: ListPermissionsResponseBodyPermissionsRole = None,
    ):
        self.dentry_uuid = dentry_uuid
        self.member = member
        self.role = role

    def validate(self):
        if self.member:
            self.member.validate()
        if self.role:
            self.role.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        if self.member is not None:
            result['Member'] = self.member.to_map()
        if self.role is not None:
            result['Role'] = self.role.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        if m.get('Member') is not None:
            temp_model = ListPermissionsResponseBodyPermissionsMember()
            self.member = temp_model.from_map(m['Member'])
        if m.get('Role') is not None:
            temp_model = ListPermissionsResponseBodyPermissionsRole()
            self.role = temp_model.from_map(m['Role'])
        return self


class ListPermissionsResponseBody(TeaModel):
    def __init__(
        self,
        duration: int = None,
        next_token: str = None,
        permissions: List[ListPermissionsResponseBodyPermissions] = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.duration = duration
        self.next_token = next_token
        self.permissions = permissions
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.permissions:
            for k in self.permissions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['duration'] = self.duration
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['permissions'] = []
        if self.permissions is not None:
            for k in self.permissions:
                result['permissions'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.permissions = []
        if m.get('permissions') is not None:
            for k in m.get('permissions'):
                temp_model = ListPermissionsResponseBodyPermissions()
                self.permissions.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class ListPermissionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPermissionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPermissionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListReportHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ListReportHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ListReportHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ListReportHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ListReportShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ListReportRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class ListReportRequest(TeaModel):
    def __init__(
        self,
        cursor: int = None,
        end_time: int = None,
        modified_end_time: int = None,
        modified_start_time: int = None,
        size: int = None,
        start_time: int = None,
        template_name: str = None,
        tenant_context: ListReportRequestTenantContext = None,
    ):
        # This parameter is required.
        self.cursor = cursor
        # This parameter is required.
        self.end_time = end_time
        self.modified_end_time = modified_end_time
        self.modified_start_time = modified_start_time
        # This parameter is required.
        self.size = size
        # This parameter is required.
        self.start_time = start_time
        self.template_name = template_name
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cursor is not None:
            result['Cursor'] = self.cursor
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.modified_end_time is not None:
            result['ModifiedEndTime'] = self.modified_end_time
        if self.modified_start_time is not None:
            result['ModifiedStartTime'] = self.modified_start_time
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cursor') is not None:
            self.cursor = m.get('Cursor')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ModifiedEndTime') is not None:
            self.modified_end_time = m.get('ModifiedEndTime')
        if m.get('ModifiedStartTime') is not None:
            self.modified_start_time = m.get('ModifiedStartTime')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('TenantContext') is not None:
            temp_model = ListReportRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class ListReportShrinkRequest(TeaModel):
    def __init__(
        self,
        cursor: int = None,
        end_time: int = None,
        modified_end_time: int = None,
        modified_start_time: int = None,
        size: int = None,
        start_time: int = None,
        template_name: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.cursor = cursor
        # This parameter is required.
        self.end_time = end_time
        self.modified_end_time = modified_end_time
        self.modified_start_time = modified_start_time
        # This parameter is required.
        self.size = size
        # This parameter is required.
        self.start_time = start_time
        self.template_name = template_name
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cursor is not None:
            result['Cursor'] = self.cursor
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.modified_end_time is not None:
            result['ModifiedEndTime'] = self.modified_end_time
        if self.modified_start_time is not None:
            result['ModifiedStartTime'] = self.modified_start_time
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cursor') is not None:
            self.cursor = m.get('Cursor')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ModifiedEndTime') is not None:
            self.modified_end_time = m.get('ModifiedEndTime')
        if m.get('ModifiedStartTime') is not None:
            self.modified_start_time = m.get('ModifiedStartTime')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class ListReportResponseBodyDataListContents(TeaModel):
    def __init__(
        self,
        key: str = None,
        sort: str = None,
        type: str = None,
        value: str = None,
    ):
        self.key = key
        self.sort = sort
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.sort is not None:
            result['Sort'] = self.sort
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Sort') is not None:
            self.sort = m.get('Sort')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListReportResponseBodyDataList(TeaModel):
    def __init__(
        self,
        contents: List[ListReportResponseBodyDataListContents] = None,
        create_time: int = None,
        creator_id: str = None,
        creator_name: str = None,
        dept_name: str = None,
        images: List[str] = None,
        latitude: str = None,
        longitude: str = None,
        modified_time: int = None,
        remark: str = None,
        report_id: str = None,
        template_name: str = None,
    ):
        self.contents = contents
        self.create_time = create_time
        self.creator_id = creator_id
        self.creator_name = creator_name
        self.dept_name = dept_name
        self.images = images
        self.latitude = latitude
        self.longitude = longitude
        self.modified_time = modified_time
        self.remark = remark
        self.report_id = report_id
        self.template_name = template_name

    def validate(self):
        if self.contents:
            for k in self.contents:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Contents'] = []
        if self.contents is not None:
            for k in self.contents:
                result['Contents'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_name is not None:
            result['CreatorName'] = self.creator_name
        if self.dept_name is not None:
            result['DeptName'] = self.dept_name
        if self.images is not None:
            result['Images'] = self.images
        if self.latitude is not None:
            result['Latitude'] = self.latitude
        if self.longitude is not None:
            result['Longitude'] = self.longitude
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.report_id is not None:
            result['ReportId'] = self.report_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.contents = []
        if m.get('Contents') is not None:
            for k in m.get('Contents'):
                temp_model = ListReportResponseBodyDataListContents()
                self.contents.append(temp_model.from_map(k))
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorName') is not None:
            self.creator_name = m.get('CreatorName')
        if m.get('DeptName') is not None:
            self.dept_name = m.get('DeptName')
        if m.get('Images') is not None:
            self.images = m.get('Images')
        if m.get('Latitude') is not None:
            self.latitude = m.get('Latitude')
        if m.get('Longitude') is not None:
            self.longitude = m.get('Longitude')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('ReportId') is not None:
            self.report_id = m.get('ReportId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        return self


class ListReportResponseBody(TeaModel):
    def __init__(
        self,
        data_list: List[ListReportResponseBodyDataList] = None,
        has_more: bool = None,
        next_cursor: int = None,
        request_id: str = None,
        size: int = None,
    ):
        self.data_list = data_list
        self.has_more = has_more
        self.next_cursor = next_cursor
        # requestId
        self.request_id = request_id
        self.size = size

    def validate(self):
        if self.data_list:
            for k in self.data_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['dataList'] = []
        if self.data_list is not None:
            for k in self.data_list:
                result['dataList'].append(k.to_map() if k else None)
        if self.has_more is not None:
            result['hasMore'] = self.has_more
        if self.next_cursor is not None:
            result['nextCursor'] = self.next_cursor
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.size is not None:
            result['size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_list = []
        if m.get('dataList') is not None:
            for k in m.get('dataList'):
                temp_model = ListReportResponseBodyDataList()
                self.data_list.append(temp_model.from_map(k))
        if m.get('hasMore') is not None:
            self.has_more = m.get('hasMore')
        if m.get('nextCursor') is not None:
            self.next_cursor = m.get('nextCursor')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('size') is not None:
            self.size = m.get('size')
        return self


class ListReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTableDataByFormInstanceIdTableIdHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ListTableDataByFormInstanceIdTableIdHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ListTableDataByFormInstanceIdTableIdHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ListTableDataByFormInstanceIdTableIdHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ListTableDataByFormInstanceIdTableIdShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ListTableDataByFormInstanceIdTableIdRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        form_instance_id: str = None,
        form_uuid: str = None,
        page_number: int = None,
        page_size: int = None,
        system_token: str = None,
        table_field_id: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        # This parameter is required.
        self.form_instance_id = form_instance_id
        # This parameter is required.
        self.form_uuid = form_uuid
        self.page_number = page_number
        self.page_size = page_size
        # This parameter is required.
        self.system_token = system_token
        # This parameter is required.
        self.table_field_id = table_field_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.form_instance_id is not None:
            result['FormInstanceId'] = self.form_instance_id
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        if self.table_field_id is not None:
            result['TableFieldId'] = self.table_field_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('FormInstanceId') is not None:
            self.form_instance_id = m.get('FormInstanceId')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        if m.get('TableFieldId') is not None:
            self.table_field_id = m.get('TableFieldId')
        return self


class ListTableDataByFormInstanceIdTableIdResponseBody(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
        page_number: int = None,
        request_id: str = None,
        total_count: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.data = data
        self.page_number = page_number
        self.request_id = request_id
        self.total_count = total_count
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class ListTableDataByFormInstanceIdTableIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTableDataByFormInstanceIdTableIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTableDataByFormInstanceIdTableIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTeamsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ListTeamsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ListTeamsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ListTeamsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ListTeamsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ListTeamsRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class ListTeamsRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        tenant_context: ListTeamsRequestTenantContext = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('TenantContext') is not None:
            temp_model = ListTeamsRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class ListTeamsShrinkRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        tenant_context_shrink: str = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class ListTeamsResponseBodyTeamsIcon(TeaModel):
    def __init__(
        self,
        type: str = None,
        value: str = None,
    ):
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListTeamsResponseBodyTeams(TeaModel):
    def __init__(
        self,
        corp_id: str = None,
        cover: str = None,
        create_time: str = None,
        creator_id: str = None,
        description: str = None,
        icon: ListTeamsResponseBodyTeamsIcon = None,
        modified_time: str = None,
        modifier_id: str = None,
        name: str = None,
        team_id: str = None,
    ):
        self.corp_id = corp_id
        self.cover = cover
        self.create_time = create_time
        self.creator_id = creator_id
        self.description = description
        self.icon = icon
        self.modified_time = modified_time
        self.modifier_id = modifier_id
        self.name = name
        self.team_id = team_id

    def validate(self):
        if self.icon:
            self.icon.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.cover is not None:
            result['Cover'] = self.cover
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.icon is not None:
            result['Icon'] = self.icon.to_map()
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.name is not None:
            result['Name'] = self.name
        if self.team_id is not None:
            result['TeamId'] = self.team_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('Cover') is not None:
            self.cover = m.get('Cover')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Icon') is not None:
            temp_model = ListTeamsResponseBodyTeamsIcon()
            self.icon = temp_model.from_map(m['Icon'])
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TeamId') is not None:
            self.team_id = m.get('TeamId')
        return self


class ListTeamsResponseBody(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        request_id: str = None,
        teams: List[ListTeamsResponseBodyTeams] = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.next_token = next_token
        self.request_id = request_id
        self.teams = teams
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.teams:
            for k in self.teams:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['teams'] = []
        if self.teams is not None:
            for k in self.teams:
                result['teams'].append(k.to_map() if k else None)
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.teams = []
        if m.get('teams') is not None:
            for k in m.get('teams'):
                temp_model = ListTeamsResponseBodyTeams()
                self.teams.append(temp_model.from_map(k))
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class ListTeamsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTeamsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTeamsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTemplateHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ListTemplateHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ListTemplateHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ListTemplateHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ListTemplateShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ListTemplateRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class ListTemplateRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        template_type: str = None,
        tenant_context: ListTemplateRequestTenantContext = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.template_type = template_type
        self.tenant_context = tenant_context
        self.workspace_id = workspace_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('TenantContext') is not None:
            temp_model = ListTemplateRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListTemplateShrinkRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        template_type: str = None,
        tenant_context_shrink: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.template_type = template_type
        self.tenant_context_shrink = tenant_context_shrink
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListTemplateResponseBodyTemplateList(TeaModel):
    def __init__(
        self,
        cover_url: str = None,
        create_time: int = None,
        doc_type: str = None,
        id: str = None,
        template_type: str = None,
        title: str = None,
        update_time: int = None,
        workspace_id: str = None,
    ):
        self.cover_url = cover_url
        self.create_time = create_time
        self.doc_type = doc_type
        self.id = id
        self.template_type = template_type
        self.title = title
        self.update_time = update_time
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cover_url is not None:
            result['CoverUrl'] = self.cover_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.id is not None:
            result['Id'] = self.id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.title is not None:
            result['Title'] = self.title
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CoverUrl') is not None:
            self.cover_url = m.get('CoverUrl')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListTemplateResponseBody(TeaModel):
    def __init__(
        self,
        has_more: bool = None,
        next_token: str = None,
        request_id: str = None,
        template_list: List[ListTemplateResponseBodyTemplateList] = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.has_more = has_more
        self.next_token = next_token
        self.request_id = request_id
        self.template_list = template_list
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.template_list:
            for k in self.template_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_more is not None:
            result['hasMore'] = self.has_more
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['templateList'] = []
        if self.template_list is not None:
            for k in self.template_list:
                result['templateList'].append(k.to_map() if k else None)
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('hasMore') is not None:
            self.has_more = m.get('hasMore')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.template_list = []
        if m.get('templateList') is not None:
            for k in m.get('templateList'):
                temp_model = ListTemplateResponseBodyTemplateList()
                self.template_list.append(temp_model.from_map(k))
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class ListTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTicketOperateRecordHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ListTicketOperateRecordHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ListTicketOperateRecordHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ListTicketOperateRecordHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ListTicketOperateRecordShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ListTicketOperateRecordRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class ListTicketOperateRecordRequest(TeaModel):
    def __init__(
        self,
        open_team_id: str = None,
        open_ticket_id: str = None,
        tenant_context: ListTicketOperateRecordRequestTenantContext = None,
    ):
        # This parameter is required.
        self.open_team_id = open_team_id
        # This parameter is required.
        self.open_ticket_id = open_ticket_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.open_team_id is not None:
            result['OpenTeamId'] = self.open_team_id
        if self.open_ticket_id is not None:
            result['OpenTicketId'] = self.open_ticket_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OpenTeamId') is not None:
            self.open_team_id = m.get('OpenTeamId')
        if m.get('OpenTicketId') is not None:
            self.open_ticket_id = m.get('OpenTicketId')
        if m.get('TenantContext') is not None:
            temp_model = ListTicketOperateRecordRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class ListTicketOperateRecordShrinkRequest(TeaModel):
    def __init__(
        self,
        open_team_id: str = None,
        open_ticket_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.open_team_id = open_team_id
        # This parameter is required.
        self.open_ticket_id = open_ticket_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.open_team_id is not None:
            result['OpenTeamId'] = self.open_team_id
        if self.open_ticket_id is not None:
            result['OpenTicketId'] = self.open_ticket_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OpenTeamId') is not None:
            self.open_team_id = m.get('OpenTeamId')
        if m.get('OpenTicketId') is not None:
            self.open_ticket_id = m.get('OpenTicketId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class ListTicketOperateRecordResponseBodyRecordsOperator(TeaModel):
    def __init__(
        self,
        nick_name: str = None,
        union_id: str = None,
    ):
        self.nick_name = nick_name
        self.union_id = union_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.union_id is not None:
            result['UnionId'] = self.union_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('UnionId') is not None:
            self.union_id = m.get('UnionId')
        return self


class ListTicketOperateRecordResponseBodyRecordsTicketMemoAttachments(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        key: str = None,
    ):
        self.file_name = file_name
        self.key = key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.key is not None:
            result['Key'] = self.key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        return self


class ListTicketOperateRecordResponseBodyRecordsTicketMemo(TeaModel):
    def __init__(
        self,
        attachments: List[ListTicketOperateRecordResponseBodyRecordsTicketMemoAttachments] = None,
        memo: str = None,
    ):
        self.attachments = attachments
        self.memo = memo

    def validate(self):
        if self.attachments:
            for k in self.attachments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Attachments'] = []
        if self.attachments is not None:
            for k in self.attachments:
                result['Attachments'].append(k.to_map() if k else None)
        if self.memo is not None:
            result['Memo'] = self.memo
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attachments = []
        if m.get('Attachments') is not None:
            for k in m.get('Attachments'):
                temp_model = ListTicketOperateRecordResponseBodyRecordsTicketMemoAttachments()
                self.attachments.append(temp_model.from_map(k))
        if m.get('Memo') is not None:
            self.memo = m.get('Memo')
        return self


class ListTicketOperateRecordResponseBodyRecords(TeaModel):
    def __init__(
        self,
        open_ticket_id: str = None,
        operate_data: str = None,
        operate_time: str = None,
        operation: str = None,
        operation_display_name: str = None,
        operator: ListTicketOperateRecordResponseBodyRecordsOperator = None,
        ticket_memo: ListTicketOperateRecordResponseBodyRecordsTicketMemo = None,
    ):
        self.open_ticket_id = open_ticket_id
        self.operate_data = operate_data
        self.operate_time = operate_time
        self.operation = operation
        self.operation_display_name = operation_display_name
        self.operator = operator
        self.ticket_memo = ticket_memo

    def validate(self):
        if self.operator:
            self.operator.validate()
        if self.ticket_memo:
            self.ticket_memo.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.open_ticket_id is not None:
            result['OpenTicketId'] = self.open_ticket_id
        if self.operate_data is not None:
            result['OperateData'] = self.operate_data
        if self.operate_time is not None:
            result['OperateTime'] = self.operate_time
        if self.operation is not None:
            result['Operation'] = self.operation
        if self.operation_display_name is not None:
            result['OperationDisplayName'] = self.operation_display_name
        if self.operator is not None:
            result['Operator'] = self.operator.to_map()
        if self.ticket_memo is not None:
            result['TicketMemo'] = self.ticket_memo.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OpenTicketId') is not None:
            self.open_ticket_id = m.get('OpenTicketId')
        if m.get('OperateData') is not None:
            self.operate_data = m.get('OperateData')
        if m.get('OperateTime') is not None:
            self.operate_time = m.get('OperateTime')
        if m.get('Operation') is not None:
            self.operation = m.get('Operation')
        if m.get('OperationDisplayName') is not None:
            self.operation_display_name = m.get('OperationDisplayName')
        if m.get('Operator') is not None:
            temp_model = ListTicketOperateRecordResponseBodyRecordsOperator()
            self.operator = temp_model.from_map(m['Operator'])
        if m.get('TicketMemo') is not None:
            temp_model = ListTicketOperateRecordResponseBodyRecordsTicketMemo()
            self.ticket_memo = temp_model.from_map(m['TicketMemo'])
        return self


class ListTicketOperateRecordResponseBody(TeaModel):
    def __init__(
        self,
        records: List[ListTicketOperateRecordResponseBodyRecords] = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.records = records
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.records:
            for k in self.records:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['records'] = []
        if self.records is not None:
            for k in self.records:
                result['records'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.records = []
        if m.get('records') is not None:
            for k in m.get('records'):
                temp_model = ListTicketOperateRecordResponseBodyRecords()
                self.records.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class ListTicketOperateRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTicketOperateRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTicketOperateRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWorkspacesHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ListWorkspacesHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ListWorkspacesHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ListWorkspacesHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ListWorkspacesShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ListWorkspacesRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class ListWorkspacesRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        order_by: str = None,
        team_id: str = None,
        tenant_context: ListWorkspacesRequestTenantContext = None,
        with_permission_role: bool = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.order_by = order_by
        self.team_id = team_id
        self.tenant_context = tenant_context
        self.with_permission_role = with_permission_role

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.team_id is not None:
            result['TeamId'] = self.team_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.with_permission_role is not None:
            result['WithPermissionRole'] = self.with_permission_role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('TeamId') is not None:
            self.team_id = m.get('TeamId')
        if m.get('TenantContext') is not None:
            temp_model = ListWorkspacesRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WithPermissionRole') is not None:
            self.with_permission_role = m.get('WithPermissionRole')
        return self


class ListWorkspacesShrinkRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        order_by: str = None,
        team_id: str = None,
        tenant_context_shrink: str = None,
        with_permission_role: bool = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.order_by = order_by
        self.team_id = team_id
        self.tenant_context_shrink = tenant_context_shrink
        self.with_permission_role = with_permission_role

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.team_id is not None:
            result['TeamId'] = self.team_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.with_permission_role is not None:
            result['WithPermissionRole'] = self.with_permission_role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('TeamId') is not None:
            self.team_id = m.get('TeamId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WithPermissionRole') is not None:
            self.with_permission_role = m.get('WithPermissionRole')
        return self


class ListWorkspacesResponseBodyWorkspacesIcon(TeaModel):
    def __init__(
        self,
        type: str = None,
        value: str = None,
    ):
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListWorkspacesResponseBodyWorkspaces(TeaModel):
    def __init__(
        self,
        corp_id: str = None,
        cover: str = None,
        create_time: str = None,
        creator_id: str = None,
        description: str = None,
        icon: ListWorkspacesResponseBodyWorkspacesIcon = None,
        modified_time: str = None,
        modifier_id: str = None,
        name: str = None,
        permission_role: str = None,
        root_node_id: str = None,
        team_id: str = None,
        type: str = None,
        url: str = None,
        workspace_id: str = None,
    ):
        self.corp_id = corp_id
        self.cover = cover
        self.create_time = create_time
        self.creator_id = creator_id
        self.description = description
        self.icon = icon
        self.modified_time = modified_time
        self.modifier_id = modifier_id
        self.name = name
        self.permission_role = permission_role
        self.root_node_id = root_node_id
        self.team_id = team_id
        self.type = type
        self.url = url
        self.workspace_id = workspace_id

    def validate(self):
        if self.icon:
            self.icon.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.cover is not None:
            result['Cover'] = self.cover
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.icon is not None:
            result['Icon'] = self.icon.to_map()
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.name is not None:
            result['Name'] = self.name
        if self.permission_role is not None:
            result['PermissionRole'] = self.permission_role
        if self.root_node_id is not None:
            result['RootNodeId'] = self.root_node_id
        if self.team_id is not None:
            result['TeamId'] = self.team_id
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('Cover') is not None:
            self.cover = m.get('Cover')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Icon') is not None:
            temp_model = ListWorkspacesResponseBodyWorkspacesIcon()
            self.icon = temp_model.from_map(m['Icon'])
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PermissionRole') is not None:
            self.permission_role = m.get('PermissionRole')
        if m.get('RootNodeId') is not None:
            self.root_node_id = m.get('RootNodeId')
        if m.get('TeamId') is not None:
            self.team_id = m.get('TeamId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListWorkspacesResponseBody(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        request_id: str = None,
        workspaces: List[ListWorkspacesResponseBodyWorkspaces] = None,
    ):
        self.next_token = next_token
        # requestId
        self.request_id = request_id
        self.workspaces = workspaces

    def validate(self):
        if self.workspaces:
            for k in self.workspaces:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['workspaces'] = []
        if self.workspaces is not None:
            for k in self.workspaces:
                result['workspaces'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.workspaces = []
        if m.get('workspaces') is not None:
            for k in m.get('workspaces'):
                temp_model = ListWorkspacesResponseBodyWorkspaces()
                self.workspaces.append(temp_model.from_map(k))
        return self


class ListWorkspacesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWorkspacesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWorkspacesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PatchEventHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class PatchEventHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: PatchEventHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = PatchEventHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class PatchEventShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class PatchEventRequestAttendees(TeaModel):
    def __init__(
        self,
        id: str = None,
        is_optional: bool = None,
    ):
        self.id = id
        self.is_optional = is_optional

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.is_optional is not None:
            result['isOptional'] = self.is_optional
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('isOptional') is not None:
            self.is_optional = m.get('isOptional')
        return self


class PatchEventRequestCardInstances(TeaModel):
    def __init__(
        self,
        out_track_id: str = None,
        scenario: str = None,
    ):
        self.out_track_id = out_track_id
        self.scenario = scenario

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.out_track_id is not None:
            result['OutTrackId'] = self.out_track_id
        if self.scenario is not None:
            result['Scenario'] = self.scenario
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OutTrackId') is not None:
            self.out_track_id = m.get('OutTrackId')
        if m.get('Scenario') is not None:
            self.scenario = m.get('Scenario')
        return self


class PatchEventRequestEnd(TeaModel):
    def __init__(
        self,
        date: str = None,
        date_time: str = None,
        time_zone: str = None,
    ):
        self.date = date
        self.date_time = date_time
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['date'] = self.date
        if self.date_time is not None:
            result['dateTime'] = self.date_time
        if self.time_zone is not None:
            result['timeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('date') is not None:
            self.date = m.get('date')
        if m.get('dateTime') is not None:
            self.date_time = m.get('dateTime')
        if m.get('timeZone') is not None:
            self.time_zone = m.get('timeZone')
        return self


class PatchEventRequestLocation(TeaModel):
    def __init__(
        self,
        display_name: str = None,
    ):
        self.display_name = display_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['displayName'] = self.display_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        return self


class PatchEventRequestRecurrencePattern(TeaModel):
    def __init__(
        self,
        day_of_month: int = None,
        days_of_week: str = None,
        index: str = None,
        interval: int = None,
        type: str = None,
    ):
        self.day_of_month = day_of_month
        self.days_of_week = days_of_week
        self.index = index
        self.interval = interval
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.day_of_month is not None:
            result['dayOfMonth'] = self.day_of_month
        if self.days_of_week is not None:
            result['daysOfWeek'] = self.days_of_week
        if self.index is not None:
            result['index'] = self.index
        if self.interval is not None:
            result['interval'] = self.interval
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dayOfMonth') is not None:
            self.day_of_month = m.get('dayOfMonth')
        if m.get('daysOfWeek') is not None:
            self.days_of_week = m.get('daysOfWeek')
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class PatchEventRequestRecurrenceRange(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        number_of_occurrences: int = None,
        type: str = None,
    ):
        self.end_date = end_date
        self.number_of_occurrences = number_of_occurrences
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['endDate'] = self.end_date
        if self.number_of_occurrences is not None:
            result['numberOfOccurrences'] = self.number_of_occurrences
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endDate') is not None:
            self.end_date = m.get('endDate')
        if m.get('numberOfOccurrences') is not None:
            self.number_of_occurrences = m.get('numberOfOccurrences')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class PatchEventRequestRecurrence(TeaModel):
    def __init__(
        self,
        pattern: PatchEventRequestRecurrencePattern = None,
        range: PatchEventRequestRecurrenceRange = None,
    ):
        self.pattern = pattern
        self.range = range

    def validate(self):
        if self.pattern:
            self.pattern.validate()
        if self.range:
            self.range.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pattern is not None:
            result['pattern'] = self.pattern.to_map()
        if self.range is not None:
            result['range'] = self.range.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('pattern') is not None:
            temp_model = PatchEventRequestRecurrencePattern()
            self.pattern = temp_model.from_map(m['pattern'])
        if m.get('range') is not None:
            temp_model = PatchEventRequestRecurrenceRange()
            self.range = temp_model.from_map(m['range'])
        return self


class PatchEventRequestReminders(TeaModel):
    def __init__(
        self,
        method: str = None,
        minutes: int = None,
    ):
        self.method = method
        self.minutes = minutes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.method is not None:
            result['method'] = self.method
        if self.minutes is not None:
            result['minutes'] = self.minutes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('method') is not None:
            self.method = m.get('method')
        if m.get('minutes') is not None:
            self.minutes = m.get('minutes')
        return self


class PatchEventRequestStart(TeaModel):
    def __init__(
        self,
        date: str = None,
        date_time: str = None,
        time_zone: str = None,
    ):
        self.date = date
        self.date_time = date_time
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['date'] = self.date
        if self.date_time is not None:
            result['dateTime'] = self.date_time
        if self.time_zone is not None:
            result['timeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('date') is not None:
            self.date = m.get('date')
        if m.get('dateTime') is not None:
            self.date_time = m.get('dateTime')
        if m.get('timeZone') is not None:
            self.time_zone = m.get('timeZone')
        return self


class PatchEventRequest(TeaModel):
    def __init__(
        self,
        attendees: List[PatchEventRequestAttendees] = None,
        calendar_id: str = None,
        card_instances: List[PatchEventRequestCardInstances] = None,
        description: str = None,
        end: PatchEventRequestEnd = None,
        event_id: str = None,
        extra: Dict[str, str] = None,
        is_all_day: bool = None,
        location: PatchEventRequestLocation = None,
        recurrence: PatchEventRequestRecurrence = None,
        reminders: List[PatchEventRequestReminders] = None,
        start: PatchEventRequestStart = None,
        summary: str = None,
    ):
        self.attendees = attendees
        # This parameter is required.
        self.calendar_id = calendar_id
        self.card_instances = card_instances
        self.description = description
        self.end = end
        # This parameter is required.
        self.event_id = event_id
        self.extra = extra
        self.is_all_day = is_all_day
        self.location = location
        self.recurrence = recurrence
        self.reminders = reminders
        self.start = start
        self.summary = summary

    def validate(self):
        if self.attendees:
            for k in self.attendees:
                if k:
                    k.validate()
        if self.card_instances:
            for k in self.card_instances:
                if k:
                    k.validate()
        if self.end:
            self.end.validate()
        if self.location:
            self.location.validate()
        if self.recurrence:
            self.recurrence.validate()
        if self.reminders:
            for k in self.reminders:
                if k:
                    k.validate()
        if self.start:
            self.start.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Attendees'] = []
        if self.attendees is not None:
            for k in self.attendees:
                result['Attendees'].append(k.to_map() if k else None)
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        result['CardInstances'] = []
        if self.card_instances is not None:
            for k in self.card_instances:
                result['CardInstances'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.end is not None:
            result['End'] = self.end.to_map()
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.extra is not None:
            result['Extra'] = self.extra
        if self.is_all_day is not None:
            result['IsAllDay'] = self.is_all_day
        if self.location is not None:
            result['Location'] = self.location.to_map()
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence.to_map()
        result['Reminders'] = []
        if self.reminders is not None:
            for k in self.reminders:
                result['Reminders'].append(k.to_map() if k else None)
        if self.start is not None:
            result['Start'] = self.start.to_map()
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attendees = []
        if m.get('Attendees') is not None:
            for k in m.get('Attendees'):
                temp_model = PatchEventRequestAttendees()
                self.attendees.append(temp_model.from_map(k))
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        self.card_instances = []
        if m.get('CardInstances') is not None:
            for k in m.get('CardInstances'):
                temp_model = PatchEventRequestCardInstances()
                self.card_instances.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('End') is not None:
            temp_model = PatchEventRequestEnd()
            self.end = temp_model.from_map(m['End'])
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('Extra') is not None:
            self.extra = m.get('Extra')
        if m.get('IsAllDay') is not None:
            self.is_all_day = m.get('IsAllDay')
        if m.get('Location') is not None:
            temp_model = PatchEventRequestLocation()
            self.location = temp_model.from_map(m['Location'])
        if m.get('Recurrence') is not None:
            temp_model = PatchEventRequestRecurrence()
            self.recurrence = temp_model.from_map(m['Recurrence'])
        self.reminders = []
        if m.get('Reminders') is not None:
            for k in m.get('Reminders'):
                temp_model = PatchEventRequestReminders()
                self.reminders.append(temp_model.from_map(k))
        if m.get('Start') is not None:
            temp_model = PatchEventRequestStart()
            self.start = temp_model.from_map(m['Start'])
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class PatchEventShrinkRequest(TeaModel):
    def __init__(
        self,
        attendees_shrink: str = None,
        calendar_id: str = None,
        card_instances_shrink: str = None,
        description: str = None,
        end_shrink: str = None,
        event_id: str = None,
        extra_shrink: str = None,
        is_all_day: bool = None,
        location_shrink: str = None,
        recurrence_shrink: str = None,
        reminders_shrink: str = None,
        start_shrink: str = None,
        summary: str = None,
    ):
        self.attendees_shrink = attendees_shrink
        # This parameter is required.
        self.calendar_id = calendar_id
        self.card_instances_shrink = card_instances_shrink
        self.description = description
        self.end_shrink = end_shrink
        # This parameter is required.
        self.event_id = event_id
        self.extra_shrink = extra_shrink
        self.is_all_day = is_all_day
        self.location_shrink = location_shrink
        self.recurrence_shrink = recurrence_shrink
        self.reminders_shrink = reminders_shrink
        self.start_shrink = start_shrink
        self.summary = summary

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attendees_shrink is not None:
            result['Attendees'] = self.attendees_shrink
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        if self.card_instances_shrink is not None:
            result['CardInstances'] = self.card_instances_shrink
        if self.description is not None:
            result['Description'] = self.description
        if self.end_shrink is not None:
            result['End'] = self.end_shrink
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.extra_shrink is not None:
            result['Extra'] = self.extra_shrink
        if self.is_all_day is not None:
            result['IsAllDay'] = self.is_all_day
        if self.location_shrink is not None:
            result['Location'] = self.location_shrink
        if self.recurrence_shrink is not None:
            result['Recurrence'] = self.recurrence_shrink
        if self.reminders_shrink is not None:
            result['Reminders'] = self.reminders_shrink
        if self.start_shrink is not None:
            result['Start'] = self.start_shrink
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Attendees') is not None:
            self.attendees_shrink = m.get('Attendees')
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        if m.get('CardInstances') is not None:
            self.card_instances_shrink = m.get('CardInstances')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('End') is not None:
            self.end_shrink = m.get('End')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('Extra') is not None:
            self.extra_shrink = m.get('Extra')
        if m.get('IsAllDay') is not None:
            self.is_all_day = m.get('IsAllDay')
        if m.get('Location') is not None:
            self.location_shrink = m.get('Location')
        if m.get('Recurrence') is not None:
            self.recurrence_shrink = m.get('Recurrence')
        if m.get('Reminders') is not None:
            self.reminders_shrink = m.get('Reminders')
        if m.get('Start') is not None:
            self.start_shrink = m.get('Start')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class PatchEventResponseBodyAttendees(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        id: str = None,
        is_optional: bool = None,
        response_status: str = None,
        self_: bool = None,
    ):
        self.display_name = display_name
        self.id = id
        self.is_optional = is_optional
        self.response_status = response_status
        self.self_ = self_

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.id is not None:
            result['Id'] = self.id
        if self.is_optional is not None:
            result['IsOptional'] = self.is_optional
        if self.response_status is not None:
            result['ResponseStatus'] = self.response_status
        if self.self_ is not None:
            result['Self'] = self.self_
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsOptional') is not None:
            self.is_optional = m.get('IsOptional')
        if m.get('ResponseStatus') is not None:
            self.response_status = m.get('ResponseStatus')
        if m.get('Self') is not None:
            self.self_ = m.get('Self')
        return self


class PatchEventResponseBodyEnd(TeaModel):
    def __init__(
        self,
        date: str = None,
        date_time: str = None,
        time_zone: str = None,
    ):
        self.date = date
        self.date_time = date_time
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['Date'] = self.date
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.time_zone is not None:
            result['TimeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Date') is not None:
            self.date = m.get('Date')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('TimeZone') is not None:
            self.time_zone = m.get('TimeZone')
        return self


class PatchEventResponseBodyLocation(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        meeting_rooms: List[str] = None,
    ):
        self.display_name = display_name
        self.meeting_rooms = meeting_rooms

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.meeting_rooms is not None:
            result['MeetingRooms'] = self.meeting_rooms
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('MeetingRooms') is not None:
            self.meeting_rooms = m.get('MeetingRooms')
        return self


class PatchEventResponseBodyOrganizer(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        id: str = None,
        response_status: str = None,
        self_: bool = None,
    ):
        self.display_name = display_name
        self.id = id
        self.response_status = response_status
        self.self_ = self_

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.id is not None:
            result['Id'] = self.id
        if self.response_status is not None:
            result['ResponseStatus'] = self.response_status
        if self.self_ is not None:
            result['Self'] = self.self_
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ResponseStatus') is not None:
            self.response_status = m.get('ResponseStatus')
        if m.get('Self') is not None:
            self.self_ = m.get('Self')
        return self


class PatchEventResponseBodyRecurrencePattern(TeaModel):
    def __init__(
        self,
        day_of_month: int = None,
        days_of_week: str = None,
        index: str = None,
        interval: int = None,
        type: str = None,
    ):
        self.day_of_month = day_of_month
        self.days_of_week = days_of_week
        self.index = index
        self.interval = interval
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.day_of_month is not None:
            result['DayOfMonth'] = self.day_of_month
        if self.days_of_week is not None:
            result['DaysOfWeek'] = self.days_of_week
        if self.index is not None:
            result['Index'] = self.index
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DayOfMonth') is not None:
            self.day_of_month = m.get('DayOfMonth')
        if m.get('DaysOfWeek') is not None:
            self.days_of_week = m.get('DaysOfWeek')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class PatchEventResponseBodyRecurrenceRange(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        number_of_occurrences: int = None,
        type: str = None,
    ):
        self.end_date = end_date
        self.number_of_occurrences = number_of_occurrences
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.number_of_occurrences is not None:
            result['NumberOfOccurrences'] = self.number_of_occurrences
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('NumberOfOccurrences') is not None:
            self.number_of_occurrences = m.get('NumberOfOccurrences')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class PatchEventResponseBodyRecurrence(TeaModel):
    def __init__(
        self,
        pattern: PatchEventResponseBodyRecurrencePattern = None,
        range: PatchEventResponseBodyRecurrenceRange = None,
    ):
        self.pattern = pattern
        self.range = range

    def validate(self):
        if self.pattern:
            self.pattern.validate()
        if self.range:
            self.range.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pattern is not None:
            result['Pattern'] = self.pattern.to_map()
        if self.range is not None:
            result['Range'] = self.range.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pattern') is not None:
            temp_model = PatchEventResponseBodyRecurrencePattern()
            self.pattern = temp_model.from_map(m['Pattern'])
        if m.get('Range') is not None:
            temp_model = PatchEventResponseBodyRecurrenceRange()
            self.range = temp_model.from_map(m['Range'])
        return self


class PatchEventResponseBodyReminders(TeaModel):
    def __init__(
        self,
        method: str = None,
        minutes: str = None,
    ):
        self.method = method
        self.minutes = minutes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.method is not None:
            result['Method'] = self.method
        if self.minutes is not None:
            result['Minutes'] = self.minutes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('Minutes') is not None:
            self.minutes = m.get('Minutes')
        return self


class PatchEventResponseBodyStart(TeaModel):
    def __init__(
        self,
        date: str = None,
        date_time: str = None,
        time_zone: str = None,
    ):
        self.date = date
        self.date_time = date_time
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['Date'] = self.date
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.time_zone is not None:
            result['TimeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Date') is not None:
            self.date = m.get('Date')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('TimeZone') is not None:
            self.time_zone = m.get('TimeZone')
        return self


class PatchEventResponseBody(TeaModel):
    def __init__(
        self,
        attendees: List[PatchEventResponseBodyAttendees] = None,
        create_time: str = None,
        description: str = None,
        end: PatchEventResponseBodyEnd = None,
        id: str = None,
        is_all_day: bool = None,
        location: PatchEventResponseBodyLocation = None,
        organizer: PatchEventResponseBodyOrganizer = None,
        recurrence: PatchEventResponseBodyRecurrence = None,
        reminders: List[PatchEventResponseBodyReminders] = None,
        request_id: str = None,
        start: PatchEventResponseBodyStart = None,
        summary: str = None,
        update_time: str = None,
    ):
        self.attendees = attendees
        self.create_time = create_time
        self.description = description
        self.end = end
        self.id = id
        self.is_all_day = is_all_day
        self.location = location
        self.organizer = organizer
        self.recurrence = recurrence
        self.reminders = reminders
        # requestId
        self.request_id = request_id
        self.start = start
        self.summary = summary
        self.update_time = update_time

    def validate(self):
        if self.attendees:
            for k in self.attendees:
                if k:
                    k.validate()
        if self.end:
            self.end.validate()
        if self.location:
            self.location.validate()
        if self.organizer:
            self.organizer.validate()
        if self.recurrence:
            self.recurrence.validate()
        if self.reminders:
            for k in self.reminders:
                if k:
                    k.validate()
        if self.start:
            self.start.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['attendees'] = []
        if self.attendees is not None:
            for k in self.attendees:
                result['attendees'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.description is not None:
            result['description'] = self.description
        if self.end is not None:
            result['end'] = self.end.to_map()
        if self.id is not None:
            result['id'] = self.id
        if self.is_all_day is not None:
            result['isAllDay'] = self.is_all_day
        if self.location is not None:
            result['location'] = self.location.to_map()
        if self.organizer is not None:
            result['organizer'] = self.organizer.to_map()
        if self.recurrence is not None:
            result['recurrence'] = self.recurrence.to_map()
        result['reminders'] = []
        if self.reminders is not None:
            for k in self.reminders:
                result['reminders'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.start is not None:
            result['start'] = self.start.to_map()
        if self.summary is not None:
            result['summary'] = self.summary
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attendees = []
        if m.get('attendees') is not None:
            for k in m.get('attendees'):
                temp_model = PatchEventResponseBodyAttendees()
                self.attendees.append(temp_model.from_map(k))
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('end') is not None:
            temp_model = PatchEventResponseBodyEnd()
            self.end = temp_model.from_map(m['end'])
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('isAllDay') is not None:
            self.is_all_day = m.get('isAllDay')
        if m.get('location') is not None:
            temp_model = PatchEventResponseBodyLocation()
            self.location = temp_model.from_map(m['location'])
        if m.get('organizer') is not None:
            temp_model = PatchEventResponseBodyOrganizer()
            self.organizer = temp_model.from_map(m['organizer'])
        if m.get('recurrence') is not None:
            temp_model = PatchEventResponseBodyRecurrence()
            self.recurrence = temp_model.from_map(m['recurrence'])
        self.reminders = []
        if m.get('reminders') is not None:
            for k in m.get('reminders'):
                temp_model = PatchEventResponseBodyReminders()
                self.reminders.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('start') is not None:
            temp_model = PatchEventResponseBodyStart()
            self.start = temp_model.from_map(m['start'])
        if m.get('summary') is not None:
            self.summary = m.get('summary')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        return self


class PatchEventResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PatchEventResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PatchEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryCloudRecordTextHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryCloudRecordTextHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryCloudRecordTextHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryCloudRecordTextHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryCloudRecordTextShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryCloudRecordTextRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryCloudRecordTextRequest(TeaModel):
    def __init__(
        self,
        direction: str = None,
        max_results: int = None,
        next_token: int = None,
        start_time: int = None,
        tenant_context: QueryCloudRecordTextRequestTenantContext = None,
        conference_id: str = None,
    ):
        self.direction = direction
        self.max_results = max_results
        self.next_token = next_token
        self.start_time = start_time
        self.tenant_context = tenant_context
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.direction is not None:
            result['Direction'] = self.direction
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Direction') is not None:
            self.direction = m.get('Direction')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            temp_model = QueryCloudRecordTextRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class QueryCloudRecordTextShrinkRequest(TeaModel):
    def __init__(
        self,
        direction: str = None,
        max_results: int = None,
        next_token: int = None,
        start_time: int = None,
        tenant_context_shrink: str = None,
        conference_id: str = None,
    ):
        self.direction = direction
        self.max_results = max_results
        self.next_token = next_token
        self.start_time = start_time
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.direction is not None:
            result['Direction'] = self.direction
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Direction') is not None:
            self.direction = m.get('Direction')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        start_time: int = None,
        word: str = None,
        word_id: str = None,
    ):
        self.end_time = end_time
        self.start_time = start_time
        self.word = word
        self.word_id = word_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.word is not None:
            result['Word'] = self.word
        if self.word_id is not None:
            result['WordId'] = self.word_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Word') is not None:
            self.word = m.get('Word')
        if m.get('WordId') is not None:
            self.word_id = m.get('WordId')
        return self


class QueryCloudRecordTextResponseBodyParagraphListSentenceList(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        sentence: str = None,
        start_time: int = None,
        user_id: str = None,
        word_list: List[QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList] = None,
    ):
        self.end_time = end_time
        self.sentence = sentence
        self.start_time = start_time
        self.user_id = user_id
        self.word_list = word_list

    def validate(self):
        if self.word_list:
            for k in self.word_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.sentence is not None:
            result['Sentence'] = self.sentence
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        result['WordList'] = []
        if self.word_list is not None:
            for k in self.word_list:
                result['WordList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Sentence') is not None:
            self.sentence = m.get('Sentence')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        self.word_list = []
        if m.get('WordList') is not None:
            for k in m.get('WordList'):
                temp_model = QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList()
                self.word_list.append(temp_model.from_map(k))
        return self


class QueryCloudRecordTextResponseBodyParagraphList(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        next_ttoken: int = None,
        nick_name: str = None,
        paragraph: str = None,
        record_id: int = None,
        sentence_list: List[QueryCloudRecordTextResponseBodyParagraphListSentenceList] = None,
        start_time: int = None,
        status: int = None,
        user_id: str = None,
    ):
        self.end_time = end_time
        self.next_ttoken = next_ttoken
        self.nick_name = nick_name
        self.paragraph = paragraph
        self.record_id = record_id
        self.sentence_list = sentence_list
        self.start_time = start_time
        self.status = status
        self.user_id = user_id

    def validate(self):
        if self.sentence_list:
            for k in self.sentence_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.next_ttoken is not None:
            result['NextTtoken'] = self.next_ttoken
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.paragraph is not None:
            result['Paragraph'] = self.paragraph
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        result['SentenceList'] = []
        if self.sentence_list is not None:
            for k in self.sentence_list:
                result['SentenceList'].append(k.to_map() if k else None)
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('NextTtoken') is not None:
            self.next_ttoken = m.get('NextTtoken')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('Paragraph') is not None:
            self.paragraph = m.get('Paragraph')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        self.sentence_list = []
        if m.get('SentenceList') is not None:
            for k in m.get('SentenceList'):
                temp_model = QueryCloudRecordTextResponseBodyParagraphListSentenceList()
                self.sentence_list.append(temp_model.from_map(k))
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class QueryCloudRecordTextResponseBody(TeaModel):
    def __init__(
        self,
        has_more: bool = None,
        paragraph_list: List[QueryCloudRecordTextResponseBodyParagraphList] = None,
        request_id: str = None,
    ):
        self.has_more = has_more
        self.paragraph_list = paragraph_list
        # requestId
        self.request_id = request_id

    def validate(self):
        if self.paragraph_list:
            for k in self.paragraph_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_more is not None:
            result['hasMore'] = self.has_more
        result['paragraphList'] = []
        if self.paragraph_list is not None:
            for k in self.paragraph_list:
                result['paragraphList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('hasMore') is not None:
            self.has_more = m.get('hasMore')
        self.paragraph_list = []
        if m.get('paragraphList') is not None:
            for k in m.get('paragraphList'):
                temp_model = QueryCloudRecordTextResponseBodyParagraphList()
                self.paragraph_list.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class QueryCloudRecordTextResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryCloudRecordTextResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryCloudRecordTextResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryCloudRecordVideoHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryCloudRecordVideoHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryCloudRecordVideoHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryCloudRecordVideoHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryCloudRecordVideoShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryCloudRecordVideoRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryCloudRecordVideoRequest(TeaModel):
    def __init__(
        self,
        tenant_context: QueryCloudRecordVideoRequestTenantContext = None,
        conference_id: str = None,
    ):
        self.tenant_context = tenant_context
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = QueryCloudRecordVideoRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class QueryCloudRecordVideoShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        conference_id: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class QueryCloudRecordVideoResponseBodyVideoList(TeaModel):
    def __init__(
        self,
        duration: int = None,
        end_time: int = None,
        file_size: int = None,
        media_id: str = None,
        record_id: str = None,
        record_type: int = None,
        region_id: str = None,
        start_time: int = None,
        user_id: str = None,
    ):
        self.duration = duration
        self.end_time = end_time
        self.file_size = file_size
        self.media_id = media_id
        self.record_id = record_id
        self.record_type = record_type
        self.region_id = region_id
        self.start_time = start_time
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.record_type is not None:
            result['RecordType'] = self.record_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('RecordType') is not None:
            self.record_type = m.get('RecordType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class QueryCloudRecordVideoResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        video_list: List[QueryCloudRecordVideoResponseBodyVideoList] = None,
    ):
        # requestId
        self.request_id = request_id
        self.video_list = video_list

    def validate(self):
        if self.video_list:
            for k in self.video_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['videoList'] = []
        if self.video_list is not None:
            for k in self.video_list:
                result['videoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.video_list = []
        if m.get('videoList') is not None:
            for k in m.get('videoList'):
                temp_model = QueryCloudRecordVideoResponseBodyVideoList()
                self.video_list.append(temp_model.from_map(k))
        return self


class QueryCloudRecordVideoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryCloudRecordVideoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryCloudRecordVideoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryCloudRecordVideoPlayInfoHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryCloudRecordVideoPlayInfoHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryCloudRecordVideoPlayInfoHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryCloudRecordVideoPlayInfoHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryCloudRecordVideoPlayInfoShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryCloudRecordVideoPlayInfoRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryCloudRecordVideoPlayInfoRequest(TeaModel):
    def __init__(
        self,
        conference_id: str = None,
        media_id: str = None,
        region_id: str = None,
        tenant_context: QueryCloudRecordVideoPlayInfoRequestTenantContext = None,
    ):
        # This parameter is required.
        self.conference_id = conference_id
        # This parameter is required.
        self.media_id = media_id
        # This parameter is required.
        self.region_id = region_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conference_id is not None:
            result['ConferenceId'] = self.conference_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConferenceId') is not None:
            self.conference_id = m.get('ConferenceId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TenantContext') is not None:
            temp_model = QueryCloudRecordVideoPlayInfoRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class QueryCloudRecordVideoPlayInfoShrinkRequest(TeaModel):
    def __init__(
        self,
        conference_id: str = None,
        media_id: str = None,
        region_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.conference_id = conference_id
        # This parameter is required.
        self.media_id = media_id
        # This parameter is required.
        self.region_id = region_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conference_id is not None:
            result['ConferenceId'] = self.conference_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConferenceId') is not None:
            self.conference_id = m.get('ConferenceId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class QueryCloudRecordVideoPlayInfoResponseBody(TeaModel):
    def __init__(
        self,
        duration: int = None,
        file_size: int = None,
        mp_4file_url: str = None,
        play_url: str = None,
        request_id: str = None,
        status: int = None,
    ):
        self.duration = duration
        self.file_size = file_size
        self.mp_4file_url = mp_4file_url
        self.play_url = play_url
        # requestId
        self.request_id = request_id
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['duration'] = self.duration
        if self.file_size is not None:
            result['fileSize'] = self.file_size
        if self.mp_4file_url is not None:
            result['mp4FileUrl'] = self.mp_4file_url
        if self.play_url is not None:
            result['playUrl'] = self.play_url
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('fileSize') is not None:
            self.file_size = m.get('fileSize')
        if m.get('mp4FileUrl') is not None:
            self.mp_4file_url = m.get('mp4FileUrl')
        if m.get('playUrl') is not None:
            self.play_url = m.get('playUrl')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class QueryCloudRecordVideoPlayInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryCloudRecordVideoPlayInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryCloudRecordVideoPlayInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryConferenceInfoHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryConferenceInfoHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryConferenceInfoHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryConferenceInfoHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryConferenceInfoShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryConferenceInfoRequest(TeaModel):
    def __init__(
        self,
        conference_id: str = None,
    ):
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class QueryConferenceInfoResponseBodyConfInfo(TeaModel):
    def __init__(
        self,
        active_num: int = None,
        attend_num: int = None,
        conf_duration: int = None,
        conference_id: str = None,
        creator_id: str = None,
        creator_nick: str = None,
        end_time: int = None,
        external_link_url: str = None,
        invited_num: int = None,
        room_code: str = None,
        start_time: int = None,
        status: int = None,
        title: str = None,
    ):
        self.active_num = active_num
        self.attend_num = attend_num
        self.conf_duration = conf_duration
        self.conference_id = conference_id
        self.creator_id = creator_id
        self.creator_nick = creator_nick
        self.end_time = end_time
        self.external_link_url = external_link_url
        self.invited_num = invited_num
        self.room_code = room_code
        self.start_time = start_time
        self.status = status
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_num is not None:
            result['ActiveNum'] = self.active_num
        if self.attend_num is not None:
            result['AttendNum'] = self.attend_num
        if self.conf_duration is not None:
            result['ConfDuration'] = self.conf_duration
        if self.conference_id is not None:
            result['ConferenceId'] = self.conference_id
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_nick is not None:
            result['CreatorNick'] = self.creator_nick
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.external_link_url is not None:
            result['ExternalLinkUrl'] = self.external_link_url
        if self.invited_num is not None:
            result['InvitedNum'] = self.invited_num
        if self.room_code is not None:
            result['RoomCode'] = self.room_code
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActiveNum') is not None:
            self.active_num = m.get('ActiveNum')
        if m.get('AttendNum') is not None:
            self.attend_num = m.get('AttendNum')
        if m.get('ConfDuration') is not None:
            self.conf_duration = m.get('ConfDuration')
        if m.get('ConferenceId') is not None:
            self.conference_id = m.get('ConferenceId')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorNick') is not None:
            self.creator_nick = m.get('CreatorNick')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExternalLinkUrl') is not None:
            self.external_link_url = m.get('ExternalLinkUrl')
        if m.get('InvitedNum') is not None:
            self.invited_num = m.get('InvitedNum')
        if m.get('RoomCode') is not None:
            self.room_code = m.get('RoomCode')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class QueryConferenceInfoResponseBody(TeaModel):
    def __init__(
        self,
        conf_info: QueryConferenceInfoResponseBodyConfInfo = None,
        request_id: str = None,
    ):
        self.conf_info = conf_info
        # requestId
        self.request_id = request_id

    def validate(self):
        if self.conf_info:
            self.conf_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conf_info is not None:
            result['confInfo'] = self.conf_info.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('confInfo') is not None:
            temp_model = QueryConferenceInfoResponseBodyConfInfo()
            self.conf_info = temp_model.from_map(m['confInfo'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class QueryConferenceInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryConferenceInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryConferenceInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryConferenceInfoByRoomCodeHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryConferenceInfoByRoomCodeHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryConferenceInfoByRoomCodeHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryConferenceInfoByRoomCodeHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryConferenceInfoByRoomCodeShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryConferenceInfoByRoomCodeRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryConferenceInfoByRoomCodeRequest(TeaModel):
    def __init__(
        self,
        tenant_context: QueryConferenceInfoByRoomCodeRequestTenantContext = None,
        max_results: int = None,
        next_token: str = None,
        room_code: str = None,
    ):
        self.tenant_context = tenant_context
        self.max_results = max_results
        # This parameter is required.
        self.next_token = next_token
        # This parameter is required.
        self.room_code = room_code

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.room_code is not None:
            result['roomCode'] = self.room_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = QueryConferenceInfoByRoomCodeRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('roomCode') is not None:
            self.room_code = m.get('roomCode')
        return self


class QueryConferenceInfoByRoomCodeShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        max_results: int = None,
        next_token: str = None,
        room_code: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        self.max_results = max_results
        # This parameter is required.
        self.next_token = next_token
        # This parameter is required.
        self.room_code = room_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.room_code is not None:
            result['roomCode'] = self.room_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('roomCode') is not None:
            self.room_code = m.get('roomCode')
        return self


class QueryConferenceInfoByRoomCodeResponseBodyConferenceList(TeaModel):
    def __init__(
        self,
        biz_type: str = None,
        conf_duration: int = None,
        conference_id: str = None,
        creator_id: str = None,
        creator_nick: str = None,
        end_time: int = None,
        external_link_url: str = None,
        room_code: str = None,
        schedule_conference_id: str = None,
        start_time: int = None,
        status: int = None,
        title: str = None,
    ):
        self.biz_type = biz_type
        self.conf_duration = conf_duration
        self.conference_id = conference_id
        self.creator_id = creator_id
        self.creator_nick = creator_nick
        self.end_time = end_time
        self.external_link_url = external_link_url
        self.room_code = room_code
        self.schedule_conference_id = schedule_conference_id
        self.start_time = start_time
        self.status = status
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.conf_duration is not None:
            result['ConfDuration'] = self.conf_duration
        if self.conference_id is not None:
            result['ConferenceId'] = self.conference_id
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_nick is not None:
            result['CreatorNick'] = self.creator_nick
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.external_link_url is not None:
            result['ExternalLinkUrl'] = self.external_link_url
        if self.room_code is not None:
            result['RoomCode'] = self.room_code
        if self.schedule_conference_id is not None:
            result['ScheduleConferenceId'] = self.schedule_conference_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('ConfDuration') is not None:
            self.conf_duration = m.get('ConfDuration')
        if m.get('ConferenceId') is not None:
            self.conference_id = m.get('ConferenceId')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorNick') is not None:
            self.creator_nick = m.get('CreatorNick')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExternalLinkUrl') is not None:
            self.external_link_url = m.get('ExternalLinkUrl')
        if m.get('RoomCode') is not None:
            self.room_code = m.get('RoomCode')
        if m.get('ScheduleConferenceId') is not None:
            self.schedule_conference_id = m.get('ScheduleConferenceId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class QueryConferenceInfoByRoomCodeResponseBody(TeaModel):
    def __init__(
        self,
        conference_list: List[QueryConferenceInfoByRoomCodeResponseBodyConferenceList] = None,
        dingtalk_request_id: str = None,
        has_more: bool = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.conference_list = conference_list
        self.dingtalk_request_id = dingtalk_request_id
        self.has_more = has_more
        self.next_token = next_token
        self.request_id = request_id
        self.total_count = total_count
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.conference_list:
            for k in self.conference_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['conferenceList'] = []
        if self.conference_list is not None:
            for k in self.conference_list:
                result['conferenceList'].append(k.to_map() if k else None)
        if self.dingtalk_request_id is not None:
            result['dingtalkRequestId'] = self.dingtalk_request_id
        if self.has_more is not None:
            result['hasMore'] = self.has_more
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.conference_list = []
        if m.get('conferenceList') is not None:
            for k in m.get('conferenceList'):
                temp_model = QueryConferenceInfoByRoomCodeResponseBodyConferenceList()
                self.conference_list.append(temp_model.from_map(k))
        if m.get('dingtalkRequestId') is not None:
            self.dingtalk_request_id = m.get('dingtalkRequestId')
        if m.get('hasMore') is not None:
            self.has_more = m.get('hasMore')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class QueryConferenceInfoByRoomCodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryConferenceInfoByRoomCodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryConferenceInfoByRoomCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryConferenceMembersHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryConferenceMembersHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryConferenceMembersHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryConferenceMembersHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryConferenceMembersShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryConferenceMembersRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryConferenceMembersRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        tenant_context: QueryConferenceMembersRequestTenantContext = None,
        conference_id: str = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.tenant_context = tenant_context
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('TenantContext') is not None:
            temp_model = QueryConferenceMembersRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class QueryConferenceMembersShrinkRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        tenant_context_shrink: str = None,
        conference_id: str = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class QueryConferenceMembersResponseBodyMemberModels(TeaModel):
    def __init__(
        self,
        attend_status: int = None,
        co_host: bool = None,
        conference_id: str = None,
        duration: int = None,
        host: bool = None,
        join_time: int = None,
        leave_time: int = None,
        outer_org_member: bool = None,
        pstn_join: bool = None,
        user_id: str = None,
        user_nick: str = None,
    ):
        self.attend_status = attend_status
        self.co_host = co_host
        self.conference_id = conference_id
        self.duration = duration
        self.host = host
        self.join_time = join_time
        self.leave_time = leave_time
        self.outer_org_member = outer_org_member
        self.pstn_join = pstn_join
        self.user_id = user_id
        self.user_nick = user_nick

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attend_status is not None:
            result['AttendStatus'] = self.attend_status
        if self.co_host is not None:
            result['CoHost'] = self.co_host
        if self.conference_id is not None:
            result['ConferenceId'] = self.conference_id
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.host is not None:
            result['Host'] = self.host
        if self.join_time is not None:
            result['JoinTime'] = self.join_time
        if self.leave_time is not None:
            result['LeaveTime'] = self.leave_time
        if self.outer_org_member is not None:
            result['OuterOrgMember'] = self.outer_org_member
        if self.pstn_join is not None:
            result['PstnJoin'] = self.pstn_join
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_nick is not None:
            result['UserNick'] = self.user_nick
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttendStatus') is not None:
            self.attend_status = m.get('AttendStatus')
        if m.get('CoHost') is not None:
            self.co_host = m.get('CoHost')
        if m.get('ConferenceId') is not None:
            self.conference_id = m.get('ConferenceId')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('JoinTime') is not None:
            self.join_time = m.get('JoinTime')
        if m.get('LeaveTime') is not None:
            self.leave_time = m.get('LeaveTime')
        if m.get('OuterOrgMember') is not None:
            self.outer_org_member = m.get('OuterOrgMember')
        if m.get('PstnJoin') is not None:
            self.pstn_join = m.get('PstnJoin')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserNick') is not None:
            self.user_nick = m.get('UserNick')
        return self


class QueryConferenceMembersResponseBody(TeaModel):
    def __init__(
        self,
        member_models: List[QueryConferenceMembersResponseBodyMemberModels] = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.member_models = member_models
        self.next_token = next_token
        # requestId
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.member_models:
            for k in self.member_models:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['memberModels'] = []
        if self.member_models is not None:
            for k in self.member_models:
                result['memberModels'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.member_models = []
        if m.get('memberModels') is not None:
            for k in m.get('memberModels'):
                temp_model = QueryConferenceMembersResponseBodyMemberModels()
                self.member_models.append(temp_model.from_map(k))
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class QueryConferenceMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryConferenceMembersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryConferenceMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDentriesInfoHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryDentriesInfoHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryDentriesInfoHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryDentriesInfoHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryDentriesInfoShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryDentriesInfoRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryDentriesInfoRequest(TeaModel):
    def __init__(
        self,
        app_ids_for_app_properties: List[str] = None,
        dentry_id: str = None,
        space_id: str = None,
        tenant_context: QueryDentriesInfoRequestTenantContext = None,
        union_id: str = None,
        with_thumbnail: bool = None,
    ):
        self.app_ids_for_app_properties = app_ids_for_app_properties
        # This parameter is required.
        self.dentry_id = dentry_id
        # This parameter is required.
        self.space_id = space_id
        self.tenant_context = tenant_context
        # This parameter is required.
        self.union_id = union_id
        self.with_thumbnail = with_thumbnail

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_ids_for_app_properties is not None:
            result['AppIdsForAppProperties'] = self.app_ids_for_app_properties
        if self.dentry_id is not None:
            result['DentryId'] = self.dentry_id
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.union_id is not None:
            result['UnionId'] = self.union_id
        if self.with_thumbnail is not None:
            result['WithThumbnail'] = self.with_thumbnail
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppIdsForAppProperties') is not None:
            self.app_ids_for_app_properties = m.get('AppIdsForAppProperties')
        if m.get('DentryId') is not None:
            self.dentry_id = m.get('DentryId')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('TenantContext') is not None:
            temp_model = QueryDentriesInfoRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('UnionId') is not None:
            self.union_id = m.get('UnionId')
        if m.get('WithThumbnail') is not None:
            self.with_thumbnail = m.get('WithThumbnail')
        return self


class QueryDentriesInfoShrinkRequest(TeaModel):
    def __init__(
        self,
        app_ids_for_app_properties_shrink: str = None,
        dentry_id: str = None,
        space_id: str = None,
        tenant_context_shrink: str = None,
        union_id: str = None,
        with_thumbnail: bool = None,
    ):
        self.app_ids_for_app_properties_shrink = app_ids_for_app_properties_shrink
        # This parameter is required.
        self.dentry_id = dentry_id
        # This parameter is required.
        self.space_id = space_id
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.union_id = union_id
        self.with_thumbnail = with_thumbnail

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_ids_for_app_properties_shrink is not None:
            result['AppIdsForAppProperties'] = self.app_ids_for_app_properties_shrink
        if self.dentry_id is not None:
            result['DentryId'] = self.dentry_id
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.union_id is not None:
            result['UnionId'] = self.union_id
        if self.with_thumbnail is not None:
            result['WithThumbnail'] = self.with_thumbnail
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppIdsForAppProperties') is not None:
            self.app_ids_for_app_properties_shrink = m.get('AppIdsForAppProperties')
        if m.get('DentryId') is not None:
            self.dentry_id = m.get('DentryId')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('UnionId') is not None:
            self.union_id = m.get('UnionId')
        if m.get('WithThumbnail') is not None:
            self.with_thumbnail = m.get('WithThumbnail')
        return self


class QueryDentriesInfoResponseBodyDentryProperties(TeaModel):
    def __init__(
        self,
        read_only: bool = None,
    ):
        self.read_only = read_only

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.read_only is not None:
            result['ReadOnly'] = self.read_only
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReadOnly') is not None:
            self.read_only = m.get('ReadOnly')
        return self


class QueryDentriesInfoResponseBodyDentryThumbnail(TeaModel):
    def __init__(
        self,
        height: int = None,
        url: str = None,
        width: int = None,
    ):
        self.height = height
        self.url = url
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryDentriesInfoResponseBodyDentry(TeaModel):
    def __init__(
        self,
        app_properties: Dict[str, List[DentryAppPropertiesValue]] = None,
        create_time: str = None,
        creator_id: str = None,
        extension: str = None,
        id: str = None,
        modified_time: str = None,
        modifier_id: str = None,
        name: str = None,
        parent_id: str = None,
        partition_type: str = None,
        path: str = None,
        properties: QueryDentriesInfoResponseBodyDentryProperties = None,
        size: int = None,
        space_id: str = None,
        status: str = None,
        storage_driver: str = None,
        thumbnail: QueryDentriesInfoResponseBodyDentryThumbnail = None,
        type: str = None,
        uuid: str = None,
        version: int = None,
    ):
        self.app_properties = app_properties
        self.create_time = create_time
        self.creator_id = creator_id
        self.extension = extension
        self.id = id
        self.modified_time = modified_time
        self.modifier_id = modifier_id
        self.name = name
        self.parent_id = parent_id
        self.partition_type = partition_type
        self.path = path
        self.properties = properties
        self.size = size
        self.space_id = space_id
        self.status = status
        self.storage_driver = storage_driver
        self.thumbnail = thumbnail
        self.type = type
        self.uuid = uuid
        self.version = version

    def validate(self):
        if self.app_properties:
            for v in self.app_properties.values():
                for k1 in v:
                    if k1:
                        k1.validate()
        if self.properties:
            self.properties.validate()
        if self.thumbnail:
            self.thumbnail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AppProperties'] = {}
        if self.app_properties is not None:
            for k, v in self.app_properties.items():
                l1 = []
                for k1 in v:
                    l1.append(k1.to_map() if k1 else None)
                result['AppProperties'][k] = l1
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.id is not None:
            result['Id'] = self.id
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.name is not None:
            result['Name'] = self.name
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.partition_type is not None:
            result['PartitionType'] = self.partition_type
        if self.path is not None:
            result['Path'] = self.path
        if self.properties is not None:
            result['Properties'] = self.properties.to_map()
        if self.size is not None:
            result['Size'] = self.size
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.status is not None:
            result['Status'] = self.status
        if self.storage_driver is not None:
            result['StorageDriver'] = self.storage_driver
        if self.thumbnail is not None:
            result['Thumbnail'] = self.thumbnail.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.app_properties = {}
        if m.get('AppProperties') is not None:
            for k, v in m.get('AppProperties').items():
                l1 = []
                for k1 in v:
                    temp_model = DentryAppPropertiesValue()
                    l1.append(temp_model.from_map(k1))
                self.app_properties['k'] = l1
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('PartitionType') is not None:
            self.partition_type = m.get('PartitionType')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Properties') is not None:
            temp_model = QueryDentriesInfoResponseBodyDentryProperties()
            self.properties = temp_model.from_map(m['Properties'])
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StorageDriver') is not None:
            self.storage_driver = m.get('StorageDriver')
        if m.get('Thumbnail') is not None:
            temp_model = QueryDentriesInfoResponseBodyDentryThumbnail()
            self.thumbnail = temp_model.from_map(m['Thumbnail'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class QueryDentriesInfoResponseBody(TeaModel):
    def __init__(
        self,
        dentry: QueryDentriesInfoResponseBodyDentry = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.dentry = dentry
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.dentry:
            self.dentry.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry is not None:
            result['Dentry'] = self.dentry.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dentry') is not None:
            temp_model = QueryDentriesInfoResponseBodyDentry()
            self.dentry = temp_model.from_map(m['Dentry'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class QueryDentriesInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDentriesInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDentriesInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDentryHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryDentryHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryDentryHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryDentryHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryDentryShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryDentryRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryDentryRequest(TeaModel):
    def __init__(
        self,
        dentry_id: str = None,
        include_space: bool = None,
        space_id: str = None,
        tenant_context: QueryDentryRequestTenantContext = None,
    ):
        # This parameter is required.
        self.dentry_id = dentry_id
        self.include_space = include_space
        # This parameter is required.
        self.space_id = space_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_id is not None:
            result['DentryId'] = self.dentry_id
        if self.include_space is not None:
            result['IncludeSpace'] = self.include_space
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryId') is not None:
            self.dentry_id = m.get('DentryId')
        if m.get('IncludeSpace') is not None:
            self.include_space = m.get('IncludeSpace')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('TenantContext') is not None:
            temp_model = QueryDentryRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class QueryDentryShrinkRequest(TeaModel):
    def __init__(
        self,
        dentry_id: str = None,
        include_space: bool = None,
        space_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.dentry_id = dentry_id
        self.include_space = include_space
        # This parameter is required.
        self.space_id = space_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_id is not None:
            result['DentryId'] = self.dentry_id
        if self.include_space is not None:
            result['IncludeSpace'] = self.include_space
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryId') is not None:
            self.dentry_id = m.get('DentryId')
        if m.get('IncludeSpace') is not None:
            self.include_space = m.get('IncludeSpace')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class QueryDentryResponseBodyCreator(TeaModel):
    def __init__(
        self,
        name: str = None,
        user_id: str = None,
    ):
        self.name = name
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class QueryDentryResponseBodyLinkSourceInfoIconUrl(TeaModel):
    def __init__(
        self,
        line: str = None,
        small: str = None,
    ):
        self.line = line
        self.small = small

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.line is not None:
            result['Line'] = self.line
        if self.small is not None:
            result['Small'] = self.small
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Line') is not None:
            self.line = m.get('Line')
        if m.get('Small') is not None:
            self.small = m.get('Small')
        return self


class QueryDentryResponseBodyLinkSourceInfo(TeaModel):
    def __init__(
        self,
        extension: str = None,
        icon_url: QueryDentryResponseBodyLinkSourceInfoIconUrl = None,
        id: str = None,
        link_type: int = None,
        space_id: str = None,
    ):
        self.extension = extension
        self.icon_url = icon_url
        self.id = id
        self.link_type = link_type
        self.space_id = space_id

    def validate(self):
        if self.icon_url:
            self.icon_url.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.icon_url is not None:
            result['IconUrl'] = self.icon_url.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.link_type is not None:
            result['LinkType'] = self.link_type
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('IconUrl') is not None:
            temp_model = QueryDentryResponseBodyLinkSourceInfoIconUrl()
            self.icon_url = temp_model.from_map(m['IconUrl'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LinkType') is not None:
            self.link_type = m.get('LinkType')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        return self


class QueryDentryResponseBodySpaceHdIconVO(TeaModel):
    def __init__(
        self,
        icon: str = None,
        type: str = None,
    ):
        self.icon = icon
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryDentryResponseBodySpaceIconVO(TeaModel):
    def __init__(
        self,
        icon: str = None,
        type: str = None,
    ):
        self.icon = icon
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryDentryResponseBodySpaceOwner(TeaModel):
    def __init__(
        self,
        name: str = None,
        user_id: str = None,
    ):
        self.name = name
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class QueryDentryResponseBodySpaceRecentListCreator(TeaModel):
    def __init__(
        self,
        name: str = None,
        user_id: str = None,
    ):
        self.name = name
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl(TeaModel):
    def __init__(
        self,
        line: str = None,
        small: str = None,
    ):
        self.line = line
        self.small = small

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.line is not None:
            result['Line'] = self.line
        if self.small is not None:
            result['Small'] = self.small
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Line') is not None:
            self.line = m.get('Line')
        if m.get('Small') is not None:
            self.small = m.get('Small')
        return self


class QueryDentryResponseBodySpaceRecentListLinkSourceInfo(TeaModel):
    def __init__(
        self,
        extension: str = None,
        icon_url: QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl = None,
        id: str = None,
        link_type: int = None,
        space_id: str = None,
    ):
        self.extension = extension
        self.icon_url = icon_url
        self.id = id
        self.link_type = link_type
        self.space_id = space_id

    def validate(self):
        if self.icon_url:
            self.icon_url.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.icon_url is not None:
            result['IconUrl'] = self.icon_url.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.link_type is not None:
            result['LinkType'] = self.link_type
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('IconUrl') is not None:
            temp_model = QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl()
            self.icon_url = temp_model.from_map(m['IconUrl'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LinkType') is not None:
            self.link_type = m.get('LinkType')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        return self


class QueryDentryResponseBodySpaceRecentListStatisticalInfo(TeaModel):
    def __init__(
        self,
        word_count: int = None,
    ):
        self.word_count = word_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.word_count is not None:
            result['WordCount'] = self.word_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WordCount') is not None:
            self.word_count = m.get('WordCount')
        return self


class QueryDentryResponseBodySpaceRecentListUpdater(TeaModel):
    def __init__(
        self,
        name: str = None,
        user_id: str = None,
    ):
        self.name = name
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class QueryDentryResponseBodySpaceRecentListVisitorInfo(TeaModel):
    def __init__(
        self,
        dentry_actions: List[str] = None,
        role_code: str = None,
        space_actions: List[str] = None,
    ):
        self.dentry_actions = dentry_actions
        self.role_code = role_code
        self.space_actions = space_actions

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_actions is not None:
            result['DentryActions'] = self.dentry_actions
        if self.role_code is not None:
            result['RoleCode'] = self.role_code
        if self.space_actions is not None:
            result['SpaceActions'] = self.space_actions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryActions') is not None:
            self.dentry_actions = m.get('DentryActions')
        if m.get('RoleCode') is not None:
            self.role_code = m.get('RoleCode')
        if m.get('SpaceActions') is not None:
            self.space_actions = m.get('SpaceActions')
        return self


class QueryDentryResponseBodySpaceRecentList(TeaModel):
    def __init__(
        self,
        content_type: str = None,
        created_time: int = None,
        creator: QueryDentryResponseBodySpaceRecentListCreator = None,
        dentry_id: str = None,
        dentry_type: str = None,
        dentry_uuid: str = None,
        doc_key: str = None,
        extension: str = None,
        has_children: bool = None,
        link_source_info: QueryDentryResponseBodySpaceRecentListLinkSourceInfo = None,
        name: str = None,
        path: str = None,
        space: Any = None,
        space_id: str = None,
        statistical_info: QueryDentryResponseBodySpaceRecentListStatisticalInfo = None,
        updated_time: int = None,
        updater: QueryDentryResponseBodySpaceRecentListUpdater = None,
        url: str = None,
        visitor_info: QueryDentryResponseBodySpaceRecentListVisitorInfo = None,
    ):
        self.content_type = content_type
        self.created_time = created_time
        self.creator = creator
        self.dentry_id = dentry_id
        self.dentry_type = dentry_type
        self.dentry_uuid = dentry_uuid
        self.doc_key = doc_key
        self.extension = extension
        self.has_children = has_children
        self.link_source_info = link_source_info
        self.name = name
        self.path = path
        self.space = space
        self.space_id = space_id
        self.statistical_info = statistical_info
        self.updated_time = updated_time
        self.updater = updater
        self.url = url
        self.visitor_info = visitor_info

    def validate(self):
        if self.creator:
            self.creator.validate()
        if self.link_source_info:
            self.link_source_info.validate()
        if self.statistical_info:
            self.statistical_info.validate()
        if self.updater:
            self.updater.validate()
        if self.visitor_info:
            self.visitor_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['ContentType'] = self.content_type
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.creator is not None:
            result['Creator'] = self.creator.to_map()
        if self.dentry_id is not None:
            result['DentryId'] = self.dentry_id
        if self.dentry_type is not None:
            result['DentryType'] = self.dentry_type
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        if self.doc_key is not None:
            result['DocKey'] = self.doc_key
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.has_children is not None:
            result['HasChildren'] = self.has_children
        if self.link_source_info is not None:
            result['LinkSourceInfo'] = self.link_source_info.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.path is not None:
            result['Path'] = self.path
        if self.space is not None:
            result['Space'] = self.space
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.statistical_info is not None:
            result['StatisticalInfo'] = self.statistical_info.to_map()
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        if self.updater is not None:
            result['Updater'] = self.updater.to_map()
        if self.url is not None:
            result['Url'] = self.url
        if self.visitor_info is not None:
            result['VisitorInfo'] = self.visitor_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContentType') is not None:
            self.content_type = m.get('ContentType')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Creator') is not None:
            temp_model = QueryDentryResponseBodySpaceRecentListCreator()
            self.creator = temp_model.from_map(m['Creator'])
        if m.get('DentryId') is not None:
            self.dentry_id = m.get('DentryId')
        if m.get('DentryType') is not None:
            self.dentry_type = m.get('DentryType')
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        if m.get('DocKey') is not None:
            self.doc_key = m.get('DocKey')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('HasChildren') is not None:
            self.has_children = m.get('HasChildren')
        if m.get('LinkSourceInfo') is not None:
            temp_model = QueryDentryResponseBodySpaceRecentListLinkSourceInfo()
            self.link_source_info = temp_model.from_map(m['LinkSourceInfo'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Space') is not None:
            self.space = m.get('Space')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('StatisticalInfo') is not None:
            temp_model = QueryDentryResponseBodySpaceRecentListStatisticalInfo()
            self.statistical_info = temp_model.from_map(m['StatisticalInfo'])
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        if m.get('Updater') is not None:
            temp_model = QueryDentryResponseBodySpaceRecentListUpdater()
            self.updater = temp_model.from_map(m['Updater'])
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('VisitorInfo') is not None:
            temp_model = QueryDentryResponseBodySpaceRecentListVisitorInfo()
            self.visitor_info = temp_model.from_map(m['VisitorInfo'])
        return self


class QueryDentryResponseBodySpaceVisitorInfo(TeaModel):
    def __init__(
        self,
        dentry_actions: List[str] = None,
        role_code: str = None,
        space_actions: List[str] = None,
    ):
        self.dentry_actions = dentry_actions
        self.role_code = role_code
        self.space_actions = space_actions

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_actions is not None:
            result['DentryActions'] = self.dentry_actions
        if self.role_code is not None:
            result['RoleCode'] = self.role_code
        if self.space_actions is not None:
            result['SpaceActions'] = self.space_actions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryActions') is not None:
            self.dentry_actions = m.get('DentryActions')
        if m.get('RoleCode') is not None:
            self.role_code = m.get('RoleCode')
        if m.get('SpaceActions') is not None:
            self.space_actions = m.get('SpaceActions')
        return self


class QueryDentryResponseBodySpace(TeaModel):
    def __init__(
        self,
        cover: str = None,
        description: str = None,
        hd_icon_vo: QueryDentryResponseBodySpaceHdIconVO = None,
        icon_vo: QueryDentryResponseBodySpaceIconVO = None,
        id: str = None,
        name: str = None,
        owner: QueryDentryResponseBodySpaceOwner = None,
        recent_list: List[QueryDentryResponseBodySpaceRecentList] = None,
        type: int = None,
        url: str = None,
        visitor_info: QueryDentryResponseBodySpaceVisitorInfo = None,
    ):
        self.cover = cover
        self.description = description
        self.hd_icon_vo = hd_icon_vo
        self.icon_vo = icon_vo
        self.id = id
        self.name = name
        self.owner = owner
        self.recent_list = recent_list
        self.type = type
        self.url = url
        self.visitor_info = visitor_info

    def validate(self):
        if self.hd_icon_vo:
            self.hd_icon_vo.validate()
        if self.icon_vo:
            self.icon_vo.validate()
        if self.owner:
            self.owner.validate()
        if self.recent_list:
            for k in self.recent_list:
                if k:
                    k.validate()
        if self.visitor_info:
            self.visitor_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cover is not None:
            result['Cover'] = self.cover
        if self.description is not None:
            result['Description'] = self.description
        if self.hd_icon_vo is not None:
            result['HdIconVO'] = self.hd_icon_vo.to_map()
        if self.icon_vo is not None:
            result['IconVO'] = self.icon_vo.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner.to_map()
        result['RecentList'] = []
        if self.recent_list is not None:
            for k in self.recent_list:
                result['RecentList'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        if self.visitor_info is not None:
            result['VisitorInfo'] = self.visitor_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cover') is not None:
            self.cover = m.get('Cover')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('HdIconVO') is not None:
            temp_model = QueryDentryResponseBodySpaceHdIconVO()
            self.hd_icon_vo = temp_model.from_map(m['HdIconVO'])
        if m.get('IconVO') is not None:
            temp_model = QueryDentryResponseBodySpaceIconVO()
            self.icon_vo = temp_model.from_map(m['IconVO'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            temp_model = QueryDentryResponseBodySpaceOwner()
            self.owner = temp_model.from_map(m['Owner'])
        self.recent_list = []
        if m.get('RecentList') is not None:
            for k in m.get('RecentList'):
                temp_model = QueryDentryResponseBodySpaceRecentList()
                self.recent_list.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('VisitorInfo') is not None:
            temp_model = QueryDentryResponseBodySpaceVisitorInfo()
            self.visitor_info = temp_model.from_map(m['VisitorInfo'])
        return self


class QueryDentryResponseBodyUpdater(TeaModel):
    def __init__(
        self,
        name: str = None,
        user_id: str = None,
    ):
        self.name = name
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class QueryDentryResponseBodyVisitorInfo(TeaModel):
    def __init__(
        self,
        dentry_actions: List[str] = None,
        role_code: str = None,
        space_actions: List[str] = None,
    ):
        self.dentry_actions = dentry_actions
        self.role_code = role_code
        self.space_actions = space_actions

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_actions is not None:
            result['DentryActions'] = self.dentry_actions
        if self.role_code is not None:
            result['RoleCode'] = self.role_code
        if self.space_actions is not None:
            result['SpaceActions'] = self.space_actions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryActions') is not None:
            self.dentry_actions = m.get('DentryActions')
        if m.get('RoleCode') is not None:
            self.role_code = m.get('RoleCode')
        if m.get('SpaceActions') is not None:
            self.space_actions = m.get('SpaceActions')
        return self


class QueryDentryResponseBody(TeaModel):
    def __init__(
        self,
        content_type: str = None,
        created_time: int = None,
        creator: QueryDentryResponseBodyCreator = None,
        dentry_id: str = None,
        dentry_type: str = None,
        dentry_uuid: str = None,
        doc_key: str = None,
        extension: str = None,
        has_children: bool = None,
        link_source_info: QueryDentryResponseBodyLinkSourceInfo = None,
        name: str = None,
        path: str = None,
        request_id: str = None,
        space: QueryDentryResponseBodySpace = None,
        space_id: str = None,
        updated_time: int = None,
        updater: QueryDentryResponseBodyUpdater = None,
        url: str = None,
        visitor_info: QueryDentryResponseBodyVisitorInfo = None,
    ):
        self.content_type = content_type
        self.created_time = created_time
        self.creator = creator
        self.dentry_id = dentry_id
        self.dentry_type = dentry_type
        self.dentry_uuid = dentry_uuid
        self.doc_key = doc_key
        self.extension = extension
        self.has_children = has_children
        self.link_source_info = link_source_info
        self.name = name
        self.path = path
        # requestId
        self.request_id = request_id
        self.space = space
        self.space_id = space_id
        self.updated_time = updated_time
        self.updater = updater
        self.url = url
        self.visitor_info = visitor_info

    def validate(self):
        if self.creator:
            self.creator.validate()
        if self.link_source_info:
            self.link_source_info.validate()
        if self.space:
            self.space.validate()
        if self.updater:
            self.updater.validate()
        if self.visitor_info:
            self.visitor_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['contentType'] = self.content_type
        if self.created_time is not None:
            result['createdTime'] = self.created_time
        if self.creator is not None:
            result['creator'] = self.creator.to_map()
        if self.dentry_id is not None:
            result['dentryId'] = self.dentry_id
        if self.dentry_type is not None:
            result['dentryType'] = self.dentry_type
        if self.dentry_uuid is not None:
            result['dentryUuid'] = self.dentry_uuid
        if self.doc_key is not None:
            result['docKey'] = self.doc_key
        if self.extension is not None:
            result['extension'] = self.extension
        if self.has_children is not None:
            result['hasChildren'] = self.has_children
        if self.link_source_info is not None:
            result['linkSourceInfo'] = self.link_source_info.to_map()
        if self.name is not None:
            result['name'] = self.name
        if self.path is not None:
            result['path'] = self.path
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.space is not None:
            result['space'] = self.space.to_map()
        if self.space_id is not None:
            result['spaceId'] = self.space_id
        if self.updated_time is not None:
            result['updatedTime'] = self.updated_time
        if self.updater is not None:
            result['updater'] = self.updater.to_map()
        if self.url is not None:
            result['url'] = self.url
        if self.visitor_info is not None:
            result['visitorInfo'] = self.visitor_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contentType') is not None:
            self.content_type = m.get('contentType')
        if m.get('createdTime') is not None:
            self.created_time = m.get('createdTime')
        if m.get('creator') is not None:
            temp_model = QueryDentryResponseBodyCreator()
            self.creator = temp_model.from_map(m['creator'])
        if m.get('dentryId') is not None:
            self.dentry_id = m.get('dentryId')
        if m.get('dentryType') is not None:
            self.dentry_type = m.get('dentryType')
        if m.get('dentryUuid') is not None:
            self.dentry_uuid = m.get('dentryUuid')
        if m.get('docKey') is not None:
            self.doc_key = m.get('docKey')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('hasChildren') is not None:
            self.has_children = m.get('hasChildren')
        if m.get('linkSourceInfo') is not None:
            temp_model = QueryDentryResponseBodyLinkSourceInfo()
            self.link_source_info = temp_model.from_map(m['linkSourceInfo'])
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('space') is not None:
            temp_model = QueryDentryResponseBodySpace()
            self.space = temp_model.from_map(m['space'])
        if m.get('spaceId') is not None:
            self.space_id = m.get('spaceId')
        if m.get('updatedTime') is not None:
            self.updated_time = m.get('updatedTime')
        if m.get('updater') is not None:
            temp_model = QueryDentryResponseBodyUpdater()
            self.updater = temp_model.from_map(m['updater'])
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('visitorInfo') is not None:
            temp_model = QueryDentryResponseBodyVisitorInfo()
            self.visitor_info = temp_model.from_map(m['visitorInfo'])
        return self


class QueryDentryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDentryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDentryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryGroupLiveInfoHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryGroupLiveInfoHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryGroupLiveInfoHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryGroupLiveInfoHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryGroupLiveInfoShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryGroupLiveInfoRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryGroupLiveInfoRequest(TeaModel):
    def __init__(
        self,
        anchor_union_id: str = None,
        live_uuid: str = None,
        tenant_context: QueryGroupLiveInfoRequestTenantContext = None,
    ):
        # This parameter is required.
        self.anchor_union_id = anchor_union_id
        # This parameter is required.
        self.live_uuid = live_uuid
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.anchor_union_id is not None:
            result['AnchorUnionId'] = self.anchor_union_id
        if self.live_uuid is not None:
            result['LiveUuid'] = self.live_uuid
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnchorUnionId') is not None:
            self.anchor_union_id = m.get('AnchorUnionId')
        if m.get('LiveUuid') is not None:
            self.live_uuid = m.get('LiveUuid')
        if m.get('TenantContext') is not None:
            temp_model = QueryGroupLiveInfoRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class QueryGroupLiveInfoShrinkRequest(TeaModel):
    def __init__(
        self,
        anchor_union_id: str = None,
        live_uuid: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.anchor_union_id = anchor_union_id
        # This parameter is required.
        self.live_uuid = live_uuid
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.anchor_union_id is not None:
            result['AnchorUnionId'] = self.anchor_union_id
        if self.live_uuid is not None:
            result['LiveUuid'] = self.live_uuid
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnchorUnionId') is not None:
            self.anchor_union_id = m.get('AnchorUnionId')
        if m.get('LiveUuid') is not None:
            self.live_uuid = m.get('LiveUuid')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class QueryGroupLiveInfoResponseBody(TeaModel):
    def __init__(
        self,
        cover_url: str = None,
        duration: int = None,
        end_time: int = None,
        introduction: str = None,
        live_id: str = None,
        live_play_url: str = None,
        live_status: int = None,
        playback_duration: int = None,
        replay_url: str = None,
        request_id: str = None,
        staff_id: str = None,
        start_time: int = None,
        subscribe_count: int = None,
        title: str = None,
        uv: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.cover_url = cover_url
        self.duration = duration
        self.end_time = end_time
        self.introduction = introduction
        self.live_id = live_id
        self.live_play_url = live_play_url
        self.live_status = live_status
        self.playback_duration = playback_duration
        self.replay_url = replay_url
        # requestId
        self.request_id = request_id
        self.staff_id = staff_id
        self.start_time = start_time
        self.subscribe_count = subscribe_count
        self.title = title
        self.uv = uv
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cover_url is not None:
            result['coverUrl'] = self.cover_url
        if self.duration is not None:
            result['duration'] = self.duration
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.introduction is not None:
            result['introduction'] = self.introduction
        if self.live_id is not None:
            result['liveId'] = self.live_id
        if self.live_play_url is not None:
            result['livePlayUrl'] = self.live_play_url
        if self.live_status is not None:
            result['liveStatus'] = self.live_status
        if self.playback_duration is not None:
            result['playbackDuration'] = self.playback_duration
        if self.replay_url is not None:
            result['replayUrl'] = self.replay_url
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.staff_id is not None:
            result['staffId'] = self.staff_id
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.subscribe_count is not None:
            result['subscribeCount'] = self.subscribe_count
        if self.title is not None:
            result['title'] = self.title
        if self.uv is not None:
            result['uv'] = self.uv
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('coverUrl') is not None:
            self.cover_url = m.get('coverUrl')
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('introduction') is not None:
            self.introduction = m.get('introduction')
        if m.get('liveId') is not None:
            self.live_id = m.get('liveId')
        if m.get('livePlayUrl') is not None:
            self.live_play_url = m.get('livePlayUrl')
        if m.get('liveStatus') is not None:
            self.live_status = m.get('liveStatus')
        if m.get('playbackDuration') is not None:
            self.playback_duration = m.get('playbackDuration')
        if m.get('replayUrl') is not None:
            self.replay_url = m.get('replayUrl')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('staffId') is not None:
            self.staff_id = m.get('staffId')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('subscribeCount') is not None:
            self.subscribe_count = m.get('subscribeCount')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('uv') is not None:
            self.uv = m.get('uv')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class QueryGroupLiveInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryGroupLiveInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryGroupLiveInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryLiveInfoHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryLiveInfoHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryLiveInfoHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryLiveInfoHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryLiveInfoShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryLiveInfoRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryLiveInfoRequest(TeaModel):
    def __init__(
        self,
        live_id: str = None,
        tenant_context: QueryLiveInfoRequestTenantContext = None,
    ):
        # This parameter is required.
        self.live_id = live_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_id is not None:
            result['LiveId'] = self.live_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveId') is not None:
            self.live_id = m.get('LiveId')
        if m.get('TenantContext') is not None:
            temp_model = QueryLiveInfoRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class QueryLiveInfoShrinkRequest(TeaModel):
    def __init__(
        self,
        live_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.live_id = live_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_id is not None:
            result['LiveId'] = self.live_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveId') is not None:
            self.live_id = m.get('LiveId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class QueryLiveInfoResponseBody(TeaModel):
    def __init__(
        self,
        cover_url: str = None,
        duration: int = None,
        end_time: int = None,
        introduction: str = None,
        live_id: str = None,
        live_play_url: str = None,
        live_status: int = None,
        playback_duration: int = None,
        request_id: str = None,
        start_time: int = None,
        subscribe_count: int = None,
        title: str = None,
        uv: int = None,
    ):
        self.cover_url = cover_url
        self.duration = duration
        self.end_time = end_time
        self.introduction = introduction
        self.live_id = live_id
        self.live_play_url = live_play_url
        self.live_status = live_status
        self.playback_duration = playback_duration
        # requestId
        self.request_id = request_id
        self.start_time = start_time
        self.subscribe_count = subscribe_count
        self.title = title
        self.uv = uv

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cover_url is not None:
            result['coverUrl'] = self.cover_url
        if self.duration is not None:
            result['duration'] = self.duration
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.introduction is not None:
            result['introduction'] = self.introduction
        if self.live_id is not None:
            result['liveId'] = self.live_id
        if self.live_play_url is not None:
            result['livePlayUrl'] = self.live_play_url
        if self.live_status is not None:
            result['liveStatus'] = self.live_status
        if self.playback_duration is not None:
            result['playbackDuration'] = self.playback_duration
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.subscribe_count is not None:
            result['subscribeCount'] = self.subscribe_count
        if self.title is not None:
            result['title'] = self.title
        if self.uv is not None:
            result['uv'] = self.uv
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('coverUrl') is not None:
            self.cover_url = m.get('coverUrl')
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('introduction') is not None:
            self.introduction = m.get('introduction')
        if m.get('liveId') is not None:
            self.live_id = m.get('liveId')
        if m.get('livePlayUrl') is not None:
            self.live_play_url = m.get('livePlayUrl')
        if m.get('liveStatus') is not None:
            self.live_status = m.get('liveStatus')
        if m.get('playbackDuration') is not None:
            self.playback_duration = m.get('playbackDuration')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('subscribeCount') is not None:
            self.subscribe_count = m.get('subscribeCount')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('uv') is not None:
            self.uv = m.get('uv')
        return self


class QueryLiveInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryLiveInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryLiveInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryLiveWatchDetailHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryLiveWatchDetailHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryLiveWatchDetailHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryLiveWatchDetailHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryLiveWatchDetailShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryLiveWatchDetailRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryLiveWatchDetailRequest(TeaModel):
    def __init__(
        self,
        live_id: str = None,
        tenant_context: QueryLiveWatchDetailRequestTenantContext = None,
    ):
        # This parameter is required.
        self.live_id = live_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_id is not None:
            result['LiveId'] = self.live_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveId') is not None:
            self.live_id = m.get('LiveId')
        if m.get('TenantContext') is not None:
            temp_model = QueryLiveWatchDetailRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class QueryLiveWatchDetailShrinkRequest(TeaModel):
    def __init__(
        self,
        live_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.live_id = live_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_id is not None:
            result['LiveId'] = self.live_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveId') is not None:
            self.live_id = m.get('LiveId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class QueryLiveWatchDetailResponseBody(TeaModel):
    def __init__(
        self,
        avg_watch_time: int = None,
        live_uv: int = None,
        msg_count: int = None,
        playback_uv: int = None,
        praise_count: int = None,
        pv: int = None,
        request_id: str = None,
        total_watch_time: int = None,
        uv: int = None,
    ):
        self.avg_watch_time = avg_watch_time
        self.live_uv = live_uv
        self.msg_count = msg_count
        self.playback_uv = playback_uv
        self.praise_count = praise_count
        self.pv = pv
        # requestId
        self.request_id = request_id
        self.total_watch_time = total_watch_time
        self.uv = uv

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_watch_time is not None:
            result['avgWatchTime'] = self.avg_watch_time
        if self.live_uv is not None:
            result['liveUv'] = self.live_uv
        if self.msg_count is not None:
            result['msgCount'] = self.msg_count
        if self.playback_uv is not None:
            result['playbackUv'] = self.playback_uv
        if self.praise_count is not None:
            result['praiseCount'] = self.praise_count
        if self.pv is not None:
            result['pv'] = self.pv
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_watch_time is not None:
            result['totalWatchTime'] = self.total_watch_time
        if self.uv is not None:
            result['uv'] = self.uv
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avgWatchTime') is not None:
            self.avg_watch_time = m.get('avgWatchTime')
        if m.get('liveUv') is not None:
            self.live_uv = m.get('liveUv')
        if m.get('msgCount') is not None:
            self.msg_count = m.get('msgCount')
        if m.get('playbackUv') is not None:
            self.playback_uv = m.get('playbackUv')
        if m.get('praiseCount') is not None:
            self.praise_count = m.get('praiseCount')
        if m.get('pv') is not None:
            self.pv = m.get('pv')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalWatchTime') is not None:
            self.total_watch_time = m.get('totalWatchTime')
        if m.get('uv') is not None:
            self.uv = m.get('uv')
        return self


class QueryLiveWatchDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryLiveWatchDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryLiveWatchDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryLiveWatchUserListHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryLiveWatchUserListHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryLiveWatchUserListHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryLiveWatchUserListHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryLiveWatchUserListShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryLiveWatchUserListRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryLiveWatchUserListRequest(TeaModel):
    def __init__(
        self,
        live_id: str = None,
        page_number: int = None,
        page_size: int = None,
        tenant_context: QueryLiveWatchUserListRequestTenantContext = None,
    ):
        # This parameter is required.
        self.live_id = live_id
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_id is not None:
            result['LiveId'] = self.live_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveId') is not None:
            self.live_id = m.get('LiveId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TenantContext') is not None:
            temp_model = QueryLiveWatchUserListRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class QueryLiveWatchUserListShrinkRequest(TeaModel):
    def __init__(
        self,
        live_id: str = None,
        page_number: int = None,
        page_size: int = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.live_id = live_id
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_id is not None:
            result['LiveId'] = self.live_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveId') is not None:
            self.live_id = m.get('LiveId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class QueryLiveWatchUserListResponseBodyOrgUsesList(TeaModel):
    def __init__(
        self,
        dept_name: str = None,
        name: str = None,
        user_id: str = None,
        watch_live_time: int = None,
        watch_playback_time: int = None,
        watch_progress_ms: int = None,
    ):
        self.dept_name = dept_name
        self.name = name
        self.user_id = user_id
        self.watch_live_time = watch_live_time
        self.watch_playback_time = watch_playback_time
        self.watch_progress_ms = watch_progress_ms

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dept_name is not None:
            result['DeptName'] = self.dept_name
        if self.name is not None:
            result['Name'] = self.name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.watch_live_time is not None:
            result['WatchLiveTime'] = self.watch_live_time
        if self.watch_playback_time is not None:
            result['WatchPlaybackTime'] = self.watch_playback_time
        if self.watch_progress_ms is not None:
            result['WatchProgressMs'] = self.watch_progress_ms
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeptName') is not None:
            self.dept_name = m.get('DeptName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('WatchLiveTime') is not None:
            self.watch_live_time = m.get('WatchLiveTime')
        if m.get('WatchPlaybackTime') is not None:
            self.watch_playback_time = m.get('WatchPlaybackTime')
        if m.get('WatchProgressMs') is not None:
            self.watch_progress_ms = m.get('WatchProgressMs')
        return self


class QueryLiveWatchUserListResponseBodyOutOrgUserList(TeaModel):
    def __init__(
        self,
        name: str = None,
        watch_live_time: int = None,
        watch_playback_time: int = None,
        watch_progress_ms: int = None,
    ):
        self.name = name
        self.watch_live_time = watch_live_time
        self.watch_playback_time = watch_playback_time
        self.watch_progress_ms = watch_progress_ms

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.watch_live_time is not None:
            result['WatchLiveTime'] = self.watch_live_time
        if self.watch_playback_time is not None:
            result['WatchPlaybackTime'] = self.watch_playback_time
        if self.watch_progress_ms is not None:
            result['WatchProgressMs'] = self.watch_progress_ms
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('WatchLiveTime') is not None:
            self.watch_live_time = m.get('WatchLiveTime')
        if m.get('WatchPlaybackTime') is not None:
            self.watch_playback_time = m.get('WatchPlaybackTime')
        if m.get('WatchProgressMs') is not None:
            self.watch_progress_ms = m.get('WatchProgressMs')
        return self


class QueryLiveWatchUserListResponseBody(TeaModel):
    def __init__(
        self,
        org_uses_list: List[QueryLiveWatchUserListResponseBodyOrgUsesList] = None,
        out_org_user_list: List[QueryLiveWatchUserListResponseBodyOutOrgUserList] = None,
        request_id: str = None,
    ):
        self.org_uses_list = org_uses_list
        self.out_org_user_list = out_org_user_list
        # requestId
        self.request_id = request_id

    def validate(self):
        if self.org_uses_list:
            for k in self.org_uses_list:
                if k:
                    k.validate()
        if self.out_org_user_list:
            for k in self.out_org_user_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['orgUsesList'] = []
        if self.org_uses_list is not None:
            for k in self.org_uses_list:
                result['orgUsesList'].append(k.to_map() if k else None)
        result['outOrgUserList'] = []
        if self.out_org_user_list is not None:
            for k in self.out_org_user_list:
                result['outOrgUserList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.org_uses_list = []
        if m.get('orgUsesList') is not None:
            for k in m.get('orgUsesList'):
                temp_model = QueryLiveWatchUserListResponseBodyOrgUsesList()
                self.org_uses_list.append(temp_model.from_map(k))
        self.out_org_user_list = []
        if m.get('outOrgUserList') is not None:
            for k in m.get('outOrgUserList'):
                temp_model = QueryLiveWatchUserListResponseBodyOutOrgUserList()
                self.out_org_user_list.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class QueryLiveWatchUserListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryLiveWatchUserListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryLiveWatchUserListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMeetingRoomHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryMeetingRoomHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryMeetingRoomHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryMeetingRoomHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryMeetingRoomShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryMeetingRoomRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryMeetingRoomRequest(TeaModel):
    def __init__(
        self,
        room_id: str = None,
        tenant_context: QueryMeetingRoomRequestTenantContext = None,
    ):
        # This parameter is required.
        self.room_id = room_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.room_id is not None:
            result['RoomId'] = self.room_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RoomId') is not None:
            self.room_id = m.get('RoomId')
        if m.get('TenantContext') is not None:
            temp_model = QueryMeetingRoomRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class QueryMeetingRoomShrinkRequest(TeaModel):
    def __init__(
        self,
        room_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.room_id = room_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.room_id is not None:
            result['RoomId'] = self.room_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RoomId') is not None:
            self.room_id = m.get('RoomId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class QueryMeetingRoomResponseBodyResultReservationAuthorityAuthorizedMembers(TeaModel):
    def __init__(
        self,
        member_id: str = None,
        member_name: str = None,
        member_type: str = None,
    ):
        self.member_id = member_id
        self.member_name = member_name
        self.member_type = member_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.member_id is not None:
            result['MemberId'] = self.member_id
        if self.member_name is not None:
            result['MemberName'] = self.member_name
        if self.member_type is not None:
            result['MemberType'] = self.member_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemberId') is not None:
            self.member_id = m.get('MemberId')
        if m.get('MemberName') is not None:
            self.member_name = m.get('MemberName')
        if m.get('MemberType') is not None:
            self.member_type = m.get('MemberType')
        return self


class QueryMeetingRoomResponseBodyResultReservationAuthority(TeaModel):
    def __init__(
        self,
        authorized_members: List[QueryMeetingRoomResponseBodyResultReservationAuthorityAuthorizedMembers] = None,
    ):
        self.authorized_members = authorized_members

    def validate(self):
        if self.authorized_members:
            for k in self.authorized_members:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AuthorizedMembers'] = []
        if self.authorized_members is not None:
            for k in self.authorized_members:
                result['AuthorizedMembers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.authorized_members = []
        if m.get('AuthorizedMembers') is not None:
            for k in m.get('AuthorizedMembers'):
                temp_model = QueryMeetingRoomResponseBodyResultReservationAuthorityAuthorizedMembers()
                self.authorized_members.append(temp_model.from_map(k))
        return self


class QueryMeetingRoomResponseBodyResultRoomGroup(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        group_name: str = None,
        parent_id: int = None,
    ):
        self.group_id = group_id
        self.group_name = group_name
        self.parent_id = parent_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        return self


class QueryMeetingRoomResponseBodyResultRoomLabels(TeaModel):
    def __init__(
        self,
        label_id: int = None,
        label_name: str = None,
    ):
        self.label_id = label_id
        self.label_name = label_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label_id is not None:
            result['LabelId'] = self.label_id
        if self.label_name is not None:
            result['LabelName'] = self.label_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LabelId') is not None:
            self.label_id = m.get('LabelId')
        if m.get('LabelName') is not None:
            self.label_name = m.get('LabelName')
        return self


class QueryMeetingRoomResponseBodyResultRoomLocation(TeaModel):
    def __init__(
        self,
        desc: str = None,
        title: str = None,
    ):
        self.desc = desc
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class QueryMeetingRoomResponseBodyResult(TeaModel):
    def __init__(
        self,
        corp_id: str = None,
        device_union_ids: List[str] = None,
        enable_cycle_reservation: bool = None,
        isv_room_id: str = None,
        reservation_authority: QueryMeetingRoomResponseBodyResultReservationAuthority = None,
        room_capacity: int = None,
        room_group: QueryMeetingRoomResponseBodyResultRoomGroup = None,
        room_id: str = None,
        room_labels: List[QueryMeetingRoomResponseBodyResultRoomLabels] = None,
        room_location: QueryMeetingRoomResponseBodyResultRoomLocation = None,
        room_name: str = None,
        room_picture: str = None,
        room_staff_id: str = None,
        room_status: int = None,
        room_union_id: str = None,
    ):
        self.corp_id = corp_id
        self.device_union_ids = device_union_ids
        self.enable_cycle_reservation = enable_cycle_reservation
        self.isv_room_id = isv_room_id
        self.reservation_authority = reservation_authority
        self.room_capacity = room_capacity
        self.room_group = room_group
        self.room_id = room_id
        self.room_labels = room_labels
        self.room_location = room_location
        self.room_name = room_name
        self.room_picture = room_picture
        self.room_staff_id = room_staff_id
        self.room_status = room_status
        self.room_union_id = room_union_id

    def validate(self):
        if self.reservation_authority:
            self.reservation_authority.validate()
        if self.room_group:
            self.room_group.validate()
        if self.room_labels:
            for k in self.room_labels:
                if k:
                    k.validate()
        if self.room_location:
            self.room_location.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.device_union_ids is not None:
            result['DeviceUnionIds'] = self.device_union_ids
        if self.enable_cycle_reservation is not None:
            result['EnableCycleReservation'] = self.enable_cycle_reservation
        if self.isv_room_id is not None:
            result['IsvRoomId'] = self.isv_room_id
        if self.reservation_authority is not None:
            result['ReservationAuthority'] = self.reservation_authority.to_map()
        if self.room_capacity is not None:
            result['RoomCapacity'] = self.room_capacity
        if self.room_group is not None:
            result['RoomGroup'] = self.room_group.to_map()
        if self.room_id is not None:
            result['RoomId'] = self.room_id
        result['RoomLabels'] = []
        if self.room_labels is not None:
            for k in self.room_labels:
                result['RoomLabels'].append(k.to_map() if k else None)
        if self.room_location is not None:
            result['RoomLocation'] = self.room_location.to_map()
        if self.room_name is not None:
            result['RoomName'] = self.room_name
        if self.room_picture is not None:
            result['RoomPicture'] = self.room_picture
        if self.room_staff_id is not None:
            result['RoomStaffId'] = self.room_staff_id
        if self.room_status is not None:
            result['RoomStatus'] = self.room_status
        if self.room_union_id is not None:
            result['RoomUnionId'] = self.room_union_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('DeviceUnionIds') is not None:
            self.device_union_ids = m.get('DeviceUnionIds')
        if m.get('EnableCycleReservation') is not None:
            self.enable_cycle_reservation = m.get('EnableCycleReservation')
        if m.get('IsvRoomId') is not None:
            self.isv_room_id = m.get('IsvRoomId')
        if m.get('ReservationAuthority') is not None:
            temp_model = QueryMeetingRoomResponseBodyResultReservationAuthority()
            self.reservation_authority = temp_model.from_map(m['ReservationAuthority'])
        if m.get('RoomCapacity') is not None:
            self.room_capacity = m.get('RoomCapacity')
        if m.get('RoomGroup') is not None:
            temp_model = QueryMeetingRoomResponseBodyResultRoomGroup()
            self.room_group = temp_model.from_map(m['RoomGroup'])
        if m.get('RoomId') is not None:
            self.room_id = m.get('RoomId')
        self.room_labels = []
        if m.get('RoomLabels') is not None:
            for k in m.get('RoomLabels'):
                temp_model = QueryMeetingRoomResponseBodyResultRoomLabels()
                self.room_labels.append(temp_model.from_map(k))
        if m.get('RoomLocation') is not None:
            temp_model = QueryMeetingRoomResponseBodyResultRoomLocation()
            self.room_location = temp_model.from_map(m['RoomLocation'])
        if m.get('RoomName') is not None:
            self.room_name = m.get('RoomName')
        if m.get('RoomPicture') is not None:
            self.room_picture = m.get('RoomPicture')
        if m.get('RoomStaffId') is not None:
            self.room_staff_id = m.get('RoomStaffId')
        if m.get('RoomStatus') is not None:
            self.room_status = m.get('RoomStatus')
        if m.get('RoomUnionId') is not None:
            self.room_union_id = m.get('RoomUnionId')
        return self


class QueryMeetingRoomResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: QueryMeetingRoomResponseBodyResult = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        # requestId
        self.request_id = request_id
        self.result = result
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = QueryMeetingRoomResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class QueryMeetingRoomResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMeetingRoomResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMeetingRoomResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMeetingRoomGroupHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryMeetingRoomGroupHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryMeetingRoomGroupHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryMeetingRoomGroupHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryMeetingRoomGroupShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryMeetingRoomGroupRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryMeetingRoomGroupRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        tenant_context: QueryMeetingRoomGroupRequestTenantContext = None,
    ):
        # This parameter is required.
        self.group_id = group_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('TenantContext') is not None:
            temp_model = QueryMeetingRoomGroupRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class QueryMeetingRoomGroupShrinkRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.group_id = group_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class QueryMeetingRoomGroupResponseBody(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        group_name: str = None,
        parent_id: int = None,
        request_id: str = None,
    ):
        self.group_id = group_id
        self.group_name = group_name
        self.parent_id = parent_id
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['groupId'] = self.group_id
        if self.group_name is not None:
            result['groupName'] = self.group_name
        if self.parent_id is not None:
            result['parentId'] = self.parent_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('groupId') is not None:
            self.group_id = m.get('groupId')
        if m.get('groupName') is not None:
            self.group_name = m.get('groupName')
        if m.get('parentId') is not None:
            self.parent_id = m.get('parentId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class QueryMeetingRoomGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMeetingRoomGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMeetingRoomGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMeetingRoomGroupListHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryMeetingRoomGroupListHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryMeetingRoomGroupListHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryMeetingRoomGroupListHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryMeetingRoomGroupListShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryMeetingRoomGroupListRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryMeetingRoomGroupListRequest(TeaModel):
    def __init__(
        self,
        request: Dict[str, Any] = None,
        tenant_context: QueryMeetingRoomGroupListRequestTenantContext = None,
    ):
        self.request = request
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request is not None:
            result['Request'] = self.request
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Request') is not None:
            self.request = m.get('Request')
        if m.get('TenantContext') is not None:
            temp_model = QueryMeetingRoomGroupListRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class QueryMeetingRoomGroupListShrinkRequest(TeaModel):
    def __init__(
        self,
        request_shrink: str = None,
        tenant_context_shrink: str = None,
    ):
        self.request_shrink = request_shrink
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_shrink is not None:
            result['Request'] = self.request_shrink
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Request') is not None:
            self.request_shrink = m.get('Request')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class QueryMeetingRoomGroupListResponseBodyResult(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        group_name: str = None,
        parent_id: int = None,
    ):
        self.group_id = group_id
        self.group_name = group_name
        self.parent_id = parent_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        return self


class QueryMeetingRoomGroupListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: List[QueryMeetingRoomGroupListResponseBodyResult] = None,
    ):
        # requestId
        self.request_id = request_id
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = QueryMeetingRoomGroupListResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        return self


class QueryMeetingRoomGroupListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMeetingRoomGroupListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMeetingRoomGroupListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMeetingRoomListHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryMeetingRoomListHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryMeetingRoomListHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryMeetingRoomListHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryMeetingRoomListShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryMeetingRoomListRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryMeetingRoomListRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: int = None,
        tenant_context: QueryMeetingRoomListRequestTenantContext = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('TenantContext') is not None:
            temp_model = QueryMeetingRoomListRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class QueryMeetingRoomListShrinkRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: int = None,
        tenant_context_shrink: str = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class QueryMeetingRoomListResponseBodyResultRoomGroup(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        group_name: str = None,
        parent_id: int = None,
    ):
        self.group_id = group_id
        self.group_name = group_name
        self.parent_id = parent_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        return self


class QueryMeetingRoomListResponseBodyResultRoomLabels(TeaModel):
    def __init__(
        self,
        label_id: int = None,
        label_name: str = None,
    ):
        self.label_id = label_id
        self.label_name = label_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label_id is not None:
            result['LabelId'] = self.label_id
        if self.label_name is not None:
            result['LabelName'] = self.label_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LabelId') is not None:
            self.label_id = m.get('LabelId')
        if m.get('LabelName') is not None:
            self.label_name = m.get('LabelName')
        return self


class QueryMeetingRoomListResponseBodyResultRoomLocation(TeaModel):
    def __init__(
        self,
        desc: str = None,
        title: str = None,
    ):
        self.desc = desc
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class QueryMeetingRoomListResponseBodyResult(TeaModel):
    def __init__(
        self,
        corp_id: str = None,
        isv_room_id: str = None,
        room_capacity: int = None,
        room_group: QueryMeetingRoomListResponseBodyResultRoomGroup = None,
        room_id: str = None,
        room_labels: List[QueryMeetingRoomListResponseBodyResultRoomLabels] = None,
        room_location: QueryMeetingRoomListResponseBodyResultRoomLocation = None,
        room_name: str = None,
        room_picture: str = None,
        room_staff_id: str = None,
        room_status: int = None,
    ):
        self.corp_id = corp_id
        self.isv_room_id = isv_room_id
        self.room_capacity = room_capacity
        self.room_group = room_group
        self.room_id = room_id
        self.room_labels = room_labels
        self.room_location = room_location
        self.room_name = room_name
        self.room_picture = room_picture
        self.room_staff_id = room_staff_id
        self.room_status = room_status

    def validate(self):
        if self.room_group:
            self.room_group.validate()
        if self.room_labels:
            for k in self.room_labels:
                if k:
                    k.validate()
        if self.room_location:
            self.room_location.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.isv_room_id is not None:
            result['IsvRoomId'] = self.isv_room_id
        if self.room_capacity is not None:
            result['RoomCapacity'] = self.room_capacity
        if self.room_group is not None:
            result['RoomGroup'] = self.room_group.to_map()
        if self.room_id is not None:
            result['RoomId'] = self.room_id
        result['RoomLabels'] = []
        if self.room_labels is not None:
            for k in self.room_labels:
                result['RoomLabels'].append(k.to_map() if k else None)
        if self.room_location is not None:
            result['RoomLocation'] = self.room_location.to_map()
        if self.room_name is not None:
            result['RoomName'] = self.room_name
        if self.room_picture is not None:
            result['RoomPicture'] = self.room_picture
        if self.room_staff_id is not None:
            result['RoomStaffId'] = self.room_staff_id
        if self.room_status is not None:
            result['RoomStatus'] = self.room_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('IsvRoomId') is not None:
            self.isv_room_id = m.get('IsvRoomId')
        if m.get('RoomCapacity') is not None:
            self.room_capacity = m.get('RoomCapacity')
        if m.get('RoomGroup') is not None:
            temp_model = QueryMeetingRoomListResponseBodyResultRoomGroup()
            self.room_group = temp_model.from_map(m['RoomGroup'])
        if m.get('RoomId') is not None:
            self.room_id = m.get('RoomId')
        self.room_labels = []
        if m.get('RoomLabels') is not None:
            for k in m.get('RoomLabels'):
                temp_model = QueryMeetingRoomListResponseBodyResultRoomLabels()
                self.room_labels.append(temp_model.from_map(k))
        if m.get('RoomLocation') is not None:
            temp_model = QueryMeetingRoomListResponseBodyResultRoomLocation()
            self.room_location = temp_model.from_map(m['RoomLocation'])
        if m.get('RoomName') is not None:
            self.room_name = m.get('RoomName')
        if m.get('RoomPicture') is not None:
            self.room_picture = m.get('RoomPicture')
        if m.get('RoomStaffId') is not None:
            self.room_staff_id = m.get('RoomStaffId')
        if m.get('RoomStatus') is not None:
            self.room_status = m.get('RoomStatus')
        return self


class QueryMeetingRoomListResponseBody(TeaModel):
    def __init__(
        self,
        has_more: bool = None,
        next_token: int = None,
        request_id: str = None,
        result: List[QueryMeetingRoomListResponseBodyResult] = None,
    ):
        self.has_more = has_more
        self.next_token = next_token
        # requestId
        self.request_id = request_id
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_more is not None:
            result['hasMore'] = self.has_more
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('hasMore') is not None:
            self.has_more = m.get('hasMore')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = QueryMeetingRoomListResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        return self


class QueryMeetingRoomListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMeetingRoomListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMeetingRoomListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMinutesHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryMinutesHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryMinutesHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryMinutesHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryMinutesShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryMinutesRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryMinutesRequest(TeaModel):
    def __init__(
        self,
        tenant_context: QueryMinutesRequestTenantContext = None,
        conference_id: str = None,
    ):
        self.tenant_context = tenant_context
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = QueryMinutesRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class QueryMinutesShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        conference_id: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class QueryMinutesResponseBodyAudioList(TeaModel):
    def __init__(
        self,
        duration: int = None,
        end_time: int = None,
        file_size: int = None,
        play_url: str = None,
        record_id: str = None,
        start_time: int = None,
        user_id: str = None,
    ):
        self.duration = duration
        self.end_time = end_time
        self.file_size = file_size
        self.play_url = play_url
        self.record_id = record_id
        self.start_time = start_time
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.play_url is not None:
            result['PlayUrl'] = self.play_url
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('PlayUrl') is not None:
            self.play_url = m.get('PlayUrl')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class QueryMinutesResponseBody(TeaModel):
    def __init__(
        self,
        audio_list: List[QueryMinutesResponseBodyAudioList] = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.audio_list = audio_list
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.audio_list:
            for k in self.audio_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['audioList'] = []
        if self.audio_list is not None:
            for k in self.audio_list:
                result['audioList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_list = []
        if m.get('audioList') is not None:
            for k in m.get('audioList'):
                temp_model = QueryMinutesResponseBodyAudioList()
                self.audio_list.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class QueryMinutesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMinutesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMinutesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMinutesSummaryHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryMinutesSummaryHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryMinutesSummaryHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryMinutesSummaryHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryMinutesSummaryShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryMinutesSummaryRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryMinutesSummaryRequest(TeaModel):
    def __init__(
        self,
        tenant_context: QueryMinutesSummaryRequestTenantContext = None,
        conference_id: str = None,
        summary_type_list: List[str] = None,
    ):
        self.tenant_context = tenant_context
        # This parameter is required.
        self.conference_id = conference_id
        self.summary_type_list = summary_type_list

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        if self.summary_type_list is not None:
            result['summaryTypeList'] = self.summary_type_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = QueryMinutesSummaryRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        if m.get('summaryTypeList') is not None:
            self.summary_type_list = m.get('summaryTypeList')
        return self


class QueryMinutesSummaryShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        conference_id: str = None,
        summary_type_list_shrink: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.conference_id = conference_id
        self.summary_type_list_shrink = summary_type_list_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        if self.summary_type_list_shrink is not None:
            result['summaryTypeList'] = self.summary_type_list_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        if m.get('summaryTypeList') is not None:
            self.summary_type_list_shrink = m.get('summaryTypeList')
        return self


class QueryMinutesSummaryResponseBodySummaryActions(TeaModel):
    def __init__(
        self,
        end: int = None,
        id: int = None,
        sentence_id: int = None,
        start: int = None,
        text: str = None,
    ):
        self.end = end
        self.id = id
        self.sentence_id = sentence_id
        self.start = start
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.id is not None:
            result['Id'] = self.id
        if self.sentence_id is not None:
            result['SentenceId'] = self.sentence_id
        if self.start is not None:
            result['Start'] = self.start
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('SentenceId') is not None:
            self.sentence_id = m.get('SentenceId')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class QueryMinutesSummaryResponseBodySummaryAutoChapters(TeaModel):
    def __init__(
        self,
        end: int = None,
        headline: str = None,
        id: int = None,
        start: int = None,
        summary: str = None,
    ):
        self.end = end
        self.headline = headline
        self.id = id
        self.start = start
        self.summary = summary

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.headline is not None:
            result['Headline'] = self.headline
        if self.id is not None:
            result['Id'] = self.id
        if self.start is not None:
            result['Start'] = self.start
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Headline') is not None:
            self.headline = m.get('Headline')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class QueryMinutesSummaryResponseBodySummaryConversationalSummary(TeaModel):
    def __init__(
        self,
        speaker_id: str = None,
        speaker_name: str = None,
        summary: str = None,
    ):
        self.speaker_id = speaker_id
        self.speaker_name = speaker_name
        self.summary = summary

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.speaker_id is not None:
            result['SpeakerId'] = self.speaker_id
        if self.speaker_name is not None:
            result['SpeakerName'] = self.speaker_name
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SpeakerId') is not None:
            self.speaker_id = m.get('SpeakerId')
        if m.get('SpeakerName') is not None:
            self.speaker_name = m.get('SpeakerName')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class QueryMinutesSummaryResponseBodySummaryKeySentences(TeaModel):
    def __init__(
        self,
        end: int = None,
        id: int = None,
        sentence_id: int = None,
        start: int = None,
        text: str = None,
    ):
        self.end = end
        self.id = id
        self.sentence_id = sentence_id
        self.start = start
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.id is not None:
            result['Id'] = self.id
        if self.sentence_id is not None:
            result['SentenceId'] = self.sentence_id
        if self.start is not None:
            result['Start'] = self.start
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('SentenceId') is not None:
            self.sentence_id = m.get('SentenceId')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class QueryMinutesSummaryResponseBodySummaryQuestionsAnsweringSummary(TeaModel):
    def __init__(
        self,
        answer: str = None,
        question: str = None,
        sentence_ids_of_answer: List[int] = None,
        sentence_ids_of_question: List[int] = None,
    ):
        self.answer = answer
        self.question = question
        self.sentence_ids_of_answer = sentence_ids_of_answer
        self.sentence_ids_of_question = sentence_ids_of_question

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.answer is not None:
            result['Answer'] = self.answer
        if self.question is not None:
            result['Question'] = self.question
        if self.sentence_ids_of_answer is not None:
            result['SentenceIdsOfAnswer'] = self.sentence_ids_of_answer
        if self.sentence_ids_of_question is not None:
            result['SentenceIdsOfQuestion'] = self.sentence_ids_of_question
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Answer') is not None:
            self.answer = m.get('Answer')
        if m.get('Question') is not None:
            self.question = m.get('Question')
        if m.get('SentenceIdsOfAnswer') is not None:
            self.sentence_ids_of_answer = m.get('SentenceIdsOfAnswer')
        if m.get('SentenceIdsOfQuestion') is not None:
            self.sentence_ids_of_question = m.get('SentenceIdsOfQuestion')
        return self


class QueryMinutesSummaryResponseBodySummary(TeaModel):
    def __init__(
        self,
        actions: QueryMinutesSummaryResponseBodySummaryActions = None,
        auto_chapters: List[QueryMinutesSummaryResponseBodySummaryAutoChapters] = None,
        conversational_summary: List[QueryMinutesSummaryResponseBodySummaryConversationalSummary] = None,
        key_sentences: QueryMinutesSummaryResponseBodySummaryKeySentences = None,
        keywords: List[str] = None,
        paragraph_summary: str = None,
        questions_answering_summary: List[QueryMinutesSummaryResponseBodySummaryQuestionsAnsweringSummary] = None,
    ):
        self.actions = actions
        self.auto_chapters = auto_chapters
        self.conversational_summary = conversational_summary
        self.key_sentences = key_sentences
        self.keywords = keywords
        self.paragraph_summary = paragraph_summary
        self.questions_answering_summary = questions_answering_summary

    def validate(self):
        if self.actions:
            self.actions.validate()
        if self.auto_chapters:
            for k in self.auto_chapters:
                if k:
                    k.validate()
        if self.conversational_summary:
            for k in self.conversational_summary:
                if k:
                    k.validate()
        if self.key_sentences:
            self.key_sentences.validate()
        if self.questions_answering_summary:
            for k in self.questions_answering_summary:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actions is not None:
            result['Actions'] = self.actions.to_map()
        result['AutoChapters'] = []
        if self.auto_chapters is not None:
            for k in self.auto_chapters:
                result['AutoChapters'].append(k.to_map() if k else None)
        result['ConversationalSummary'] = []
        if self.conversational_summary is not None:
            for k in self.conversational_summary:
                result['ConversationalSummary'].append(k.to_map() if k else None)
        if self.key_sentences is not None:
            result['KeySentences'] = self.key_sentences.to_map()
        if self.keywords is not None:
            result['Keywords'] = self.keywords
        if self.paragraph_summary is not None:
            result['ParagraphSummary'] = self.paragraph_summary
        result['QuestionsAnsweringSummary'] = []
        if self.questions_answering_summary is not None:
            for k in self.questions_answering_summary:
                result['QuestionsAnsweringSummary'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Actions') is not None:
            temp_model = QueryMinutesSummaryResponseBodySummaryActions()
            self.actions = temp_model.from_map(m['Actions'])
        self.auto_chapters = []
        if m.get('AutoChapters') is not None:
            for k in m.get('AutoChapters'):
                temp_model = QueryMinutesSummaryResponseBodySummaryAutoChapters()
                self.auto_chapters.append(temp_model.from_map(k))
        self.conversational_summary = []
        if m.get('ConversationalSummary') is not None:
            for k in m.get('ConversationalSummary'):
                temp_model = QueryMinutesSummaryResponseBodySummaryConversationalSummary()
                self.conversational_summary.append(temp_model.from_map(k))
        if m.get('KeySentences') is not None:
            temp_model = QueryMinutesSummaryResponseBodySummaryKeySentences()
            self.key_sentences = temp_model.from_map(m['KeySentences'])
        if m.get('Keywords') is not None:
            self.keywords = m.get('Keywords')
        if m.get('ParagraphSummary') is not None:
            self.paragraph_summary = m.get('ParagraphSummary')
        self.questions_answering_summary = []
        if m.get('QuestionsAnsweringSummary') is not None:
            for k in m.get('QuestionsAnsweringSummary'):
                temp_model = QueryMinutesSummaryResponseBodySummaryQuestionsAnsweringSummary()
                self.questions_answering_summary.append(temp_model.from_map(k))
        return self


class QueryMinutesSummaryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        summary: QueryMinutesSummaryResponseBodySummary = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.summary = summary
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.summary:
            self.summary.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.summary is not None:
            result['summary'] = self.summary.to_map()
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('summary') is not None:
            temp_model = QueryMinutesSummaryResponseBodySummary()
            self.summary = temp_model.from_map(m['summary'])
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class QueryMinutesSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMinutesSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMinutesSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMinutesTextHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryMinutesTextHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryMinutesTextHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryMinutesTextHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryMinutesTextShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryMinutesTextRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryMinutesTextRequest(TeaModel):
    def __init__(
        self,
        tenant_context: QueryMinutesTextRequestTenantContext = None,
        conference_id: str = None,
        direction: str = None,
        max_results: int = None,
        next_token: str = None,
    ):
        self.tenant_context = tenant_context
        # This parameter is required.
        self.conference_id = conference_id
        # This parameter is required.
        self.direction = direction
        self.max_results = max_results
        self.next_token = next_token

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        if self.direction is not None:
            result['direction'] = self.direction
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = QueryMinutesTextRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        if m.get('direction') is not None:
            self.direction = m.get('direction')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        return self


class QueryMinutesTextShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        conference_id: str = None,
        direction: str = None,
        max_results: int = None,
        next_token: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.conference_id = conference_id
        # This parameter is required.
        self.direction = direction
        self.max_results = max_results
        self.next_token = next_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        if self.direction is not None:
            result['direction'] = self.direction
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        if m.get('direction') is not None:
            self.direction = m.get('direction')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        return self


class QueryMinutesTextResponseBodyParagraphListSentenceListWordList(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        start_time: int = None,
        word: str = None,
        word_id: str = None,
    ):
        self.end_time = end_time
        self.start_time = start_time
        self.word = word
        self.word_id = word_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.word is not None:
            result['Word'] = self.word
        if self.word_id is not None:
            result['WordId'] = self.word_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Word') is not None:
            self.word = m.get('Word')
        if m.get('WordId') is not None:
            self.word_id = m.get('WordId')
        return self


class QueryMinutesTextResponseBodyParagraphListSentenceList(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        sentence: str = None,
        start_time: int = None,
        user_id: str = None,
        word_list: List[QueryMinutesTextResponseBodyParagraphListSentenceListWordList] = None,
    ):
        self.end_time = end_time
        self.sentence = sentence
        self.start_time = start_time
        self.user_id = user_id
        self.word_list = word_list

    def validate(self):
        if self.word_list:
            for k in self.word_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.sentence is not None:
            result['Sentence'] = self.sentence
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        result['WordList'] = []
        if self.word_list is not None:
            for k in self.word_list:
                result['WordList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Sentence') is not None:
            self.sentence = m.get('Sentence')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        self.word_list = []
        if m.get('WordList') is not None:
            for k in m.get('WordList'):
                temp_model = QueryMinutesTextResponseBodyParagraphListSentenceListWordList()
                self.word_list.append(temp_model.from_map(k))
        return self


class QueryMinutesTextResponseBodyParagraphList(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        nick_name: str = None,
        paragraph: str = None,
        paragraph_id: int = None,
        record_id: int = None,
        sentence_list: List[QueryMinutesTextResponseBodyParagraphListSentenceList] = None,
        start_time: int = None,
        user_id: str = None,
    ):
        self.end_time = end_time
        self.nick_name = nick_name
        self.paragraph = paragraph
        self.paragraph_id = paragraph_id
        self.record_id = record_id
        self.sentence_list = sentence_list
        self.start_time = start_time
        self.user_id = user_id

    def validate(self):
        if self.sentence_list:
            for k in self.sentence_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.paragraph is not None:
            result['Paragraph'] = self.paragraph
        if self.paragraph_id is not None:
            result['ParagraphId'] = self.paragraph_id
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        result['SentenceList'] = []
        if self.sentence_list is not None:
            for k in self.sentence_list:
                result['SentenceList'].append(k.to_map() if k else None)
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('Paragraph') is not None:
            self.paragraph = m.get('Paragraph')
        if m.get('ParagraphId') is not None:
            self.paragraph_id = m.get('ParagraphId')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        self.sentence_list = []
        if m.get('SentenceList') is not None:
            for k in m.get('SentenceList'):
                temp_model = QueryMinutesTextResponseBodyParagraphListSentenceList()
                self.sentence_list.append(temp_model.from_map(k))
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class QueryMinutesTextResponseBody(TeaModel):
    def __init__(
        self,
        has_more: bool = None,
        next_token: str = None,
        paragraph_list: List[QueryMinutesTextResponseBodyParagraphList] = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.has_more = has_more
        self.next_token = next_token
        self.paragraph_list = paragraph_list
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.paragraph_list:
            for k in self.paragraph_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_more is not None:
            result['hasMore'] = self.has_more
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['paragraphList'] = []
        if self.paragraph_list is not None:
            for k in self.paragraph_list:
                result['paragraphList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('hasMore') is not None:
            self.has_more = m.get('hasMore')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.paragraph_list = []
        if m.get('paragraphList') is not None:
            for k in m.get('paragraphList'):
                temp_model = QueryMinutesTextResponseBodyParagraphList()
                self.paragraph_list.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class QueryMinutesTextResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMinutesTextResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMinutesTextResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryOrgHonorsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryOrgHonorsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryOrgHonorsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryOrgHonorsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryOrgHonorsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryOrgHonorsRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryOrgHonorsRequest(TeaModel):
    def __init__(
        self,
        tenant_context: QueryOrgHonorsRequestTenantContext = None,
        max_results: int = None,
        next_token: str = None,
        org_id: int = None,
    ):
        self.tenant_context = tenant_context
        self.max_results = max_results
        # This parameter is required.
        self.next_token = next_token
        # This parameter is required.
        self.org_id = org_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.org_id is not None:
            result['orgId'] = self.org_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = QueryOrgHonorsRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('orgId') is not None:
            self.org_id = m.get('orgId')
        return self


class QueryOrgHonorsShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        max_results: int = None,
        next_token: str = None,
        org_id: int = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        self.max_results = max_results
        # This parameter is required.
        self.next_token = next_token
        # This parameter is required.
        self.org_id = org_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.org_id is not None:
            result['orgId'] = self.org_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('orgId') is not None:
            self.org_id = m.get('orgId')
        return self


class QueryOrgHonorsResponseBodyOpenHonors(TeaModel):
    def __init__(
        self,
        honor_desc: str = None,
        honor_id: int = None,
        honor_img_url: str = None,
        honor_name: str = None,
        honor_pendant_img_url: str = None,
    ):
        self.honor_desc = honor_desc
        self.honor_id = honor_id
        self.honor_img_url = honor_img_url
        self.honor_name = honor_name
        self.honor_pendant_img_url = honor_pendant_img_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honor_desc is not None:
            result['honorDesc'] = self.honor_desc
        if self.honor_id is not None:
            result['honorId'] = self.honor_id
        if self.honor_img_url is not None:
            result['honorImgUrl'] = self.honor_img_url
        if self.honor_name is not None:
            result['honorName'] = self.honor_name
        if self.honor_pendant_img_url is not None:
            result['honorPendantImgUrl'] = self.honor_pendant_img_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('honorDesc') is not None:
            self.honor_desc = m.get('honorDesc')
        if m.get('honorId') is not None:
            self.honor_id = m.get('honorId')
        if m.get('honorImgUrl') is not None:
            self.honor_img_url = m.get('honorImgUrl')
        if m.get('honorName') is not None:
            self.honor_name = m.get('honorName')
        if m.get('honorPendantImgUrl') is not None:
            self.honor_pendant_img_url = m.get('honorPendantImgUrl')
        return self


class QueryOrgHonorsResponseBody(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        open_honors: List[QueryOrgHonorsResponseBodyOpenHonors] = None,
        request_id: str = None,
    ):
        self.next_token = next_token
        self.open_honors = open_honors
        # requestId
        self.request_id = request_id

    def validate(self):
        if self.open_honors:
            for k in self.open_honors:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['openHonors'] = []
        if self.open_honors is not None:
            for k in self.open_honors:
                result['openHonors'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.open_honors = []
        if m.get('openHonors') is not None:
            for k in m.get('openHonors'):
                temp_model = QueryOrgHonorsResponseBodyOpenHonors()
                self.open_honors.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class QueryOrgHonorsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryOrgHonorsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryOrgHonorsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryOrgTodoTasksHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryOrgTodoTasksHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryOrgTodoTasksHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryOrgTodoTasksHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryOrgTodoTasksShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryOrgTodoTasksRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryOrgTodoTasksRequest(TeaModel):
    def __init__(
        self,
        tenant_context: QueryOrgTodoTasksRequestTenantContext = None,
        is_done: bool = None,
        next_token: str = None,
    ):
        self.tenant_context = tenant_context
        self.is_done = is_done
        self.next_token = next_token

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.is_done is not None:
            result['isDone'] = self.is_done
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = QueryOrgTodoTasksRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('isDone') is not None:
            self.is_done = m.get('isDone')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        return self


class QueryOrgTodoTasksShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        is_done: bool = None,
        next_token: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        self.is_done = is_done
        self.next_token = next_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.is_done is not None:
            result['isDone'] = self.is_done
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('isDone') is not None:
            self.is_done = m.get('isDone')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        return self


class QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl(TeaModel):
    def __init__(
        self,
        app_url: str = None,
        pc_url: str = None,
    ):
        self.app_url = app_url
        self.pc_url = pc_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_url is not None:
            result['appUrl'] = self.app_url
        if self.pc_url is not None:
            result['pcUrl'] = self.pc_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('appUrl') is not None:
            self.app_url = m.get('appUrl')
        if m.get('pcUrl') is not None:
            self.pc_url = m.get('pcUrl')
        return self


class QueryOrgTodoTasksResponseBodyTodoCards(TeaModel):
    def __init__(
        self,
        biz_tag: str = None,
        created_time: int = None,
        creator_id: str = None,
        detail_url: QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl = None,
        due_time: int = None,
        is_done: bool = None,
        modified_time: int = None,
        priority: int = None,
        source_id: str = None,
        subject: str = None,
        task_id: str = None,
    ):
        self.biz_tag = biz_tag
        self.created_time = created_time
        self.creator_id = creator_id
        self.detail_url = detail_url
        self.due_time = due_time
        self.is_done = is_done
        self.modified_time = modified_time
        self.priority = priority
        self.source_id = source_id
        self.subject = subject
        self.task_id = task_id

    def validate(self):
        if self.detail_url:
            self.detail_url.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_tag is not None:
            result['bizTag'] = self.biz_tag
        if self.created_time is not None:
            result['createdTime'] = self.created_time
        if self.creator_id is not None:
            result['creatorId'] = self.creator_id
        if self.detail_url is not None:
            result['detailUrl'] = self.detail_url.to_map()
        if self.due_time is not None:
            result['dueTime'] = self.due_time
        if self.is_done is not None:
            result['isDone'] = self.is_done
        if self.modified_time is not None:
            result['modifiedTime'] = self.modified_time
        if self.priority is not None:
            result['priority'] = self.priority
        if self.source_id is not None:
            result['sourceId'] = self.source_id
        if self.subject is not None:
            result['subject'] = self.subject
        if self.task_id is not None:
            result['taskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bizTag') is not None:
            self.biz_tag = m.get('bizTag')
        if m.get('createdTime') is not None:
            self.created_time = m.get('createdTime')
        if m.get('creatorId') is not None:
            self.creator_id = m.get('creatorId')
        if m.get('detailUrl') is not None:
            temp_model = QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl()
            self.detail_url = temp_model.from_map(m['detailUrl'])
        if m.get('dueTime') is not None:
            self.due_time = m.get('dueTime')
        if m.get('isDone') is not None:
            self.is_done = m.get('isDone')
        if m.get('modifiedTime') is not None:
            self.modified_time = m.get('modifiedTime')
        if m.get('priority') is not None:
            self.priority = m.get('priority')
        if m.get('sourceId') is not None:
            self.source_id = m.get('sourceId')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        return self


class QueryOrgTodoTasksResponseBody(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        request_id: str = None,
        todo_cards: List[QueryOrgTodoTasksResponseBodyTodoCards] = None,
    ):
        self.next_token = next_token
        # requestId
        self.request_id = request_id
        self.todo_cards = todo_cards

    def validate(self):
        if self.todo_cards:
            for k in self.todo_cards:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['todoCards'] = []
        if self.todo_cards is not None:
            for k in self.todo_cards:
                result['todoCards'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.todo_cards = []
        if m.get('todoCards') is not None:
            for k in m.get('todoCards'):
                temp_model = QueryOrgTodoTasksResponseBodyTodoCards()
                self.todo_cards.append(temp_model.from_map(k))
        return self


class QueryOrgTodoTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryOrgTodoTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryOrgTodoTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryRecordMinutesUrlHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryRecordMinutesUrlHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryRecordMinutesUrlHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryRecordMinutesUrlHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryRecordMinutesUrlShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryRecordMinutesUrlRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryRecordMinutesUrlRequest(TeaModel):
    def __init__(
        self,
        biz_type: str = None,
        conference_id: str = None,
        tenant_context: QueryRecordMinutesUrlRequestTenantContext = None,
    ):
        # This parameter is required.
        self.biz_type = biz_type
        # This parameter is required.
        self.conference_id = conference_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.conference_id is not None:
            result['ConferenceId'] = self.conference_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('ConferenceId') is not None:
            self.conference_id = m.get('ConferenceId')
        if m.get('TenantContext') is not None:
            temp_model = QueryRecordMinutesUrlRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class QueryRecordMinutesUrlShrinkRequest(TeaModel):
    def __init__(
        self,
        biz_type: str = None,
        conference_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.biz_type = biz_type
        # This parameter is required.
        self.conference_id = conference_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.conference_id is not None:
            result['ConferenceId'] = self.conference_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('ConferenceId') is not None:
            self.conference_id = m.get('ConferenceId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class QueryRecordMinutesUrlResponseBodyRecordMinutesUrls(TeaModel):
    def __init__(
        self,
        record_minutes_url: str = None,
    ):
        self.record_minutes_url = record_minutes_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.record_minutes_url is not None:
            result['RecordMinutesUrl'] = self.record_minutes_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RecordMinutesUrl') is not None:
            self.record_minutes_url = m.get('RecordMinutesUrl')
        return self


class QueryRecordMinutesUrlResponseBody(TeaModel):
    def __init__(
        self,
        record_minutes_urls: List[QueryRecordMinutesUrlResponseBodyRecordMinutesUrls] = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.record_minutes_urls = record_minutes_urls
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.record_minutes_urls:
            for k in self.record_minutes_urls:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['recordMinutesUrls'] = []
        if self.record_minutes_urls is not None:
            for k in self.record_minutes_urls:
                result['recordMinutesUrls'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.record_minutes_urls = []
        if m.get('recordMinutesUrls') is not None:
            for k in m.get('recordMinutesUrls'):
                temp_model = QueryRecordMinutesUrlResponseBodyRecordMinutesUrls()
                self.record_minutes_urls.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class QueryRecordMinutesUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryRecordMinutesUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryRecordMinutesUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryReportDetailHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryReportDetailHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryReportDetailHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryReportDetailHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryReportDetailShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryReportDetailRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryReportDetailRequest(TeaModel):
    def __init__(
        self,
        report_id: str = None,
        tenant_context: QueryReportDetailRequestTenantContext = None,
    ):
        # This parameter is required.
        self.report_id = report_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.report_id is not None:
            result['ReportId'] = self.report_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReportId') is not None:
            self.report_id = m.get('ReportId')
        if m.get('TenantContext') is not None:
            temp_model = QueryReportDetailRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class QueryReportDetailShrinkRequest(TeaModel):
    def __init__(
        self,
        report_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.report_id = report_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.report_id is not None:
            result['ReportId'] = self.report_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReportId') is not None:
            self.report_id = m.get('ReportId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class QueryReportDetailResponseBodyContent(TeaModel):
    def __init__(
        self,
        images: List[str] = None,
        key: str = None,
        sort: str = None,
        type: str = None,
        value: str = None,
    ):
        self.images = images
        self.key = key
        self.sort = sort
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.images is not None:
            result['Images'] = self.images
        if self.key is not None:
            result['Key'] = self.key
        if self.sort is not None:
            result['Sort'] = self.sort
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Images') is not None:
            self.images = m.get('Images')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Sort') is not None:
            self.sort = m.get('Sort')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class QueryReportDetailResponseBody(TeaModel):
    def __init__(
        self,
        content: List[QueryReportDetailResponseBodyContent] = None,
        create_time: int = None,
        creator_id: str = None,
        creator_name: str = None,
        dept_name: str = None,
        modified_time: int = None,
        remark: str = None,
        report_id: str = None,
        request_id: str = None,
        template_name: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.content = content
        self.create_time = create_time
        self.creator_id = creator_id
        self.creator_name = creator_name
        self.dept_name = dept_name
        self.modified_time = modified_time
        self.remark = remark
        self.report_id = report_id
        self.request_id = request_id
        self.template_name = template_name
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.content:
            for k in self.content:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['content'] = []
        if self.content is not None:
            for k in self.content:
                result['content'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.creator_id is not None:
            result['creatorId'] = self.creator_id
        if self.creator_name is not None:
            result['creatorName'] = self.creator_name
        if self.dept_name is not None:
            result['deptName'] = self.dept_name
        if self.modified_time is not None:
            result['modifiedTime'] = self.modified_time
        if self.remark is not None:
            result['remark'] = self.remark
        if self.report_id is not None:
            result['reportId'] = self.report_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.template_name is not None:
            result['templateName'] = self.template_name
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.content = []
        if m.get('content') is not None:
            for k in m.get('content'):
                temp_model = QueryReportDetailResponseBodyContent()
                self.content.append(temp_model.from_map(k))
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('creatorId') is not None:
            self.creator_id = m.get('creatorId')
        if m.get('creatorName') is not None:
            self.creator_name = m.get('creatorName')
        if m.get('deptName') is not None:
            self.dept_name = m.get('deptName')
        if m.get('modifiedTime') is not None:
            self.modified_time = m.get('modifiedTime')
        if m.get('remark') is not None:
            self.remark = m.get('remark')
        if m.get('reportId') is not None:
            self.report_id = m.get('reportId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('templateName') is not None:
            self.template_name = m.get('templateName')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class QueryReportDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryReportDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryReportDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryScheduleConferenceHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryScheduleConferenceHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryScheduleConferenceHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryScheduleConferenceHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryScheduleConferenceShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryScheduleConferenceRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryScheduleConferenceRequest(TeaModel):
    def __init__(
        self,
        tenant_context: QueryScheduleConferenceRequestTenantContext = None,
        schedule_conference_id: str = None,
    ):
        self.tenant_context = tenant_context
        # This parameter is required.
        self.schedule_conference_id = schedule_conference_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.schedule_conference_id is not None:
            result['scheduleConferenceId'] = self.schedule_conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = QueryScheduleConferenceRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('scheduleConferenceId') is not None:
            self.schedule_conference_id = m.get('scheduleConferenceId')
        return self


class QueryScheduleConferenceShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        schedule_conference_id: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.schedule_conference_id = schedule_conference_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.schedule_conference_id is not None:
            result['scheduleConferenceId'] = self.schedule_conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('scheduleConferenceId') is not None:
            self.schedule_conference_id = m.get('scheduleConferenceId')
        return self


class QueryScheduleConferenceResponseBody(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        phones: List[str] = None,
        request_id: str = None,
        room_code: str = None,
        schedule_conference_id: str = None,
        start_time: int = None,
        title: str = None,
        url: str = None,
    ):
        self.end_time = end_time
        self.phones = phones
        self.request_id = request_id
        self.room_code = room_code
        self.schedule_conference_id = schedule_conference_id
        self.start_time = start_time
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.phones is not None:
            result['phones'] = self.phones
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.room_code is not None:
            result['roomCode'] = self.room_code
        if self.schedule_conference_id is not None:
            result['scheduleConferenceId'] = self.schedule_conference_id
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.title is not None:
            result['title'] = self.title
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('phones') is not None:
            self.phones = m.get('phones')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('roomCode') is not None:
            self.room_code = m.get('roomCode')
        if m.get('scheduleConferenceId') is not None:
            self.schedule_conference_id = m.get('scheduleConferenceId')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class QueryScheduleConferenceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryScheduleConferenceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryScheduleConferenceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryScheduleConferenceInfoHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryScheduleConferenceInfoHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryScheduleConferenceInfoHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryScheduleConferenceInfoHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryScheduleConferenceInfoShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryScheduleConferenceInfoRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryScheduleConferenceInfoRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        schedule_conference_id: str = None,
        tenant_context: QueryScheduleConferenceInfoRequestTenantContext = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.schedule_conference_id = schedule_conference_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.schedule_conference_id is not None:
            result['ScheduleConferenceId'] = self.schedule_conference_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('ScheduleConferenceId') is not None:
            self.schedule_conference_id = m.get('ScheduleConferenceId')
        if m.get('TenantContext') is not None:
            temp_model = QueryScheduleConferenceInfoRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class QueryScheduleConferenceInfoShrinkRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        schedule_conference_id: str = None,
        tenant_context_shrink: str = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.schedule_conference_id = schedule_conference_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.schedule_conference_id is not None:
            result['ScheduleConferenceId'] = self.schedule_conference_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('ScheduleConferenceId') is not None:
            self.schedule_conference_id = m.get('ScheduleConferenceId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class QueryScheduleConferenceInfoResponseBodyConferenceList(TeaModel):
    def __init__(
        self,
        conference_id: str = None,
        end_time: int = None,
        room_code: str = None,
        start_time: int = None,
        status: int = None,
        title: str = None,
    ):
        self.conference_id = conference_id
        self.end_time = end_time
        self.room_code = room_code
        self.start_time = start_time
        self.status = status
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conference_id is not None:
            result['ConferenceId'] = self.conference_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.room_code is not None:
            result['RoomCode'] = self.room_code
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConferenceId') is not None:
            self.conference_id = m.get('ConferenceId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RoomCode') is not None:
            self.room_code = m.get('RoomCode')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class QueryScheduleConferenceInfoResponseBody(TeaModel):
    def __init__(
        self,
        conference_list: List[QueryScheduleConferenceInfoResponseBodyConferenceList] = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.conference_list = conference_list
        self.next_token = next_token
        self.request_id = request_id
        self.total_count = total_count
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.conference_list:
            for k in self.conference_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['conferenceList'] = []
        if self.conference_list is not None:
            for k in self.conference_list:
                result['conferenceList'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.conference_list = []
        if m.get('conferenceList') is not None:
            for k in m.get('conferenceList'):
                temp_model = QueryScheduleConferenceInfoResponseBodyConferenceList()
                self.conference_list.append(temp_model.from_map(k))
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class QueryScheduleConferenceInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryScheduleConferenceInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryScheduleConferenceInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryUserHonorsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class QueryUserHonorsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: QueryUserHonorsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = QueryUserHonorsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class QueryUserHonorsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class QueryUserHonorsRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class QueryUserHonorsRequest(TeaModel):
    def __init__(
        self,
        tenant_context: QueryUserHonorsRequestTenantContext = None,
        max_results: int = None,
        next_token: str = None,
        org_id: int = None,
        user_id: str = None,
    ):
        self.tenant_context = tenant_context
        self.max_results = max_results
        # This parameter is required.
        self.next_token = next_token
        # This parameter is required.
        self.org_id = org_id
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.org_id is not None:
            result['orgId'] = self.org_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = QueryUserHonorsRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('orgId') is not None:
            self.org_id = m.get('orgId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class QueryUserHonorsShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        max_results: int = None,
        next_token: str = None,
        org_id: int = None,
        user_id: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        self.max_results = max_results
        # This parameter is required.
        self.next_token = next_token
        # This parameter is required.
        self.org_id = org_id
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.org_id is not None:
            result['orgId'] = self.org_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('orgId') is not None:
            self.org_id = m.get('orgId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class QueryUserHonorsResponseBodyHonorsGrantHistory(TeaModel):
    def __init__(
        self,
        grant_time: int = None,
        sender_userid: str = None,
    ):
        self.grant_time = grant_time
        self.sender_userid = sender_userid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grant_time is not None:
            result['grantTime'] = self.grant_time
        if self.sender_userid is not None:
            result['senderUserid'] = self.sender_userid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('grantTime') is not None:
            self.grant_time = m.get('grantTime')
        if m.get('senderUserid') is not None:
            self.sender_userid = m.get('senderUserid')
        return self


class QueryUserHonorsResponseBodyHonors(TeaModel):
    def __init__(
        self,
        expiration_time: int = None,
        grant_history: List[QueryUserHonorsResponseBodyHonorsGrantHistory] = None,
        honor_desc: str = None,
        honor_id: str = None,
        honor_name: str = None,
    ):
        self.expiration_time = expiration_time
        self.grant_history = grant_history
        self.honor_desc = honor_desc
        self.honor_id = honor_id
        self.honor_name = honor_name

    def validate(self):
        if self.grant_history:
            for k in self.grant_history:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expiration_time is not None:
            result['expirationTime'] = self.expiration_time
        result['grantHistory'] = []
        if self.grant_history is not None:
            for k in self.grant_history:
                result['grantHistory'].append(k.to_map() if k else None)
        if self.honor_desc is not None:
            result['honorDesc'] = self.honor_desc
        if self.honor_id is not None:
            result['honorId'] = self.honor_id
        if self.honor_name is not None:
            result['honorName'] = self.honor_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('expirationTime') is not None:
            self.expiration_time = m.get('expirationTime')
        self.grant_history = []
        if m.get('grantHistory') is not None:
            for k in m.get('grantHistory'):
                temp_model = QueryUserHonorsResponseBodyHonorsGrantHistory()
                self.grant_history.append(temp_model.from_map(k))
        if m.get('honorDesc') is not None:
            self.honor_desc = m.get('honorDesc')
        if m.get('honorId') is not None:
            self.honor_id = m.get('honorId')
        if m.get('honorName') is not None:
            self.honor_name = m.get('honorName')
        return self


class QueryUserHonorsResponseBody(TeaModel):
    def __init__(
        self,
        honors: List[QueryUserHonorsResponseBodyHonors] = None,
        next_token: str = None,
        request_id: str = None,
    ):
        self.honors = honors
        self.next_token = next_token
        # requestId
        self.request_id = request_id

    def validate(self):
        if self.honors:
            for k in self.honors:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['honors'] = []
        if self.honors is not None:
            for k in self.honors:
                result['honors'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.honors = []
        if m.get('honors') is not None:
            for k in m.get('honors'):
                temp_model = QueryUserHonorsResponseBodyHonors()
                self.honors.append(temp_model.from_map(k))
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class QueryUserHonorsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryUserHonorsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryUserHonorsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RecallHonorHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class RecallHonorHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: RecallHonorHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = RecallHonorHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class RecallHonorShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class RecallHonorRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class RecallHonorRequest(TeaModel):
    def __init__(
        self,
        tenant_context: RecallHonorRequestTenantContext = None,
        honor_id: str = None,
        org_id: int = None,
        user_id: str = None,
    ):
        self.tenant_context = tenant_context
        # This parameter is required.
        self.honor_id = honor_id
        # This parameter is required.
        self.org_id = org_id
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.honor_id is not None:
            result['honorId'] = self.honor_id
        if self.org_id is not None:
            result['orgId'] = self.org_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = RecallHonorRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('honorId') is not None:
            self.honor_id = m.get('honorId')
        if m.get('orgId') is not None:
            self.org_id = m.get('orgId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class RecallHonorShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        honor_id: str = None,
        org_id: int = None,
        user_id: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.honor_id = honor_id
        # This parameter is required.
        self.org_id = org_id
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.honor_id is not None:
            result['honorId'] = self.honor_id
        if self.org_id is not None:
            result['orgId'] = self.org_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('honorId') is not None:
            self.honor_id = m.get('honorId')
        if m.get('orgId') is not None:
            self.org_id = m.get('orgId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class RecallHonorResponseBodyContent(TeaModel):
    def __init__(
        self,
        data: Any = None,
    ):
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class RecallHonorResponseBody(TeaModel):
    def __init__(
        self,
        content: RecallHonorResponseBodyContent = None,
        error_code: str = None,
        error_ctx: Dict[str, Any] = None,
        error_msg: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.content = content
        self.error_code = error_code
        self.error_ctx = error_ctx
        self.error_msg = error_msg
        self.http_status_code = http_status_code
        # requestId
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content.to_map()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_ctx is not None:
            result['errorCtx'] = self.error_ctx
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            temp_model = RecallHonorResponseBodyContent()
            self.content = temp_model.from_map(m['content'])
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorCtx') is not None:
            self.error_ctx = m.get('errorCtx')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class RecallHonorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RecallHonorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RecallHonorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReceiverListReportHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ReceiverListReportHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: ReceiverListReportHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = ReceiverListReportHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class ReceiverListReportShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class ReceiverListReportRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class ReceiverListReportRequest(TeaModel):
    def __init__(
        self,
        offset: int = None,
        report_id: str = None,
        size: int = None,
        tenant_context: ReceiverListReportRequestTenantContext = None,
    ):
        # This parameter is required.
        self.offset = offset
        # This parameter is required.
        self.report_id = report_id
        # This parameter is required.
        self.size = size
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.offset is not None:
            result['Offset'] = self.offset
        if self.report_id is not None:
            result['ReportId'] = self.report_id
        if self.size is not None:
            result['Size'] = self.size
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        if m.get('ReportId') is not None:
            self.report_id = m.get('ReportId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('TenantContext') is not None:
            temp_model = ReceiverListReportRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class ReceiverListReportShrinkRequest(TeaModel):
    def __init__(
        self,
        offset: int = None,
        report_id: str = None,
        size: int = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.offset = offset
        # This parameter is required.
        self.report_id = report_id
        # This parameter is required.
        self.size = size
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.offset is not None:
            result['Offset'] = self.offset
        if self.report_id is not None:
            result['ReportId'] = self.report_id
        if self.size is not None:
            result['Size'] = self.size
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        if m.get('ReportId') is not None:
            self.report_id = m.get('ReportId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class ReceiverListReportResponseBody(TeaModel):
    def __init__(
        self,
        has_more: bool = None,
        next_cursor: int = None,
        request_id: str = None,
        userid_list: List[str] = None,
    ):
        self.has_more = has_more
        self.next_cursor = next_cursor
        # requestId
        self.request_id = request_id
        self.userid_list = userid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_more is not None:
            result['hasMore'] = self.has_more
        if self.next_cursor is not None:
            result['nextCursor'] = self.next_cursor
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.userid_list is not None:
            result['useridList'] = self.userid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('hasMore') is not None:
            self.has_more = m.get('hasMore')
        if m.get('nextCursor') is not None:
            self.next_cursor = m.get('nextCursor')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('useridList') is not None:
            self.userid_list = m.get('useridList')
        return self


class ReceiverListReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReceiverListReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReceiverListReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RedirectTaskHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class RedirectTaskHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: RedirectTaskHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = RedirectTaskHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class RedirectTaskShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class RedirectTaskRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        by_manager: str = None,
        language: str = None,
        now_action_executor_id: str = None,
        process_instance_id: str = None,
        remark: str = None,
        system_token: str = None,
        task_id: int = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        self.by_manager = by_manager
        self.language = language
        # This parameter is required.
        self.now_action_executor_id = now_action_executor_id
        # This parameter is required.
        self.process_instance_id = process_instance_id
        self.remark = remark
        # This parameter is required.
        self.system_token = system_token
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.by_manager is not None:
            result['ByManager'] = self.by_manager
        if self.language is not None:
            result['Language'] = self.language
        if self.now_action_executor_id is not None:
            result['NowActionExecutorId'] = self.now_action_executor_id
        if self.process_instance_id is not None:
            result['ProcessInstanceId'] = self.process_instance_id
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('ByManager') is not None:
            self.by_manager = m.get('ByManager')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('NowActionExecutorId') is not None:
            self.now_action_executor_id = m.get('NowActionExecutorId')
        if m.get('ProcessInstanceId') is not None:
            self.process_instance_id = m.get('ProcessInstanceId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class RedirectTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class RedirectTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RedirectTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RedirectTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveAttendeeHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class RemoveAttendeeHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: RemoveAttendeeHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = RemoveAttendeeHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class RemoveAttendeeShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class RemoveAttendeeRequest(TeaModel):
    def __init__(
        self,
        attendees_to_remove: List[str] = None,
        calendar_id: str = None,
        event_id: str = None,
    ):
        self.attendees_to_remove = attendees_to_remove
        # This parameter is required.
        self.calendar_id = calendar_id
        # This parameter is required.
        self.event_id = event_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attendees_to_remove is not None:
            result['AttendeesToRemove'] = self.attendees_to_remove
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        if self.event_id is not None:
            result['EventId'] = self.event_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttendeesToRemove') is not None:
            self.attendees_to_remove = m.get('AttendeesToRemove')
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        return self


class RemoveAttendeeShrinkRequest(TeaModel):
    def __init__(
        self,
        attendees_to_remove_shrink: str = None,
        calendar_id: str = None,
        event_id: str = None,
    ):
        self.attendees_to_remove_shrink = attendees_to_remove_shrink
        # This parameter is required.
        self.calendar_id = calendar_id
        # This parameter is required.
        self.event_id = event_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attendees_to_remove_shrink is not None:
            result['AttendeesToRemove'] = self.attendees_to_remove_shrink
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        if self.event_id is not None:
            result['EventId'] = self.event_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttendeesToRemove') is not None:
            self.attendees_to_remove_shrink = m.get('AttendeesToRemove')
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        return self


class RemoveAttendeeResponseBodyContent(TeaModel):
    def __init__(
        self,
        data: Any = None,
    ):
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        return self


class RemoveAttendeeResponseBody(TeaModel):
    def __init__(
        self,
        content: RemoveAttendeeResponseBodyContent = None,
        error_code: str = None,
        error_ctx: Dict[str, Any] = None,
        error_msg: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.content = content
        self.error_code = error_code
        self.error_ctx = error_ctx
        self.error_msg = error_msg
        self.http_status_code = http_status_code
        # RequestId
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_ctx is not None:
            result['ErrorCtx'] = self.error_ctx
        if self.error_msg is not None:
            result['ErrorMsg'] = self.error_msg
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            temp_model = RemoveAttendeeResponseBodyContent()
            self.content = temp_model.from_map(m['Content'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorCtx') is not None:
            self.error_ctx = m.get('ErrorCtx')
        if m.get('ErrorMsg') is not None:
            self.error_msg = m.get('ErrorMsg')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RemoveAttendeeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveAttendeeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveAttendeeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveMeetingRoomsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class RemoveMeetingRoomsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: RemoveMeetingRoomsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = RemoveMeetingRoomsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class RemoveMeetingRoomsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class RemoveMeetingRoomsRequestMeetingRoomsToRemove(TeaModel):
    def __init__(
        self,
        room_id: str = None,
    ):
        # This parameter is required.
        self.room_id = room_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.room_id is not None:
            result['RoomId'] = self.room_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RoomId') is not None:
            self.room_id = m.get('RoomId')
        return self


class RemoveMeetingRoomsRequest(TeaModel):
    def __init__(
        self,
        calendar_id: str = None,
        event_id: str = None,
        meeting_rooms_to_remove: List[RemoveMeetingRoomsRequestMeetingRoomsToRemove] = None,
    ):
        # This parameter is required.
        self.calendar_id = calendar_id
        # This parameter is required.
        self.event_id = event_id
        self.meeting_rooms_to_remove = meeting_rooms_to_remove

    def validate(self):
        if self.meeting_rooms_to_remove:
            for k in self.meeting_rooms_to_remove:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        if self.event_id is not None:
            result['EventId'] = self.event_id
        result['MeetingRoomsToRemove'] = []
        if self.meeting_rooms_to_remove is not None:
            for k in self.meeting_rooms_to_remove:
                result['MeetingRoomsToRemove'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        self.meeting_rooms_to_remove = []
        if m.get('MeetingRoomsToRemove') is not None:
            for k in m.get('MeetingRoomsToRemove'):
                temp_model = RemoveMeetingRoomsRequestMeetingRoomsToRemove()
                self.meeting_rooms_to_remove.append(temp_model.from_map(k))
        return self


class RemoveMeetingRoomsShrinkRequest(TeaModel):
    def __init__(
        self,
        calendar_id: str = None,
        event_id: str = None,
        meeting_rooms_to_remove_shrink: str = None,
    ):
        # This parameter is required.
        self.calendar_id = calendar_id
        # This parameter is required.
        self.event_id = event_id
        self.meeting_rooms_to_remove_shrink = meeting_rooms_to_remove_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.meeting_rooms_to_remove_shrink is not None:
            result['MeetingRoomsToRemove'] = self.meeting_rooms_to_remove_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('MeetingRoomsToRemove') is not None:
            self.meeting_rooms_to_remove_shrink = m.get('MeetingRoomsToRemove')
        return self


class RemoveMeetingRoomsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: bool = None,
    ):
        # requestId
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class RemoveMeetingRoomsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveMeetingRoomsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveMeetingRoomsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RespondEventHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class RespondEventHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: RespondEventHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = RespondEventHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class RespondEventShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class RespondEventRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class RespondEventRequest(TeaModel):
    def __init__(
        self,
        calendar_id: str = None,
        event_id: str = None,
        response_status: str = None,
        tenant_context: RespondEventRequestTenantContext = None,
    ):
        # This parameter is required.
        self.calendar_id = calendar_id
        # This parameter is required.
        self.event_id = event_id
        # This parameter is required.
        self.response_status = response_status
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.response_status is not None:
            result['ResponseStatus'] = self.response_status
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('ResponseStatus') is not None:
            self.response_status = m.get('ResponseStatus')
        if m.get('TenantContext') is not None:
            temp_model = RespondEventRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class RespondEventShrinkRequest(TeaModel):
    def __init__(
        self,
        calendar_id: str = None,
        event_id: str = None,
        response_status: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.calendar_id = calendar_id
        # This parameter is required.
        self.event_id = event_id
        # This parameter is required.
        self.response_status = response_status
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.response_status is not None:
            result['ResponseStatus'] = self.response_status
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('ResponseStatus') is not None:
            self.response_status = m.get('ResponseStatus')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class RespondEventResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class RespondEventResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RespondEventResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RespondEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RetrieveRunHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_id: str = None,
    ):
        self.common_headers = common_headers
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class RetrieveRunRequest(TeaModel):
    def __init__(
        self,
        assistant_id: str = None,
        original_assistant_id: str = None,
        run_id: str = None,
        source_id_of_original_assistant_id: str = None,
        source_type_of_original_assistant_id: str = None,
    ):
        # This parameter is required.
        self.assistant_id = assistant_id
        self.original_assistant_id = original_assistant_id
        self.run_id = run_id
        self.source_id_of_original_assistant_id = source_id_of_original_assistant_id
        self.source_type_of_original_assistant_id = source_type_of_original_assistant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assistant_id is not None:
            result['assistantId'] = self.assistant_id
        if self.original_assistant_id is not None:
            result['originalAssistantId'] = self.original_assistant_id
        if self.run_id is not None:
            result['runId'] = self.run_id
        if self.source_id_of_original_assistant_id is not None:
            result['sourceIdOfOriginalAssistantId'] = self.source_id_of_original_assistant_id
        if self.source_type_of_original_assistant_id is not None:
            result['sourceTypeOfOriginalAssistantId'] = self.source_type_of_original_assistant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assistantId') is not None:
            self.assistant_id = m.get('assistantId')
        if m.get('originalAssistantId') is not None:
            self.original_assistant_id = m.get('originalAssistantId')
        if m.get('runId') is not None:
            self.run_id = m.get('runId')
        if m.get('sourceIdOfOriginalAssistantId') is not None:
            self.source_id_of_original_assistant_id = m.get('sourceIdOfOriginalAssistantId')
        if m.get('sourceTypeOfOriginalAssistantId') is not None:
            self.source_type_of_original_assistant_id = m.get('sourceTypeOfOriginalAssistantId')
        return self


class RetrieveRunResponseBodyRun(TeaModel):
    def __init__(
        self,
        cancelled_at: int = None,
        completed_at: int = None,
        create_at: int = None,
        expires_at: int = None,
        failed_at: int = None,
        id: str = None,
        last_error_msg: str = None,
        started_at: int = None,
        status: str = None,
        thread_id: str = None,
    ):
        self.cancelled_at = cancelled_at
        self.completed_at = completed_at
        self.create_at = create_at
        self.expires_at = expires_at
        self.failed_at = failed_at
        self.id = id
        self.last_error_msg = last_error_msg
        self.started_at = started_at
        self.status = status
        self.thread_id = thread_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cancelled_at is not None:
            result['cancelledAt'] = self.cancelled_at
        if self.completed_at is not None:
            result['completedAt'] = self.completed_at
        if self.create_at is not None:
            result['createAt'] = self.create_at
        if self.expires_at is not None:
            result['expiresAt'] = self.expires_at
        if self.failed_at is not None:
            result['failedAt'] = self.failed_at
        if self.id is not None:
            result['id'] = self.id
        if self.last_error_msg is not None:
            result['lastErrorMsg'] = self.last_error_msg
        if self.started_at is not None:
            result['startedAt'] = self.started_at
        if self.status is not None:
            result['status'] = self.status
        if self.thread_id is not None:
            result['threadId'] = self.thread_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cancelledAt') is not None:
            self.cancelled_at = m.get('cancelledAt')
        if m.get('completedAt') is not None:
            self.completed_at = m.get('completedAt')
        if m.get('createAt') is not None:
            self.create_at = m.get('createAt')
        if m.get('expiresAt') is not None:
            self.expires_at = m.get('expiresAt')
        if m.get('failedAt') is not None:
            self.failed_at = m.get('failedAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('lastErrorMsg') is not None:
            self.last_error_msg = m.get('lastErrorMsg')
        if m.get('startedAt') is not None:
            self.started_at = m.get('startedAt')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('threadId') is not None:
            self.thread_id = m.get('threadId')
        return self


class RetrieveRunResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        run: RetrieveRunResponseBodyRun = None,
    ):
        self.request_id = request_id
        self.run = run

    def validate(self):
        if self.run:
            self.run.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.run is not None:
            result['run'] = self.run.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('run') is not None:
            temp_model = RetrieveRunResponseBodyRun()
            self.run = temp_model.from_map(m['run'])
        return self


class RetrieveRunResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RetrieveRunResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RetrieveRunResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveContentHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SaveContentHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SaveContentHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SaveContentHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SaveContentShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SaveContentRequestContents(TeaModel):
    def __init__(
        self,
        content: str = None,
        content_type: str = None,
        key: str = None,
        sort: int = None,
        type: int = None,
    ):
        # This parameter is required.
        self.content = content
        # This parameter is required.
        self.content_type = content_type
        # This parameter is required.
        self.key = key
        # This parameter is required.
        self.sort = sort
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.content_type is not None:
            result['ContentType'] = self.content_type
        if self.key is not None:
            result['Key'] = self.key
        if self.sort is not None:
            result['Sort'] = self.sort
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('ContentType') is not None:
            self.content_type = m.get('ContentType')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Sort') is not None:
            self.sort = m.get('Sort')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SaveContentRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class SaveContentRequest(TeaModel):
    def __init__(
        self,
        contents: List[SaveContentRequestContents] = None,
        dd_from: str = None,
        template_id: str = None,
        tenant_context: SaveContentRequestTenantContext = None,
    ):
        # This parameter is required.
        self.contents = contents
        # This parameter is required.
        self.dd_from = dd_from
        # This parameter is required.
        self.template_id = template_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.contents:
            for k in self.contents:
                if k:
                    k.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Contents'] = []
        if self.contents is not None:
            for k in self.contents:
                result['Contents'].append(k.to_map() if k else None)
        if self.dd_from is not None:
            result['DdFrom'] = self.dd_from
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.contents = []
        if m.get('Contents') is not None:
            for k in m.get('Contents'):
                temp_model = SaveContentRequestContents()
                self.contents.append(temp_model.from_map(k))
        if m.get('DdFrom') is not None:
            self.dd_from = m.get('DdFrom')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TenantContext') is not None:
            temp_model = SaveContentRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class SaveContentShrinkRequest(TeaModel):
    def __init__(
        self,
        contents_shrink: str = None,
        dd_from: str = None,
        template_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.contents_shrink = contents_shrink
        # This parameter is required.
        self.dd_from = dd_from
        # This parameter is required.
        self.template_id = template_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contents_shrink is not None:
            result['Contents'] = self.contents_shrink
        if self.dd_from is not None:
            result['DdFrom'] = self.dd_from
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Contents') is not None:
            self.contents_shrink = m.get('Contents')
        if m.get('DdFrom') is not None:
            self.dd_from = m.get('DdFrom')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class SaveContentResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # requestId
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class SaveContentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveContentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveContentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveFormDataHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SaveFormDataHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SaveFormDataHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SaveFormDataHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SaveFormDataShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SaveFormDataRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        form_data_json: str = None,
        form_uuid: str = None,
        language: str = None,
        system_token: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        # This parameter is required.
        self.form_data_json = form_data_json
        # This parameter is required.
        self.form_uuid = form_uuid
        self.language = language
        # This parameter is required.
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.form_data_json is not None:
            result['FormDataJson'] = self.form_data_json
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.language is not None:
            result['Language'] = self.language
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('FormDataJson') is not None:
            self.form_data_json = m.get('FormDataJson')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class SaveFormDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.result = result
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class SaveFormDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveFormDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveFormDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveFormRemarkHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SaveFormRemarkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SaveFormRemarkHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SaveFormRemarkHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SaveFormRemarkShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SaveFormRemarkRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        at_user_id: str = None,
        content: str = None,
        form_instance_id: str = None,
        language: str = None,
        reply_id: int = None,
        system_token: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        self.at_user_id = at_user_id
        # This parameter is required.
        self.content = content
        # This parameter is required.
        self.form_instance_id = form_instance_id
        self.language = language
        self.reply_id = reply_id
        # This parameter is required.
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.at_user_id is not None:
            result['AtUserId'] = self.at_user_id
        if self.content is not None:
            result['Content'] = self.content
        if self.form_instance_id is not None:
            result['FormInstanceId'] = self.form_instance_id
        if self.language is not None:
            result['Language'] = self.language
        if self.reply_id is not None:
            result['ReplyId'] = self.reply_id
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('AtUserId') is not None:
            self.at_user_id = m.get('AtUserId')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('FormInstanceId') is not None:
            self.form_instance_id = m.get('FormInstanceId')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('ReplyId') is not None:
            self.reply_id = m.get('ReplyId')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class SaveFormRemarkResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.result = result
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class SaveFormRemarkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveFormRemarkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveFormRemarkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchEmployeeFieldValuesHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SearchEmployeeFieldValuesHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SearchEmployeeFieldValuesHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SearchEmployeeFieldValuesHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SearchEmployeeFieldValuesShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SearchEmployeeFieldValuesRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        create_from_time_gmt: str = None,
        create_to_time_gmt: str = None,
        form_uuid: str = None,
        language: str = None,
        modified_from_time_gmt: str = None,
        modified_to_time_gmt: str = None,
        originator_id: str = None,
        search_field_json: str = None,
        system_token: str = None,
        target_field_json: str = None,
    ):
        self.app_type = app_type
        self.create_from_time_gmt = create_from_time_gmt
        self.create_to_time_gmt = create_to_time_gmt
        self.form_uuid = form_uuid
        self.language = language
        self.modified_from_time_gmt = modified_from_time_gmt
        self.modified_to_time_gmt = modified_to_time_gmt
        self.originator_id = originator_id
        self.search_field_json = search_field_json
        self.system_token = system_token
        self.target_field_json = target_field_json

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.create_from_time_gmt is not None:
            result['CreateFromTimeGMT'] = self.create_from_time_gmt
        if self.create_to_time_gmt is not None:
            result['CreateToTimeGMT'] = self.create_to_time_gmt
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.language is not None:
            result['Language'] = self.language
        if self.modified_from_time_gmt is not None:
            result['ModifiedFromTimeGMT'] = self.modified_from_time_gmt
        if self.modified_to_time_gmt is not None:
            result['ModifiedToTimeGMT'] = self.modified_to_time_gmt
        if self.originator_id is not None:
            result['OriginatorId'] = self.originator_id
        if self.search_field_json is not None:
            result['SearchFieldJson'] = self.search_field_json
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        if self.target_field_json is not None:
            result['TargetFieldJson'] = self.target_field_json
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('CreateFromTimeGMT') is not None:
            self.create_from_time_gmt = m.get('CreateFromTimeGMT')
        if m.get('CreateToTimeGMT') is not None:
            self.create_to_time_gmt = m.get('CreateToTimeGMT')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('ModifiedFromTimeGMT') is not None:
            self.modified_from_time_gmt = m.get('ModifiedFromTimeGMT')
        if m.get('ModifiedToTimeGMT') is not None:
            self.modified_to_time_gmt = m.get('ModifiedToTimeGMT')
        if m.get('OriginatorId') is not None:
            self.originator_id = m.get('OriginatorId')
        if m.get('SearchFieldJson') is not None:
            self.search_field_json = m.get('SearchFieldJson')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        if m.get('TargetFieldJson') is not None:
            self.target_field_json = m.get('TargetFieldJson')
        return self


class SearchEmployeeFieldValuesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.result = result
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class SearchEmployeeFieldValuesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchEmployeeFieldValuesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchEmployeeFieldValuesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchFormDataIdListHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SearchFormDataIdListHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SearchFormDataIdListHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SearchFormDataIdListHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SearchFormDataIdListShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SearchFormDataIdListRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        create_from_time_gmt: str = None,
        create_to_time_gmt: str = None,
        form_uuid: str = None,
        language: str = None,
        modified_from_time_gmt: str = None,
        modified_to_time_gmt: str = None,
        originator_id: str = None,
        page_number: int = None,
        page_size: int = None,
        search_field_json: str = None,
        system_token: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        self.create_from_time_gmt = create_from_time_gmt
        self.create_to_time_gmt = create_to_time_gmt
        # This parameter is required.
        self.form_uuid = form_uuid
        self.language = language
        self.modified_from_time_gmt = modified_from_time_gmt
        self.modified_to_time_gmt = modified_to_time_gmt
        self.originator_id = originator_id
        self.page_number = page_number
        self.page_size = page_size
        self.search_field_json = search_field_json
        # This parameter is required.
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.create_from_time_gmt is not None:
            result['CreateFromTimeGMT'] = self.create_from_time_gmt
        if self.create_to_time_gmt is not None:
            result['CreateToTimeGMT'] = self.create_to_time_gmt
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.language is not None:
            result['Language'] = self.language
        if self.modified_from_time_gmt is not None:
            result['ModifiedFromTimeGMT'] = self.modified_from_time_gmt
        if self.modified_to_time_gmt is not None:
            result['ModifiedToTimeGMT'] = self.modified_to_time_gmt
        if self.originator_id is not None:
            result['OriginatorId'] = self.originator_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_field_json is not None:
            result['SearchFieldJson'] = self.search_field_json
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('CreateFromTimeGMT') is not None:
            self.create_from_time_gmt = m.get('CreateFromTimeGMT')
        if m.get('CreateToTimeGMT') is not None:
            self.create_to_time_gmt = m.get('CreateToTimeGMT')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('ModifiedFromTimeGMT') is not None:
            self.modified_from_time_gmt = m.get('ModifiedFromTimeGMT')
        if m.get('ModifiedToTimeGMT') is not None:
            self.modified_to_time_gmt = m.get('ModifiedToTimeGMT')
        if m.get('OriginatorId') is not None:
            self.originator_id = m.get('OriginatorId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchFieldJson') is not None:
            self.search_field_json = m.get('SearchFieldJson')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class SearchFormDataIdListResponseBody(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
        page_number: int = None,
        request_id: str = None,
        total_count: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.data = data
        self.page_number = page_number
        self.request_id = request_id
        self.total_count = total_count
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class SearchFormDataIdListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchFormDataIdListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchFormDataIdListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchFormDataSecondGenerationHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SearchFormDataSecondGenerationHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SearchFormDataSecondGenerationHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SearchFormDataSecondGenerationHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SearchFormDataSecondGenerationShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SearchFormDataSecondGenerationRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        create_from_time_gmt: str = None,
        create_to_time_gmt: str = None,
        form_uuid: str = None,
        modified_from_time_gmt: str = None,
        modified_to_time_gmt: str = None,
        order_config_json: str = None,
        originator_id: str = None,
        page_number: int = None,
        page_size: int = None,
        search_condition: str = None,
        system_token: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        self.create_from_time_gmt = create_from_time_gmt
        self.create_to_time_gmt = create_to_time_gmt
        # This parameter is required.
        self.form_uuid = form_uuid
        self.modified_from_time_gmt = modified_from_time_gmt
        self.modified_to_time_gmt = modified_to_time_gmt
        self.order_config_json = order_config_json
        self.originator_id = originator_id
        self.page_number = page_number
        self.page_size = page_size
        self.search_condition = search_condition
        # This parameter is required.
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.create_from_time_gmt is not None:
            result['CreateFromTimeGMT'] = self.create_from_time_gmt
        if self.create_to_time_gmt is not None:
            result['CreateToTimeGMT'] = self.create_to_time_gmt
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.modified_from_time_gmt is not None:
            result['ModifiedFromTimeGMT'] = self.modified_from_time_gmt
        if self.modified_to_time_gmt is not None:
            result['ModifiedToTimeGMT'] = self.modified_to_time_gmt
        if self.order_config_json is not None:
            result['OrderConfigJson'] = self.order_config_json
        if self.originator_id is not None:
            result['OriginatorId'] = self.originator_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_condition is not None:
            result['SearchCondition'] = self.search_condition
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('CreateFromTimeGMT') is not None:
            self.create_from_time_gmt = m.get('CreateFromTimeGMT')
        if m.get('CreateToTimeGMT') is not None:
            self.create_to_time_gmt = m.get('CreateToTimeGMT')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('ModifiedFromTimeGMT') is not None:
            self.modified_from_time_gmt = m.get('ModifiedFromTimeGMT')
        if m.get('ModifiedToTimeGMT') is not None:
            self.modified_to_time_gmt = m.get('ModifiedToTimeGMT')
        if m.get('OrderConfigJson') is not None:
            self.order_config_json = m.get('OrderConfigJson')
        if m.get('OriginatorId') is not None:
            self.originator_id = m.get('OriginatorId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchCondition') is not None:
            self.search_condition = m.get('SearchCondition')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class SearchFormDataSecondGenerationResponseBodyDataModifyUserName(TeaModel):
    def __init__(
        self,
        name_in_chinese: str = None,
        name_in_english: str = None,
    ):
        self.name_in_chinese = name_in_chinese
        self.name_in_english = name_in_english

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_in_chinese is not None:
            result['NameInChinese'] = self.name_in_chinese
        if self.name_in_english is not None:
            result['NameInEnglish'] = self.name_in_english
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameInChinese') is not None:
            self.name_in_chinese = m.get('NameInChinese')
        if m.get('NameInEnglish') is not None:
            self.name_in_english = m.get('NameInEnglish')
        return self


class SearchFormDataSecondGenerationResponseBodyDataModifyUser(TeaModel):
    def __init__(
        self,
        name: SearchFormDataSecondGenerationResponseBodyDataModifyUserName = None,
        user_id: str = None,
    ):
        self.name = name
        self.user_id = user_id

    def validate(self):
        if self.name:
            self.name.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            temp_model = SearchFormDataSecondGenerationResponseBodyDataModifyUserName()
            self.name = temp_model.from_map(m['Name'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class SearchFormDataSecondGenerationResponseBodyDataOriginatorName(TeaModel):
    def __init__(
        self,
        name_in_chinese: str = None,
        name_in_english: str = None,
    ):
        self.name_in_chinese = name_in_chinese
        self.name_in_english = name_in_english

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_in_chinese is not None:
            result['NameInChinese'] = self.name_in_chinese
        if self.name_in_english is not None:
            result['NameInEnglish'] = self.name_in_english
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameInChinese') is not None:
            self.name_in_chinese = m.get('NameInChinese')
        if m.get('NameInEnglish') is not None:
            self.name_in_english = m.get('NameInEnglish')
        return self


class SearchFormDataSecondGenerationResponseBodyDataOriginator(TeaModel):
    def __init__(
        self,
        name: SearchFormDataSecondGenerationResponseBodyDataOriginatorName = None,
        user_id: str = None,
    ):
        self.name = name
        self.user_id = user_id

    def validate(self):
        if self.name:
            self.name.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            temp_model = SearchFormDataSecondGenerationResponseBodyDataOriginatorName()
            self.name = temp_model.from_map(m['Name'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class SearchFormDataSecondGenerationResponseBodyData(TeaModel):
    def __init__(
        self,
        create_time_gmt: str = None,
        creator_user_id: str = None,
        form_data: Dict[str, Any] = None,
        form_instance_id: str = None,
        form_uuid: str = None,
        id: int = None,
        instance_value: str = None,
        modified_time_gmt: str = None,
        modifier: str = None,
        modify_user: SearchFormDataSecondGenerationResponseBodyDataModifyUser = None,
        originator: SearchFormDataSecondGenerationResponseBodyDataOriginator = None,
        sequence: str = None,
        serial_number: str = None,
        title: str = None,
        version: int = None,
    ):
        self.create_time_gmt = create_time_gmt
        self.creator_user_id = creator_user_id
        self.form_data = form_data
        self.form_instance_id = form_instance_id
        self.form_uuid = form_uuid
        self.id = id
        self.instance_value = instance_value
        self.modified_time_gmt = modified_time_gmt
        self.modifier = modifier
        self.modify_user = modify_user
        self.originator = originator
        self.sequence = sequence
        self.serial_number = serial_number
        self.title = title
        self.version = version

    def validate(self):
        if self.modify_user:
            self.modify_user.validate()
        if self.originator:
            self.originator.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time_gmt is not None:
            result['CreateTimeGMT'] = self.create_time_gmt
        if self.creator_user_id is not None:
            result['CreatorUserId'] = self.creator_user_id
        if self.form_data is not None:
            result['FormData'] = self.form_data
        if self.form_instance_id is not None:
            result['FormInstanceId'] = self.form_instance_id
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_value is not None:
            result['InstanceValue'] = self.instance_value
        if self.modified_time_gmt is not None:
            result['ModifiedTimeGMT'] = self.modified_time_gmt
        if self.modifier is not None:
            result['Modifier'] = self.modifier
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user.to_map()
        if self.originator is not None:
            result['Originator'] = self.originator.to_map()
        if self.sequence is not None:
            result['Sequence'] = self.sequence
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        if self.title is not None:
            result['Title'] = self.title
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTimeGMT') is not None:
            self.create_time_gmt = m.get('CreateTimeGMT')
        if m.get('CreatorUserId') is not None:
            self.creator_user_id = m.get('CreatorUserId')
        if m.get('FormData') is not None:
            self.form_data = m.get('FormData')
        if m.get('FormInstanceId') is not None:
            self.form_instance_id = m.get('FormInstanceId')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceValue') is not None:
            self.instance_value = m.get('InstanceValue')
        if m.get('ModifiedTimeGMT') is not None:
            self.modified_time_gmt = m.get('ModifiedTimeGMT')
        if m.get('Modifier') is not None:
            self.modifier = m.get('Modifier')
        if m.get('ModifyUser') is not None:
            temp_model = SearchFormDataSecondGenerationResponseBodyDataModifyUser()
            self.modify_user = temp_model.from_map(m['ModifyUser'])
        if m.get('Originator') is not None:
            temp_model = SearchFormDataSecondGenerationResponseBodyDataOriginator()
            self.originator = temp_model.from_map(m['Originator'])
        if m.get('Sequence') is not None:
            self.sequence = m.get('Sequence')
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class SearchFormDataSecondGenerationResponseBody(TeaModel):
    def __init__(
        self,
        data: List[SearchFormDataSecondGenerationResponseBodyData] = None,
        page_number: int = None,
        request_id: str = None,
        total_count: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.data = data
        self.page_number = page_number
        self.request_id = request_id
        self.total_count = total_count
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = SearchFormDataSecondGenerationResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class SearchFormDataSecondGenerationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchFormDataSecondGenerationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchFormDataSecondGenerationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchFormDataSecondGenerationNoTableFieldHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SearchFormDataSecondGenerationNoTableFieldHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SearchFormDataSecondGenerationNoTableFieldHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SearchFormDataSecondGenerationNoTableFieldHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SearchFormDataSecondGenerationNoTableFieldShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SearchFormDataSecondGenerationNoTableFieldRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        create_from_time_gmt: str = None,
        create_to_time_gmt: str = None,
        form_uuid: str = None,
        modified_from_time_gmt: str = None,
        modified_to_time_gmt: str = None,
        order_config_json: str = None,
        originator_id: str = None,
        page_number: int = None,
        page_size: int = None,
        search_condition: str = None,
        system_token: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        self.create_from_time_gmt = create_from_time_gmt
        self.create_to_time_gmt = create_to_time_gmt
        # This parameter is required.
        self.form_uuid = form_uuid
        self.modified_from_time_gmt = modified_from_time_gmt
        self.modified_to_time_gmt = modified_to_time_gmt
        self.order_config_json = order_config_json
        self.originator_id = originator_id
        self.page_number = page_number
        self.page_size = page_size
        self.search_condition = search_condition
        # This parameter is required.
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.create_from_time_gmt is not None:
            result['CreateFromTimeGMT'] = self.create_from_time_gmt
        if self.create_to_time_gmt is not None:
            result['CreateToTimeGMT'] = self.create_to_time_gmt
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.modified_from_time_gmt is not None:
            result['ModifiedFromTimeGMT'] = self.modified_from_time_gmt
        if self.modified_to_time_gmt is not None:
            result['ModifiedToTimeGMT'] = self.modified_to_time_gmt
        if self.order_config_json is not None:
            result['OrderConfigJson'] = self.order_config_json
        if self.originator_id is not None:
            result['OriginatorId'] = self.originator_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_condition is not None:
            result['SearchCondition'] = self.search_condition
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('CreateFromTimeGMT') is not None:
            self.create_from_time_gmt = m.get('CreateFromTimeGMT')
        if m.get('CreateToTimeGMT') is not None:
            self.create_to_time_gmt = m.get('CreateToTimeGMT')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('ModifiedFromTimeGMT') is not None:
            self.modified_from_time_gmt = m.get('ModifiedFromTimeGMT')
        if m.get('ModifiedToTimeGMT') is not None:
            self.modified_to_time_gmt = m.get('ModifiedToTimeGMT')
        if m.get('OrderConfigJson') is not None:
            self.order_config_json = m.get('OrderConfigJson')
        if m.get('OriginatorId') is not None:
            self.originator_id = m.get('OriginatorId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchCondition') is not None:
            self.search_condition = m.get('SearchCondition')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUserName(TeaModel):
    def __init__(
        self,
        name_in_chinese: str = None,
        name_in_english: str = None,
    ):
        self.name_in_chinese = name_in_chinese
        self.name_in_english = name_in_english

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_in_chinese is not None:
            result['NameInChinese'] = self.name_in_chinese
        if self.name_in_english is not None:
            result['NameInEnglish'] = self.name_in_english
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameInChinese') is not None:
            self.name_in_chinese = m.get('NameInChinese')
        if m.get('NameInEnglish') is not None:
            self.name_in_english = m.get('NameInEnglish')
        return self


class SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUser(TeaModel):
    def __init__(
        self,
        name: SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUserName = None,
        user_id: str = None,
    ):
        self.name = name
        self.user_id = user_id

    def validate(self):
        if self.name:
            self.name.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            temp_model = SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUserName()
            self.name = temp_model.from_map(m['Name'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginatorName(TeaModel):
    def __init__(
        self,
        name_in_chinese: str = None,
        name_in_english: str = None,
    ):
        self.name_in_chinese = name_in_chinese
        self.name_in_english = name_in_english

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_in_chinese is not None:
            result['NameInChinese'] = self.name_in_chinese
        if self.name_in_english is not None:
            result['NameInEnglish'] = self.name_in_english
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameInChinese') is not None:
            self.name_in_chinese = m.get('NameInChinese')
        if m.get('NameInEnglish') is not None:
            self.name_in_english = m.get('NameInEnglish')
        return self


class SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginator(TeaModel):
    def __init__(
        self,
        name: SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginatorName = None,
        user_id: str = None,
    ):
        self.name = name
        self.user_id = user_id

    def validate(self):
        if self.name:
            self.name.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            temp_model = SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginatorName()
            self.name = temp_model.from_map(m['Name'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class SearchFormDataSecondGenerationNoTableFieldResponseBodyData(TeaModel):
    def __init__(
        self,
        create_time_gmt: str = None,
        creator_user_id: str = None,
        form_data: Dict[str, Any] = None,
        form_instance_id: str = None,
        form_uuid: str = None,
        id: int = None,
        instance_value: str = None,
        modified_time_gmt: str = None,
        modifier: str = None,
        modify_user: SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUser = None,
        originator: SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginator = None,
        sequence: str = None,
        serial_number: str = None,
        title: str = None,
        version: int = None,
    ):
        self.create_time_gmt = create_time_gmt
        self.creator_user_id = creator_user_id
        self.form_data = form_data
        self.form_instance_id = form_instance_id
        self.form_uuid = form_uuid
        self.id = id
        self.instance_value = instance_value
        self.modified_time_gmt = modified_time_gmt
        self.modifier = modifier
        self.modify_user = modify_user
        self.originator = originator
        self.sequence = sequence
        self.serial_number = serial_number
        self.title = title
        self.version = version

    def validate(self):
        if self.modify_user:
            self.modify_user.validate()
        if self.originator:
            self.originator.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time_gmt is not None:
            result['CreateTimeGMT'] = self.create_time_gmt
        if self.creator_user_id is not None:
            result['CreatorUserId'] = self.creator_user_id
        if self.form_data is not None:
            result['FormData'] = self.form_data
        if self.form_instance_id is not None:
            result['FormInstanceId'] = self.form_instance_id
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_value is not None:
            result['InstanceValue'] = self.instance_value
        if self.modified_time_gmt is not None:
            result['ModifiedTimeGMT'] = self.modified_time_gmt
        if self.modifier is not None:
            result['Modifier'] = self.modifier
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user.to_map()
        if self.originator is not None:
            result['Originator'] = self.originator.to_map()
        if self.sequence is not None:
            result['Sequence'] = self.sequence
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        if self.title is not None:
            result['Title'] = self.title
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTimeGMT') is not None:
            self.create_time_gmt = m.get('CreateTimeGMT')
        if m.get('CreatorUserId') is not None:
            self.creator_user_id = m.get('CreatorUserId')
        if m.get('FormData') is not None:
            self.form_data = m.get('FormData')
        if m.get('FormInstanceId') is not None:
            self.form_instance_id = m.get('FormInstanceId')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceValue') is not None:
            self.instance_value = m.get('InstanceValue')
        if m.get('ModifiedTimeGMT') is not None:
            self.modified_time_gmt = m.get('ModifiedTimeGMT')
        if m.get('Modifier') is not None:
            self.modifier = m.get('Modifier')
        if m.get('ModifyUser') is not None:
            temp_model = SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUser()
            self.modify_user = temp_model.from_map(m['ModifyUser'])
        if m.get('Originator') is not None:
            temp_model = SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginator()
            self.originator = temp_model.from_map(m['Originator'])
        if m.get('Sequence') is not None:
            self.sequence = m.get('Sequence')
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class SearchFormDataSecondGenerationNoTableFieldResponseBody(TeaModel):
    def __init__(
        self,
        data: List[SearchFormDataSecondGenerationNoTableFieldResponseBodyData] = None,
        page_number: int = None,
        request_id: str = None,
        total_count: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.data = data
        self.page_number = page_number
        self.request_id = request_id
        self.total_count = total_count
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = SearchFormDataSecondGenerationNoTableFieldResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class SearchFormDataSecondGenerationNoTableFieldResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchFormDataSecondGenerationNoTableFieldResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchFormDataSecondGenerationNoTableFieldResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchFormDatasHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SearchFormDatasHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SearchFormDatasHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SearchFormDatasHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SearchFormDatasShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SearchFormDatasRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        create_from_time_gmt: str = None,
        create_to_time_gmt: str = None,
        current_page: int = None,
        dynamic_order: str = None,
        form_uuid: str = None,
        language: str = None,
        modified_from_time_gmt: str = None,
        modified_to_time_gmt: str = None,
        originator_id: str = None,
        page_size: int = None,
        search_field_json: str = None,
        system_token: str = None,
    ):
        # This parameter is required.
        self.app_type = app_type
        self.create_from_time_gmt = create_from_time_gmt
        self.create_to_time_gmt = create_to_time_gmt
        self.current_page = current_page
        self.dynamic_order = dynamic_order
        # This parameter is required.
        self.form_uuid = form_uuid
        self.language = language
        self.modified_from_time_gmt = modified_from_time_gmt
        self.modified_to_time_gmt = modified_to_time_gmt
        self.originator_id = originator_id
        self.page_size = page_size
        self.search_field_json = search_field_json
        # This parameter is required.
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.create_from_time_gmt is not None:
            result['CreateFromTimeGMT'] = self.create_from_time_gmt
        if self.create_to_time_gmt is not None:
            result['CreateToTimeGMT'] = self.create_to_time_gmt
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dynamic_order is not None:
            result['DynamicOrder'] = self.dynamic_order
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.language is not None:
            result['Language'] = self.language
        if self.modified_from_time_gmt is not None:
            result['ModifiedFromTimeGMT'] = self.modified_from_time_gmt
        if self.modified_to_time_gmt is not None:
            result['ModifiedToTimeGMT'] = self.modified_to_time_gmt
        if self.originator_id is not None:
            result['OriginatorId'] = self.originator_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_field_json is not None:
            result['SearchFieldJson'] = self.search_field_json
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('CreateFromTimeGMT') is not None:
            self.create_from_time_gmt = m.get('CreateFromTimeGMT')
        if m.get('CreateToTimeGMT') is not None:
            self.create_to_time_gmt = m.get('CreateToTimeGMT')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DynamicOrder') is not None:
            self.dynamic_order = m.get('DynamicOrder')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('ModifiedFromTimeGMT') is not None:
            self.modified_from_time_gmt = m.get('ModifiedFromTimeGMT')
        if m.get('ModifiedToTimeGMT') is not None:
            self.modified_to_time_gmt = m.get('ModifiedToTimeGMT')
        if m.get('OriginatorId') is not None:
            self.originator_id = m.get('OriginatorId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchFieldJson') is not None:
            self.search_field_json = m.get('SearchFieldJson')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class SearchFormDatasResponseBodyDataModifyUserUserName(TeaModel):
    def __init__(
        self,
        name_in_chinese: str = None,
        name_in_english: str = None,
        type: str = None,
    ):
        self.name_in_chinese = name_in_chinese
        self.name_in_english = name_in_english
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_in_chinese is not None:
            result['NameInChinese'] = self.name_in_chinese
        if self.name_in_english is not None:
            result['NameInEnglish'] = self.name_in_english
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameInChinese') is not None:
            self.name_in_chinese = m.get('NameInChinese')
        if m.get('NameInEnglish') is not None:
            self.name_in_english = m.get('NameInEnglish')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SearchFormDatasResponseBodyDataModifyUser(TeaModel):
    def __init__(
        self,
        user_id: str = None,
        user_name: SearchFormDatasResponseBodyDataModifyUserUserName = None,
    ):
        self.user_id = user_id
        self.user_name = user_name

    def validate(self):
        if self.user_name:
            self.user_name.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            temp_model = SearchFormDatasResponseBodyDataModifyUserUserName()
            self.user_name = temp_model.from_map(m['UserName'])
        return self


class SearchFormDatasResponseBodyDataOriginatorUserName(TeaModel):
    def __init__(
        self,
        name_in_chinese: str = None,
        name_in_english: str = None,
        type: str = None,
    ):
        self.name_in_chinese = name_in_chinese
        self.name_in_english = name_in_english
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_in_chinese is not None:
            result['NameInChinese'] = self.name_in_chinese
        if self.name_in_english is not None:
            result['NameInEnglish'] = self.name_in_english
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameInChinese') is not None:
            self.name_in_chinese = m.get('NameInChinese')
        if m.get('NameInEnglish') is not None:
            self.name_in_english = m.get('NameInEnglish')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SearchFormDatasResponseBodyDataOriginator(TeaModel):
    def __init__(
        self,
        user_id: str = None,
        user_name: SearchFormDatasResponseBodyDataOriginatorUserName = None,
    ):
        self.user_id = user_id
        self.user_name = user_name

    def validate(self):
        if self.user_name:
            self.user_name.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            temp_model = SearchFormDatasResponseBodyDataOriginatorUserName()
            self.user_name = temp_model.from_map(m['UserName'])
        return self


class SearchFormDatasResponseBodyData(TeaModel):
    def __init__(
        self,
        created_time_gmt: str = None,
        creator_user_id: str = None,
        data_id: int = None,
        form_data: Dict[str, Any] = None,
        form_instance_id: str = None,
        form_uuid: str = None,
        instance_value: str = None,
        model_uuid: str = None,
        modified_time_gmt: str = None,
        modifier_user_id: str = None,
        modify_user: SearchFormDatasResponseBodyDataModifyUser = None,
        originator: SearchFormDatasResponseBodyDataOriginator = None,
        sequence: str = None,
        serial_no: str = None,
        title: str = None,
        version: int = None,
    ):
        self.created_time_gmt = created_time_gmt
        self.creator_user_id = creator_user_id
        self.data_id = data_id
        self.form_data = form_data
        self.form_instance_id = form_instance_id
        self.form_uuid = form_uuid
        self.instance_value = instance_value
        self.model_uuid = model_uuid
        self.modified_time_gmt = modified_time_gmt
        self.modifier_user_id = modifier_user_id
        self.modify_user = modify_user
        self.originator = originator
        self.sequence = sequence
        self.serial_no = serial_no
        self.title = title
        self.version = version

    def validate(self):
        if self.modify_user:
            self.modify_user.validate()
        if self.originator:
            self.originator.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_time_gmt is not None:
            result['CreatedTimeGMT'] = self.created_time_gmt
        if self.creator_user_id is not None:
            result['CreatorUserId'] = self.creator_user_id
        if self.data_id is not None:
            result['DataId'] = self.data_id
        if self.form_data is not None:
            result['FormData'] = self.form_data
        if self.form_instance_id is not None:
            result['FormInstanceId'] = self.form_instance_id
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.instance_value is not None:
            result['InstanceValue'] = self.instance_value
        if self.model_uuid is not None:
            result['ModelUuid'] = self.model_uuid
        if self.modified_time_gmt is not None:
            result['ModifiedTimeGMT'] = self.modified_time_gmt
        if self.modifier_user_id is not None:
            result['ModifierUserId'] = self.modifier_user_id
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user.to_map()
        if self.originator is not None:
            result['Originator'] = self.originator.to_map()
        if self.sequence is not None:
            result['Sequence'] = self.sequence
        if self.serial_no is not None:
            result['SerialNo'] = self.serial_no
        if self.title is not None:
            result['Title'] = self.title
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatedTimeGMT') is not None:
            self.created_time_gmt = m.get('CreatedTimeGMT')
        if m.get('CreatorUserId') is not None:
            self.creator_user_id = m.get('CreatorUserId')
        if m.get('DataId') is not None:
            self.data_id = m.get('DataId')
        if m.get('FormData') is not None:
            self.form_data = m.get('FormData')
        if m.get('FormInstanceId') is not None:
            self.form_instance_id = m.get('FormInstanceId')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('InstanceValue') is not None:
            self.instance_value = m.get('InstanceValue')
        if m.get('ModelUuid') is not None:
            self.model_uuid = m.get('ModelUuid')
        if m.get('ModifiedTimeGMT') is not None:
            self.modified_time_gmt = m.get('ModifiedTimeGMT')
        if m.get('ModifierUserId') is not None:
            self.modifier_user_id = m.get('ModifierUserId')
        if m.get('ModifyUser') is not None:
            temp_model = SearchFormDatasResponseBodyDataModifyUser()
            self.modify_user = temp_model.from_map(m['ModifyUser'])
        if m.get('Originator') is not None:
            temp_model = SearchFormDatasResponseBodyDataOriginator()
            self.originator = temp_model.from_map(m['Originator'])
        if m.get('Sequence') is not None:
            self.sequence = m.get('Sequence')
        if m.get('SerialNo') is not None:
            self.serial_no = m.get('SerialNo')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class SearchFormDatasResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        data: List[SearchFormDatasResponseBodyData] = None,
        request_id: str = None,
        total_count: int = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.current_page = current_page
        self.data = data
        self.request_id = request_id
        self.total_count = total_count
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = SearchFormDatasResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class SearchFormDatasResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchFormDatasResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchFormDatasResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchInnerGroupsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SearchInnerGroupsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SearchInnerGroupsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SearchInnerGroupsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SearchInnerGroupsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SearchInnerGroupsRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        search_key: str = None,
    ):
        self.max_results = max_results
        self.search_key = search_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        return self


class SearchInnerGroupsResponseBodyGroupInfos(TeaModel):
    def __init__(
        self,
        icon: str = None,
        member_amount: str = None,
        open_conversation_id: str = None,
        title: str = None,
    ):
        self.icon = icon
        self.member_amount = member_amount
        self.open_conversation_id = open_conversation_id
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.member_amount is not None:
            result['MemberAmount'] = self.member_amount
        if self.open_conversation_id is not None:
            result['OpenConversationId'] = self.open_conversation_id
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('MemberAmount') is not None:
            self.member_amount = m.get('MemberAmount')
        if m.get('OpenConversationId') is not None:
            self.open_conversation_id = m.get('OpenConversationId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class SearchInnerGroupsResponseBody(TeaModel):
    def __init__(
        self,
        group_infos: List[SearchInnerGroupsResponseBodyGroupInfos] = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.group_infos = group_infos
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.group_infos:
            for k in self.group_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['groupInfos'] = []
        if self.group_infos is not None:
            for k in self.group_infos:
                result['groupInfos'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.group_infos = []
        if m.get('groupInfos') is not None:
            for k in m.get('groupInfos'):
                temp_model = SearchInnerGroupsResponseBodyGroupInfos()
                self.group_infos.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class SearchInnerGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchInnerGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchInnerGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendBannerHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SendBannerHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SendBannerHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SendBannerHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SendBannerShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SendBannerRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class SendBannerRequest(TeaModel):
    def __init__(
        self,
        content: Dict[str, Any] = None,
        end_time: int = None,
        start_time: int = None,
        tenant_context: SendBannerRequestTenantContext = None,
    ):
        self.content = content
        self.end_time = end_time
        self.start_time = start_time
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            temp_model = SendBannerRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class SendBannerShrinkRequest(TeaModel):
    def __init__(
        self,
        content_shrink: str = None,
        end_time: int = None,
        start_time: int = None,
        tenant_context_shrink: str = None,
    ):
        self.content_shrink = content_shrink
        self.end_time = end_time
        self.start_time = start_time
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_shrink is not None:
            result['Content'] = self.content_shrink
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content_shrink = m.get('Content')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class SendBannerResponseBody(TeaModel):
    def __init__(
        self,
        arguments: List[Any] = None,
        request_id: str = None,
        success: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.arguments = arguments
        self.request_id = request_id
        self.success = success
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arguments is not None:
            result['arguments'] = self.arguments
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('arguments') is not None:
            self.arguments = m.get('arguments')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class SendBannerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SendBannerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendBannerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendPopupHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SendPopupHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SendPopupHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SendPopupHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SendPopupShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SendPopupRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class SendPopupRequest(TeaModel):
    def __init__(
        self,
        content: Dict[str, Any] = None,
        end_time: int = None,
        start_time: int = None,
        tenant_context: SendPopupRequestTenantContext = None,
    ):
        self.content = content
        self.end_time = end_time
        self.start_time = start_time
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            temp_model = SendPopupRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class SendPopupShrinkRequest(TeaModel):
    def __init__(
        self,
        content_shrink: str = None,
        end_time: int = None,
        start_time: int = None,
        tenant_context_shrink: str = None,
    ):
        self.content_shrink = content_shrink
        self.end_time = end_time
        self.start_time = start_time
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_shrink is not None:
            result['Content'] = self.content_shrink
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content_shrink = m.get('Content')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class SendPopupResponseBody(TeaModel):
    def __init__(
        self,
        arguments: List[Any] = None,
        request_id: str = None,
        success: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.arguments = arguments
        self.request_id = request_id
        self.success = success
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arguments is not None:
            result['arguments'] = self.arguments
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('arguments') is not None:
            self.arguments = m.get('arguments')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class SendPopupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SendPopupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendPopupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendSearchShadeHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SendSearchShadeHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SendSearchShadeHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SendSearchShadeHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SendSearchShadeShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SendSearchShadeRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class SendSearchShadeRequest(TeaModel):
    def __init__(
        self,
        content: Dict[str, Any] = None,
        end_time: int = None,
        start_time: int = None,
        tenant_context: SendSearchShadeRequestTenantContext = None,
    ):
        self.content = content
        self.end_time = end_time
        self.start_time = start_time
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            temp_model = SendSearchShadeRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class SendSearchShadeShrinkRequest(TeaModel):
    def __init__(
        self,
        content_shrink: str = None,
        end_time: int = None,
        start_time: int = None,
        tenant_context_shrink: str = None,
    ):
        self.content_shrink = content_shrink
        self.end_time = end_time
        self.start_time = start_time
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_shrink is not None:
            result['Content'] = self.content_shrink
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content_shrink = m.get('Content')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class SendSearchShadeResponseBody(TeaModel):
    def __init__(
        self,
        arguments: List[Any] = None,
        request_id: str = None,
        success: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.arguments = arguments
        self.request_id = request_id
        self.success = success
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arguments is not None:
            result['arguments'] = self.arguments
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('arguments') is not None:
            self.arguments = m.get('arguments')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class SendSearchShadeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SendSearchShadeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendSearchShadeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetColumnsVisibilityHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SetColumnsVisibilityHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SetColumnsVisibilityHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SetColumnsVisibilityHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SetColumnsVisibilityShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SetColumnsVisibilityRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class SetColumnsVisibilityRequest(TeaModel):
    def __init__(
        self,
        column: int = None,
        column_count: int = None,
        sheet_id: str = None,
        tenant_context: SetColumnsVisibilityRequestTenantContext = None,
        visibility: str = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.column = column
        # This parameter is required.
        self.column_count = column_count
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context = tenant_context
        # This parameter is required.
        self.visibility = visibility
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column is not None:
            result['Column'] = self.column
        if self.column_count is not None:
            result['ColumnCount'] = self.column_count
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.visibility is not None:
            result['Visibility'] = self.visibility
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Column') is not None:
            self.column = m.get('Column')
        if m.get('ColumnCount') is not None:
            self.column_count = m.get('ColumnCount')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            temp_model = SetColumnsVisibilityRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('Visibility') is not None:
            self.visibility = m.get('Visibility')
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class SetColumnsVisibilityShrinkRequest(TeaModel):
    def __init__(
        self,
        column: int = None,
        column_count: int = None,
        sheet_id: str = None,
        tenant_context_shrink: str = None,
        visibility: str = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.column = column
        # This parameter is required.
        self.column_count = column_count
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.visibility = visibility
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column is not None:
            result['Column'] = self.column
        if self.column_count is not None:
            result['ColumnCount'] = self.column_count
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.visibility is not None:
            result['Visibility'] = self.visibility
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Column') is not None:
            self.column = m.get('Column')
        if m.get('ColumnCount') is not None:
            self.column_count = m.get('ColumnCount')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('Visibility') is not None:
            self.visibility = m.get('Visibility')
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class SetColumnsVisibilityResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
    ):
        self.id = id
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class SetColumnsVisibilityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetColumnsVisibilityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetColumnsVisibilityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetConferenceHostsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SetConferenceHostsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SetConferenceHostsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SetConferenceHostsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SetConferenceHostsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SetConferenceHostsRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class SetConferenceHostsRequest(TeaModel):
    def __init__(
        self,
        operation_type: str = None,
        tenant_context: SetConferenceHostsRequestTenantContext = None,
        user_ids: List[str] = None,
        conference_id: str = None,
    ):
        # This parameter is required.
        self.operation_type = operation_type
        self.tenant_context = tenant_context
        # This parameter is required.
        self.user_ids = user_ids
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operation_type is not None:
            result['OperationType'] = self.operation_type
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OperationType') is not None:
            self.operation_type = m.get('OperationType')
        if m.get('TenantContext') is not None:
            temp_model = SetConferenceHostsRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class SetConferenceHostsShrinkRequest(TeaModel):
    def __init__(
        self,
        operation_type: str = None,
        tenant_context_shrink: str = None,
        user_ids_shrink: str = None,
        conference_id: str = None,
    ):
        # This parameter is required.
        self.operation_type = operation_type
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.user_ids_shrink = user_ids_shrink
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operation_type is not None:
            result['OperationType'] = self.operation_type
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.user_ids_shrink is not None:
            result['UserIds'] = self.user_ids_shrink
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OperationType') is not None:
            self.operation_type = m.get('OperationType')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('UserIds') is not None:
            self.user_ids_shrink = m.get('UserIds')
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class SetConferenceHostsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.success = success
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class SetConferenceHostsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetConferenceHostsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetConferenceHostsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetRowsVisibilityHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SetRowsVisibilityHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SetRowsVisibilityHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SetRowsVisibilityHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SetRowsVisibilityShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SetRowsVisibilityRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class SetRowsVisibilityRequest(TeaModel):
    def __init__(
        self,
        row: int = None,
        row_count: int = None,
        sheet_id: str = None,
        tenant_context: SetRowsVisibilityRequestTenantContext = None,
        visibility: str = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.row = row
        # This parameter is required.
        self.row_count = row_count
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context = tenant_context
        # This parameter is required.
        self.visibility = visibility
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.row is not None:
            result['Row'] = self.row
        if self.row_count is not None:
            result['RowCount'] = self.row_count
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.visibility is not None:
            result['Visibility'] = self.visibility
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Row') is not None:
            self.row = m.get('Row')
        if m.get('RowCount') is not None:
            self.row_count = m.get('RowCount')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            temp_model = SetRowsVisibilityRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('Visibility') is not None:
            self.visibility = m.get('Visibility')
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class SetRowsVisibilityShrinkRequest(TeaModel):
    def __init__(
        self,
        row: int = None,
        row_count: int = None,
        sheet_id: str = None,
        tenant_context_shrink: str = None,
        visibility: str = None,
        workbook_id: str = None,
    ):
        # This parameter is required.
        self.row = row
        # This parameter is required.
        self.row_count = row_count
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.visibility = visibility
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.row is not None:
            result['Row'] = self.row
        if self.row_count is not None:
            result['RowCount'] = self.row_count
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.visibility is not None:
            result['Visibility'] = self.visibility
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Row') is not None:
            self.row = m.get('Row')
        if m.get('RowCount') is not None:
            self.row_count = m.get('RowCount')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('Visibility') is not None:
            self.visibility = m.get('Visibility')
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class SetRowsVisibilityResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
    ):
        self.id = id
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class SetRowsVisibilityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetRowsVisibilityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetRowsVisibilityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SimpleListReportHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SimpleListReportHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SimpleListReportHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SimpleListReportHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SimpleListReportShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SimpleListReportRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class SimpleListReportRequest(TeaModel):
    def __init__(
        self,
        cursor: int = None,
        end_time: int = None,
        size: int = None,
        start_time: int = None,
        template_name: str = None,
        tenant_context: SimpleListReportRequestTenantContext = None,
    ):
        # This parameter is required.
        self.cursor = cursor
        # This parameter is required.
        self.end_time = end_time
        # This parameter is required.
        self.size = size
        # This parameter is required.
        self.start_time = start_time
        self.template_name = template_name
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cursor is not None:
            result['Cursor'] = self.cursor
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cursor') is not None:
            self.cursor = m.get('Cursor')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('TenantContext') is not None:
            temp_model = SimpleListReportRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class SimpleListReportShrinkRequest(TeaModel):
    def __init__(
        self,
        cursor: int = None,
        end_time: int = None,
        size: int = None,
        start_time: int = None,
        template_name: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.cursor = cursor
        # This parameter is required.
        self.end_time = end_time
        # This parameter is required.
        self.size = size
        # This parameter is required.
        self.start_time = start_time
        self.template_name = template_name
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cursor is not None:
            result['Cursor'] = self.cursor
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cursor') is not None:
            self.cursor = m.get('Cursor')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class SimpleListReportResponseBodyDataList(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        creator_id: str = None,
        creator_name: str = None,
        dept_name: str = None,
        remark: str = None,
        report_id: str = None,
        template_name: str = None,
    ):
        self.create_time = create_time
        self.creator_id = creator_id
        self.creator_name = creator_name
        self.dept_name = dept_name
        self.remark = remark
        self.report_id = report_id
        self.template_name = template_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_name is not None:
            result['CreatorName'] = self.creator_name
        if self.dept_name is not None:
            result['DeptName'] = self.dept_name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.report_id is not None:
            result['ReportId'] = self.report_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorName') is not None:
            self.creator_name = m.get('CreatorName')
        if m.get('DeptName') is not None:
            self.dept_name = m.get('DeptName')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('ReportId') is not None:
            self.report_id = m.get('ReportId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        return self


class SimpleListReportResponseBody(TeaModel):
    def __init__(
        self,
        data_list: List[SimpleListReportResponseBodyDataList] = None,
        has_more: bool = None,
        next_cursor: int = None,
        request_id: str = None,
        size: int = None,
    ):
        self.data_list = data_list
        self.has_more = has_more
        self.next_cursor = next_cursor
        # requestId
        self.request_id = request_id
        self.size = size

    def validate(self):
        if self.data_list:
            for k in self.data_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['dataList'] = []
        if self.data_list is not None:
            for k in self.data_list:
                result['dataList'].append(k.to_map() if k else None)
        if self.has_more is not None:
            result['hasMore'] = self.has_more
        if self.next_cursor is not None:
            result['nextCursor'] = self.next_cursor
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.size is not None:
            result['size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_list = []
        if m.get('dataList') is not None:
            for k in m.get('dataList'):
                temp_model = SimpleListReportResponseBodyDataList()
                self.data_list.append(temp_model.from_map(k))
        if m.get('hasMore') is not None:
            self.has_more = m.get('hasMore')
        if m.get('nextCursor') is not None:
            self.next_cursor = m.get('nextCursor')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('size') is not None:
            self.size = m.get('size')
        return self


class SimpleListReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SimpleListReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SimpleListReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartCloudRecordHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class StartCloudRecordHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: StartCloudRecordHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = StartCloudRecordHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class StartCloudRecordShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class StartCloudRecordRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class StartCloudRecordRequest(TeaModel):
    def __init__(
        self,
        mode: str = None,
        small_window_position: str = None,
        tenant_context: StartCloudRecordRequestTenantContext = None,
        conference_id: str = None,
    ):
        self.mode = mode
        self.small_window_position = small_window_position
        self.tenant_context = tenant_context
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.small_window_position is not None:
            result['SmallWindowPosition'] = self.small_window_position
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('SmallWindowPosition') is not None:
            self.small_window_position = m.get('SmallWindowPosition')
        if m.get('TenantContext') is not None:
            temp_model = StartCloudRecordRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class StartCloudRecordShrinkRequest(TeaModel):
    def __init__(
        self,
        mode: str = None,
        small_window_position: str = None,
        tenant_context_shrink: str = None,
        conference_id: str = None,
    ):
        self.mode = mode
        self.small_window_position = small_window_position
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.small_window_position is not None:
            result['SmallWindowPosition'] = self.small_window_position
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('SmallWindowPosition') is not None:
            self.small_window_position = m.get('SmallWindowPosition')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class StartCloudRecordResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        request_id: str = None,
    ):
        self.code = code
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class StartCloudRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartCloudRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartCloudRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartInstanceHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class StartInstanceHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: StartInstanceHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = StartInstanceHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class StartInstanceShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class StartInstanceRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        department_id: str = None,
        form_data_json: str = None,
        form_uuid: str = None,
        language: str = None,
        process_code: str = None,
        process_data: str = None,
        system_token: str = None,
    ):
        self.app_type = app_type
        self.department_id = department_id
        self.form_data_json = form_data_json
        self.form_uuid = form_uuid
        self.language = language
        self.process_code = process_code
        self.process_data = process_data
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.department_id is not None:
            result['DepartmentId'] = self.department_id
        if self.form_data_json is not None:
            result['FormDataJson'] = self.form_data_json
        if self.form_uuid is not None:
            result['FormUuid'] = self.form_uuid
        if self.language is not None:
            result['Language'] = self.language
        if self.process_code is not None:
            result['ProcessCode'] = self.process_code
        if self.process_data is not None:
            result['ProcessData'] = self.process_data
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('DepartmentId') is not None:
            self.department_id = m.get('DepartmentId')
        if m.get('FormDataJson') is not None:
            self.form_data_json = m.get('FormDataJson')
        if m.get('FormUuid') is not None:
            self.form_uuid = m.get('FormUuid')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('ProcessCode') is not None:
            self.process_code = m.get('ProcessCode')
        if m.get('ProcessData') is not None:
            self.process_data = m.get('ProcessData')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class StartInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.result = result
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class StartInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartMinutesHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class StartMinutesHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: StartMinutesHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = StartMinutesHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class StartMinutesShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class StartMinutesRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class StartMinutesRequest(TeaModel):
    def __init__(
        self,
        tenant_context: StartMinutesRequestTenantContext = None,
        conference_id: str = None,
        owner_user_id: str = None,
        record_audio: bool = None,
    ):
        self.tenant_context = tenant_context
        # This parameter is required.
        self.conference_id = conference_id
        # This parameter is required.
        self.owner_user_id = owner_user_id
        self.record_audio = record_audio

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        if self.owner_user_id is not None:
            result['ownerUserId'] = self.owner_user_id
        if self.record_audio is not None:
            result['recordAudio'] = self.record_audio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = StartMinutesRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        if m.get('ownerUserId') is not None:
            self.owner_user_id = m.get('ownerUserId')
        if m.get('recordAudio') is not None:
            self.record_audio = m.get('recordAudio')
        return self


class StartMinutesShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        conference_id: str = None,
        owner_user_id: str = None,
        record_audio: bool = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.conference_id = conference_id
        # This parameter is required.
        self.owner_user_id = owner_user_id
        self.record_audio = record_audio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        if self.owner_user_id is not None:
            result['ownerUserId'] = self.owner_user_id
        if self.record_audio is not None:
            result['recordAudio'] = self.record_audio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        if m.get('ownerUserId') is not None:
            self.owner_user_id = m.get('ownerUserId')
        if m.get('recordAudio') is not None:
            self.record_audio = m.get('recordAudio')
        return self


class StartMinutesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.code = code
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class StartMinutesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartMinutesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartMinutesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StatisticsListByTypeReportHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class StatisticsListByTypeReportHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: StatisticsListByTypeReportHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = StatisticsListByTypeReportHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class StatisticsListByTypeReportShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class StatisticsListByTypeReportRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class StatisticsListByTypeReportRequest(TeaModel):
    def __init__(
        self,
        offset: int = None,
        report_id: str = None,
        size: int = None,
        tenant_context: StatisticsListByTypeReportRequestTenantContext = None,
        type: int = None,
    ):
        # This parameter is required.
        self.offset = offset
        # This parameter is required.
        self.report_id = report_id
        # This parameter is required.
        self.size = size
        self.tenant_context = tenant_context
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.offset is not None:
            result['Offset'] = self.offset
        if self.report_id is not None:
            result['ReportId'] = self.report_id
        if self.size is not None:
            result['Size'] = self.size
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        if m.get('ReportId') is not None:
            self.report_id = m.get('ReportId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('TenantContext') is not None:
            temp_model = StatisticsListByTypeReportRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class StatisticsListByTypeReportShrinkRequest(TeaModel):
    def __init__(
        self,
        offset: int = None,
        report_id: str = None,
        size: int = None,
        tenant_context_shrink: str = None,
        type: int = None,
    ):
        # This parameter is required.
        self.offset = offset
        # This parameter is required.
        self.report_id = report_id
        # This parameter is required.
        self.size = size
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.offset is not None:
            result['Offset'] = self.offset
        if self.report_id is not None:
            result['ReportId'] = self.report_id
        if self.size is not None:
            result['Size'] = self.size
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        if m.get('ReportId') is not None:
            self.report_id = m.get('ReportId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class StatisticsListByTypeReportResponseBody(TeaModel):
    def __init__(
        self,
        has_more: bool = None,
        next_cursor: int = None,
        request_id: str = None,
        userid_list: List[str] = None,
    ):
        self.has_more = has_more
        self.next_cursor = next_cursor
        # requestId
        self.request_id = request_id
        self.userid_list = userid_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_more is not None:
            result['hasMore'] = self.has_more
        if self.next_cursor is not None:
            result['nextCursor'] = self.next_cursor
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.userid_list is not None:
            result['useridList'] = self.userid_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('hasMore') is not None:
            self.has_more = m.get('hasMore')
        if m.get('nextCursor') is not None:
            self.next_cursor = m.get('nextCursor')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('useridList') is not None:
            self.userid_list = m.get('useridList')
        return self


class StatisticsListByTypeReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StatisticsListByTypeReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StatisticsListByTypeReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StatisticsReportHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class StatisticsReportHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: StatisticsReportHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = StatisticsReportHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class StatisticsReportShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class StatisticsReportRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class StatisticsReportRequest(TeaModel):
    def __init__(
        self,
        report_id: str = None,
        tenant_context: StatisticsReportRequestTenantContext = None,
    ):
        # This parameter is required.
        self.report_id = report_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.report_id is not None:
            result['ReportId'] = self.report_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReportId') is not None:
            self.report_id = m.get('ReportId')
        if m.get('TenantContext') is not None:
            temp_model = StatisticsReportRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class StatisticsReportShrinkRequest(TeaModel):
    def __init__(
        self,
        report_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.report_id = report_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.report_id is not None:
            result['ReportId'] = self.report_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReportId') is not None:
            self.report_id = m.get('ReportId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class StatisticsReportResponseBody(TeaModel):
    def __init__(
        self,
        comment_num: int = None,
        comment_user_num: int = None,
        like_num: int = None,
        read_num: int = None,
        request_id: str = None,
    ):
        self.comment_num = comment_num
        self.comment_user_num = comment_user_num
        self.like_num = like_num
        self.read_num = read_num
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment_num is not None:
            result['commentNum'] = self.comment_num
        if self.comment_user_num is not None:
            result['commentUserNum'] = self.comment_user_num
        if self.like_num is not None:
            result['likeNum'] = self.like_num
        if self.read_num is not None:
            result['readNum'] = self.read_num
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commentNum') is not None:
            self.comment_num = m.get('commentNum')
        if m.get('commentUserNum') is not None:
            self.comment_user_num = m.get('commentUserNum')
        if m.get('likeNum') is not None:
            self.like_num = m.get('likeNum')
        if m.get('readNum') is not None:
            self.read_num = m.get('readNum')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class StatisticsReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StatisticsReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StatisticsReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopCloudRecordHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class StopCloudRecordHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: StopCloudRecordHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = StopCloudRecordHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class StopCloudRecordShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class StopCloudRecordRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class StopCloudRecordRequest(TeaModel):
    def __init__(
        self,
        tenant_context: StopCloudRecordRequestTenantContext = None,
        conference_id: str = None,
    ):
        self.tenant_context = tenant_context
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = StopCloudRecordRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class StopCloudRecordShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        conference_id: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class StopCloudRecordResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        request_id: str = None,
    ):
        self.code = code
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class StopCloudRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopCloudRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopCloudRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopMinutesHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class StopMinutesHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: StopMinutesHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = StopMinutesHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class StopMinutesShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class StopMinutesRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class StopMinutesRequest(TeaModel):
    def __init__(
        self,
        tenant_context: StopMinutesRequestTenantContext = None,
        conference_id: str = None,
    ):
        self.tenant_context = tenant_context
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = StopMinutesRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class StopMinutesShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        conference_id: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class StopMinutesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.code = code
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class StopMinutesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopMinutesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopMinutesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubscribeCalendarHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SubscribeCalendarHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SubscribeCalendarHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SubscribeCalendarHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SubscribeCalendarShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SubscribeCalendarRequest(TeaModel):
    def __init__(
        self,
        calendar_id: str = None,
    ):
        # This parameter is required.
        self.calendar_id = calendar_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        return self


class SubscribeCalendarResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class SubscribeCalendarResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubscribeCalendarResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubscribeCalendarResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubscribeEventHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SubscribeEventHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SubscribeEventHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SubscribeEventHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SubscribeEventShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SubscribeEventRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class SubscribeEventRequest(TeaModel):
    def __init__(
        self,
        scope: str = None,
        scope_id: str = None,
        tenant_context: SubscribeEventRequestTenantContext = None,
    ):
        # This parameter is required.
        self.scope = scope
        # This parameter is required.
        self.scope_id = scope_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.scope_id is not None:
            result['ScopeId'] = self.scope_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('ScopeId') is not None:
            self.scope_id = m.get('ScopeId')
        if m.get('TenantContext') is not None:
            temp_model = SubscribeEventRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class SubscribeEventShrinkRequest(TeaModel):
    def __init__(
        self,
        scope: str = None,
        scope_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.scope = scope
        # This parameter is required.
        self.scope_id = scope_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.scope_id is not None:
            result['ScopeId'] = self.scope_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('ScopeId') is not None:
            self.scope_id = m.get('ScopeId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class SubscribeEventResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.success = success
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class SubscribeEventResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubscribeEventResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubscribeEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SwitchMainOrgHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SwitchMainOrgHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SwitchMainOrgHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SwitchMainOrgHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SwitchMainOrgShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SwitchMainOrgRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class SwitchMainOrgRequest(TeaModel):
    def __init__(
        self,
        target_org_id: int = None,
        tenant_context: SwitchMainOrgRequestTenantContext = None,
    ):
        self.target_org_id = target_org_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_org_id is not None:
            result['TargetOrgId'] = self.target_org_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TargetOrgId') is not None:
            self.target_org_id = m.get('TargetOrgId')
        if m.get('TenantContext') is not None:
            temp_model = SwitchMainOrgRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class SwitchMainOrgShrinkRequest(TeaModel):
    def __init__(
        self,
        target_org_id: int = None,
        tenant_context_shrink: str = None,
    ):
        self.target_org_id = target_org_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_org_id is not None:
            result['TargetOrgId'] = self.target_org_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TargetOrgId') is not None:
            self.target_org_id = m.get('TargetOrgId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class SwitchMainOrgResponseBodyContent(TeaModel):
    def __init__(
        self,
        data: Any = None,
    ):
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class SwitchMainOrgResponseBody(TeaModel):
    def __init__(
        self,
        content: SwitchMainOrgResponseBodyContent = None,
        error_code: str = None,
        error_ctx: Dict[str, Any] = None,
        error_msg: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.content = content
        self.error_code = error_code
        self.error_ctx = error_ctx
        self.error_msg = error_msg
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content.to_map()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_ctx is not None:
            result['errorCtx'] = self.error_ctx
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            temp_model = SwitchMainOrgResponseBodyContent()
            self.content = temp_model.from_map(m['content'])
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorCtx') is not None:
            self.error_ctx = m.get('errorCtx')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class SwitchMainOrgResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SwitchMainOrgResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SwitchMainOrgResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SyncDingTypeHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class SyncDingTypeHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: SyncDingTypeHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = SyncDingTypeHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class SyncDingTypeShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class SyncDingTypeRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class SyncDingTypeRequest(TeaModel):
    def __init__(
        self,
        ding_type: str = None,
        is_dimission: str = None,
        source: str = None,
        tenant_context: SyncDingTypeRequestTenantContext = None,
        work_no: str = None,
    ):
        # This parameter is required.
        self.ding_type = ding_type
        self.is_dimission = is_dimission
        # This parameter is required.
        self.source = source
        self.tenant_context = tenant_context
        # This parameter is required.
        self.work_no = work_no

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ding_type is not None:
            result['DingType'] = self.ding_type
        if self.is_dimission is not None:
            result['IsDimission'] = self.is_dimission
        if self.source is not None:
            result['Source'] = self.source
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.work_no is not None:
            result['WorkNo'] = self.work_no
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DingType') is not None:
            self.ding_type = m.get('DingType')
        if m.get('IsDimission') is not None:
            self.is_dimission = m.get('IsDimission')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('TenantContext') is not None:
            temp_model = SyncDingTypeRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkNo') is not None:
            self.work_no = m.get('WorkNo')
        return self


class SyncDingTypeShrinkRequest(TeaModel):
    def __init__(
        self,
        ding_type: str = None,
        is_dimission: str = None,
        source: str = None,
        tenant_context_shrink: str = None,
        work_no: str = None,
    ):
        # This parameter is required.
        self.ding_type = ding_type
        self.is_dimission = is_dimission
        # This parameter is required.
        self.source = source
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.work_no = work_no

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ding_type is not None:
            result['DingType'] = self.ding_type
        if self.is_dimission is not None:
            result['IsDimission'] = self.is_dimission
        if self.source is not None:
            result['Source'] = self.source
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.work_no is not None:
            result['WorkNo'] = self.work_no
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DingType') is not None:
            self.ding_type = m.get('DingType')
        if m.get('IsDimission') is not None:
            self.is_dimission = m.get('IsDimission')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkNo') is not None:
            self.work_no = m.get('WorkNo')
        return self


class SyncDingTypeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.success = success
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class SyncDingTypeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SyncDingTypeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SyncDingTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TerminateInstanceHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class TerminateInstanceHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: TerminateInstanceHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = TerminateInstanceHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class TerminateInstanceShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class TerminateInstanceRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        language: str = None,
        process_instance_id: str = None,
        system_token: str = None,
    ):
        self.app_type = app_type
        self.language = language
        self.process_instance_id = process_instance_id
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.language is not None:
            result['Language'] = self.language
        if self.process_instance_id is not None:
            result['ProcessInstanceId'] = self.process_instance_id
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('ProcessInstanceId') is not None:
            self.process_instance_id = m.get('ProcessInstanceId')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class TerminateInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class TerminateInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TerminateInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TerminateInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TransferTicketHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class TransferTicketHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: TransferTicketHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = TransferTicketHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class TransferTicketShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class TransferTicketRequestNotify(TeaModel):
    def __init__(
        self,
        group_notice_receiver_user_ids: List[str] = None,
        notice_all_group_member: bool = None,
        work_notice_receiver_user_ids: List[str] = None,
    ):
        self.group_notice_receiver_user_ids = group_notice_receiver_user_ids
        self.notice_all_group_member = notice_all_group_member
        self.work_notice_receiver_user_ids = work_notice_receiver_user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_notice_receiver_user_ids is not None:
            result['GroupNoticeReceiverUserIds'] = self.group_notice_receiver_user_ids
        if self.notice_all_group_member is not None:
            result['NoticeAllGroupMember'] = self.notice_all_group_member
        if self.work_notice_receiver_user_ids is not None:
            result['WorkNoticeReceiverUserIds'] = self.work_notice_receiver_user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupNoticeReceiverUserIds') is not None:
            self.group_notice_receiver_user_ids = m.get('GroupNoticeReceiverUserIds')
        if m.get('NoticeAllGroupMember') is not None:
            self.notice_all_group_member = m.get('NoticeAllGroupMember')
        if m.get('WorkNoticeReceiverUserIds') is not None:
            self.work_notice_receiver_user_ids = m.get('WorkNoticeReceiverUserIds')
        return self


class TransferTicketRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class TransferTicketRequestTicketMemoAttachments(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        key: str = None,
    ):
        self.file_name = file_name
        self.key = key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.key is not None:
            result['Key'] = self.key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        return self


class TransferTicketRequestTicketMemo(TeaModel):
    def __init__(
        self,
        attachments: List[TransferTicketRequestTicketMemoAttachments] = None,
        memo: str = None,
    ):
        self.attachments = attachments
        self.memo = memo

    def validate(self):
        if self.attachments:
            for k in self.attachments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Attachments'] = []
        if self.attachments is not None:
            for k in self.attachments:
                result['Attachments'].append(k.to_map() if k else None)
        if self.memo is not None:
            result['Memo'] = self.memo
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attachments = []
        if m.get('Attachments') is not None:
            for k in m.get('Attachments'):
                temp_model = TransferTicketRequestTicketMemoAttachments()
                self.attachments.append(temp_model.from_map(k))
        if m.get('Memo') is not None:
            self.memo = m.get('Memo')
        return self


class TransferTicketRequest(TeaModel):
    def __init__(
        self,
        notify: TransferTicketRequestNotify = None,
        open_team_id: str = None,
        open_ticket_id: str = None,
        processor_user_ids: List[str] = None,
        tenant_context: TransferTicketRequestTenantContext = None,
        ticket_memo: TransferTicketRequestTicketMemo = None,
    ):
        self.notify = notify
        # This parameter is required.
        self.open_team_id = open_team_id
        # This parameter is required.
        self.open_ticket_id = open_ticket_id
        self.processor_user_ids = processor_user_ids
        self.tenant_context = tenant_context
        self.ticket_memo = ticket_memo

    def validate(self):
        if self.notify:
            self.notify.validate()
        if self.tenant_context:
            self.tenant_context.validate()
        if self.ticket_memo:
            self.ticket_memo.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notify is not None:
            result['Notify'] = self.notify.to_map()
        if self.open_team_id is not None:
            result['OpenTeamId'] = self.open_team_id
        if self.open_ticket_id is not None:
            result['OpenTicketId'] = self.open_ticket_id
        if self.processor_user_ids is not None:
            result['ProcessorUserIds'] = self.processor_user_ids
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.ticket_memo is not None:
            result['TicketMemo'] = self.ticket_memo.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Notify') is not None:
            temp_model = TransferTicketRequestNotify()
            self.notify = temp_model.from_map(m['Notify'])
        if m.get('OpenTeamId') is not None:
            self.open_team_id = m.get('OpenTeamId')
        if m.get('OpenTicketId') is not None:
            self.open_ticket_id = m.get('OpenTicketId')
        if m.get('ProcessorUserIds') is not None:
            self.processor_user_ids = m.get('ProcessorUserIds')
        if m.get('TenantContext') is not None:
            temp_model = TransferTicketRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('TicketMemo') is not None:
            temp_model = TransferTicketRequestTicketMemo()
            self.ticket_memo = temp_model.from_map(m['TicketMemo'])
        return self


class TransferTicketShrinkRequest(TeaModel):
    def __init__(
        self,
        notify_shrink: str = None,
        open_team_id: str = None,
        open_ticket_id: str = None,
        processor_user_ids_shrink: str = None,
        tenant_context_shrink: str = None,
        ticket_memo_shrink: str = None,
    ):
        self.notify_shrink = notify_shrink
        # This parameter is required.
        self.open_team_id = open_team_id
        # This parameter is required.
        self.open_ticket_id = open_ticket_id
        self.processor_user_ids_shrink = processor_user_ids_shrink
        self.tenant_context_shrink = tenant_context_shrink
        self.ticket_memo_shrink = ticket_memo_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notify_shrink is not None:
            result['Notify'] = self.notify_shrink
        if self.open_team_id is not None:
            result['OpenTeamId'] = self.open_team_id
        if self.open_ticket_id is not None:
            result['OpenTicketId'] = self.open_ticket_id
        if self.processor_user_ids_shrink is not None:
            result['ProcessorUserIds'] = self.processor_user_ids_shrink
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.ticket_memo_shrink is not None:
            result['TicketMemo'] = self.ticket_memo_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Notify') is not None:
            self.notify_shrink = m.get('Notify')
        if m.get('OpenTeamId') is not None:
            self.open_team_id = m.get('OpenTeamId')
        if m.get('OpenTicketId') is not None:
            self.open_ticket_id = m.get('OpenTicketId')
        if m.get('ProcessorUserIds') is not None:
            self.processor_user_ids_shrink = m.get('ProcessorUserIds')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('TicketMemo') is not None:
            self.ticket_memo_shrink = m.get('TicketMemo')
        return self


class TransferTicketResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class TransferTicketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TransferTicketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TransferTicketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnsubscribeCalendarHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UnsubscribeCalendarHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UnsubscribeCalendarHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UnsubscribeCalendarHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UnsubscribeCalendarShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UnsubscribeCalendarRequest(TeaModel):
    def __init__(
        self,
        calendar_id: str = None,
    ):
        # This parameter is required.
        self.calendar_id = calendar_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        return self


class UnsubscribeCalendarResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: bool = None,
    ):
        # requestId
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class UnsubscribeCalendarResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnsubscribeCalendarResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnsubscribeCalendarResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnsubscribeEventHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UnsubscribeEventHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UnsubscribeEventHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UnsubscribeEventHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UnsubscribeEventShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UnsubscribeEventRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class UnsubscribeEventRequest(TeaModel):
    def __init__(
        self,
        scope: str = None,
        scope_id: str = None,
        tenant_context: UnsubscribeEventRequestTenantContext = None,
    ):
        # This parameter is required.
        self.scope = scope
        # This parameter is required.
        self.scope_id = scope_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.scope_id is not None:
            result['ScopeId'] = self.scope_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('ScopeId') is not None:
            self.scope_id = m.get('ScopeId')
        if m.get('TenantContext') is not None:
            temp_model = UnsubscribeEventRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class UnsubscribeEventShrinkRequest(TeaModel):
    def __init__(
        self,
        scope: str = None,
        scope_id: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.scope = scope
        # This parameter is required.
        self.scope_id = scope_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.scope_id is not None:
            result['ScopeId'] = self.scope_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('ScopeId') is not None:
            self.scope_id = m.get('ScopeId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class UnsubscribeEventResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.success = success
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class UnsubscribeEventResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnsubscribeEventResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnsubscribeEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateFormDataHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdateFormDataHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdateFormDataHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdateFormDataHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdateFormDataShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdateFormDataRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        form_instance_id: str = None,
        language: str = None,
        system_token: str = None,
        update_form_data_json: str = None,
        use_latest_version: bool = None,
    ):
        self.app_type = app_type
        self.form_instance_id = form_instance_id
        self.language = language
        self.system_token = system_token
        self.update_form_data_json = update_form_data_json
        self.use_latest_version = use_latest_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.form_instance_id is not None:
            result['FormInstanceId'] = self.form_instance_id
        if self.language is not None:
            result['Language'] = self.language
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        if self.update_form_data_json is not None:
            result['UpdateFormDataJson'] = self.update_form_data_json
        if self.use_latest_version is not None:
            result['UseLatestVersion'] = self.use_latest_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('FormInstanceId') is not None:
            self.form_instance_id = m.get('FormInstanceId')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        if m.get('UpdateFormDataJson') is not None:
            self.update_form_data_json = m.get('UpdateFormDataJson')
        if m.get('UseLatestVersion') is not None:
            self.use_latest_version = m.get('UseLatestVersion')
        return self


class UpdateFormDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class UpdateFormDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateFormDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateFormDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateInstanceHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdateInstanceHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdateInstanceHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdateInstanceHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdateInstanceShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdateInstanceRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        language: str = None,
        process_instance_id: str = None,
        system_token: str = None,
        update_form_data_json: str = None,
    ):
        self.app_type = app_type
        self.language = language
        self.process_instance_id = process_instance_id
        self.system_token = system_token
        self.update_form_data_json = update_form_data_json

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.language is not None:
            result['Language'] = self.language
        if self.process_instance_id is not None:
            result['ProcessInstanceId'] = self.process_instance_id
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        if self.update_form_data_json is not None:
            result['UpdateFormDataJson'] = self.update_form_data_json
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('ProcessInstanceId') is not None:
            self.process_instance_id = m.get('ProcessInstanceId')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        if m.get('UpdateFormDataJson') is not None:
            self.update_form_data_json = m.get('UpdateFormDataJson')
        return self


class UpdateInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class UpdateInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdateLiveHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdateLiveHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdateLiveHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdateLiveShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdateLiveRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class UpdateLiveRequest(TeaModel):
    def __init__(
        self,
        cover_url: str = None,
        introduction: str = None,
        live_id: str = None,
        pre_end_time: int = None,
        pre_start_time: int = None,
        tenant_context: UpdateLiveRequestTenantContext = None,
        title: str = None,
    ):
        self.cover_url = cover_url
        self.introduction = introduction
        # This parameter is required.
        self.live_id = live_id
        # This parameter is required.
        self.pre_end_time = pre_end_time
        # This parameter is required.
        self.pre_start_time = pre_start_time
        self.tenant_context = tenant_context
        # This parameter is required.
        self.title = title

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cover_url is not None:
            result['CoverUrl'] = self.cover_url
        if self.introduction is not None:
            result['Introduction'] = self.introduction
        if self.live_id is not None:
            result['LiveId'] = self.live_id
        if self.pre_end_time is not None:
            result['PreEndTime'] = self.pre_end_time
        if self.pre_start_time is not None:
            result['PreStartTime'] = self.pre_start_time
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CoverUrl') is not None:
            self.cover_url = m.get('CoverUrl')
        if m.get('Introduction') is not None:
            self.introduction = m.get('Introduction')
        if m.get('LiveId') is not None:
            self.live_id = m.get('LiveId')
        if m.get('PreEndTime') is not None:
            self.pre_end_time = m.get('PreEndTime')
        if m.get('PreStartTime') is not None:
            self.pre_start_time = m.get('PreStartTime')
        if m.get('TenantContext') is not None:
            temp_model = UpdateLiveRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class UpdateLiveShrinkRequest(TeaModel):
    def __init__(
        self,
        cover_url: str = None,
        introduction: str = None,
        live_id: str = None,
        pre_end_time: int = None,
        pre_start_time: int = None,
        tenant_context_shrink: str = None,
        title: str = None,
    ):
        self.cover_url = cover_url
        self.introduction = introduction
        # This parameter is required.
        self.live_id = live_id
        # This parameter is required.
        self.pre_end_time = pre_end_time
        # This parameter is required.
        self.pre_start_time = pre_start_time
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cover_url is not None:
            result['CoverUrl'] = self.cover_url
        if self.introduction is not None:
            result['Introduction'] = self.introduction
        if self.live_id is not None:
            result['LiveId'] = self.live_id
        if self.pre_end_time is not None:
            result['PreEndTime'] = self.pre_end_time
        if self.pre_start_time is not None:
            result['PreStartTime'] = self.pre_start_time
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CoverUrl') is not None:
            self.cover_url = m.get('CoverUrl')
        if m.get('Introduction') is not None:
            self.introduction = m.get('Introduction')
        if m.get('LiveId') is not None:
            self.live_id = m.get('LiveId')
        if m.get('PreEndTime') is not None:
            self.pre_end_time = m.get('PreEndTime')
        if m.get('PreStartTime') is not None:
            self.pre_start_time = m.get('PreStartTime')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class UpdateLiveResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # requestId
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateLiveResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMeetingRoomHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdateMeetingRoomHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdateMeetingRoomHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdateMeetingRoomHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdateMeetingRoomShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdateMeetingRoomRequestReservationAuthorityAuthorizedMembers(TeaModel):
    def __init__(
        self,
        member_id: str = None,
        member_name: str = None,
        member_type: str = None,
    ):
        self.member_id = member_id
        self.member_name = member_name
        self.member_type = member_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.member_id is not None:
            result['MemberId'] = self.member_id
        if self.member_name is not None:
            result['MemberName'] = self.member_name
        if self.member_type is not None:
            result['MemberType'] = self.member_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemberId') is not None:
            self.member_id = m.get('MemberId')
        if m.get('MemberName') is not None:
            self.member_name = m.get('MemberName')
        if m.get('MemberType') is not None:
            self.member_type = m.get('MemberType')
        return self


class UpdateMeetingRoomRequestReservationAuthority(TeaModel):
    def __init__(
        self,
        authorized_members: List[UpdateMeetingRoomRequestReservationAuthorityAuthorizedMembers] = None,
    ):
        self.authorized_members = authorized_members

    def validate(self):
        if self.authorized_members:
            for k in self.authorized_members:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AuthorizedMembers'] = []
        if self.authorized_members is not None:
            for k in self.authorized_members:
                result['AuthorizedMembers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.authorized_members = []
        if m.get('AuthorizedMembers') is not None:
            for k in m.get('AuthorizedMembers'):
                temp_model = UpdateMeetingRoomRequestReservationAuthorityAuthorizedMembers()
                self.authorized_members.append(temp_model.from_map(k))
        return self


class UpdateMeetingRoomRequestRoomLocation(TeaModel):
    def __init__(
        self,
        desc: str = None,
        title: str = None,
    ):
        self.desc = desc
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class UpdateMeetingRoomRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class UpdateMeetingRoomRequest(TeaModel):
    def __init__(
        self,
        enable_cycle_reservation: bool = None,
        group_id: int = None,
        isv_room_id: str = None,
        reservation_authority: UpdateMeetingRoomRequestReservationAuthority = None,
        room_capacity: int = None,
        room_id: str = None,
        room_label_ids: List[int] = None,
        room_location: UpdateMeetingRoomRequestRoomLocation = None,
        room_name: str = None,
        room_picture: str = None,
        room_status: int = None,
        tenant_context: UpdateMeetingRoomRequestTenantContext = None,
    ):
        self.enable_cycle_reservation = enable_cycle_reservation
        self.group_id = group_id
        self.isv_room_id = isv_room_id
        self.reservation_authority = reservation_authority
        self.room_capacity = room_capacity
        self.room_id = room_id
        self.room_label_ids = room_label_ids
        self.room_location = room_location
        self.room_name = room_name
        self.room_picture = room_picture
        self.room_status = room_status
        self.tenant_context = tenant_context

    def validate(self):
        if self.reservation_authority:
            self.reservation_authority.validate()
        if self.room_location:
            self.room_location.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_cycle_reservation is not None:
            result['EnableCycleReservation'] = self.enable_cycle_reservation
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.isv_room_id is not None:
            result['IsvRoomId'] = self.isv_room_id
        if self.reservation_authority is not None:
            result['ReservationAuthority'] = self.reservation_authority.to_map()
        if self.room_capacity is not None:
            result['RoomCapacity'] = self.room_capacity
        if self.room_id is not None:
            result['RoomId'] = self.room_id
        if self.room_label_ids is not None:
            result['RoomLabelIds'] = self.room_label_ids
        if self.room_location is not None:
            result['RoomLocation'] = self.room_location.to_map()
        if self.room_name is not None:
            result['RoomName'] = self.room_name
        if self.room_picture is not None:
            result['RoomPicture'] = self.room_picture
        if self.room_status is not None:
            result['RoomStatus'] = self.room_status
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableCycleReservation') is not None:
            self.enable_cycle_reservation = m.get('EnableCycleReservation')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IsvRoomId') is not None:
            self.isv_room_id = m.get('IsvRoomId')
        if m.get('ReservationAuthority') is not None:
            temp_model = UpdateMeetingRoomRequestReservationAuthority()
            self.reservation_authority = temp_model.from_map(m['ReservationAuthority'])
        if m.get('RoomCapacity') is not None:
            self.room_capacity = m.get('RoomCapacity')
        if m.get('RoomId') is not None:
            self.room_id = m.get('RoomId')
        if m.get('RoomLabelIds') is not None:
            self.room_label_ids = m.get('RoomLabelIds')
        if m.get('RoomLocation') is not None:
            temp_model = UpdateMeetingRoomRequestRoomLocation()
            self.room_location = temp_model.from_map(m['RoomLocation'])
        if m.get('RoomName') is not None:
            self.room_name = m.get('RoomName')
        if m.get('RoomPicture') is not None:
            self.room_picture = m.get('RoomPicture')
        if m.get('RoomStatus') is not None:
            self.room_status = m.get('RoomStatus')
        if m.get('TenantContext') is not None:
            temp_model = UpdateMeetingRoomRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class UpdateMeetingRoomShrinkRequest(TeaModel):
    def __init__(
        self,
        enable_cycle_reservation: bool = None,
        group_id: int = None,
        isv_room_id: str = None,
        reservation_authority_shrink: str = None,
        room_capacity: int = None,
        room_id: str = None,
        room_label_ids_shrink: str = None,
        room_location_shrink: str = None,
        room_name: str = None,
        room_picture: str = None,
        room_status: int = None,
        tenant_context_shrink: str = None,
    ):
        self.enable_cycle_reservation = enable_cycle_reservation
        self.group_id = group_id
        self.isv_room_id = isv_room_id
        self.reservation_authority_shrink = reservation_authority_shrink
        self.room_capacity = room_capacity
        self.room_id = room_id
        self.room_label_ids_shrink = room_label_ids_shrink
        self.room_location_shrink = room_location_shrink
        self.room_name = room_name
        self.room_picture = room_picture
        self.room_status = room_status
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_cycle_reservation is not None:
            result['EnableCycleReservation'] = self.enable_cycle_reservation
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.isv_room_id is not None:
            result['IsvRoomId'] = self.isv_room_id
        if self.reservation_authority_shrink is not None:
            result['ReservationAuthority'] = self.reservation_authority_shrink
        if self.room_capacity is not None:
            result['RoomCapacity'] = self.room_capacity
        if self.room_id is not None:
            result['RoomId'] = self.room_id
        if self.room_label_ids_shrink is not None:
            result['RoomLabelIds'] = self.room_label_ids_shrink
        if self.room_location_shrink is not None:
            result['RoomLocation'] = self.room_location_shrink
        if self.room_name is not None:
            result['RoomName'] = self.room_name
        if self.room_picture is not None:
            result['RoomPicture'] = self.room_picture
        if self.room_status is not None:
            result['RoomStatus'] = self.room_status
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableCycleReservation') is not None:
            self.enable_cycle_reservation = m.get('EnableCycleReservation')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IsvRoomId') is not None:
            self.isv_room_id = m.get('IsvRoomId')
        if m.get('ReservationAuthority') is not None:
            self.reservation_authority_shrink = m.get('ReservationAuthority')
        if m.get('RoomCapacity') is not None:
            self.room_capacity = m.get('RoomCapacity')
        if m.get('RoomId') is not None:
            self.room_id = m.get('RoomId')
        if m.get('RoomLabelIds') is not None:
            self.room_label_ids_shrink = m.get('RoomLabelIds')
        if m.get('RoomLocation') is not None:
            self.room_location_shrink = m.get('RoomLocation')
        if m.get('RoomName') is not None:
            self.room_name = m.get('RoomName')
        if m.get('RoomPicture') is not None:
            self.room_picture = m.get('RoomPicture')
        if m.get('RoomStatus') is not None:
            self.room_status = m.get('RoomStatus')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class UpdateMeetingRoomResponseBody(TeaModel):
    def __init__(
        self,
        result: bool = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.result = result
        # requestId
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['Result'] = self.result
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class UpdateMeetingRoomResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMeetingRoomResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMeetingRoomResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMeetingRoomGroupHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdateMeetingRoomGroupHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdateMeetingRoomGroupHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdateMeetingRoomGroupHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdateMeetingRoomGroupShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdateMeetingRoomGroupRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class UpdateMeetingRoomGroupRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        group_name: str = None,
        tenant_context: UpdateMeetingRoomGroupRequestTenantContext = None,
    ):
        # This parameter is required.
        self.group_id = group_id
        self.group_name = group_name
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('TenantContext') is not None:
            temp_model = UpdateMeetingRoomGroupRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class UpdateMeetingRoomGroupShrinkRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        group_name: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.group_id = group_id
        self.group_name = group_name
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class UpdateMeetingRoomGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: bool = None,
    ):
        # requestId
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class UpdateMeetingRoomGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMeetingRoomGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMeetingRoomGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMultiDimTableHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdateMultiDimTableHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdateMultiDimTableHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdateMultiDimTableHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdateMultiDimTableShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdateMultiDimTableRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class UpdateMultiDimTableRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        name: str = None,
        sheet_id_or_name: str = None,
        tenant_context: UpdateMultiDimTableRequestTenantContext = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.name is not None:
            result['Name'] = self.name
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            temp_model = UpdateMultiDimTableRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class UpdateMultiDimTableShrinkRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        name: str = None,
        sheet_id_or_name: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.name is not None:
            result['Name'] = self.name
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class UpdateMultiDimTableResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.id = id
        self.name = name
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class UpdateMultiDimTableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMultiDimTableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMultiDimTableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMultiDimTableFieldHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdateMultiDimTableFieldHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdateMultiDimTableFieldHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdateMultiDimTableFieldHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdateMultiDimTableFieldShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdateMultiDimTableFieldRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class UpdateMultiDimTableFieldRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        field_id_or_name: str = None,
        name: str = None,
        property: Dict[str, Any] = None,
        sheet_id_or_name: str = None,
        tenant_context: UpdateMultiDimTableFieldRequestTenantContext = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.field_id_or_name = field_id_or_name
        # This parameter is required.
        self.name = name
        self.property = property
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context = tenant_context

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.field_id_or_name is not None:
            result['FieldIdOrName'] = self.field_id_or_name
        if self.name is not None:
            result['Name'] = self.name
        if self.property is not None:
            result['Property'] = self.property
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('FieldIdOrName') is not None:
            self.field_id_or_name = m.get('FieldIdOrName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Property') is not None:
            self.property = m.get('Property')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            temp_model = UpdateMultiDimTableFieldRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class UpdateMultiDimTableFieldShrinkRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        field_id_or_name: str = None,
        name: str = None,
        property_shrink: str = None,
        sheet_id_or_name: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.field_id_or_name = field_id_or_name
        # This parameter is required.
        self.name = name
        self.property_shrink = property_shrink
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.field_id_or_name is not None:
            result['FieldIdOrName'] = self.field_id_or_name
        if self.name is not None:
            result['Name'] = self.name
        if self.property_shrink is not None:
            result['Property'] = self.property_shrink
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('FieldIdOrName') is not None:
            self.field_id_or_name = m.get('FieldIdOrName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Property') is not None:
            self.property_shrink = m.get('Property')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class UpdateMultiDimTableFieldResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.id = id
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class UpdateMultiDimTableFieldResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMultiDimTableFieldResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMultiDimTableFieldResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMultiDimTableRecordsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdateMultiDimTableRecordsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdateMultiDimTableRecordsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdateMultiDimTableRecordsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdateMultiDimTableRecordsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdateMultiDimTableRecordsRequestRecordIds(TeaModel):
    def __init__(
        self,
        fields: Dict[str, Any] = None,
        id: str = None,
    ):
        # This parameter is required.
        self.fields = fields
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fields is not None:
            result['Fields'] = self.fields
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Fields') is not None:
            self.fields = m.get('Fields')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class UpdateMultiDimTableRecordsRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class UpdateMultiDimTableRecordsRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        record_ids: List[UpdateMultiDimTableRecordsRequestRecordIds] = None,
        sheet_id_or_name: str = None,
        tenant_context: UpdateMultiDimTableRecordsRequestTenantContext = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.record_ids = record_ids
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context = tenant_context

    def validate(self):
        if self.record_ids:
            for k in self.record_ids:
                if k:
                    k.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        result['RecordIds'] = []
        if self.record_ids is not None:
            for k in self.record_ids:
                result['RecordIds'].append(k.to_map() if k else None)
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        self.record_ids = []
        if m.get('RecordIds') is not None:
            for k in m.get('RecordIds'):
                temp_model = UpdateMultiDimTableRecordsRequestRecordIds()
                self.record_ids.append(temp_model.from_map(k))
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            temp_model = UpdateMultiDimTableRecordsRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class UpdateMultiDimTableRecordsShrinkRequest(TeaModel):
    def __init__(
        self,
        base_id: str = None,
        record_ids_shrink: str = None,
        sheet_id_or_name: str = None,
        tenant_context_shrink: str = None,
    ):
        # This parameter is required.
        self.base_id = base_id
        # This parameter is required.
        self.record_ids_shrink = record_ids_shrink
        # This parameter is required.
        self.sheet_id_or_name = sheet_id_or_name
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_id is not None:
            result['BaseId'] = self.base_id
        if self.record_ids_shrink is not None:
            result['RecordIds'] = self.record_ids_shrink
        if self.sheet_id_or_name is not None:
            result['SheetIdOrName'] = self.sheet_id_or_name
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseId') is not None:
            self.base_id = m.get('BaseId')
        if m.get('RecordIds') is not None:
            self.record_ids_shrink = m.get('RecordIds')
        if m.get('SheetIdOrName') is not None:
            self.sheet_id_or_name = m.get('SheetIdOrName')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class UpdateMultiDimTableRecordsResponseBodyValue(TeaModel):
    def __init__(
        self,
        id: str = None,
    ):
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class UpdateMultiDimTableRecordsResponseBody(TeaModel):
    def __init__(
        self,
        value: List[UpdateMultiDimTableRecordsResponseBodyValue] = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.value = value
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        if self.value:
            for k in self.value:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Value'] = []
        if self.value is not None:
            for k in self.value:
                result['Value'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.value = []
        if m.get('Value') is not None:
            for k in m.get('Value'):
                temp_model = UpdateMultiDimTableRecordsResponseBodyValue()
                self.value.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class UpdateMultiDimTableRecordsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMultiDimTableRecordsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMultiDimTableRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePermissionHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdatePermissionHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdatePermissionHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdatePermissionHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdatePermissionShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdatePermissionRequestMembers(TeaModel):
    def __init__(
        self,
        corp_id: str = None,
        id: str = None,
        type: str = None,
    ):
        self.corp_id = corp_id
        self.id = id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.corp_id is not None:
            result['CorpId'] = self.corp_id
        if self.id is not None:
            result['Id'] = self.id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CorpId') is not None:
            self.corp_id = m.get('CorpId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdatePermissionRequestOption(TeaModel):
    def __init__(
        self,
        duration: int = None,
    ):
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class UpdatePermissionRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class UpdatePermissionRequest(TeaModel):
    def __init__(
        self,
        dentry_uuid: str = None,
        members: List[UpdatePermissionRequestMembers] = None,
        option: UpdatePermissionRequestOption = None,
        role_id: str = None,
        tenant_context: UpdatePermissionRequestTenantContext = None,
    ):
        self.dentry_uuid = dentry_uuid
        # This parameter is required.
        self.members = members
        self.option = option
        self.role_id = role_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.members:
            for k in self.members:
                if k:
                    k.validate()
        if self.option:
            self.option.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        result['Members'] = []
        if self.members is not None:
            for k in self.members:
                result['Members'].append(k.to_map() if k else None)
        if self.option is not None:
            result['Option'] = self.option.to_map()
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        self.members = []
        if m.get('Members') is not None:
            for k in m.get('Members'):
                temp_model = UpdatePermissionRequestMembers()
                self.members.append(temp_model.from_map(k))
        if m.get('Option') is not None:
            temp_model = UpdatePermissionRequestOption()
            self.option = temp_model.from_map(m['Option'])
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        if m.get('TenantContext') is not None:
            temp_model = UpdatePermissionRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class UpdatePermissionShrinkRequest(TeaModel):
    def __init__(
        self,
        dentry_uuid: str = None,
        members_shrink: str = None,
        option_shrink: str = None,
        role_id: str = None,
        tenant_context_shrink: str = None,
    ):
        self.dentry_uuid = dentry_uuid
        # This parameter is required.
        self.members_shrink = members_shrink
        self.option_shrink = option_shrink
        self.role_id = role_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dentry_uuid is not None:
            result['DentryUuid'] = self.dentry_uuid
        if self.members_shrink is not None:
            result['Members'] = self.members_shrink
        if self.option_shrink is not None:
            result['Option'] = self.option_shrink
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DentryUuid') is not None:
            self.dentry_uuid = m.get('DentryUuid')
        if m.get('Members') is not None:
            self.members_shrink = m.get('Members')
        if m.get('Option') is not None:
            self.option_shrink = m.get('Option')
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class UpdatePermissionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.success = success
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class UpdatePermissionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdatePermissionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateRangeHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdateRangeHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdateRangeHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdateRangeHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdateRangeShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdateRangeRequestHyperlinks(TeaModel):
    def __init__(
        self,
        type: str = None,
        link: str = None,
        text: str = None,
    ):
        self.type = type
        self.link = link
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.link is not None:
            result['Link'] = self.link
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class UpdateRangeRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class UpdateRangeRequest(TeaModel):
    def __init__(
        self,
        background_colors: List[List[str]] = None,
        hyperlinks: List[List[UpdateRangeRequestHyperlinks]] = None,
        number_format: str = None,
        range_address: str = None,
        sheet_id: str = None,
        tenant_context: UpdateRangeRequestTenantContext = None,
        values: List[List[str]] = None,
        workbook_id: str = None,
    ):
        self.background_colors = background_colors
        self.hyperlinks = hyperlinks
        self.number_format = number_format
        # This parameter is required.
        self.range_address = range_address
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context = tenant_context
        self.values = values
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        if self.hyperlinks:
            for k in self.hyperlinks:
                for k1 in k:
                    if k1:
                        k1.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.background_colors is not None:
            result['BackgroundColors'] = self.background_colors
        result['Hyperlinks'] = []
        if self.hyperlinks is not None:
            for k in self.hyperlinks:
                l1 = []
                for k1 in k:
                    l1.append(k1.to_map() if k1 else None)
                result['Hyperlinks'].append(l1)
        if self.number_format is not None:
            result['NumberFormat'] = self.number_format
        if self.range_address is not None:
            result['RangeAddress'] = self.range_address
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.values is not None:
            result['Values'] = self.values
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackgroundColors') is not None:
            self.background_colors = m.get('BackgroundColors')
        self.hyperlinks = []
        if m.get('Hyperlinks') is not None:
            for k in m.get('Hyperlinks'):
                l1 = []
                for k1 in k:
                    temp_model = UpdateRangeRequestHyperlinks()
                    l1.append(temp_model.from_map(k1))
                self.hyperlinks.append(l1)
        if m.get('NumberFormat') is not None:
            self.number_format = m.get('NumberFormat')
        if m.get('RangeAddress') is not None:
            self.range_address = m.get('RangeAddress')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            temp_model = UpdateRangeRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('Values') is not None:
            self.values = m.get('Values')
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class UpdateRangeShrinkRequest(TeaModel):
    def __init__(
        self,
        background_colors_shrink: str = None,
        hyperlinks_shrink: str = None,
        number_format: str = None,
        range_address: str = None,
        sheet_id: str = None,
        tenant_context_shrink: str = None,
        values_shrink: str = None,
        workbook_id: str = None,
    ):
        self.background_colors_shrink = background_colors_shrink
        self.hyperlinks_shrink = hyperlinks_shrink
        self.number_format = number_format
        # This parameter is required.
        self.range_address = range_address
        # This parameter is required.
        self.sheet_id = sheet_id
        self.tenant_context_shrink = tenant_context_shrink
        self.values_shrink = values_shrink
        # This parameter is required.
        self.workbook_id = workbook_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.background_colors_shrink is not None:
            result['BackgroundColors'] = self.background_colors_shrink
        if self.hyperlinks_shrink is not None:
            result['Hyperlinks'] = self.hyperlinks_shrink
        if self.number_format is not None:
            result['NumberFormat'] = self.number_format
        if self.range_address is not None:
            result['RangeAddress'] = self.range_address
        if self.sheet_id is not None:
            result['SheetId'] = self.sheet_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.values_shrink is not None:
            result['Values'] = self.values_shrink
        if self.workbook_id is not None:
            result['WorkbookId'] = self.workbook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackgroundColors') is not None:
            self.background_colors_shrink = m.get('BackgroundColors')
        if m.get('Hyperlinks') is not None:
            self.hyperlinks_shrink = m.get('Hyperlinks')
        if m.get('NumberFormat') is not None:
            self.number_format = m.get('NumberFormat')
        if m.get('RangeAddress') is not None:
            self.range_address = m.get('RangeAddress')
        if m.get('SheetId') is not None:
            self.sheet_id = m.get('SheetId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('Values') is not None:
            self.values_shrink = m.get('Values')
        if m.get('WorkbookId') is not None:
            self.workbook_id = m.get('WorkbookId')
        return self


class UpdateRangeResponseBody(TeaModel):
    def __init__(
        self,
        a_1notation: str = None,
        request_id: str = None,
    ):
        self.a_1notation = a_1notation
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.a_1notation is not None:
            result['a1Notation'] = self.a_1notation
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('a1Notation') is not None:
            self.a_1notation = m.get('a1Notation')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateRangeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateRangeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateRangeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateScheduleConfSettingsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdateScheduleConfSettingsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdateScheduleConfSettingsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdateScheduleConfSettingsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdateScheduleConfSettingsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfOpenRecordSetting(TeaModel):
    def __init__(
        self,
        is_follow_host: bool = None,
        mode: str = None,
        record_auto_start: int = None,
        record_auto_start_type: int = None,
    ):
        self.is_follow_host = is_follow_host
        self.mode = mode
        self.record_auto_start = record_auto_start
        self.record_auto_start_type = record_auto_start_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_follow_host is not None:
            result['IsFollowHost'] = self.is_follow_host
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.record_auto_start is not None:
            result['RecordAutoStart'] = self.record_auto_start
        if self.record_auto_start_type is not None:
            result['RecordAutoStartType'] = self.record_auto_start_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsFollowHost') is not None:
            self.is_follow_host = m.get('IsFollowHost')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('RecordAutoStart') is not None:
            self.record_auto_start = m.get('RecordAutoStart')
        if m.get('RecordAutoStartType') is not None:
            self.record_auto_start_type = m.get('RecordAutoStartType')
        return self


class UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings(TeaModel):
    def __init__(
        self,
        auto_open_mode: int = None,
        cool_app_code: str = None,
        extension_app_biz_data: str = None,
    ):
        self.auto_open_mode = auto_open_mode
        self.cool_app_code = cool_app_code
        self.extension_app_biz_data = extension_app_biz_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_open_mode is not None:
            result['AutoOpenMode'] = self.auto_open_mode
        if self.cool_app_code is not None:
            result['CoolAppCode'] = self.cool_app_code
        if self.extension_app_biz_data is not None:
            result['ExtensionAppBizData'] = self.extension_app_biz_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoOpenMode') is not None:
            self.auto_open_mode = m.get('AutoOpenMode')
        if m.get('CoolAppCode') is not None:
            self.cool_app_code = m.get('CoolAppCode')
        if m.get('ExtensionAppBizData') is not None:
            self.extension_app_biz_data = m.get('ExtensionAppBizData')
        return self


class UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting(TeaModel):
    def __init__(
        self,
        cloud_record_owner_user_id: str = None,
        enable_chat: int = None,
        enable_web_anonymous_join: bool = None,
        join_before_host: int = None,
        lock_media_status_mic_mute: int = None,
        lock_nick: int = None,
        minutes_owner_user_id: str = None,
        mozi_conf_extension_app_settings: List[UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings] = None,
        push_all_meeting_records: bool = None,
        push_cloud_record_card: bool = None,
        push_minutes_card: bool = None,
        waiting_room: int = None,
    ):
        self.cloud_record_owner_user_id = cloud_record_owner_user_id
        self.enable_chat = enable_chat
        self.enable_web_anonymous_join = enable_web_anonymous_join
        self.join_before_host = join_before_host
        self.lock_media_status_mic_mute = lock_media_status_mic_mute
        self.lock_nick = lock_nick
        self.minutes_owner_user_id = minutes_owner_user_id
        self.mozi_conf_extension_app_settings = mozi_conf_extension_app_settings
        self.push_all_meeting_records = push_all_meeting_records
        self.push_cloud_record_card = push_cloud_record_card
        self.push_minutes_card = push_minutes_card
        self.waiting_room = waiting_room

    def validate(self):
        if self.mozi_conf_extension_app_settings:
            for k in self.mozi_conf_extension_app_settings:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cloud_record_owner_user_id is not None:
            result['CloudRecordOwnerUserId'] = self.cloud_record_owner_user_id
        if self.enable_chat is not None:
            result['EnableChat'] = self.enable_chat
        if self.enable_web_anonymous_join is not None:
            result['EnableWebAnonymousJoin'] = self.enable_web_anonymous_join
        if self.join_before_host is not None:
            result['JoinBeforeHost'] = self.join_before_host
        if self.lock_media_status_mic_mute is not None:
            result['LockMediaStatusMicMute'] = self.lock_media_status_mic_mute
        if self.lock_nick is not None:
            result['LockNick'] = self.lock_nick
        if self.minutes_owner_user_id is not None:
            result['MinutesOwnerUserId'] = self.minutes_owner_user_id
        result['MoziConfExtensionAppSettings'] = []
        if self.mozi_conf_extension_app_settings is not None:
            for k in self.mozi_conf_extension_app_settings:
                result['MoziConfExtensionAppSettings'].append(k.to_map() if k else None)
        if self.push_all_meeting_records is not None:
            result['PushAllMeetingRecords'] = self.push_all_meeting_records
        if self.push_cloud_record_card is not None:
            result['PushCloudRecordCard'] = self.push_cloud_record_card
        if self.push_minutes_card is not None:
            result['PushMinutesCard'] = self.push_minutes_card
        if self.waiting_room is not None:
            result['WaitingRoom'] = self.waiting_room
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CloudRecordOwnerUserId') is not None:
            self.cloud_record_owner_user_id = m.get('CloudRecordOwnerUserId')
        if m.get('EnableChat') is not None:
            self.enable_chat = m.get('EnableChat')
        if m.get('EnableWebAnonymousJoin') is not None:
            self.enable_web_anonymous_join = m.get('EnableWebAnonymousJoin')
        if m.get('JoinBeforeHost') is not None:
            self.join_before_host = m.get('JoinBeforeHost')
        if m.get('LockMediaStatusMicMute') is not None:
            self.lock_media_status_mic_mute = m.get('LockMediaStatusMicMute')
        if m.get('LockNick') is not None:
            self.lock_nick = m.get('LockNick')
        if m.get('MinutesOwnerUserId') is not None:
            self.minutes_owner_user_id = m.get('MinutesOwnerUserId')
        self.mozi_conf_extension_app_settings = []
        if m.get('MoziConfExtensionAppSettings') is not None:
            for k in m.get('MoziConfExtensionAppSettings'):
                temp_model = UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings()
                self.mozi_conf_extension_app_settings.append(temp_model.from_map(k))
        if m.get('PushAllMeetingRecords') is not None:
            self.push_all_meeting_records = m.get('PushAllMeetingRecords')
        if m.get('PushCloudRecordCard') is not None:
            self.push_cloud_record_card = m.get('PushCloudRecordCard')
        if m.get('PushMinutesCard') is not None:
            self.push_minutes_card = m.get('PushMinutesCard')
        if m.get('WaitingRoom') is not None:
            self.waiting_room = m.get('WaitingRoom')
        return self


class UpdateScheduleConfSettingsRequestScheduleConfSettingModel(TeaModel):
    def __init__(
        self,
        cohost_user_ids: List[str] = None,
        conf_allowed_corp_id: str = None,
        host_user_id: str = None,
        lock_room: int = None,
        mozi_conf_open_record_setting: UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfOpenRecordSetting = None,
        mozi_conf_virtual_extra_setting: UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting = None,
        mute_on_join: int = None,
        screen_share_forbidden: int = None,
    ):
        self.cohost_user_ids = cohost_user_ids
        self.conf_allowed_corp_id = conf_allowed_corp_id
        self.host_user_id = host_user_id
        self.lock_room = lock_room
        self.mozi_conf_open_record_setting = mozi_conf_open_record_setting
        self.mozi_conf_virtual_extra_setting = mozi_conf_virtual_extra_setting
        self.mute_on_join = mute_on_join
        self.screen_share_forbidden = screen_share_forbidden

    def validate(self):
        if self.mozi_conf_open_record_setting:
            self.mozi_conf_open_record_setting.validate()
        if self.mozi_conf_virtual_extra_setting:
            self.mozi_conf_virtual_extra_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cohost_user_ids is not None:
            result['CohostUserIds'] = self.cohost_user_ids
        if self.conf_allowed_corp_id is not None:
            result['ConfAllowedCorpId'] = self.conf_allowed_corp_id
        if self.host_user_id is not None:
            result['HostUserId'] = self.host_user_id
        if self.lock_room is not None:
            result['LockRoom'] = self.lock_room
        if self.mozi_conf_open_record_setting is not None:
            result['MoziConfOpenRecordSetting'] = self.mozi_conf_open_record_setting.to_map()
        if self.mozi_conf_virtual_extra_setting is not None:
            result['MoziConfVirtualExtraSetting'] = self.mozi_conf_virtual_extra_setting.to_map()
        if self.mute_on_join is not None:
            result['MuteOnJoin'] = self.mute_on_join
        if self.screen_share_forbidden is not None:
            result['ScreenShareForbidden'] = self.screen_share_forbidden
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CohostUserIds') is not None:
            self.cohost_user_ids = m.get('CohostUserIds')
        if m.get('ConfAllowedCorpId') is not None:
            self.conf_allowed_corp_id = m.get('ConfAllowedCorpId')
        if m.get('HostUserId') is not None:
            self.host_user_id = m.get('HostUserId')
        if m.get('LockRoom') is not None:
            self.lock_room = m.get('LockRoom')
        if m.get('MoziConfOpenRecordSetting') is not None:
            temp_model = UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfOpenRecordSetting()
            self.mozi_conf_open_record_setting = temp_model.from_map(m['MoziConfOpenRecordSetting'])
        if m.get('MoziConfVirtualExtraSetting') is not None:
            temp_model = UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting()
            self.mozi_conf_virtual_extra_setting = temp_model.from_map(m['MoziConfVirtualExtraSetting'])
        if m.get('MuteOnJoin') is not None:
            self.mute_on_join = m.get('MuteOnJoin')
        if m.get('ScreenShareForbidden') is not None:
            self.screen_share_forbidden = m.get('ScreenShareForbidden')
        return self


class UpdateScheduleConfSettingsRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class UpdateScheduleConfSettingsRequest(TeaModel):
    def __init__(
        self,
        schedule_conf_setting_model: UpdateScheduleConfSettingsRequestScheduleConfSettingModel = None,
        schedule_conference_id: str = None,
        tenant_context: UpdateScheduleConfSettingsRequestTenantContext = None,
    ):
        self.schedule_conf_setting_model = schedule_conf_setting_model
        self.schedule_conference_id = schedule_conference_id
        self.tenant_context = tenant_context

    def validate(self):
        if self.schedule_conf_setting_model:
            self.schedule_conf_setting_model.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.schedule_conf_setting_model is not None:
            result['ScheduleConfSettingModel'] = self.schedule_conf_setting_model.to_map()
        if self.schedule_conference_id is not None:
            result['ScheduleConferenceId'] = self.schedule_conference_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ScheduleConfSettingModel') is not None:
            temp_model = UpdateScheduleConfSettingsRequestScheduleConfSettingModel()
            self.schedule_conf_setting_model = temp_model.from_map(m['ScheduleConfSettingModel'])
        if m.get('ScheduleConferenceId') is not None:
            self.schedule_conference_id = m.get('ScheduleConferenceId')
        if m.get('TenantContext') is not None:
            temp_model = UpdateScheduleConfSettingsRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        return self


class UpdateScheduleConfSettingsShrinkRequest(TeaModel):
    def __init__(
        self,
        schedule_conf_setting_model_shrink: str = None,
        schedule_conference_id: str = None,
        tenant_context_shrink: str = None,
    ):
        self.schedule_conf_setting_model_shrink = schedule_conf_setting_model_shrink
        self.schedule_conference_id = schedule_conference_id
        self.tenant_context_shrink = tenant_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.schedule_conf_setting_model_shrink is not None:
            result['ScheduleConfSettingModel'] = self.schedule_conf_setting_model_shrink
        if self.schedule_conference_id is not None:
            result['ScheduleConferenceId'] = self.schedule_conference_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ScheduleConfSettingModel') is not None:
            self.schedule_conf_setting_model_shrink = m.get('ScheduleConfSettingModel')
        if m.get('ScheduleConferenceId') is not None:
            self.schedule_conference_id = m.get('ScheduleConferenceId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        return self


class UpdateScheduleConfSettingsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.success = success
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class UpdateScheduleConfSettingsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateScheduleConfSettingsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateScheduleConfSettingsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateScheduleConferenceHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdateScheduleConferenceHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdateScheduleConferenceHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdateScheduleConferenceHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdateScheduleConferenceShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdateScheduleConferenceRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class UpdateScheduleConferenceRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        schedule_conference_id: str = None,
        start_time: int = None,
        tenant_context: UpdateScheduleConferenceRequestTenantContext = None,
        title: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        # This parameter is required.
        self.schedule_conference_id = schedule_conference_id
        # This parameter is required.
        self.start_time = start_time
        self.tenant_context = tenant_context
        # This parameter is required.
        self.title = title

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.schedule_conference_id is not None:
            result['ScheduleConferenceId'] = self.schedule_conference_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ScheduleConferenceId') is not None:
            self.schedule_conference_id = m.get('ScheduleConferenceId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            temp_model = UpdateScheduleConferenceRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class UpdateScheduleConferenceShrinkRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        schedule_conference_id: str = None,
        start_time: int = None,
        tenant_context_shrink: str = None,
        title: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        # This parameter is required.
        self.schedule_conference_id = schedule_conference_id
        # This parameter is required.
        self.start_time = start_time
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.schedule_conference_id is not None:
            result['ScheduleConferenceId'] = self.schedule_conference_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ScheduleConferenceId') is not None:
            self.schedule_conference_id = m.get('ScheduleConferenceId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class UpdateScheduleConferenceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # requestId
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateScheduleConferenceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateScheduleConferenceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateScheduleConferenceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateStatusHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdateStatusHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdateStatusHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdateStatusHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdateStatusShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdateStatusRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        error_lines: List[int] = None,
        import_sequence: str = None,
        language: str = None,
        status: str = None,
        system_token: str = None,
    ):
        self.app_type = app_type
        self.error_lines = error_lines
        self.import_sequence = import_sequence
        self.language = language
        self.status = status
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.error_lines is not None:
            result['ErrorLines'] = self.error_lines
        if self.import_sequence is not None:
            result['ImportSequence'] = self.import_sequence
        if self.language is not None:
            result['Language'] = self.language
        if self.status is not None:
            result['Status'] = self.status
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('ErrorLines') is not None:
            self.error_lines = m.get('ErrorLines')
        if m.get('ImportSequence') is not None:
            self.import_sequence = m.get('ImportSequence')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class UpdateStatusShrinkRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        error_lines_shrink: str = None,
        import_sequence: str = None,
        language: str = None,
        status: str = None,
        system_token: str = None,
    ):
        self.app_type = app_type
        self.error_lines_shrink = error_lines_shrink
        self.import_sequence = import_sequence
        self.language = language
        self.status = status
        self.system_token = system_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.error_lines_shrink is not None:
            result['ErrorLines'] = self.error_lines_shrink
        if self.import_sequence is not None:
            result['ImportSequence'] = self.import_sequence
        if self.language is not None:
            result['Language'] = self.language
        if self.status is not None:
            result['Status'] = self.status
        if self.system_token is not None:
            result['SystemToken'] = self.system_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('ErrorLines') is not None:
            self.error_lines_shrink = m.get('ErrorLines')
        if m.get('ImportSequence') is not None:
            self.import_sequence = m.get('ImportSequence')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SystemToken') is not None:
            self.system_token = m.get('SystemToken')
        return self


class UpdateStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class UpdateStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSubscribedCalendarsHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdateSubscribedCalendarsHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdateSubscribedCalendarsHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdateSubscribedCalendarsHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdateSubscribedCalendarsShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdateSubscribedCalendarsRequestSubscribeScope(TeaModel):
    def __init__(
        self,
        user_ids: List[str] = None,
    ):
        self.user_ids = user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        return self


class UpdateSubscribedCalendarsRequest(TeaModel):
    def __init__(
        self,
        calendar_id: str = None,
        description: str = None,
        managers: List[str] = None,
        name: str = None,
        subscribe_scope: UpdateSubscribedCalendarsRequestSubscribeScope = None,
    ):
        # This parameter is required.
        self.calendar_id = calendar_id
        self.description = description
        self.managers = managers
        self.name = name
        self.subscribe_scope = subscribe_scope

    def validate(self):
        if self.subscribe_scope:
            self.subscribe_scope.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        if self.description is not None:
            result['Description'] = self.description
        if self.managers is not None:
            result['Managers'] = self.managers
        if self.name is not None:
            result['Name'] = self.name
        if self.subscribe_scope is not None:
            result['SubscribeScope'] = self.subscribe_scope.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Managers') is not None:
            self.managers = m.get('Managers')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SubscribeScope') is not None:
            temp_model = UpdateSubscribedCalendarsRequestSubscribeScope()
            self.subscribe_scope = temp_model.from_map(m['SubscribeScope'])
        return self


class UpdateSubscribedCalendarsShrinkRequest(TeaModel):
    def __init__(
        self,
        calendar_id: str = None,
        description: str = None,
        managers_shrink: str = None,
        name: str = None,
        subscribe_scope_shrink: str = None,
    ):
        # This parameter is required.
        self.calendar_id = calendar_id
        self.description = description
        self.managers_shrink = managers_shrink
        self.name = name
        self.subscribe_scope_shrink = subscribe_scope_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calendar_id is not None:
            result['CalendarId'] = self.calendar_id
        if self.description is not None:
            result['Description'] = self.description
        if self.managers_shrink is not None:
            result['Managers'] = self.managers_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.subscribe_scope_shrink is not None:
            result['SubscribeScope'] = self.subscribe_scope_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalendarId') is not None:
            self.calendar_id = m.get('CalendarId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Managers') is not None:
            self.managers_shrink = m.get('Managers')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SubscribeScope') is not None:
            self.subscribe_scope_shrink = m.get('SubscribeScope')
        return self


class UpdateSubscribedCalendarsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: bool = None,
    ):
        # requestId
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class UpdateSubscribedCalendarsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSubscribedCalendarsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSubscribedCalendarsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTodoTaskHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdateTodoTaskHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdateTodoTaskHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdateTodoTaskHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdateTodoTaskShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdateTodoTaskRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class UpdateTodoTaskRequest(TeaModel):
    def __init__(
        self,
        tenant_context: UpdateTodoTaskRequestTenantContext = None,
        description: str = None,
        done: bool = None,
        due_time: int = None,
        executor_ids: List[str] = None,
        participant_ids: List[str] = None,
        subject: str = None,
        task_id: str = None,
    ):
        self.tenant_context = tenant_context
        self.description = description
        self.done = done
        self.due_time = due_time
        self.executor_ids = executor_ids
        self.participant_ids = participant_ids
        self.subject = subject
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.description is not None:
            result['description'] = self.description
        if self.done is not None:
            result['done'] = self.done
        if self.due_time is not None:
            result['dueTime'] = self.due_time
        if self.executor_ids is not None:
            result['executorIds'] = self.executor_ids
        if self.participant_ids is not None:
            result['participantIds'] = self.participant_ids
        if self.subject is not None:
            result['subject'] = self.subject
        if self.task_id is not None:
            result['taskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = UpdateTodoTaskRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('done') is not None:
            self.done = m.get('done')
        if m.get('dueTime') is not None:
            self.due_time = m.get('dueTime')
        if m.get('executorIds') is not None:
            self.executor_ids = m.get('executorIds')
        if m.get('participantIds') is not None:
            self.participant_ids = m.get('participantIds')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        return self


class UpdateTodoTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        description: str = None,
        done: bool = None,
        due_time: int = None,
        executor_ids_shrink: str = None,
        participant_ids_shrink: str = None,
        subject: str = None,
        task_id: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        self.description = description
        self.done = done
        self.due_time = due_time
        self.executor_ids_shrink = executor_ids_shrink
        self.participant_ids_shrink = participant_ids_shrink
        self.subject = subject
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.description is not None:
            result['description'] = self.description
        if self.done is not None:
            result['done'] = self.done
        if self.due_time is not None:
            result['dueTime'] = self.due_time
        if self.executor_ids_shrink is not None:
            result['executorIds'] = self.executor_ids_shrink
        if self.participant_ids_shrink is not None:
            result['participantIds'] = self.participant_ids_shrink
        if self.subject is not None:
            result['subject'] = self.subject
        if self.task_id is not None:
            result['taskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('done') is not None:
            self.done = m.get('done')
        if m.get('dueTime') is not None:
            self.due_time = m.get('dueTime')
        if m.get('executorIds') is not None:
            self.executor_ids_shrink = m.get('executorIds')
        if m.get('participantIds') is not None:
            self.participant_ids_shrink = m.get('participantIds')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        return self


class UpdateTodoTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: bool = None,
    ):
        # requestId
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class UpdateTodoTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTodoTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTodoTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTodoTaskExecutorStatusHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdateTodoTaskExecutorStatusHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdateTodoTaskExecutorStatusHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdateTodoTaskExecutorStatusHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdateTodoTaskExecutorStatusShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdateTodoTaskExecutorStatusRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class UpdateTodoTaskExecutorStatusRequestExecutorStatusList(TeaModel):
    def __init__(
        self,
        id: str = None,
        is_done: bool = None,
    ):
        self.id = id
        self.is_done = is_done

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.is_done is not None:
            result['isDone'] = self.is_done
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('isDone') is not None:
            self.is_done = m.get('isDone')
        return self


class UpdateTodoTaskExecutorStatusRequest(TeaModel):
    def __init__(
        self,
        tenant_context: UpdateTodoTaskExecutorStatusRequestTenantContext = None,
        executor_status_list: List[UpdateTodoTaskExecutorStatusRequestExecutorStatusList] = None,
        operator_id: str = None,
        task_id: str = None,
    ):
        self.tenant_context = tenant_context
        self.executor_status_list = executor_status_list
        self.operator_id = operator_id
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()
        if self.executor_status_list:
            for k in self.executor_status_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        result['executorStatusList'] = []
        if self.executor_status_list is not None:
            for k in self.executor_status_list:
                result['executorStatusList'].append(k.to_map() if k else None)
        if self.operator_id is not None:
            result['operatorId'] = self.operator_id
        if self.task_id is not None:
            result['taskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = UpdateTodoTaskExecutorStatusRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        self.executor_status_list = []
        if m.get('executorStatusList') is not None:
            for k in m.get('executorStatusList'):
                temp_model = UpdateTodoTaskExecutorStatusRequestExecutorStatusList()
                self.executor_status_list.append(temp_model.from_map(k))
        if m.get('operatorId') is not None:
            self.operator_id = m.get('operatorId')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        return self


class UpdateTodoTaskExecutorStatusShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        executor_status_list_shrink: str = None,
        operator_id: str = None,
        task_id: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        self.executor_status_list_shrink = executor_status_list_shrink
        self.operator_id = operator_id
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.executor_status_list_shrink is not None:
            result['executorStatusList'] = self.executor_status_list_shrink
        if self.operator_id is not None:
            result['operatorId'] = self.operator_id
        if self.task_id is not None:
            result['taskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('executorStatusList') is not None:
            self.executor_status_list_shrink = m.get('executorStatusList')
        if m.get('operatorId') is not None:
            self.operator_id = m.get('operatorId')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        return self


class UpdateTodoTaskExecutorStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: bool = None,
    ):
        # requestId
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class UpdateTodoTaskExecutorStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTodoTaskExecutorStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTodoTaskExecutorStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateUserAvatarHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdateUserAvatarHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdateUserAvatarHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdateUserAvatarHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdateUserAvatarShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdateUserAvatarRequest(TeaModel):
    def __init__(
        self,
        avatar_media_id: str = None,
    ):
        self.avatar_media_id = avatar_media_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_media_id is not None:
            result['AvatarMediaId'] = self.avatar_media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarMediaId') is not None:
            self.avatar_media_id = m.get('AvatarMediaId')
        return self


class UpdateUserAvatarResponseBody(TeaModel):
    def __init__(
        self,
        errcode: str = None,
        errmsg: str = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.errcode = errcode
        self.errmsg = errmsg
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.errcode is not None:
            result['errcode'] = self.errcode
        if self.errmsg is not None:
            result['errmsg'] = self.errmsg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errcode') is not None:
            self.errcode = m.get('errcode')
        if m.get('errmsg') is not None:
            self.errmsg = m.get('errmsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class UpdateUserAvatarResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateUserAvatarResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateUserAvatarResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateVideoConferenceSettingHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdateVideoConferenceSettingHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdateVideoConferenceSettingHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdateVideoConferenceSettingHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdateVideoConferenceSettingShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdateVideoConferenceSettingRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class UpdateVideoConferenceSettingRequest(TeaModel):
    def __init__(
        self,
        allow_unmute_self: bool = None,
        auto_transfer_host: bool = None,
        forbidden_share_screen: bool = None,
        lock_conference: bool = None,
        mute_all: bool = None,
        only_internal_employees_join: bool = None,
        tenant_context: UpdateVideoConferenceSettingRequestTenantContext = None,
        conference_id: str = None,
    ):
        self.allow_unmute_self = allow_unmute_self
        self.auto_transfer_host = auto_transfer_host
        self.forbidden_share_screen = forbidden_share_screen
        self.lock_conference = lock_conference
        self.mute_all = mute_all
        self.only_internal_employees_join = only_internal_employees_join
        self.tenant_context = tenant_context
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_unmute_self is not None:
            result['AllowUnmuteSelf'] = self.allow_unmute_self
        if self.auto_transfer_host is not None:
            result['AutoTransferHost'] = self.auto_transfer_host
        if self.forbidden_share_screen is not None:
            result['ForbiddenShareScreen'] = self.forbidden_share_screen
        if self.lock_conference is not None:
            result['LockConference'] = self.lock_conference
        if self.mute_all is not None:
            result['MuteAll'] = self.mute_all
        if self.only_internal_employees_join is not None:
            result['OnlyInternalEmployeesJoin'] = self.only_internal_employees_join
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllowUnmuteSelf') is not None:
            self.allow_unmute_self = m.get('AllowUnmuteSelf')
        if m.get('AutoTransferHost') is not None:
            self.auto_transfer_host = m.get('AutoTransferHost')
        if m.get('ForbiddenShareScreen') is not None:
            self.forbidden_share_screen = m.get('ForbiddenShareScreen')
        if m.get('LockConference') is not None:
            self.lock_conference = m.get('LockConference')
        if m.get('MuteAll') is not None:
            self.mute_all = m.get('MuteAll')
        if m.get('OnlyInternalEmployeesJoin') is not None:
            self.only_internal_employees_join = m.get('OnlyInternalEmployeesJoin')
        if m.get('TenantContext') is not None:
            temp_model = UpdateVideoConferenceSettingRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class UpdateVideoConferenceSettingShrinkRequest(TeaModel):
    def __init__(
        self,
        allow_unmute_self: bool = None,
        auto_transfer_host: bool = None,
        forbidden_share_screen: bool = None,
        lock_conference: bool = None,
        mute_all: bool = None,
        only_internal_employees_join: bool = None,
        tenant_context_shrink: str = None,
        conference_id: str = None,
    ):
        self.allow_unmute_self = allow_unmute_self
        self.auto_transfer_host = auto_transfer_host
        self.forbidden_share_screen = forbidden_share_screen
        self.lock_conference = lock_conference
        self.mute_all = mute_all
        self.only_internal_employees_join = only_internal_employees_join
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.conference_id = conference_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_unmute_self is not None:
            result['AllowUnmuteSelf'] = self.allow_unmute_self
        if self.auto_transfer_host is not None:
            result['AutoTransferHost'] = self.auto_transfer_host
        if self.forbidden_share_screen is not None:
            result['ForbiddenShareScreen'] = self.forbidden_share_screen
        if self.lock_conference is not None:
            result['LockConference'] = self.lock_conference
        if self.mute_all is not None:
            result['MuteAll'] = self.mute_all
        if self.only_internal_employees_join is not None:
            result['OnlyInternalEmployeesJoin'] = self.only_internal_employees_join
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.conference_id is not None:
            result['conferenceId'] = self.conference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllowUnmuteSelf') is not None:
            self.allow_unmute_self = m.get('AllowUnmuteSelf')
        if m.get('AutoTransferHost') is not None:
            self.auto_transfer_host = m.get('AutoTransferHost')
        if m.get('ForbiddenShareScreen') is not None:
            self.forbidden_share_screen = m.get('ForbiddenShareScreen')
        if m.get('LockConference') is not None:
            self.lock_conference = m.get('LockConference')
        if m.get('MuteAll') is not None:
            self.mute_all = m.get('MuteAll')
        if m.get('OnlyInternalEmployeesJoin') is not None:
            self.only_internal_employees_join = m.get('OnlyInternalEmployeesJoin')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('conferenceId') is not None:
            self.conference_id = m.get('conferenceId')
        return self


class UpdateVideoConferenceSettingResponseBody(TeaModel):
    def __init__(
        self,
        case_result: str = None,
        code: str = None,
        request_id: str = None,
        vendor_request_id: str = None,
        vendor_type: str = None,
    ):
        self.case_result = case_result
        self.code = code
        self.request_id = request_id
        self.vendor_request_id = vendor_request_id
        self.vendor_type = vendor_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.case_result is not None:
            result['caseResult'] = self.case_result
        if self.code is not None:
            result['code'] = self.code
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vendor_request_id is not None:
            result['vendorRequestId'] = self.vendor_request_id
        if self.vendor_type is not None:
            result['vendorType'] = self.vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('caseResult') is not None:
            self.case_result = m.get('caseResult')
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vendorRequestId') is not None:
            self.vendor_request_id = m.get('vendorRequestId')
        if m.get('vendorType') is not None:
            self.vendor_type = m.get('vendorType')
        return self


class UpdateVideoConferenceSettingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateVideoConferenceSettingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateVideoConferenceSettingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateWorkspaceDocMembersHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdateWorkspaceDocMembersHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdateWorkspaceDocMembersHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdateWorkspaceDocMembersHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdateWorkspaceDocMembersShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdateWorkspaceDocMembersRequestMembers(TeaModel):
    def __init__(
        self,
        member_id: str = None,
        member_type: str = None,
        role_type: str = None,
    ):
        self.member_id = member_id
        self.member_type = member_type
        self.role_type = role_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.member_id is not None:
            result['MemberId'] = self.member_id
        if self.member_type is not None:
            result['MemberType'] = self.member_type
        if self.role_type is not None:
            result['RoleType'] = self.role_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemberId') is not None:
            self.member_id = m.get('MemberId')
        if m.get('MemberType') is not None:
            self.member_type = m.get('MemberType')
        if m.get('RoleType') is not None:
            self.role_type = m.get('RoleType')
        return self


class UpdateWorkspaceDocMembersRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class UpdateWorkspaceDocMembersRequest(TeaModel):
    def __init__(
        self,
        members: List[UpdateWorkspaceDocMembersRequestMembers] = None,
        node_id: str = None,
        tenant_context: UpdateWorkspaceDocMembersRequestTenantContext = None,
        workspace_id: str = None,
    ):
        self.members = members
        # This parameter is required.
        self.node_id = node_id
        self.tenant_context = tenant_context
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.members:
            for k in self.members:
                if k:
                    k.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Members'] = []
        if self.members is not None:
            for k in self.members:
                result['Members'].append(k.to_map() if k else None)
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.members = []
        if m.get('Members') is not None:
            for k in m.get('Members'):
                temp_model = UpdateWorkspaceDocMembersRequestMembers()
                self.members.append(temp_model.from_map(k))
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('TenantContext') is not None:
            temp_model = UpdateWorkspaceDocMembersRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UpdateWorkspaceDocMembersShrinkRequest(TeaModel):
    def __init__(
        self,
        members_shrink: str = None,
        node_id: str = None,
        tenant_context_shrink: str = None,
        workspace_id: str = None,
    ):
        self.members_shrink = members_shrink
        # This parameter is required.
        self.node_id = node_id
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.members_shrink is not None:
            result['Members'] = self.members_shrink
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Members') is not None:
            self.members_shrink = m.get('Members')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UpdateWorkspaceDocMembersResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateWorkspaceDocMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateWorkspaceDocMembersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateWorkspaceDocMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateWorkspaceMembersHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UpdateWorkspaceMembersHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UpdateWorkspaceMembersHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UpdateWorkspaceMembersHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UpdateWorkspaceMembersShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UpdateWorkspaceMembersRequestMembers(TeaModel):
    def __init__(
        self,
        member_id: str = None,
        member_type: str = None,
        role_type: str = None,
    ):
        # This parameter is required.
        self.member_id = member_id
        # This parameter is required.
        self.member_type = member_type
        # This parameter is required.
        self.role_type = role_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.member_id is not None:
            result['MemberId'] = self.member_id
        if self.member_type is not None:
            result['MemberType'] = self.member_type
        if self.role_type is not None:
            result['RoleType'] = self.role_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemberId') is not None:
            self.member_id = m.get('MemberId')
        if m.get('MemberType') is not None:
            self.member_type = m.get('MemberType')
        if m.get('RoleType') is not None:
            self.role_type = m.get('RoleType')
        return self


class UpdateWorkspaceMembersRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class UpdateWorkspaceMembersRequest(TeaModel):
    def __init__(
        self,
        members: List[UpdateWorkspaceMembersRequestMembers] = None,
        tenant_context: UpdateWorkspaceMembersRequestTenantContext = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.members = members
        self.tenant_context = tenant_context
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.members:
            for k in self.members:
                if k:
                    k.validate()
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Members'] = []
        if self.members is not None:
            for k in self.members:
                result['Members'].append(k.to_map() if k else None)
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.members = []
        if m.get('Members') is not None:
            for k in m.get('Members'):
                temp_model = UpdateWorkspaceMembersRequestMembers()
                self.members.append(temp_model.from_map(k))
        if m.get('TenantContext') is not None:
            temp_model = UpdateWorkspaceMembersRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UpdateWorkspaceMembersShrinkRequest(TeaModel):
    def __init__(
        self,
        members_shrink: str = None,
        tenant_context_shrink: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.members_shrink = members_shrink
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.members_shrink is not None:
            result['Members'] = self.members_shrink
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Members') is not None:
            self.members_shrink = m.get('Members')
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UpdateWorkspaceMembersResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateWorkspaceMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateWorkspaceMembersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateWorkspaceMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UploadMediaHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class UploadMediaHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: UploadMediaHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = UploadMediaHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class UploadMediaShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class UploadMediaRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class UploadMediaRequest(TeaModel):
    def __init__(
        self,
        tenant_context: UploadMediaRequestTenantContext = None,
        media_name: str = None,
        media_type: str = None,
        org_id: int = None,
        url: str = None,
    ):
        self.tenant_context = tenant_context
        self.media_name = media_name
        # This parameter is required.
        self.media_type = media_type
        # This parameter is required.
        self.org_id = org_id
        # This parameter is required.
        self.url = url

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.media_name is not None:
            result['mediaName'] = self.media_name
        if self.media_type is not None:
            result['mediaType'] = self.media_type
        if self.org_id is not None:
            result['orgId'] = self.org_id
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = UploadMediaRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('mediaName') is not None:
            self.media_name = m.get('mediaName')
        if m.get('mediaType') is not None:
            self.media_type = m.get('mediaType')
        if m.get('orgId') is not None:
            self.org_id = m.get('orgId')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class UploadMediaShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        media_name: str = None,
        media_type: str = None,
        org_id: int = None,
        url: str = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        self.media_name = media_name
        # This parameter is required.
        self.media_type = media_type
        # This parameter is required.
        self.org_id = org_id
        # This parameter is required.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.media_name is not None:
            result['mediaName'] = self.media_name
        if self.media_type is not None:
            result['mediaType'] = self.media_type
        if self.org_id is not None:
            result['orgId'] = self.org_id
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('mediaName') is not None:
            self.media_name = m.get('mediaName')
        if m.get('mediaType') is not None:
            self.media_type = m.get('mediaType')
        if m.get('orgId') is not None:
            self.org_id = m.get('orgId')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class UploadMediaResponseBody(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        request_id: str = None,
    ):
        self.media_id = media_id
        # requestId
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['mediaId'] = self.media_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('mediaId') is not None:
            self.media_id = m.get('mediaId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UploadMediaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UploadMediaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UploadMediaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class WearOrgHonorHeadersAccountContext(TeaModel):
    def __init__(
        self,
        account_id: str = None,
    ):
        self.account_id = account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class WearOrgHonorHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context: WearOrgHonorHeadersAccountContext = None,
    ):
        self.common_headers = common_headers
        self.account_context = account_context

    def validate(self):
        if self.account_context:
            self.account_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context is not None:
            result['AccountContext'] = self.account_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            temp_model = WearOrgHonorHeadersAccountContext()
            self.account_context = temp_model.from_map(m['AccountContext'])
        return self


class WearOrgHonorShrinkHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        account_context_shrink: str = None,
    ):
        self.common_headers = common_headers
        self.account_context_shrink = account_context_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.account_context_shrink is not None:
            result['AccountContext'] = self.account_context_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('AccountContext') is not None:
            self.account_context_shrink = m.get('AccountContext')
        return self


class WearOrgHonorRequestTenantContext(TeaModel):
    def __init__(
        self,
        tenant_id: str = None,
    ):
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['tenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenantId') is not None:
            self.tenant_id = m.get('tenantId')
        return self


class WearOrgHonorRequest(TeaModel):
    def __init__(
        self,
        tenant_context: WearOrgHonorRequestTenantContext = None,
        honor_id: str = None,
        org_id: int = None,
        user_id: str = None,
        wear: bool = None,
    ):
        self.tenant_context = tenant_context
        # This parameter is required.
        self.honor_id = honor_id
        # This parameter is required.
        self.org_id = org_id
        # This parameter is required.
        self.user_id = user_id
        # This parameter is required.
        self.wear = wear

    def validate(self):
        if self.tenant_context:
            self.tenant_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context is not None:
            result['TenantContext'] = self.tenant_context.to_map()
        if self.honor_id is not None:
            result['honorId'] = self.honor_id
        if self.org_id is not None:
            result['orgId'] = self.org_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.wear is not None:
            result['wear'] = self.wear
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            temp_model = WearOrgHonorRequestTenantContext()
            self.tenant_context = temp_model.from_map(m['TenantContext'])
        if m.get('honorId') is not None:
            self.honor_id = m.get('honorId')
        if m.get('orgId') is not None:
            self.org_id = m.get('orgId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('wear') is not None:
            self.wear = m.get('wear')
        return self


class WearOrgHonorShrinkRequest(TeaModel):
    def __init__(
        self,
        tenant_context_shrink: str = None,
        honor_id: str = None,
        org_id: int = None,
        user_id: str = None,
        wear: bool = None,
    ):
        self.tenant_context_shrink = tenant_context_shrink
        # This parameter is required.
        self.honor_id = honor_id
        # This parameter is required.
        self.org_id = org_id
        # This parameter is required.
        self.user_id = user_id
        # This parameter is required.
        self.wear = wear

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_context_shrink is not None:
            result['TenantContext'] = self.tenant_context_shrink
        if self.honor_id is not None:
            result['honorId'] = self.honor_id
        if self.org_id is not None:
            result['orgId'] = self.org_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.wear is not None:
            result['wear'] = self.wear
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TenantContext') is not None:
            self.tenant_context_shrink = m.get('TenantContext')
        if m.get('honorId') is not None:
            self.honor_id = m.get('honorId')
        if m.get('orgId') is not None:
            self.org_id = m.get('orgId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('wear') is not None:
            self.wear = m.get('wear')
        return self


class WearOrgHonorResponseBodyContent(TeaModel):
    def __init__(
        self,
        data: Any = None,
    ):
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class WearOrgHonorResponseBody(TeaModel):
    def __init__(
        self,
        content: WearOrgHonorResponseBodyContent = None,
        error_code: str = None,
        error_ctx: Dict[str, Any] = None,
        error_msg: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.content = content
        self.error_code = error_code
        self.error_ctx = error_ctx
        self.error_msg = error_msg
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content.to_map()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_ctx is not None:
            result['errorCtx'] = self.error_ctx
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            temp_model = WearOrgHonorResponseBodyContent()
            self.content = temp_model.from_map(m['content'])
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorCtx') is not None:
            self.error_ctx = m.get('errorCtx')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class WearOrgHonorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WearOrgHonorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WearOrgHonorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


