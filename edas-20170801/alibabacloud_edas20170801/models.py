# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import List, Dict, Any


class AppConfigConfigMountDescsMountItems(TeaModel):
    def __init__(
        self,
        key: str = None,
        path: str = None,
    ):
        self.key = key
        self.path = path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.path is not None:
            result['Path'] = self.path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        return self


class AppConfigConfigMountDescs(TeaModel):
    def __init__(
        self,
        mount_items: List[AppConfigConfigMountDescsMountItems] = None,
        mount_path: str = None,
        name: str = None,
        type: str = None,
    ):
        self.mount_items = mount_items
        self.mount_path = mount_path
        self.name = name
        self.type = type

    def validate(self):
        if self.mount_items:
            for k in self.mount_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MountItems'] = []
        if self.mount_items is not None:
            for k in self.mount_items:
                result['MountItems'].append(k.to_map() if k else None)
        if self.mount_path is not None:
            result['MountPath'] = self.mount_path
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.mount_items = []
        if m.get('MountItems') is not None:
            for k in m.get('MountItems'):
                temp_model = AppConfigConfigMountDescsMountItems()
                self.mount_items.append(temp_model.from_map(k))
        if m.get('MountPath') is not None:
            self.mount_path = m.get('MountPath')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AppConfigEmptyDirs(TeaModel):
    def __init__(
        self,
        mount_path: str = None,
        name: str = None,
        read_only: bool = None,
        sub_path_expr: str = None,
    ):
        self.mount_path = mount_path
        self.name = name
        self.read_only = read_only
        self.sub_path_expr = sub_path_expr

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mount_path is not None:
            result['MountPath'] = self.mount_path
        if self.name is not None:
            result['Name'] = self.name
        if self.read_only is not None:
            result['ReadOnly'] = self.read_only
        if self.sub_path_expr is not None:
            result['SubPathExpr'] = self.sub_path_expr
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MountPath') is not None:
            self.mount_path = m.get('MountPath')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ReadOnly') is not None:
            self.read_only = m.get('ReadOnly')
        if m.get('SubPathExpr') is not None:
            self.sub_path_expr = m.get('SubPathExpr')
        return self


class AppConfigEnvFroms(TeaModel):
    def __init__(
        self,
        config_map_ref: str = None,
        secret_ref: str = None,
    ):
        self.config_map_ref = config_map_ref
        self.secret_ref = secret_ref

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_ref is not None:
            result['ConfigMapRef'] = self.config_map_ref
        if self.secret_ref is not None:
            result['SecretRef'] = self.secret_ref
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapRef') is not None:
            self.config_map_ref = m.get('ConfigMapRef')
        if m.get('SecretRef') is not None:
            self.secret_ref = m.get('SecretRef')
        return self


class AppConfigEnvs(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
        value_from: str = None,
    ):
        self.name = name
        self.value = value
        self.value_from = value_from

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        if self.value_from is not None:
            result['ValueFrom'] = self.value_from
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('ValueFrom') is not None:
            self.value_from = m.get('ValueFrom')
        return self


class AppConfigImageConfig(TeaModel):
    def __init__(
        self,
        container_registry_id: str = None,
        cr_instance_id: str = None,
        cr_region_id: str = None,
        image_url: str = None,
    ):
        self.container_registry_id = container_registry_id
        self.cr_instance_id = cr_instance_id
        self.cr_region_id = cr_region_id
        self.image_url = image_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_registry_id is not None:
            result['ContainerRegistryId'] = self.container_registry_id
        if self.cr_instance_id is not None:
            result['CrInstanceId'] = self.cr_instance_id
        if self.cr_region_id is not None:
            result['CrRegionId'] = self.cr_region_id
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContainerRegistryId') is not None:
            self.container_registry_id = m.get('ContainerRegistryId')
        if m.get('CrInstanceId') is not None:
            self.cr_instance_id = m.get('CrInstanceId')
        if m.get('CrRegionId') is not None:
            self.cr_region_id = m.get('CrRegionId')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        return self


class AppConfigLocalVolumes(TeaModel):
    def __init__(
        self,
        mount_path: str = None,
        name: str = None,
        node_path: str = None,
        ops_auth: int = None,
        type: str = None,
    ):
        self.mount_path = mount_path
        self.name = name
        self.node_path = node_path
        self.ops_auth = ops_auth
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mount_path is not None:
            result['MountPath'] = self.mount_path
        if self.name is not None:
            result['Name'] = self.name
        if self.node_path is not None:
            result['NodePath'] = self.node_path
        if self.ops_auth is not None:
            result['OpsAuth'] = self.ops_auth
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MountPath') is not None:
            self.mount_path = m.get('MountPath')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NodePath') is not None:
            self.node_path = m.get('NodePath')
        if m.get('OpsAuth') is not None:
            self.ops_auth = m.get('OpsAuth')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AppConfigNasMountDescs(TeaModel):
    def __init__(
        self,
        mount_path: str = None,
        nas_path: str = None,
    ):
        self.mount_path = mount_path
        self.nas_path = nas_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mount_path is not None:
            result['MountPath'] = self.mount_path
        if self.nas_path is not None:
            result['NasPath'] = self.nas_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MountPath') is not None:
            self.mount_path = m.get('MountPath')
        if m.get('NasPath') is not None:
            self.nas_path = m.get('NasPath')
        return self


class AppConfigPackageConfig(TeaModel):
    def __init__(
        self,
        edas_container_version: str = None,
        jdk: str = None,
        package_type: str = None,
        package_url: str = None,
        package_version: str = None,
        timezone: str = None,
        uri_encoding: str = None,
        use_body_encoding: bool = None,
        web_container: str = None,
    ):
        self.edas_container_version = edas_container_version
        self.jdk = jdk
        self.package_type = package_type
        self.package_url = package_url
        self.package_version = package_version
        self.timezone = timezone
        self.uri_encoding = uri_encoding
        self.use_body_encoding = use_body_encoding
        self.web_container = web_container

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.jdk is not None:
            result['Jdk'] = self.jdk
        if self.package_type is not None:
            result['PackageType'] = self.package_type
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.uri_encoding is not None:
            result['UriEncoding'] = self.uri_encoding
        if self.use_body_encoding is not None:
            result['UseBodyEncoding'] = self.use_body_encoding
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('Jdk') is not None:
            self.jdk = m.get('Jdk')
        if m.get('PackageType') is not None:
            self.package_type = m.get('PackageType')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('UriEncoding') is not None:
            self.uri_encoding = m.get('UriEncoding')
        if m.get('UseBodyEncoding') is not None:
            self.use_body_encoding = m.get('UseBodyEncoding')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        return self


class AppConfigPvcMountDescsMountPaths(TeaModel):
    def __init__(
        self,
        mount_path: str = None,
        read_only: bool = None,
        sub_path_expr: str = None,
    ):
        self.mount_path = mount_path
        self.read_only = read_only
        self.sub_path_expr = sub_path_expr

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mount_path is not None:
            result['MountPath'] = self.mount_path
        if self.read_only is not None:
            result['ReadOnly'] = self.read_only
        if self.sub_path_expr is not None:
            result['SubPathExpr'] = self.sub_path_expr
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MountPath') is not None:
            self.mount_path = m.get('MountPath')
        if m.get('ReadOnly') is not None:
            self.read_only = m.get('ReadOnly')
        if m.get('SubPathExpr') is not None:
            self.sub_path_expr = m.get('SubPathExpr')
        return self


class AppConfigPvcMountDescs(TeaModel):
    def __init__(
        self,
        mount_paths: List[AppConfigPvcMountDescsMountPaths] = None,
        pvc_name: str = None,
    ):
        self.mount_paths = mount_paths
        self.pvc_name = pvc_name

    def validate(self):
        if self.mount_paths:
            for k in self.mount_paths:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MountPaths'] = []
        if self.mount_paths is not None:
            for k in self.mount_paths:
                result['MountPaths'].append(k.to_map() if k else None)
        if self.pvc_name is not None:
            result['PvcName'] = self.pvc_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.mount_paths = []
        if m.get('MountPaths') is not None:
            for k in m.get('MountPaths'):
                temp_model = AppConfigPvcMountDescsMountPaths()
                self.mount_paths.append(temp_model.from_map(k))
        if m.get('PvcName') is not None:
            self.pvc_name = m.get('PvcName')
        return self


class AppConfigSlsConfigs(TeaModel):
    def __init__(
        self,
        log_dir: str = None,
        logstore: str = None,
        project: str = None,
        type: str = None,
    ):
        self.log_dir = log_dir
        self.logstore = logstore
        self.project = project
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.log_dir is not None:
            result['LogDir'] = self.log_dir
        if self.logstore is not None:
            result['Logstore'] = self.logstore
        if self.project is not None:
            result['Project'] = self.project
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LogDir') is not None:
            self.log_dir = m.get('LogDir')
        if m.get('Logstore') is not None:
            self.logstore = m.get('Logstore')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AppConfigWebContainerConfig(TeaModel):
    def __init__(
        self,
        connector_type: str = None,
        context_input_type: str = None,
        context_path: str = None,
        http_port: int = None,
        max_threads: int = None,
        server_xml: str = None,
        uri_encoding: str = None,
        use_advanced_server_xml: bool = None,
        use_body_encoding: bool = None,
        use_default_config: bool = None,
    ):
        self.connector_type = connector_type
        self.context_input_type = context_input_type
        self.context_path = context_path
        self.http_port = http_port
        self.max_threads = max_threads
        self.server_xml = server_xml
        self.uri_encoding = uri_encoding
        self.use_advanced_server_xml = use_advanced_server_xml
        self.use_body_encoding = use_body_encoding
        self.use_default_config = use_default_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connector_type is not None:
            result['ConnectorType'] = self.connector_type
        if self.context_input_type is not None:
            result['ContextInputType'] = self.context_input_type
        if self.context_path is not None:
            result['ContextPath'] = self.context_path
        if self.http_port is not None:
            result['HttpPort'] = self.http_port
        if self.max_threads is not None:
            result['MaxThreads'] = self.max_threads
        if self.server_xml is not None:
            result['ServerXml'] = self.server_xml
        if self.uri_encoding is not None:
            result['UriEncoding'] = self.uri_encoding
        if self.use_advanced_server_xml is not None:
            result['UseAdvancedServerXml'] = self.use_advanced_server_xml
        if self.use_body_encoding is not None:
            result['UseBodyEncoding'] = self.use_body_encoding
        if self.use_default_config is not None:
            result['UseDefaultConfig'] = self.use_default_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnectorType') is not None:
            self.connector_type = m.get('ConnectorType')
        if m.get('ContextInputType') is not None:
            self.context_input_type = m.get('ContextInputType')
        if m.get('ContextPath') is not None:
            self.context_path = m.get('ContextPath')
        if m.get('HttpPort') is not None:
            self.http_port = m.get('HttpPort')
        if m.get('MaxThreads') is not None:
            self.max_threads = m.get('MaxThreads')
        if m.get('ServerXml') is not None:
            self.server_xml = m.get('ServerXml')
        if m.get('UriEncoding') is not None:
            self.uri_encoding = m.get('UriEncoding')
        if m.get('UseAdvancedServerXml') is not None:
            self.use_advanced_server_xml = m.get('UseAdvancedServerXml')
        if m.get('UseBodyEncoding') is not None:
            self.use_body_encoding = m.get('UseBodyEncoding')
        if m.get('UseDefaultConfig') is not None:
            self.use_default_config = m.get('UseDefaultConfig')
        return self


class AppConfig(TeaModel):
    def __init__(
        self,
        command: str = None,
        command_args: List[str] = None,
        config_mount_descs: List[AppConfigConfigMountDescs] = None,
        deploy_across_nodes: bool = None,
        deploy_across_zones: bool = None,
        empty_dirs: List[AppConfigEmptyDirs] = None,
        enable_ahas: bool = None,
        env_froms: List[AppConfigEnvFroms] = None,
        envs: List[AppConfigEnvs] = None,
        image_config: AppConfigImageConfig = None,
        is_multilingual_app: bool = None,
        java_start_up_config: str = None,
        limit_cpu: str = None,
        limit_mem: str = None,
        liveness: str = None,
        local_volumes: List[AppConfigLocalVolumes] = None,
        nas_id: str = None,
        nas_mount_descs: List[AppConfigNasMountDescs] = None,
        nas_storage_type: str = None,
        package_config: AppConfigPackageConfig = None,
        post_start: str = None,
        pre_stop: str = None,
        pvc_mount_descs: List[AppConfigPvcMountDescs] = None,
        readiness: str = None,
        replicas: int = None,
        request_cpu: str = None,
        request_mem: str = None,
        runtime_class_name: str = None,
        sls_configs: List[AppConfigSlsConfigs] = None,
        web_container_config: AppConfigWebContainerConfig = None,
    ):
        self.command = command
        self.command_args = command_args
        self.config_mount_descs = config_mount_descs
        self.deploy_across_nodes = deploy_across_nodes
        self.deploy_across_zones = deploy_across_zones
        self.empty_dirs = empty_dirs
        self.enable_ahas = enable_ahas
        self.env_froms = env_froms
        self.envs = envs
        self.image_config = image_config
        self.is_multilingual_app = is_multilingual_app
        self.java_start_up_config = java_start_up_config
        self.limit_cpu = limit_cpu
        self.limit_mem = limit_mem
        self.liveness = liveness
        self.local_volumes = local_volumes
        self.nas_id = nas_id
        self.nas_mount_descs = nas_mount_descs
        self.nas_storage_type = nas_storage_type
        self.package_config = package_config
        self.post_start = post_start
        self.pre_stop = pre_stop
        self.pvc_mount_descs = pvc_mount_descs
        self.readiness = readiness
        self.replicas = replicas
        self.request_cpu = request_cpu
        self.request_mem = request_mem
        self.runtime_class_name = runtime_class_name
        self.sls_configs = sls_configs
        self.web_container_config = web_container_config

    def validate(self):
        if self.config_mount_descs:
            for k in self.config_mount_descs:
                if k:
                    k.validate()
        if self.empty_dirs:
            for k in self.empty_dirs:
                if k:
                    k.validate()
        if self.env_froms:
            for k in self.env_froms:
                if k:
                    k.validate()
        if self.envs:
            for k in self.envs:
                if k:
                    k.validate()
        if self.image_config:
            self.image_config.validate()
        if self.local_volumes:
            for k in self.local_volumes:
                if k:
                    k.validate()
        if self.nas_mount_descs:
            for k in self.nas_mount_descs:
                if k:
                    k.validate()
        if self.package_config:
            self.package_config.validate()
        if self.pvc_mount_descs:
            for k in self.pvc_mount_descs:
                if k:
                    k.validate()
        if self.sls_configs:
            for k in self.sls_configs:
                if k:
                    k.validate()
        if self.web_container_config:
            self.web_container_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        result['ConfigMountDescs'] = []
        if self.config_mount_descs is not None:
            for k in self.config_mount_descs:
                result['ConfigMountDescs'].append(k.to_map() if k else None)
        if self.deploy_across_nodes is not None:
            result['DeployAcrossNodes'] = self.deploy_across_nodes
        if self.deploy_across_zones is not None:
            result['DeployAcrossZones'] = self.deploy_across_zones
        result['EmptyDirs'] = []
        if self.empty_dirs is not None:
            for k in self.empty_dirs:
                result['EmptyDirs'].append(k.to_map() if k else None)
        if self.enable_ahas is not None:
            result['EnableAhas'] = self.enable_ahas
        result['EnvFroms'] = []
        if self.env_froms is not None:
            for k in self.env_froms:
                result['EnvFroms'].append(k.to_map() if k else None)
        result['Envs'] = []
        if self.envs is not None:
            for k in self.envs:
                result['Envs'].append(k.to_map() if k else None)
        if self.image_config is not None:
            result['ImageConfig'] = self.image_config.to_map()
        if self.is_multilingual_app is not None:
            result['IsMultilingualApp'] = self.is_multilingual_app
        if self.java_start_up_config is not None:
            result['JavaStartUpConfig'] = self.java_start_up_config
        if self.limit_cpu is not None:
            result['LimitCpu'] = self.limit_cpu
        if self.limit_mem is not None:
            result['LimitMem'] = self.limit_mem
        if self.liveness is not None:
            result['Liveness'] = self.liveness
        result['LocalVolumes'] = []
        if self.local_volumes is not None:
            for k in self.local_volumes:
                result['LocalVolumes'].append(k.to_map() if k else None)
        if self.nas_id is not None:
            result['NasId'] = self.nas_id
        result['NasMountDescs'] = []
        if self.nas_mount_descs is not None:
            for k in self.nas_mount_descs:
                result['NasMountDescs'].append(k.to_map() if k else None)
        if self.nas_storage_type is not None:
            result['NasStorageType'] = self.nas_storage_type
        if self.package_config is not None:
            result['PackageConfig'] = self.package_config.to_map()
        if self.post_start is not None:
            result['PostStart'] = self.post_start
        if self.pre_stop is not None:
            result['PreStop'] = self.pre_stop
        result['PvcMountDescs'] = []
        if self.pvc_mount_descs is not None:
            for k in self.pvc_mount_descs:
                result['PvcMountDescs'].append(k.to_map() if k else None)
        if self.readiness is not None:
            result['Readiness'] = self.readiness
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.request_cpu is not None:
            result['RequestCpu'] = self.request_cpu
        if self.request_mem is not None:
            result['RequestMem'] = self.request_mem
        if self.runtime_class_name is not None:
            result['RuntimeClassName'] = self.runtime_class_name
        result['SlsConfigs'] = []
        if self.sls_configs is not None:
            for k in self.sls_configs:
                result['SlsConfigs'].append(k.to_map() if k else None)
        if self.web_container_config is not None:
            result['WebContainerConfig'] = self.web_container_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        self.config_mount_descs = []
        if m.get('ConfigMountDescs') is not None:
            for k in m.get('ConfigMountDescs'):
                temp_model = AppConfigConfigMountDescs()
                self.config_mount_descs.append(temp_model.from_map(k))
        if m.get('DeployAcrossNodes') is not None:
            self.deploy_across_nodes = m.get('DeployAcrossNodes')
        if m.get('DeployAcrossZones') is not None:
            self.deploy_across_zones = m.get('DeployAcrossZones')
        self.empty_dirs = []
        if m.get('EmptyDirs') is not None:
            for k in m.get('EmptyDirs'):
                temp_model = AppConfigEmptyDirs()
                self.empty_dirs.append(temp_model.from_map(k))
        if m.get('EnableAhas') is not None:
            self.enable_ahas = m.get('EnableAhas')
        self.env_froms = []
        if m.get('EnvFroms') is not None:
            for k in m.get('EnvFroms'):
                temp_model = AppConfigEnvFroms()
                self.env_froms.append(temp_model.from_map(k))
        self.envs = []
        if m.get('Envs') is not None:
            for k in m.get('Envs'):
                temp_model = AppConfigEnvs()
                self.envs.append(temp_model.from_map(k))
        if m.get('ImageConfig') is not None:
            temp_model = AppConfigImageConfig()
            self.image_config = temp_model.from_map(m['ImageConfig'])
        if m.get('IsMultilingualApp') is not None:
            self.is_multilingual_app = m.get('IsMultilingualApp')
        if m.get('JavaStartUpConfig') is not None:
            self.java_start_up_config = m.get('JavaStartUpConfig')
        if m.get('LimitCpu') is not None:
            self.limit_cpu = m.get('LimitCpu')
        if m.get('LimitMem') is not None:
            self.limit_mem = m.get('LimitMem')
        if m.get('Liveness') is not None:
            self.liveness = m.get('Liveness')
        self.local_volumes = []
        if m.get('LocalVolumes') is not None:
            for k in m.get('LocalVolumes'):
                temp_model = AppConfigLocalVolumes()
                self.local_volumes.append(temp_model.from_map(k))
        if m.get('NasId') is not None:
            self.nas_id = m.get('NasId')
        self.nas_mount_descs = []
        if m.get('NasMountDescs') is not None:
            for k in m.get('NasMountDescs'):
                temp_model = AppConfigNasMountDescs()
                self.nas_mount_descs.append(temp_model.from_map(k))
        if m.get('NasStorageType') is not None:
            self.nas_storage_type = m.get('NasStorageType')
        if m.get('PackageConfig') is not None:
            temp_model = AppConfigPackageConfig()
            self.package_config = temp_model.from_map(m['PackageConfig'])
        if m.get('PostStart') is not None:
            self.post_start = m.get('PostStart')
        if m.get('PreStop') is not None:
            self.pre_stop = m.get('PreStop')
        self.pvc_mount_descs = []
        if m.get('PvcMountDescs') is not None:
            for k in m.get('PvcMountDescs'):
                temp_model = AppConfigPvcMountDescs()
                self.pvc_mount_descs.append(temp_model.from_map(k))
        if m.get('Readiness') is not None:
            self.readiness = m.get('Readiness')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('RequestCpu') is not None:
            self.request_cpu = m.get('RequestCpu')
        if m.get('RequestMem') is not None:
            self.request_mem = m.get('RequestMem')
        if m.get('RuntimeClassName') is not None:
            self.runtime_class_name = m.get('RuntimeClassName')
        self.sls_configs = []
        if m.get('SlsConfigs') is not None:
            for k in m.get('SlsConfigs'):
                temp_model = AppConfigSlsConfigs()
                self.sls_configs.append(temp_model.from_map(k))
        if m.get('WebContainerConfig') is not None:
            temp_model = AppConfigWebContainerConfig()
            self.web_container_config = temp_model.from_map(m['WebContainerConfig'])
        return self


class AbortAndRollbackChangeOrderRequest(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change process.
        # 
        # This parameter is required.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class AbortAndRollbackChangeOrderResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change process.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class AbortAndRollbackChangeOrderResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: AbortAndRollbackChangeOrderResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        trace_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The information about the change process.
        self.data = data
        # The error code that is returned.
        self.error_code = error_code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The ID of the trace.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = AbortAndRollbackChangeOrderResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class AbortAndRollbackChangeOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AbortAndRollbackChangeOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AbortAndRollbackChangeOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AbortChangeOrderRequest(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change process. You can call the [GetChangeOrderInfo](https://help.aliyun.com/document_detail/62072.html) operation to query the change process ID.
        # 
        # This parameter is required.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class AbortChangeOrderResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change process.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class AbortChangeOrderResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: AbortChangeOrderResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        trace_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The change process.
        self.data = data
        # The error code that is returned.
        self.error_code = error_code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The ID of the trace.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = AbortChangeOrderResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class AbortChangeOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AbortChangeOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AbortChangeOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLogPathRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        path: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The absolute path of the log directory that you want to add. The value must start and end with a forward slash (`/`) and must contain `/log` or `/logs`. The following directories are the default log directories in Enterprise Distributed Application Service (EDAS):
        # 
        # *   /home/admin/edas-container/logs/\
        # *   /home/admin/taobao-tomcat-7.0.59/logs/\
        # *   /home/admin/taobao-tomcat-production-7.0.59.3/logs/\
        # *   /home/admin/taobao-tomcat-production-7.0.70/logs/\
        # *   /home/admin/edas-agent/logs/\
        # 
        # This parameter is required.
        self.path = path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.path is not None:
            result['Path'] = self.path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        return self


class AddLogPathResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddLogPathResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLogPathResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLogPathResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AuthorizeApplicationRequest(TeaModel):
    def __init__(
        self,
        app_ids: str = None,
        target_user_id: str = None,
    ):
        # The ID of the application. You can specify multiple IDs. Separate multiple IDs with semicolons (;). If you leave this parameter empty, the permissions on the application are revoked.
        # 
        # This parameter is required.
        self.app_ids = app_ids
        # The ID of the RAM user to be authorized. The value of the parameter is in the `sub-account name@primary account UID` format.
        # 
        # This parameter is required.
        self.target_user_id = target_user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_ids is not None:
            result['AppIds'] = self.app_ids
        if self.target_user_id is not None:
            result['TargetUserId'] = self.target_user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppIds') is not None:
            self.app_ids = m.get('AppIds')
        if m.get('TargetUserId') is not None:
            self.target_user_id = m.get('TargetUserId')
        return self


class AuthorizeApplicationResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AuthorizeApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AuthorizeApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AuthorizeApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AuthorizeResourceGroupRequest(TeaModel):
    def __init__(
        self,
        resource_group_ids: str = None,
        target_user_id: str = None,
    ):
        # The ID of the resource group. You can call the ListResourceGroup operation to query the resource group ID. For more information, see [ListResourceGroup](https://help.aliyun.com/document_detail/62055.html).
        # 
        # You can specify multiple resource group IDs. Separate multiple resource group IDs with semicolons (;).
        # 
        # This parameter is required.
        self.resource_group_ids = resource_group_ids
        # The ID of the RAM user to be authorized.
        # 
        # This parameter is required.
        self.target_user_id = target_user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_group_ids is not None:
            result['ResourceGroupIds'] = self.resource_group_ids
        if self.target_user_id is not None:
            result['TargetUserId'] = self.target_user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceGroupIds') is not None:
            self.resource_group_ids = m.get('ResourceGroupIds')
        if m.get('TargetUserId') is not None:
            self.target_user_id = m.get('TargetUserId')
        return self


class AuthorizeResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AuthorizeResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AuthorizeResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AuthorizeResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AuthorizeRoleRequest(TeaModel):
    def __init__(
        self,
        role_ids: str = None,
        target_user_id: str = None,
    ):
        # The ID of the role to be assigned. If you want to assign multiple roles to the specified RAM user, separate the IDs of the roles with semicolons (;). If you leave this parameter empty, the roles assigned to the specified RAM user are revoked.
        # 
        # This parameter is required.
        self.role_ids = role_ids
        # The ID of the RAM user to which you want to assign the roles.
        # 
        # This parameter is required.
        self.target_user_id = target_user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.role_ids is not None:
            result['RoleIds'] = self.role_ids
        if self.target_user_id is not None:
            result['TargetUserId'] = self.target_user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RoleIds') is not None:
            self.role_ids = m.get('RoleIds')
        if m.get('TargetUserId') is not None:
            self.target_user_id = m.get('TargetUserId')
        return self


class AuthorizeRoleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AuthorizeRoleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AuthorizeRoleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AuthorizeRoleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindEcsSlbRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        deploy_group_id: str = None,
        listener_health_check_url: str = None,
        listener_port: int = None,
        listener_protocol: str = None,
        slb_id: str = None,
        vforwarding_url_rule: str = None,
        vserver_group_id: str = None,
        vserver_group_name: str = None,
    ):
        # The ID of the application. You can query the application ID by calling the ListApplication operation. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the instance group whose application you want to bind. You can call the ListDeployGroup operation to query the group ID. For more information, see [ListDeployGroup](https://help.aliyun.com/document_detail/62077.html).
        self.deploy_group_id = deploy_group_id
        # The health check URL.
        self.listener_health_check_url = listener_health_check_url
        # The listener port for the SLB instance.
        # 
        # This parameter is required.
        self.listener_port = listener_port
        # The listener protocol for the SLB instance.
        # 
        # This parameter is required.
        self.listener_protocol = listener_protocol
        # The ID of the SLB instance.
        # 
        # This parameter is required.
        self.slb_id = slb_id
        # The forwarding rule of the SLB listener.
        self.vforwarding_url_rule = vforwarding_url_rule
        # The ID of the vServer group for the SLB instance.
        self.vserver_group_id = vserver_group_id
        # The name of the vServer group.
        self.vserver_group_name = vserver_group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.deploy_group_id is not None:
            result['DeployGroupId'] = self.deploy_group_id
        if self.listener_health_check_url is not None:
            result['ListenerHealthCheckUrl'] = self.listener_health_check_url
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.listener_protocol is not None:
            result['ListenerProtocol'] = self.listener_protocol
        if self.slb_id is not None:
            result['SlbId'] = self.slb_id
        if self.vforwarding_url_rule is not None:
            result['VForwardingUrlRule'] = self.vforwarding_url_rule
        if self.vserver_group_id is not None:
            result['VServerGroupId'] = self.vserver_group_id
        if self.vserver_group_name is not None:
            result['VServerGroupName'] = self.vserver_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DeployGroupId') is not None:
            self.deploy_group_id = m.get('DeployGroupId')
        if m.get('ListenerHealthCheckUrl') is not None:
            self.listener_health_check_url = m.get('ListenerHealthCheckUrl')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('ListenerProtocol') is not None:
            self.listener_protocol = m.get('ListenerProtocol')
        if m.get('SlbId') is not None:
            self.slb_id = m.get('SlbId')
        if m.get('VForwardingUrlRule') is not None:
            self.vforwarding_url_rule = m.get('VForwardingUrlRule')
        if m.get('VServerGroupId') is not None:
            self.vserver_group_id = m.get('VServerGroupId')
        if m.get('VServerGroupName') is not None:
            self.vserver_group_name = m.get('VServerGroupName')
        return self


class BindEcsSlbResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The change process ID for this operation.
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class BindEcsSlbResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindEcsSlbResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindEcsSlbResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindK8sSlbRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        cluster_id: str = None,
        port: str = None,
        scheduler: str = None,
        service_port_infos: str = None,
        slb_id: str = None,
        slb_protocol: str = None,
        specification: str = None,
        target_port: str = None,
        type: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The frontend port. Valid values: 1 to 65535.
        self.port = port
        # The scheduling algorithm for the SLB instance. If you do not specify this parameter, the default value rr is used. Valid values:
        # 
        # *   wrr: weighted round-robin scheduling. Backend servers that have higher weights receive more requests than those that have lower weights.
        # *   rr: round-robin scheduling. Requests are sequentially distributed to backend servers.
        self.scheduler = scheduler
        # The information about the ports. This parameter is required if you want to configure multi-port mappings or use a protocol other than TCP. You must set this parameter to a JSON array. Example: [{"targetPort":8080,"port":82,"loadBalancerProtocol":"TCP"},{"port":81,"certId":"1362469756373809_16c185d6fa2_1914500329_-xxxxxxx","targetPort":8181,"lo adBalancerProtocol":"HTTPS"}]
        # 
        # *   port: The frontend port. Valid values: 1 to 65535. This parameter is required. Each port must be unique.
        # *   targetPort: The backend port. Valid values: 1 to 65535. This parameter is required.
        # *   loadBalancerProtocol: This parameter is required. Valid values: TCP and HTTPS. If the HTTP protocol is used, set this parameter to TCP.
        # *   certId: the ID of the certificate. This parameter is required if the HTTPS protocol is used. You can purchase an SLB instance in the SLB console.
        # 
        # > The ServicePortInfos parameter is specified to support multi-port mappings. If you want this parameter to take effect, make sure that you have set the AppId, ClusterId, Type, and SlbId parameters.
        self.service_port_infos = service_port_infos
        # The ID of the SLB instance. If you leave this parameter empty, Enterprise Distributed Application Service (EDAS) automatically purchases an SLB instance.
        self.slb_id = slb_id
        # The protocol used by the SLB instance. Valid values: TCP, HTTP, and HTTPS.
        self.slb_protocol = slb_protocol
        # The instance type of the SLB instance. Valid values:
        # 
        # *   slb.s1.small
        # *   slb.s2.small
        # *   slb.s2.medium
        # *   slb.s3.small
        # *   slb.s3.medium
        # *   slb.s3.large
        self.specification = specification
        # The backend port, which is also the service port of the application. Valid values: 1 to 65535.
        self.target_port = target_port
        # The type of the SLB instance. Valid values:
        # 
        # *   internet: Internet-facing SLB instance
        # *   intranet: internal-facing SLB instance
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.port is not None:
            result['Port'] = self.port
        if self.scheduler is not None:
            result['Scheduler'] = self.scheduler
        if self.service_port_infos is not None:
            result['ServicePortInfos'] = self.service_port_infos
        if self.slb_id is not None:
            result['SlbId'] = self.slb_id
        if self.slb_protocol is not None:
            result['SlbProtocol'] = self.slb_protocol
        if self.specification is not None:
            result['Specification'] = self.specification
        if self.target_port is not None:
            result['TargetPort'] = self.target_port
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Scheduler') is not None:
            self.scheduler = m.get('Scheduler')
        if m.get('ServicePortInfos') is not None:
            self.service_port_infos = m.get('ServicePortInfos')
        if m.get('SlbId') is not None:
            self.slb_id = m.get('SlbId')
        if m.get('SlbProtocol') is not None:
            self.slb_protocol = m.get('SlbProtocol')
        if m.get('Specification') is not None:
            self.specification = m.get('Specification')
        if m.get('TargetPort') is not None:
            self.target_port = m.get('TargetPort')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class BindK8sSlbResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process.
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class BindK8sSlbResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindK8sSlbResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindK8sSlbResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindSlbRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        listener_port: int = None,
        slb_id: str = None,
        slb_ip: str = None,
        type: str = None,
        vserver_group_id: str = None,
    ):
        # The ID of the EDAS application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The listener port for the SLB instance.
        self.listener_port = listener_port
        # The ID of the SLB instance.
        # 
        # This parameter is required.
        self.slb_id = slb_id
        # The IP address of the SLB instance.
        # 
        # This parameter is required.
        self.slb_ip = slb_ip
        # The type of the SLB instance. Valid values:
        # 
        # *   internet: Internet-facing SLB instance
        # *   intranet: internal-facing SLB instance
        # 
        # This parameter is required.
        self.type = type
        # The ID of the vServer group for the internal-facing SLB instance.
        self.vserver_group_id = vserver_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.slb_id is not None:
            result['SlbId'] = self.slb_id
        if self.slb_ip is not None:
            result['SlbIp'] = self.slb_ip
        if self.type is not None:
            result['Type'] = self.type
        if self.vserver_group_id is not None:
            result['VServerGroupId'] = self.vserver_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('SlbId') is not None:
            self.slb_id = m.get('SlbId')
        if m.get('SlbIp') is not None:
            self.slb_ip = m.get('SlbIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VServerGroupId') is not None:
            self.vserver_group_id = m.get('VServerGroupId')
        return self


class BindSlbResponseBodyData(TeaModel):
    def __init__(
        self,
        ext_slb_id: str = None,
        ext_slb_ip: str = None,
        ext_slb_name: str = None,
        ext_vserver_group_id: str = None,
        slb_id: str = None,
        slb_ip: str = None,
        slb_name: str = None,
        slb_port: int = None,
        vserver_group_id: str = None,
    ):
        # The ID of the Internet-facing SLB instance.
        self.ext_slb_id = ext_slb_id
        # The IP address of the Internet-facing SLB instance.
        self.ext_slb_ip = ext_slb_ip
        # The name of the Internet-facing SLB instance.
        self.ext_slb_name = ext_slb_name
        # The ID of the vServer group for the Internet-facing SLB instance.
        self.ext_vserver_group_id = ext_vserver_group_id
        # The ID of the internal-facing SLB instance.
        self.slb_id = slb_id
        # The IP address of the internal-facing SLB instance.
        self.slb_ip = slb_ip
        # The name of the internal-facing SLB instance.
        self.slb_name = slb_name
        # The listener port for the SLB instance.
        self.slb_port = slb_port
        # The ID of the vServer group for the internal-facing SLB instance.
        self.vserver_group_id = vserver_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ext_slb_id is not None:
            result['ExtSlbId'] = self.ext_slb_id
        if self.ext_slb_ip is not None:
            result['ExtSlbIp'] = self.ext_slb_ip
        if self.ext_slb_name is not None:
            result['ExtSlbName'] = self.ext_slb_name
        if self.ext_vserver_group_id is not None:
            result['ExtVServerGroupId'] = self.ext_vserver_group_id
        if self.slb_id is not None:
            result['SlbId'] = self.slb_id
        if self.slb_ip is not None:
            result['SlbIp'] = self.slb_ip
        if self.slb_name is not None:
            result['SlbName'] = self.slb_name
        if self.slb_port is not None:
            result['SlbPort'] = self.slb_port
        if self.vserver_group_id is not None:
            result['VServerGroupId'] = self.vserver_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExtSlbId') is not None:
            self.ext_slb_id = m.get('ExtSlbId')
        if m.get('ExtSlbIp') is not None:
            self.ext_slb_ip = m.get('ExtSlbIp')
        if m.get('ExtSlbName') is not None:
            self.ext_slb_name = m.get('ExtSlbName')
        if m.get('ExtVServerGroupId') is not None:
            self.ext_vserver_group_id = m.get('ExtVServerGroupId')
        if m.get('SlbId') is not None:
            self.slb_id = m.get('SlbId')
        if m.get('SlbIp') is not None:
            self.slb_ip = m.get('SlbIp')
        if m.get('SlbName') is not None:
            self.slb_name = m.get('SlbName')
        if m.get('SlbPort') is not None:
            self.slb_port = m.get('SlbPort')
        if m.get('VServerGroupId') is not None:
            self.vserver_group_id = m.get('VServerGroupId')
        return self


class BindSlbResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: BindSlbResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The data that is returned.
        self.data = data
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BindSlbResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class BindSlbResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindSlbResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindSlbResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ChangeDeployGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        ecc_info: str = None,
        force_status: bool = None,
        group_name: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the elastic compute component (ECC) that corresponds to the ECS instance for which you want to change the application instance group. You can call the ListApplicationEcc operation to query the ECC ID. For more information, see [ListApplicationEcc](https://help.aliyun.com/document_detail/199277.html).
        # 
        # > You can change the application instance group for only one ECS instance at a time.
        # 
        # This parameter is required.
        self.ecc_info = ecc_info
        # Specifies whether to forcibly change the application instance group if the deployment package version of the ECC is different from that of the application instance group.
        self.force_status = force_status
        # The name of the application instance group. Examples: group_a and group_b. The parameter value for the default application instance group is `_DEFAULT_GROUP`. The name can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.ecc_info is not None:
            result['EccInfo'] = self.ecc_info
        if self.force_status is not None:
            result['ForceStatus'] = self.force_status
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EccInfo') is not None:
            self.ecc_info = m.get('EccInfo')
        if m.get('ForceStatus') is not None:
            self.force_status = m.get('ForceStatus')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class ChangeDeployGroupResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process.
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ChangeDeployGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ChangeDeployGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ChangeDeployGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ContinuePipelineRequest(TeaModel):
    def __init__(
        self,
        confirm: bool = None,
        pipeline_id: str = None,
    ):
        # Specifies whether to release the next batch. Valid values:
        # 
        # *   true: releases the next batch.
        # *   false: does not release the next batch.
        self.confirm = confirm
        # The ID of the change process. You can call the GetChangeOrderInfo operation to query the ID of the change process that corresponds to a specific batch. For more information, see [GetChangeOrderInfo](https://help.aliyun.com/document_detail/62072.html).
        # 
        # This parameter is required.
        self.pipeline_id = pipeline_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.confirm is not None:
            result['Confirm'] = self.confirm
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Confirm') is not None:
            self.confirm = m.get('Confirm')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        return self


class ContinuePipelineResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ContinuePipelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ContinuePipelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ContinuePipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ConvertK8sResourceRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        namespace: str = None,
        resource_name: str = None,
        resource_type: str = None,
    ):
        # The ID of the cluster. You can call the ListCluster operation to query the cluster ID. For more information, see [ListCluster](https://help.aliyun.com/document_detail/154995.html).
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The namespace.
        # 
        # This parameter is required.
        self.namespace = namespace
        # The name of the resource.
        # 
        # This parameter is required.
        self.resource_name = resource_name
        # The type of the resource that is used. Set the value to deployment.
        # 
        # This parameter is required.
        self.resource_type = resource_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.resource_name is not None:
            result['ResourceName'] = self.resource_name
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('ResourceName') is not None:
            self.resource_name = m.get('ResourceName')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class ConvertK8sResourceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ConvertK8sResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ConvertK8sResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ConvertK8sResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateApplicationScalingRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        scaling_behaviour: str = None,
        scaling_rule_enable: bool = None,
        scaling_rule_metric: str = None,
        scaling_rule_name: str = None,
        scaling_rule_timer: str = None,
        scaling_rule_trigger: str = None,
        scaling_rule_type: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplicationlink](https://help.aliyun.com/document_detail/149390.html).
        self.app_id = app_id
        # Configure custom elastic behavior, refer to the example for specific data structure.
        self.scaling_behaviour = scaling_behaviour
        # Specifies whether to enable the auto scaling policy. Valid values:
        # 
        # *   **true**: enables the auto scaling policy.
        # *   **false**: disables the auto scaling policy.
        self.scaling_rule_enable = scaling_rule_enable
        # This parameter is deprecated.
        self.scaling_rule_metric = scaling_rule_metric
        # The name of the auto scaling policy. The name must start with a lowercase letter, and can contain lowercase letters, digits, and hyphens (-). The name must be 1 to 32 characters in length.
        self.scaling_rule_name = scaling_rule_name
        # This parameter is deprecated.
        self.scaling_rule_timer = scaling_rule_timer
        # The trigger policy for the auto scaling policy. Set the value in the JSON format by using the ScalingRuleTriggerDTO class. For more information, see Additional information about request parameters.
        self.scaling_rule_trigger = scaling_rule_trigger
        # The type of the auto scaling policy. Set the value to **trigger**.
        self.scaling_rule_type = scaling_rule_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.scaling_behaviour is not None:
            result['ScalingBehaviour'] = self.scaling_behaviour
        if self.scaling_rule_enable is not None:
            result['ScalingRuleEnable'] = self.scaling_rule_enable
        if self.scaling_rule_metric is not None:
            result['ScalingRuleMetric'] = self.scaling_rule_metric
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        if self.scaling_rule_timer is not None:
            result['ScalingRuleTimer'] = self.scaling_rule_timer
        if self.scaling_rule_trigger is not None:
            result['ScalingRuleTrigger'] = self.scaling_rule_trigger
        if self.scaling_rule_type is not None:
            result['ScalingRuleType'] = self.scaling_rule_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ScalingBehaviour') is not None:
            self.scaling_behaviour = m.get('ScalingBehaviour')
        if m.get('ScalingRuleEnable') is not None:
            self.scaling_rule_enable = m.get('ScalingRuleEnable')
        if m.get('ScalingRuleMetric') is not None:
            self.scaling_rule_metric = m.get('ScalingRuleMetric')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        if m.get('ScalingRuleTimer') is not None:
            self.scaling_rule_timer = m.get('ScalingRuleTimer')
        if m.get('ScalingRuleTrigger') is not None:
            self.scaling_rule_trigger = m.get('ScalingRuleTrigger')
        if m.get('ScalingRuleType') is not None:
            self.scaling_rule_type = m.get('ScalingRuleType')
        return self


class CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies(TeaModel):
    def __init__(
        self,
        period_seconds: int = None,
        type: str = None,
        value: str = None,
    ):
        # The period during which the check is performed. Valid values: 0 to 1800. Unit: seconds.
        self.period_seconds = period_seconds
        # The type of the policy. The value can be Pods or Percent.
        self.type = type
        # The value of the auto scaling policy. The value of this parameter is an integer greater than 0. If the policy type is Pods, the value indicates the number of pods. If the policy type is Percent, the value indicates a percentage. The value is allowed to exceed 100%.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.period_seconds is not None:
            result['PeriodSeconds'] = self.period_seconds
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PeriodSeconds') is not None:
            self.period_seconds = m.get('PeriodSeconds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown(TeaModel):
    def __init__(
        self,
        policies: List[CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies] = None,
        select_policy: str = None,
        stabilization_window_seconds: int = None,
    ):
        # The configurations of the auto scaling policy.
        self.policies = policies
        self.select_policy = select_policy
        self.stabilization_window_seconds = stabilization_window_seconds

    def validate(self):
        if self.policies:
            for k in self.policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Policies'] = []
        if self.policies is not None:
            for k in self.policies:
                result['Policies'].append(k.to_map() if k else None)
        if self.select_policy is not None:
            result['SelectPolicy'] = self.select_policy
        if self.stabilization_window_seconds is not None:
            result['StabilizationWindowSeconds'] = self.stabilization_window_seconds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.policies = []
        if m.get('Policies') is not None:
            for k in m.get('Policies'):
                temp_model = CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies()
                self.policies.append(temp_model.from_map(k))
        if m.get('SelectPolicy') is not None:
            self.select_policy = m.get('SelectPolicy')
        if m.get('StabilizationWindowSeconds') is not None:
            self.stabilization_window_seconds = m.get('StabilizationWindowSeconds')
        return self


class CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies(TeaModel):
    def __init__(
        self,
        period_seconds: int = None,
        type: str = None,
        value: str = None,
    ):
        # The period during which the check is performed. Valid values: 0 to 1800. Unit: seconds.
        self.period_seconds = period_seconds
        # The type of the policy. The value can be Pods or Percent.
        self.type = type
        # The value of the auto scaling policy. The value of this parameter is an integer greater than 0. If the policy type is Pods, the value indicates the number of pods. If the policy type is Percent, the value indicates a percentage. The value is allowed to exceed 100%.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.period_seconds is not None:
            result['PeriodSeconds'] = self.period_seconds
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PeriodSeconds') is not None:
            self.period_seconds = m.get('PeriodSeconds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp(TeaModel):
    def __init__(
        self,
        policies: List[CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies] = None,
        select_policy: str = None,
        stabilization_window_seconds: int = None,
    ):
        # The configurations of the auto scaling policy.
        self.policies = policies
        self.select_policy = select_policy
        self.stabilization_window_seconds = stabilization_window_seconds

    def validate(self):
        if self.policies:
            for k in self.policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Policies'] = []
        if self.policies is not None:
            for k in self.policies:
                result['Policies'].append(k.to_map() if k else None)
        if self.select_policy is not None:
            result['SelectPolicy'] = self.select_policy
        if self.stabilization_window_seconds is not None:
            result['StabilizationWindowSeconds'] = self.stabilization_window_seconds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.policies = []
        if m.get('Policies') is not None:
            for k in m.get('Policies'):
                temp_model = CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies()
                self.policies.append(temp_model.from_map(k))
        if m.get('SelectPolicy') is not None:
            self.select_policy = m.get('SelectPolicy')
        if m.get('StabilizationWindowSeconds') is not None:
            self.stabilization_window_seconds = m.get('StabilizationWindowSeconds')
        return self


class CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour(TeaModel):
    def __init__(
        self,
        scale_down: CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown = None,
        scale_up: CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp = None,
    ):
        # The behavior configurations of the scale-in.
        self.scale_down = scale_down
        # The behavior configurations of the scale-out.
        self.scale_up = scale_up

    def validate(self):
        if self.scale_down:
            self.scale_down.validate()
        if self.scale_up:
            self.scale_up.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.scale_down is not None:
            result['ScaleDown'] = self.scale_down.to_map()
        if self.scale_up is not None:
            result['ScaleUp'] = self.scale_up.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ScaleDown') is not None:
            temp_model = CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown()
            self.scale_down = temp_model.from_map(m['ScaleDown'])
        if m.get('ScaleUp') is not None:
            temp_model = CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp()
            self.scale_up = temp_model.from_map(m['ScaleUp'])
        return self


class CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics(TeaModel):
    def __init__(
        self,
        metric_target_average_utilization: int = None,
        metric_type: str = None,
    ):
        # This parameter is deprecated.
        self.metric_target_average_utilization = metric_target_average_utilization
        # This parameter is deprecated.
        self.metric_type = metric_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_target_average_utilization is not None:
            result['MetricTargetAverageUtilization'] = self.metric_target_average_utilization
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetricTargetAverageUtilization') is not None:
            self.metric_target_average_utilization = m.get('MetricTargetAverageUtilization')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        return self


class CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric(TeaModel):
    def __init__(
        self,
        max_replicas: int = None,
        metrics: List[CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics] = None,
        min_replicas: int = None,
    ):
        # This parameter is deprecated.
        self.max_replicas = max_replicas
        # This parameter is deprecated.
        self.metrics = metrics
        # This parameter is deprecated.
        self.min_replicas = min_replicas

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics()
                self.metrics.append(temp_model.from_map(k))
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        return self


class CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers(TeaModel):
    def __init__(
        self,
        meta_data: str = None,
        name: str = None,
        type: str = None,
    ):
        # The metadata of the trigger.
        self.meta_data = meta_data
        # The name of the trigger.
        self.name = name
        # The type of the trigger. Only cron and app_metric are supported.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.meta_data is not None:
            result['MetaData'] = self.meta_data
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetaData') is not None:
            self.meta_data = m.get('MetaData')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger(TeaModel):
    def __init__(
        self,
        max_replicas: int = None,
        min_replicas: int = None,
        triggers: List[CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers] = None,
    ):
        # The maximum number of replicas. The maximum value is 1000.
        self.max_replicas = max_replicas
        # The minimum number of replicas. The minimum value is 0.
        self.min_replicas = min_replicas
        # The triggers.
        self.triggers = triggers

    def validate(self):
        if self.triggers:
            for k in self.triggers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        result['Triggers'] = []
        if self.triggers is not None:
            for k in self.triggers:
                result['Triggers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        self.triggers = []
        if m.get('Triggers') is not None:
            for k in m.get('Triggers'):
                temp_model = CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers()
                self.triggers.append(temp_model.from_map(k))
        return self


class CreateApplicationScalingRuleResponseBodyAppScalingRule(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        behaviour: CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour = None,
        create_time: int = None,
        last_disable_time: int = None,
        max_replicas: int = None,
        metric: CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric = None,
        min_replicas: int = None,
        scale_rule_enabled: bool = None,
        scale_rule_name: str = None,
        scale_rule_type: str = None,
        trigger: CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger = None,
        update_time: int = None,
    ):
        # The ID of the application to which the auto scaling policy belongs.
        self.app_id = app_id
        # The scaling behavior.
        self.behaviour = behaviour
        # The timestamp when the auto scaling policy was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The timestamp when the auto scaling policy was last disabled. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.last_disable_time = last_disable_time
        # This parameter is deprecated.
        self.max_replicas = max_replicas
        # This parameter is deprecated.
        self.metric = metric
        # This parameter is deprecated.
        self.min_replicas = min_replicas
        # Indicates whether the auto scaling policy is enabled. Valid values:
        # 
        # *   **true**: The auto scaling policy is enabled.
        # *   **false**: The auto scaling policy is disabled.
        self.scale_rule_enabled = scale_rule_enabled
        # The name of the auto scaling policy.
        self.scale_rule_name = scale_rule_name
        # The type of the rule. Only trigger is supported.
        self.scale_rule_type = scale_rule_type
        # The configurations of the trigger.
        self.trigger = trigger
        # The timestamp when the auto scaling policy was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time

    def validate(self):
        if self.behaviour:
            self.behaviour.validate()
        if self.metric:
            self.metric.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.behaviour is not None:
            result['Behaviour'] = self.behaviour.to_map()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_disable_time is not None:
            result['LastDisableTime'] = self.last_disable_time
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.metric is not None:
            result['Metric'] = self.metric.to_map()
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        if self.scale_rule_enabled is not None:
            result['ScaleRuleEnabled'] = self.scale_rule_enabled
        if self.scale_rule_name is not None:
            result['ScaleRuleName'] = self.scale_rule_name
        if self.scale_rule_type is not None:
            result['ScaleRuleType'] = self.scale_rule_type
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Behaviour') is not None:
            temp_model = CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour()
            self.behaviour = temp_model.from_map(m['Behaviour'])
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastDisableTime') is not None:
            self.last_disable_time = m.get('LastDisableTime')
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('Metric') is not None:
            temp_model = CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric()
            self.metric = temp_model.from_map(m['Metric'])
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        if m.get('ScaleRuleEnabled') is not None:
            self.scale_rule_enabled = m.get('ScaleRuleEnabled')
        if m.get('ScaleRuleName') is not None:
            self.scale_rule_name = m.get('ScaleRuleName')
        if m.get('ScaleRuleType') is not None:
            self.scale_rule_type = m.get('ScaleRuleType')
        if m.get('Trigger') is not None:
            temp_model = CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class CreateApplicationScalingRuleResponseBody(TeaModel):
    def __init__(
        self,
        app_scaling_rule: CreateApplicationScalingRuleResponseBodyAppScalingRule = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The information about the auto scaling policy.
        self.app_scaling_rule = app_scaling_rule
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.app_scaling_rule:
            self.app_scaling_rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_scaling_rule is not None:
            result['AppScalingRule'] = self.app_scaling_rule.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppScalingRule') is not None:
            temp_model = CreateApplicationScalingRuleResponseBodyAppScalingRule()
            self.app_scaling_rule = temp_model.from_map(m['AppScalingRule'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateApplicationScalingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateApplicationScalingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateApplicationScalingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateConfigTemplateRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        description: str = None,
        format: str = None,
        name: str = None,
    ):
        # The content of the configuration template. The value must be in the format that is specified by the Format parameter.
        self.content = content
        # The description of the configuration template. The description can be up to 255 characters in length.
        self.description = description
        # The data format of the configuration template. Valid values:
        # 
        # *   JSON: JSON format
        # *   XML: XML format
        # *   YAML: YAML format
        # *   Properties: .properties format
        # *   KeyValue: key-value pairs
        # *   Custom: custom format
        self.format = format
        # The name of the configuration template. The name can be up to 64 characters in length.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.description is not None:
            result['Description'] = self.description
        if self.format is not None:
            result['Format'] = self.format
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class CreateConfigTemplateResponseBodyData(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The ID of the template.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class CreateConfigTemplateResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: CreateConfigTemplateResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The data returned.
        self.data = data
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateConfigTemplateResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateConfigTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateConfigTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateConfigTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateIDCImportCommandRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
    ):
        # The cluster ID. You can call the ListCluster operation to query the cluster ID. For more information, see [ListCluster](https://help.aliyun.com/document_detail/154995.html).
        # 
        # This parameter is required.
        self.cluster_id = cluster_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        return self


class CreateIDCImportCommandResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code.
        self.code = code
        # The generated import command.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateIDCImportCommandResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateIDCImportCommandResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateIDCImportCommandResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateK8sConfigMapRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        data: Dict[str, Any] = None,
        name: str = None,
        namespace: str = None,
    ):
        # The ID of the Kubernetes cluster.
        self.cluster_id = cluster_id
        # The data of the ConfigMap. The value must be a JSON array string.
        self.data = data
        # The name of the ConfigMap. The name must start with a letter, and can contain digits, letters, and hyphens (-). It can be up to 63 characters in length.
        self.name = name
        # The namespace of the Kubernetes cluster.
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.data is not None:
            result['Data'] = self.data
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        return self


class CreateK8sConfigMapResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code.
        self.code = code
        # The additional information returned.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateK8sConfigMapResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateK8sConfigMapResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateK8sConfigMapResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateK8sIngressRuleRequest(TeaModel):
    def __init__(
        self,
        annotations: str = None,
        cluster_id: str = None,
        ingress_conf: Dict[str, Any] = None,
        labels: str = None,
        name: str = None,
        namespace: str = None,
    ):
        # The annotations.
        self.annotations = annotations
        # The ID of the Kubernetes cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The routing rules of the Ingress. Set this parameter to a JSON string in the following format:
        # 
        #     {
        #       "rules": [
        #         {
        #           "host": "abc.com",
        #           "secretName": "tls-secret",
        #           "paths": [
        #             {
        #               "path": "/path",
        #               "backend": {
        #                 "servicePort": 80,
        #                 "serviceName": "xxx"
        #               }
        #             }
        #           ]
        #         }
        #       ]
        #     }
        # 
        # Parameter description:
        # 
        # *   rules: the list of routing rules.
        # *   host: the domain name to be accessed.
        # *   secretName: the name of the Secret that stores the information about the Transport Layer Security (TLS) certificate. The certificate is required if you need to use the HTTPS protocol.
        # *   paths: the list of paths to be accessed.
        # *   path: the path to be accessed.
        # *   backend: the configuration of the backend service. You can specify a service that is created in the Enterprise Distributed Application Service (EDAS) console.
        # *   serviceName: the name of the backend service.
        # *   servicePort: the port of the backend service.
        self.ingress_conf = ingress_conf
        # The labels.
        self.labels = labels
        # The name of the Ingress. The name can contain lowercase letters, digits, and hyphens (-). It must start with a lowercase letter but cannot end with a hyphen (-). The name can be up to 63 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The namespace of the Kubernetes cluster.
        # 
        # This parameter is required.
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotations is not None:
            result['Annotations'] = self.annotations
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.ingress_conf is not None:
            result['IngressConf'] = self.ingress_conf
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Annotations') is not None:
            self.annotations = m.get('Annotations')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('IngressConf') is not None:
            self.ingress_conf = m.get('IngressConf')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        return self


class CreateK8sIngressRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class CreateK8sIngressRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateK8sIngressRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateK8sIngressRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateK8sSecretRequest(TeaModel):
    def __init__(
        self,
        base_64encoded: bool = None,
        cert_id: str = None,
        cert_region_id: str = None,
        cluster_id: str = None,
        data: str = None,
        name: str = None,
        namespace: str = None,
        type: str = None,
    ):
        # Specifies whether the data has been encoded in Base64. Valid values: true and false.
        self.base_64encoded = base_64encoded
        # The certificate ID provided by Alibaba Cloud Certificate Management Service.
        self.cert_id = cert_id
        # The region in which the certificate is stored.
        self.cert_region_id = cert_region_id
        # The cluster ID.
        self.cluster_id = cluster_id
        # The data of the Secret. The value must be a JSON array that contains the following information:
        # 
        # *   Key: Secret key
        # *   Value: Secret value
        self.data = data
        # The name of the Secret. The name must start with a letter, and can contain digits, letters, and hyphens (-). It can be up to 63 characters in length.
        self.name = name
        # The namespace of the Kubernetes cluster.
        self.namespace = namespace
        # The Secret type. Valid values:
        # 
        # *   Opaque: user-defined data
        # *   kubernetes.io/tls: Transport Layer Security (TLS) certificate
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_64encoded is not None:
            result['Base64Encoded'] = self.base_64encoded
        if self.cert_id is not None:
            result['CertId'] = self.cert_id
        if self.cert_region_id is not None:
            result['CertRegionId'] = self.cert_region_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.data is not None:
            result['Data'] = self.data
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Base64Encoded') is not None:
            self.base_64encoded = m.get('Base64Encoded')
        if m.get('CertId') is not None:
            self.cert_id = m.get('CertId')
        if m.get('CertRegionId') is not None:
            self.cert_region_id = m.get('CertRegionId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateK8sSecretResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code.
        self.code = code
        # The additional information returned.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateK8sSecretResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateK8sSecretResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateK8sSecretResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateK8sServiceRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        external_traffic_policy: str = None,
        name: str = None,
        service_ports: str = None,
        type: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The policy used for external traffic management. Valid values:
        # 
        # *   Local: The network traffic can be routed to pods on the node where the Service is deployed.
        # *   Cluster: The network traffic can be routed to pods on other nodes in the cluster.
        # 
        # Default value: Local.
        self.external_traffic_policy = external_traffic_policy
        # The name of the Kubernetes Service.
        # 
        # This parameter is required.
        self.name = name
        # The port mapping of the Kubernetes Service. Set this parameter to a JSON array. The following parameters are included in the configurations:
        # 
        # *   **protocol**: the protocol used by the Service. Valid values: TCP and UDP. This parameter is mandatory.
        # *   **port**: the frontend service port. Valid values: 1 to 65535. This parameter is mandatory.
        # *   **targetPort**: the backend container port. Valid values: 1 to 65535. This parameter is mandatory.
        # 
        # Example: `[{"protocol": "TCP", "port": 80, "targetPort": 8080},{"protocol": "TCP", "port": 81, "targetPort": 8081}]`
        # 
        # This parameter is required.
        self.service_ports = service_ports
        # The type of the Kubernetes Service. Set the value to ClusterIP.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.external_traffic_policy is not None:
            result['ExternalTrafficPolicy'] = self.external_traffic_policy
        if self.name is not None:
            result['Name'] = self.name
        if self.service_ports is not None:
            result['ServicePorts'] = self.service_ports
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ExternalTrafficPolicy') is not None:
            self.external_traffic_policy = m.get('ExternalTrafficPolicy')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ServicePorts') is not None:
            self.service_ports = m.get('ServicePorts')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateK8sServiceResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The change process ID.
        self.change_order_id = change_order_id
        # The HTTP status code.
        self.code = code
        # The additional information returned.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateK8sServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateK8sServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateK8sServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DeleteApplicationResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process.
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteApplicationScalingRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        scaling_rule_name: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        self.app_id = app_id
        # The name of the auto scaling policy.
        self.scaling_rule_name = scaling_rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        return self


class DeleteApplicationScalingRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteApplicationScalingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteApplicationScalingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteApplicationScalingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteClusterRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        mode: int = None,
    ):
        # The ID of the cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The type of the cluster ID. Valid values:
        # 
        # *   0: specifies the ID of the cluster in Enterprise Distributed Application Service (EDAS).
        # *   1: specifies the ID of the ACK cluster.
        self.mode = mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.mode is not None:
            result['Mode'] = self.mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        return self


class DeleteClusterResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: bool = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # Indicates whether the cluster is deleted. Valid values:
        # 
        # *   true: The cluster is deleted.
        # *   false: The cluster is not deleted.
        self.data = data
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteClusterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteClusterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteClusterMemberRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_member_id: str = None,
    ):
        # The ID of the cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The member ID of the ECS instance that you want to remove from the cluster.
        # 
        # This parameter is required.
        self.cluster_member_id = cluster_member_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_member_id is not None:
            result['ClusterMemberId'] = self.cluster_member_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterMemberId') is not None:
            self.cluster_member_id = m.get('ClusterMemberId')
        return self


class DeleteClusterMemberResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: bool = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # Indicates whether the request is successful.
        self.data = data
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteClusterMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteClusterMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteClusterMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteConfigTemplateRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The ID of the configuration template.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteConfigTemplateResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteConfigTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteConfigTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteConfigTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDeployGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group_name: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The name of the instance group.
        # 
        # This parameter is required.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class DeleteDeployGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The data that is returned.
        self.data = data
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDeployGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDeployGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDeployGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEcuRequest(TeaModel):
    def __init__(
        self,
        ecu_id: str = None,
    ):
        # The unique ID of the ECU to be deleted.
        # 
        # This parameter is required.
        self.ecu_id = ecu_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ecu_id is not None:
            result['EcuId'] = self.ecu_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EcuId') is not None:
            self.ecu_id = m.get('EcuId')
        return self


class DeleteEcuResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The returned data that indicates whether the ECU is deleted. A value of `OK` indicates that the ECU is deleted.
        self.data = data
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteEcuResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEcuResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEcuResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteK8sApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        force: bool = None,
    ):
        # The ID of the application that you want to delete. You can call the ListApplication operation to query the application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # Specifies whether to forcibly delete the application and disable application deletion protection.
        self.force = force

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.force is not None:
            result['Force'] = self.force
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Force') is not None:
            self.force = m.get('Force')
        return self


class DeleteK8sApplicationResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process for this operation. If an instance on which the application is deployed is running or a Server Load Balancer (SLB) instance is bound to the application, this operation generates a change process ID and deletes the application. You can call the GetChangeOrderInfo operation to query the progress of this operation. You can determine whether the operation is successful based on the value of the Code parameter.
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteK8sApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteK8sApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteK8sApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteK8sConfigMapRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        name: str = None,
        namespace: str = None,
    ):
        # The ID of the cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The name of the ConfigMap. The name must start with a letter, and can contain digits, letters, and hyphens (-). It can be up to 63 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The namespace of the Kubernetes cluster.
        # 
        # This parameter is required.
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        return self


class DeleteK8sConfigMapResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteK8sConfigMapResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteK8sConfigMapResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteK8sConfigMapResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteK8sIngressRuleRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        name: str = None,
        namespace: str = None,
    ):
        # The ID of the Kubernetes cluster.
        self.cluster_id = cluster_id
        # The name of the Ingress. The name can contain lowercase letters, digits, and hyphens (-). It must start with a lowercase letter but cannot end with a hyphen (-). The name can be up to 63 characters in length.
        self.name = name
        # The namespace of the Kubernetes cluster.
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        return self


class DeleteK8sIngressRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class DeleteK8sIngressRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteK8sIngressRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteK8sIngressRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteK8sSecretRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        name: str = None,
        namespace: str = None,
    ):
        # The ID of the cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The name of the Secret. The name must start with a letter, and can contain digits, letters, and hyphens (-). It can be up to 63 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The namespace of the Kubernetes cluster.
        # 
        # This parameter is required.
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        return self


class DeleteK8sSecretResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteK8sSecretResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteK8sSecretResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteK8sSecretResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteK8sServiceRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        name: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The name of the service.
        # 
        # This parameter is required.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DeleteK8sServiceResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process.
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteK8sServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteK8sServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteK8sServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLogPathRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        path: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The absolute path of the log directory that you want to remove. The value must start and end with a forward slash (`/`) and must contain `/log` or `/logs`. The following directories are the default log directories in Enterprise Distributed Application Service (EDAS):
        # 
        # *   /home/admin/edas-container/logs/\
        # *   /home/admin/taobao-tomcat-7.0.59/logs/\
        # *   /home/admin/taobao-tomcat-production-7.0.59.3/logs/\
        # *   /home/admin/taobao-tomcat-production-7.0.70/logs/\
        # *   /home/admin/edas-agent/logs/\
        self.path = path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.path is not None:
            result['Path'] = self.path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        return self


class DeleteLogPathResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLogPathResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLogPathResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLogPathResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRoleRequest(TeaModel):
    def __init__(
        self,
        role_id: int = None,
    ):
        # The ID of the RAM role.
        # 
        # This parameter is required.
        self.role_id = role_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        return self


class DeleteRoleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteRoleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRoleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRoleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteServiceGroupRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
    ):
        # The ID of the service group that you want to delete.
        # 
        # This parameter is required.
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class DeleteServiceGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteServiceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteServiceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteServiceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSwimmingLaneRequest(TeaModel):
    def __init__(
        self,
        lane_id: int = None,
    ):
        # The ID of the lane.
        # 
        # This parameter is required.
        self.lane_id = lane_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lane_id is not None:
            result['LaneId'] = self.lane_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LaneId') is not None:
            self.lane_id = m.get('LaneId')
        return self


class DeleteSwimmingLaneResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # Indicates whether the lane is deleted.
        self.data = data
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSwimmingLaneResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSwimmingLaneResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSwimmingLaneResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteUserDefineRegionRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        region_tag: str = None,
    ):
        # The unique ID of the custom namespace. You can call the ListUserDefineRegion operation to query the ID. For more information, see [ListUserDefineRegion](https://help.aliyun.com/document_detail/149377.html).
        self.id = id
        # The tag of the custom namespace.
        self.region_tag = region_tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.region_tag is not None:
            result['RegionTag'] = self.region_tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RegionTag') is not None:
            self.region_tag = m.get('RegionTag')
        return self


class DeleteUserDefineRegionResponseBodyRegionDefine(TeaModel):
    def __init__(
        self,
        belong_region: str = None,
        description: str = None,
        id: int = None,
        region_id: str = None,
        region_name: str = None,
        user_id: str = None,
    ):
        # The ID of the region to which the custom namespace belongs.
        self.belong_region = belong_region
        # The description of the custom namespace.
        self.description = description
        # The unique identifier of the custom namespace.
        self.id = id
        # The ID of the custom namespace. The ID cannot be changed after the custom namespace is created. The format is `region ID:custom namespace ID`.
        self.region_id = region_id
        # The name of the custom namespace.
        self.region_name = region_name
        # The ID of the Alibaba Cloud account to which the custom namespace belongs.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.belong_region is not None:
            result['BelongRegion'] = self.belong_region
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.region_name is not None:
            result['RegionName'] = self.region_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BelongRegion') is not None:
            self.belong_region = m.get('BelongRegion')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegionName') is not None:
            self.region_name = m.get('RegionName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DeleteUserDefineRegionResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        region_define: DeleteUserDefineRegionResponseBodyRegionDefine = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The custom namespace.
        self.region_define = region_define
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.region_define:
            self.region_define.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.region_define is not None:
            result['RegionDefine'] = self.region_define.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RegionDefine') is not None:
            temp_model = DeleteUserDefineRegionResponseBodyRegionDefine()
            self.region_define = temp_model.from_map(m['RegionDefine'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteUserDefineRegionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteUserDefineRegionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteUserDefineRegionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeployApplicationRequest(TeaModel):
    def __init__(
        self,
        app_env: str = None,
        app_id: str = None,
        batch: int = None,
        batch_wait_time: int = None,
        build_pack_id: int = None,
        component_ids: str = None,
        deploy_type: str = None,
        desc: str = None,
        gray: bool = None,
        group_id: str = None,
        image_url: str = None,
        package_version: str = None,
        release_type: int = None,
        traffic_control_strategy: str = None,
        war_url: str = None,
    ):
        # The environment variables of the application. Specify each environment variable by using two key-value pairs. Example: `{"name":"x","value":"y"},{"name":"x2","value":"y2"}`. The `keys` of the two key-value pairs are `name` and `value`.
        self.app_env = app_env
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/423162.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The number of batches per instance group.
        # 
        # *   If you specify an ID when you set the GroupId parameter, the application is deployed to the specified instance group. The minimum number of batches that can be specified is 1. The maximum number of batches is the maximum number of ECS instances in the Normal state in the instance group. The actual value falls in the range of [1, specified number]. The specified number of batches equals the number of ECS instances in the specified instance group.
        # *   If you set the GroupId parameter to all, the application is deployed to all instance groups. The minimum number of batches that can be specified is 1. The maximum number of batches is the number of ECS instances in the instance group that has the largest number of ECS instances in the Normal state.
        self.batch = batch
        # The wait time between deployment batches for the application. Unit: minutes.
        # 
        # *   Default value: 0. If no wait time between deployment batches is needed, set this parameter to 0.
        # *   Maximum value: 5.
        # 
        # If many deployment batches are needed, we recommend that you specify a small value for this parameter. Otherwise, the application deployment is time-consuming.
        self.batch_wait_time = batch_wait_time
        # The build package number of EDAS Container.
        # 
        # *   You do not need to set the parameter if you do not need to change the EDAS Container version during the deployment.
        # *   Set the parameter if you need to update the EDAS Container version of the application during the deployment.
        # 
        # You can query the build package number by using one of the following methods:
        # 
        # *   Call the ListBuildPack operation. For more information, see [ListBuildPack](https://help.aliyun.com/document_detail/149391.html).
        # *   Obtain the value in the **Build package number** column of the [Release notes for EDAS Container](https://help.aliyun.com/document_detail/92614.html) topic. For example, `59` indicates `EDAS Container 3.5.8`.
        self.build_pack_id = build_pack_id
        # The IDs of the components used by the application. The parameter is not applicable to High-Speed Framework (HSF) applications. You can call the ListComponents operation to query the component IDs. For more information, see [ListComponents](https://help.aliyun.com/document_detail/423223.html).
        # 
        # *   If you have specified the component IDs when you create the application, you do not need to set the parameter when you deploy the application.
        # *   Set the parameter if you need to update the component versions for the application during the deployment.
        # 
        # Valid values for common application components:
        # 
        # *   4: Apache Tomcat 7.0.91
        # *   7: Apache Tomcat 8.5.42
        # *   5: OpenJDK 1.8.x
        # *   6: OpenJDK 1.7.x
        # 
        # For more information, see the Common application parameters section of the [InsertApplication](https://help.aliyun.com/document_detail/423185.html) topic.
        self.component_ids = component_ids
        # The deployment mode of the application. Valid values: `url` and `image`. The image value is deprecated. You can deploy an application to a Swarm cluster only by using an image.``
        # 
        # This parameter is required.
        self.deploy_type = deploy_type
        # The description of the application deployment.
        self.desc = desc
        # Specifies whether canary release is selected as the deployment method. Valid values:
        # 
        # *   true: Canary release is selected.
        # 
        #     *   To implement a canary release, specify the GroupId parameter, which specifies the ID of the instance group for the canary release.
        #     *   Canary release can be selected as the deployment method for only one batch.
        #     *   After the canary release is complete, the application is released in regular mode. The Batch parameter specifies the number of batches.
        # 
        # *   false: Single-batch release or phased release is selected.
        self.gray = gray
        # The ID of the instance group to which the application is deployed. You can call the ListDeployGroup operation to query the ID of the instance group. For more information, see [ListDeployGroup](https://help.aliyun.com/document_detail/423184.html).
        # 
        # Set the parameter to `all` if you want to deploy the application to all instance groups.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The URL of the application image that is used to deploy the application in a Swarm cluster. We recommend that you use an image that is stored in Alibaba Cloud Container Registry. This parameter is deprecated.
        self.image_url = image_url
        # The version of the application deployment package. The value can be up to 64 characters in length. We recommend that you use a timestamp.
        # 
        # This parameter is required.
        self.package_version = package_version
        # The mode in which the deployment batches are triggered. Valid values:
        # 
        # *   0: automatic.
        # *   1: You must manually trigger the next batch. You can manually click **Proceed to Next Batch** in the console or call the ContinuePipeline operation to proceed to the next batch. We recommend that you choose the automatic mode when you call an API operation to deploy the application. For more information, see [ContinuePipeline](https://help.aliyun.com/document_detail/126990.html).
        self.release_type = release_type
        # The canary release policy. For more information about canary release policies, see [DeployK8sApplication](https://help.aliyun.com/document_detail/423212.html).
        self.traffic_control_strategy = traffic_control_strategy
        # The URL of the application deployment package. The package can be a WAR or JAR package. This parameter is required if you set the **DeployType** parameter to `url`. We recommend that you specify the URL of an application deployment package that is stored in an Object Storage Service (OSS) bucket.
        self.war_url = war_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_env is not None:
            result['AppEnv'] = self.app_env
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.batch is not None:
            result['Batch'] = self.batch
        if self.batch_wait_time is not None:
            result['BatchWaitTime'] = self.batch_wait_time
        if self.build_pack_id is not None:
            result['BuildPackId'] = self.build_pack_id
        if self.component_ids is not None:
            result['ComponentIds'] = self.component_ids
        if self.deploy_type is not None:
            result['DeployType'] = self.deploy_type
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.gray is not None:
            result['Gray'] = self.gray
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.release_type is not None:
            result['ReleaseType'] = self.release_type
        if self.traffic_control_strategy is not None:
            result['TrafficControlStrategy'] = self.traffic_control_strategy
        if self.war_url is not None:
            result['WarUrl'] = self.war_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppEnv') is not None:
            self.app_env = m.get('AppEnv')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Batch') is not None:
            self.batch = m.get('Batch')
        if m.get('BatchWaitTime') is not None:
            self.batch_wait_time = m.get('BatchWaitTime')
        if m.get('BuildPackId') is not None:
            self.build_pack_id = m.get('BuildPackId')
        if m.get('ComponentIds') is not None:
            self.component_ids = m.get('ComponentIds')
        if m.get('DeployType') is not None:
            self.deploy_type = m.get('DeployType')
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('Gray') is not None:
            self.gray = m.get('Gray')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('ReleaseType') is not None:
            self.release_type = m.get('ReleaseType')
        if m.get('TrafficControlStrategy') is not None:
            self.traffic_control_strategy = m.get('TrafficControlStrategy')
        if m.get('WarUrl') is not None:
            self.war_url = m.get('WarUrl')
        return self


class DeployApplicationResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The change process ID of the application deployment.
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The message returned for the request.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeployApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeployApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeployApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeployK8sApplicationRequest(TeaModel):
    def __init__(
        self,
        annotations: str = None,
        app_id: str = None,
        args: str = None,
        batch_timeout: int = None,
        batch_wait_time: int = None,
        build_pack_id: str = None,
        canary_rule_id: str = None,
        change_order_desc: str = None,
        command: str = None,
        config_mount_descs: str = None,
        cpu_limit: int = None,
        cpu_request: int = None,
        custom_affinity: str = None,
        custom_agent_version: str = None,
        custom_tolerations: str = None,
        deploy_across_nodes: str = None,
        deploy_across_zones: str = None,
        edas_container_version: str = None,
        empty_dirs: str = None,
        enable_ahas: bool = None,
        enable_empty_push_reject: bool = None,
        enable_lossless_rule: bool = None,
        env_froms: str = None,
        envs: str = None,
        image: str = None,
        image_platforms: str = None,
        image_tag: str = None,
        init_containers: str = None,
        jdk: str = None,
        java_start_up_config: str = None,
        labels: str = None,
        limit_ephemeral_storage: int = None,
        liveness: str = None,
        local_volume: str = None,
        lossless_rule_aligned: bool = None,
        lossless_rule_delay_time: int = None,
        lossless_rule_func_type: int = None,
        lossless_rule_related: bool = None,
        lossless_rule_warmup_time: int = None,
        mcpu_limit: int = None,
        mcpu_request: int = None,
        memory_limit: int = None,
        memory_request: int = None,
        mount_descs: str = None,
        nas_id: str = None,
        package_url: str = None,
        package_version: str = None,
        package_version_id: str = None,
        post_start: str = None,
        pre_stop: str = None,
        pvc_mount_descs: str = None,
        readiness: str = None,
        replicas: int = None,
        requests_ephemeral_storage: int = None,
        runtime_class_name: str = None,
        sidecars: str = None,
        sls_configs: str = None,
        startup: str = None,
        storage_type: str = None,
        terminate_grace_period: int = None,
        traffic_control_strategy: str = None,
        update_strategy: str = None,
        uri_encoding: str = None,
        use_body_encoding: bool = None,
        user_base_image_url: str = None,
        volumes_str: str = None,
        web_container: str = None,
        web_container_config: str = None,
    ):
        # The annotation of an application pod.
        self.annotations = annotations
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The argument array in the container start-up command. Set this parameter to a JSON array in the format of `["args1","args2"\\]`, where each key is set to a string. If you want to cancel this configuration, set this parameter to an empty JSON array in the format of `"[\\]"`.
        self.args = args
        # The timeout period for an at-a-time release. Unit: seconds.
        self.batch_timeout = batch_timeout
        # The minimum time interval for the phased release of pods. For more information, see [minReadySeconds](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds).
        self.batch_wait_time = batch_wait_time
        # The build package number of EDAS Container.
        # 
        # *   You do not need to set the parameter if you do not need to change the EDAS Container version during the deployment.
        # *   Set the parameter if you need to update the EDAS Container version of the application during the deployment.
        # 
        # You can query the build package number by using one of the following methods:
        # 
        # *   Call the ListBuildPack operation. For more information, see [ListBuildPack](https://help.aliyun.com/document_detail/423222.html).
        # *   Obtain the value in the **Build package number** column of the [Release notes for EDAS Container](https://help.aliyun.com/document_detail/92614.html) topic. For example, `59` indicates `EDAS Container 3.5.8`.
        self.build_pack_id = build_pack_id
        self.canary_rule_id = canary_rule_id
        # The description of the change process.
        self.change_order_desc = change_order_desc
        # The commands that you run to start the container.
        # 
        # > If you want to cancel this configuration, set this parameter to an empty string in the format of `""`.
        self.command = command
        # The configuration for mounting a Kubernetes ConfigMap or Secret to a directory in an elastic container instance. The following parameters are included in the configuration:
        # 
        # *   name: the name of the Kubernetes ConfigMap or Secret.
        # *   type: the type of the API object that you want to mount. You can mount a Kubernetes ConfigMap or Secret.
        # *   mountPath: the mount path. The mount path must be an absolute path that starts with a forward slash (/).
        self.config_mount_descs = config_mount_descs
        # The maximum number of CPU cores allowed for each application instance when the application is running. Unit: cores. Value 0 indicates that no limit is set on CPU cores.
        self.cpu_limit = cpu_limit
        # The number of CPU cores requested for each application instance when the application is running. Unit: cores. We recommend that you set this parameter. Value 0 indicates that no limit is set on CPU cores.
        # 
        # > You must set this parameter together with the CpuLimit parameter. Make sure that the value of this parameter does not exceed that of the CpuLimit parameter.
        self.cpu_request = cpu_request
        # The affinity configuration of the pod. This parameter takes effect only if both the DeployAcrossNodes and DeployAcrossZones parameters are set to false.
        self.custom_affinity = custom_affinity
        self.custom_agent_version = custom_agent_version
        # The scheduling tolerance configuration of the pod. This parameter takes effect only if both the DeployAcrossNodes and DeployAcrossZones parameters are set to false.
        self.custom_tolerations = custom_tolerations
        # Specifies whether to distribute application instances to multiple nodes. Value true indicates that application instances are distrubuted across zones. Other values indicate that application instances are not distributed across zones.
        self.deploy_across_nodes = deploy_across_nodes
        # Specifies whether to distribute application instances across zones. Value true indicates that application instances are distrubuted across zones. Other values indicate that application instances are not distributed across zones.
        self.deploy_across_zones = deploy_across_zones
        # The version of EDAS Container on which the deployment package of the application depends. This parameter is applicable to High-Speed Service Framework (HSF) applications that you deploy by using WAR packages. This parameter is unavailable if you deploy applications by using images.
        self.edas_container_version = edas_container_version
        # The configuration for mounting a Kubernetes emptyDir volume to a directory in an elastic container instance. The following parameters are included in the configuration:
        # 
        # *   mountPath: The mount path in the container. This parameter is required.
        # *   readOnly: (Optional) The mount mode. Value true indicates the read-only mode. Value false indicates the read and write mode. Default value: false.
        # *   subPathExpr: (Optional) The regular expression that is used to match the subdirectory.
        self.empty_dirs = empty_dirs
        # Specifies whether to enable access to Application High Availability Service (AHAS).
        self.enable_ahas = enable_ahas
        # Specifies whether to enable the empty list protection feature. Valid values:
        # 
        # *   true: enables the empty list protection feature.
        # *   false: disables the empty list protection feature.
        self.enable_empty_push_reject = enable_empty_push_reject
        # Specifies whether to enable graceful start rules. Valid values:
        # 
        # *   true: enables graceful start rules.
        # *   false: disables graceful start rules.
        self.enable_lossless_rule = enable_lossless_rule
        # The Kubernetes environment variables that are configured in EnvFrom mode. A ConfigMap or Secret is mounted to a directory. Each key corresponds to a file in the directory, and the content of the file is the value of the key.
        # 
        # This parameter contains the following parameters:
        # 
        # *   configMapRef: the ConfigMap that is referenced. The following parameter is contained:
        # 
        #     *   name: the name of the ConfigMap.
        # 
        # *   secretRef: the Secret that is referenced. The following parameter is contained:
        # 
        #     *   name: the name of the Secret.
        self.env_froms = env_froms
        # The environment variables that are used to deploy the application. Set this parameter to a JSON array. Valid values: regular environment variables, Kubernetes ConfigMap environment variables, and Kubernetes Secret environment variables. Specify regular environment variables in the following format:
        # 
        # `{"name":"x", "value": "y"}`
        # 
        # Specify Kubernetes ConfigMap environment variables in the following format to reference values from ConfigMaps:
        # 
        # `{ "name": "x2", "valueFrom": { "configMapKeyRef": { "name": "my-config", "key": "y2" } } }`
        # 
        # Specify Kubernetes Secret environment variables in the following format to reference values from Secrets:
        # 
        # `{ "name": "x3", "valueFrom": { "secretKeyRef": { "name": "my-secret", "key": "y3" } } }`
        # 
        # >  If you want to cancel this configuration, set this parameter to an empty JSON array, which is in the format of "[]".
        self.envs = envs
        # The absolute URL of the image. This parameter setting overwrites the setting of the ImageTag parameter.
        self.image = image
        # The destination image platform. This parameter takes effect only when you deploy applications by using .war or .jar packages.
        # 
        # *   If you want to specify x86_64, set the value to linux/amd64.
        # *   If you want to specify ARM64, set the value to linux/arm64.
        # *   If you want to specify both x86_64 and ARM64, set the value to linux/amd64,linux/arm64.
        # *   If you leave this parameter empty, the default architecture is used.
        self.image_platforms = image_platforms
        # The tag of the image.
        self.image_tag = image_tag
        self.init_containers = init_containers
        # The version of the Java Development Kit (JDK) on which the deployment package of the application depends. Open JDK 7 and Open JDK 8 are supported. This parameter is unavailable if you deploy applications by using images.
        self.jdk = jdk
        # The configuration of Java startup parameters for a Java application. These startup parameters involve the memory, application, garbage collection (GC) policy, tools, service registration and discovery, and custom configurations. Proper parameter settings help reduce the GC overheads, shorten the server response time, and improve the throughput. Set this parameter to a JSON string. In the example, original indicates the configuration value, and startup indicates a startup parameter. The system automatically concatenates all startup values as the settings of Java startup parameters for the application. To delete this configuration, leave the parameter value empty by entering `""` or `"{}"`.
        self.java_start_up_config = java_start_up_config
        # The label of an application pod.
        self.labels = labels
        # The maximum size of space required by ephemeral storage. Unit: GB. Value 0 indicates that no limit is set on the ephemeral storage space.
        self.limit_ephemeral_storage = limit_ephemeral_storage
        # The configuration for the liveness check on the container. Example: `{"failureThreshold": 3,"initialDelaySeconds": 5,"successThreshold": 1,"timeoutSeconds": 1,"tcpSocket":{"host":"", "port":8080}}`. If you want to cancel this configuration, set this parameter to `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
        self.liveness = liveness
        # The configurations that are used when the host files are mounted to the container on which the application is running. Example: `[{"type":"","nodePath":"/localfiles","mountPath":"/app/files"},{"type":"Directory","nodePath":"/mnt","mountPath":"/app/storage"}\\]`. The nodePath parameter specifies the host path, the mountPath parameter specifies the path within the container, and the type parameter specifies the mounting type.
        self.local_volume = local_volume
        # Specifies whether to enable Graceful Rolling Release and configure Complete Service Registration before Readiness Probing. Valid values:
        # 
        # *   true: If you turn on the switch, the system uses the /health path and provides port 55199 for the health check. The system does not intrude into the application. When the service is registered, the system returns HTTP 200 status code. Otherwise, the system returns HTTP 500 status code.
        # 
        # > If you set both the LosslessRuleRelated parameter and this parameter to true, the operation checks whether the service prefetching is complete.
        # 
        # *   false: If you turn off the switch, the system does not provide a port to check whether the service is registered.
        self.lossless_rule_aligned = lossless_rule_aligned
        # The delay of service registration. Valid values: 0 to 86400. Unit: seconds.
        self.lossless_rule_delay_time = lossless_rule_delay_time
        # The number of prefetching curves. Valid values: 0 to 20. The default value is 2, which is suitable for common prefetching scenarios. This value indicates that the received traffic amount of the provider during prefetching is displayed as a quadratic curve.
        self.lossless_rule_func_type = lossless_rule_func_type
        # Specifies whether to enable Graceful Rolling Release and configure Complete Service Prefetching before Readiness Probing. Valid values:
        # 
        # *   true: If you turn on the switch, the system uses the /health path and provides port 55199 for the health check. The system does not intrude into the application. When service prefetching is complete, the system returns HTTP 200 status code. Otherwise, the system returns HTTP 500 status code.
        # *   false: If you turn off the switch, the system does not provide a port to check whether service prefetching is complete.
        self.lossless_rule_related = lossless_rule_related
        # The service prefetching duration. Valid values: 0 to 86400. Unit: seconds.
        self.lossless_rule_warmup_time = lossless_rule_warmup_time
        # The maximum number of CPU cores allowed. Unit: cores. Value 0 indicates that no limit is set on CPU cores.
        self.mcpu_limit = mcpu_limit
        # The minimum number of CPU cores required. Unit: cores. Value 0 indicates that no limit is set on CPU cores.
        # 
        # > You must set this parameter together with the CpuLimit parameter. Make sure that the value of this parameter does not exceed that of the CpuLimit parameter.
        self.mcpu_request = mcpu_request
        # The maximum size of memory allowed for each application instance when the application is running. Unit: MB. Value 0 indicates that no limit is set on the memory size.
        self.memory_limit = memory_limit
        # The size of memory requested for each application instance when the application is running. Unit: MB. We recommend that you set this parameter. If you do not want to apply for a memory quota, set this parameter to 0.
        # 
        # > You must set this parameter together with the MemoryLimit parameter. Make sure that the value of this parameter does not exceed that of the MemoryLimit parameter.
        self.memory_request = memory_request
        # The description of the NAS mounting configuration. Set this parameter to a serialized JSON string. Example: `[{"nasPath": "/k8s","mountPath": "/mnt"},{"nasPath": "/files","mountPath": "/app/files"}\\]`. The nasPath parameter specifies the file storage path, and the mountPath parameter specifies the path to mount the file system to the container in which the application is running.
        self.mount_descs = mount_descs
        # The ID of the File Storage NAS (NAS) file system mounted to the container in which the application is running. The NAS file system must be in the same region as the cluster. The NAS file system must have an available mount target, or have a mount target on the vSwitch in the virtual private cloud (VPC) in which the application resides. If you do not specify this parameter but specify the MountDescs parameter, a NAS file system is automatically purchased and mounted to the vSwitch in the VPC.
        self.nas_id = nas_id
        # The URL of the deployment package. This parameter is required if you use a FatJar or WAR package to deploy the application.
        # 
        # > The version of EDAS SDK for Java or Python must be V2.44.0 or later.
        self.package_url = package_url
        # The version of the deployment package. This parameter is required if you use a FatJar or WAR package to deploy the application. You must specify a version.
        # 
        # > The version of EDAS SDK for Java or Python must be V2.44.0 or later.
        self.package_version = package_version
        # The version ID of the deployment package.
        self.package_version_id = package_version_id
        # The post-start script. Example: `{"exec":{"command":["cat","/etc/group"\\]}}`. If you want to cancel this configuration, set this parameter to `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
        self.post_start = post_start
        # The pre-stop script. Example: `{"tcpSocket":{"host":"", "port":8080}}`. If you want to cancel this configuration, set this parameter to `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
        self.pre_stop = pre_stop
        # The configuration for mounting a Kubernetes PersistentVolumeClaim (PVC) to a directory in an elastic container instance. The following parameters are included in the configuration:
        # 
        # *   pvcName: the name of the PVC. Make sure that the volume exists and is in the Bound state.
        # 
        # *   mountPaths: the directory to which you want to mount the PVC. You can configure multiple directories. You can set the following two parameters for each mount directory:
        # 
        #     *   mountPath: the mount path. The mount path must be an absolute path that starts with a forward slash (/).
        #     *   readOnly: the mount mode. Value true indicates the read-only mode. Value false indicates the read and write mode. Default value: false.
        self.pvc_mount_descs = pvc_mount_descs
        # The configuration for the readiness check on the container. If the check fails, the traffic that passes through the Kubernetes service is not transmitted to the container. Example: `{"failureThreshold": 3,"initialDelaySeconds": 5,"successThreshold": 1,"timeoutSeconds": 1,"httpGet": {"path": "/consumer","port": 8080,"scheme": "HTTP","httpHeaders": [{"name": "test","value": "testvalue"}\\]}}`. If you want to cancel this configuration, set this parameter to `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
        self.readiness = readiness
        # The number of application instances. The minimum value is 0.
        self.replicas = replicas
        # The minimum size of space required by ephemeral storage. Unit: GB. Value 0 indicates that no limit is set on the ephemeral storage space.
        self.requests_ephemeral_storage = requests_ephemeral_storage
        # The type of the container runtime. Valid values:
        # 
        # *   runc: standard container runtime
        # *   runv: sandboxed container runtime
        # 
        # This parameter is applicable only to clusters that use sandboxed containers.
        self.runtime_class_name = runtime_class_name
        self.sidecars = sidecars
        # The Logstore configuration. If you want to cancel this configuration, leave the parameter value empty by entering `""` or `"{}"`.
        # 
        # *   The following parameters are included in the configuration:
        # 
        #     *   type: the collection type. Set this parameter to file to specify the file type. Set this parameter to stdout to specify the standard output type.
        # 
        #     *   logstore: the name of the Logstore. Make sure that the name of the Logstore is unique in the cluster. The name must comply with the following rules:
        # 
        #         *   The name can contain only lowercase letters, digits, hyphens (-), and underscores (_).
        #         *   The name must start and end with a lowercase letter or a digit.
        #         *   The name must be 3 to 63 characters in length. If you leave this parameter empty, the system automatically generates a name.
        # 
        #     *   logDir: If the standard output type is used, the collection path is stdout.log. If the file type is used, the collection path is the path of the collected file. Wildcards (\\*) are supported. The collection path must match the following regular expression: `^/(.+)/(.*)^/$`.
        self.sls_configs = sls_configs
        self.startup = startup
        # The storage type of the NAS file system.
        # 
        # *   Valid values for General-purpose NAS file systems: Capacity and Performance.
        # *   Valid values for Extreme NAS file systems: standard and advance.
        # 
        # You can set this parameter only to Performance.
        self.storage_type = storage_type
        self.terminate_grace_period = terminate_grace_period
        # The traffic adjustment policy for a canary release.
        self.traffic_control_strategy = traffic_control_strategy
        # The phased release policy.
        # 
        # *   Example 1: One instance for a canary release + Two subsequent batches + Automatic batching + 1-minute batch interval.
        # 
        # `{"type":"GrayBatchUpdate","batchUpdate":{"batch":2,"releaseType":"auto","batchWaitTime":1},"grayUpdate":{"gray":1}}`
        # 
        # *   Example 2: One instance for a canary release + Two subsequent batches + Manual batching.
        # 
        # `{"type":"GrayBatchUpdate","batchUpdate":{"batch":2,"releaseType":"manual"},"grayUpdate":{"gray":1}}`
        # 
        # *   Example 3: Two batches + Automatic batching + 0-minute batch interval.
        # 
        # `{"type":"BatchUpdate","batchUpdate":{"batch":2,"releaseType":"auto","batchWaitTime":0}}`
        self.update_strategy = update_strategy
        # The URI encoding scheme. Valid values: ISO-8859-1, GBK, GB2312, and UTF-8.
        # 
        # > If you do not specify this parameter in the application configurations, the default URI encoding scheme in the Tomcat container is applied.
        self.uri_encoding = uri_encoding
        # Specifies whether to use the encoding scheme specified in the request body for URI query parameters.
        # 
        # > If this parameter is not specified in application configuration, the default value false is applied.
        self.use_body_encoding = use_body_encoding
        self.user_base_image_url = user_base_image_url
        # The data volume.
        self.volumes_str = volumes_str
        # The version of the Tomcat container on which the deployment package of the application depends. This parameter is applicable to Spring Cloud and Dubbo applications that you deploy by using WAR packages. This parameter is unavailable if you deploy applications by using images.
        self.web_container = web_container
        # The Tomcat container configuration. If you want to cancel this configuration, set this parameter to `""` or `"{}"`. The following parameters are included in the configuration:
        # 
        # *   useDefaultConfig: specifies whether to use the default configuration. Value true indicates to use the default configuration. Value false indicates to use the custom configuration. If the default configuration is used, the following parameters do not take effect.
        # 
        # *   contextInputType: the type of the access path for the application. Valid values:
        # 
        #     *   war: The access path for the application is the name of the WAR package. You do not need to specify a custom path.
        #     *   root: The access path for the application is /. You do not need to specify a custom path.
        #     *   custom: If you select this option, you must specify a custom path for the contextPath parameter.
        # 
        # *   contextPath: the custom access path for the application. This parameter is required only when you set the contextInputType parameter to custom.
        # 
        # *   httpPort: the port number. The port number ranges from 1024 to 65535. Though the admin permissions are configured for the container, the root permissions are required to perform operations on ports whose number is less than 1024. Enter a value that ranges from 1025 to 65535 because the container has only the admin permissions. If you do not configure this parameter, the default port number 8080 is used.
        # 
        # *   maxThreads: the maximum number of connections in the connection pool. Default value: 400.
        # 
        #     **\
        # 
        #     **Note**This parameter greatly affects the application performance. We recommend that you set this parameter under professional guidance.
        # 
        # *   uriEncoding: the URI encoding scheme in the Tomcat container. Valid values: UTF-8, ISO-8859-1, GBK, and GB2312. If you do not specify this parameter, the default value ISO-8859-1 is used.
        # 
        # *   useBodyEncoding: specifies whether to use the encoding scheme specified in the request body for URI query parameters.
        # 
        # *   useAdvancedServerXml: specifies whether to use advanced configurations to customize the `server.xml` file. If the preceding parameter types and specific parameters cannot meet your requirements, you can use advanced configurations to customize the `server.xml` file of Tomcat.
        # 
        # *   serverXml: the content of the `server.xml` file customized by using advanced configurations. This parameter takes effect only when you set the useAdvancedServerXml parameter to true.
        self.web_container_config = web_container_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotations is not None:
            result['Annotations'] = self.annotations
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.args is not None:
            result['Args'] = self.args
        if self.batch_timeout is not None:
            result['BatchTimeout'] = self.batch_timeout
        if self.batch_wait_time is not None:
            result['BatchWaitTime'] = self.batch_wait_time
        if self.build_pack_id is not None:
            result['BuildPackId'] = self.build_pack_id
        if self.canary_rule_id is not None:
            result['CanaryRuleId'] = self.canary_rule_id
        if self.change_order_desc is not None:
            result['ChangeOrderDesc'] = self.change_order_desc
        if self.command is not None:
            result['Command'] = self.command
        if self.config_mount_descs is not None:
            result['ConfigMountDescs'] = self.config_mount_descs
        if self.cpu_limit is not None:
            result['CpuLimit'] = self.cpu_limit
        if self.cpu_request is not None:
            result['CpuRequest'] = self.cpu_request
        if self.custom_affinity is not None:
            result['CustomAffinity'] = self.custom_affinity
        if self.custom_agent_version is not None:
            result['CustomAgentVersion'] = self.custom_agent_version
        if self.custom_tolerations is not None:
            result['CustomTolerations'] = self.custom_tolerations
        if self.deploy_across_nodes is not None:
            result['DeployAcrossNodes'] = self.deploy_across_nodes
        if self.deploy_across_zones is not None:
            result['DeployAcrossZones'] = self.deploy_across_zones
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.empty_dirs is not None:
            result['EmptyDirs'] = self.empty_dirs
        if self.enable_ahas is not None:
            result['EnableAhas'] = self.enable_ahas
        if self.enable_empty_push_reject is not None:
            result['EnableEmptyPushReject'] = self.enable_empty_push_reject
        if self.enable_lossless_rule is not None:
            result['EnableLosslessRule'] = self.enable_lossless_rule
        if self.env_froms is not None:
            result['EnvFroms'] = self.env_froms
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.image is not None:
            result['Image'] = self.image
        if self.image_platforms is not None:
            result['ImagePlatforms'] = self.image_platforms
        if self.image_tag is not None:
            result['ImageTag'] = self.image_tag
        if self.init_containers is not None:
            result['InitContainers'] = self.init_containers
        if self.jdk is not None:
            result['JDK'] = self.jdk
        if self.java_start_up_config is not None:
            result['JavaStartUpConfig'] = self.java_start_up_config
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.limit_ephemeral_storage is not None:
            result['LimitEphemeralStorage'] = self.limit_ephemeral_storage
        if self.liveness is not None:
            result['Liveness'] = self.liveness
        if self.local_volume is not None:
            result['LocalVolume'] = self.local_volume
        if self.lossless_rule_aligned is not None:
            result['LosslessRuleAligned'] = self.lossless_rule_aligned
        if self.lossless_rule_delay_time is not None:
            result['LosslessRuleDelayTime'] = self.lossless_rule_delay_time
        if self.lossless_rule_func_type is not None:
            result['LosslessRuleFuncType'] = self.lossless_rule_func_type
        if self.lossless_rule_related is not None:
            result['LosslessRuleRelated'] = self.lossless_rule_related
        if self.lossless_rule_warmup_time is not None:
            result['LosslessRuleWarmupTime'] = self.lossless_rule_warmup_time
        if self.mcpu_limit is not None:
            result['McpuLimit'] = self.mcpu_limit
        if self.mcpu_request is not None:
            result['McpuRequest'] = self.mcpu_request
        if self.memory_limit is not None:
            result['MemoryLimit'] = self.memory_limit
        if self.memory_request is not None:
            result['MemoryRequest'] = self.memory_request
        if self.mount_descs is not None:
            result['MountDescs'] = self.mount_descs
        if self.nas_id is not None:
            result['NasId'] = self.nas_id
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.package_version_id is not None:
            result['PackageVersionId'] = self.package_version_id
        if self.post_start is not None:
            result['PostStart'] = self.post_start
        if self.pre_stop is not None:
            result['PreStop'] = self.pre_stop
        if self.pvc_mount_descs is not None:
            result['PvcMountDescs'] = self.pvc_mount_descs
        if self.readiness is not None:
            result['Readiness'] = self.readiness
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.requests_ephemeral_storage is not None:
            result['RequestsEphemeralStorage'] = self.requests_ephemeral_storage
        if self.runtime_class_name is not None:
            result['RuntimeClassName'] = self.runtime_class_name
        if self.sidecars is not None:
            result['Sidecars'] = self.sidecars
        if self.sls_configs is not None:
            result['SlsConfigs'] = self.sls_configs
        if self.startup is not None:
            result['Startup'] = self.startup
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        if self.terminate_grace_period is not None:
            result['TerminateGracePeriod'] = self.terminate_grace_period
        if self.traffic_control_strategy is not None:
            result['TrafficControlStrategy'] = self.traffic_control_strategy
        if self.update_strategy is not None:
            result['UpdateStrategy'] = self.update_strategy
        if self.uri_encoding is not None:
            result['UriEncoding'] = self.uri_encoding
        if self.use_body_encoding is not None:
            result['UseBodyEncoding'] = self.use_body_encoding
        if self.user_base_image_url is not None:
            result['UserBaseImageUrl'] = self.user_base_image_url
        if self.volumes_str is not None:
            result['VolumesStr'] = self.volumes_str
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        if self.web_container_config is not None:
            result['WebContainerConfig'] = self.web_container_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Annotations') is not None:
            self.annotations = m.get('Annotations')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Args') is not None:
            self.args = m.get('Args')
        if m.get('BatchTimeout') is not None:
            self.batch_timeout = m.get('BatchTimeout')
        if m.get('BatchWaitTime') is not None:
            self.batch_wait_time = m.get('BatchWaitTime')
        if m.get('BuildPackId') is not None:
            self.build_pack_id = m.get('BuildPackId')
        if m.get('CanaryRuleId') is not None:
            self.canary_rule_id = m.get('CanaryRuleId')
        if m.get('ChangeOrderDesc') is not None:
            self.change_order_desc = m.get('ChangeOrderDesc')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('ConfigMountDescs') is not None:
            self.config_mount_descs = m.get('ConfigMountDescs')
        if m.get('CpuLimit') is not None:
            self.cpu_limit = m.get('CpuLimit')
        if m.get('CpuRequest') is not None:
            self.cpu_request = m.get('CpuRequest')
        if m.get('CustomAffinity') is not None:
            self.custom_affinity = m.get('CustomAffinity')
        if m.get('CustomAgentVersion') is not None:
            self.custom_agent_version = m.get('CustomAgentVersion')
        if m.get('CustomTolerations') is not None:
            self.custom_tolerations = m.get('CustomTolerations')
        if m.get('DeployAcrossNodes') is not None:
            self.deploy_across_nodes = m.get('DeployAcrossNodes')
        if m.get('DeployAcrossZones') is not None:
            self.deploy_across_zones = m.get('DeployAcrossZones')
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('EmptyDirs') is not None:
            self.empty_dirs = m.get('EmptyDirs')
        if m.get('EnableAhas') is not None:
            self.enable_ahas = m.get('EnableAhas')
        if m.get('EnableEmptyPushReject') is not None:
            self.enable_empty_push_reject = m.get('EnableEmptyPushReject')
        if m.get('EnableLosslessRule') is not None:
            self.enable_lossless_rule = m.get('EnableLosslessRule')
        if m.get('EnvFroms') is not None:
            self.env_froms = m.get('EnvFroms')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ImagePlatforms') is not None:
            self.image_platforms = m.get('ImagePlatforms')
        if m.get('ImageTag') is not None:
            self.image_tag = m.get('ImageTag')
        if m.get('InitContainers') is not None:
            self.init_containers = m.get('InitContainers')
        if m.get('JDK') is not None:
            self.jdk = m.get('JDK')
        if m.get('JavaStartUpConfig') is not None:
            self.java_start_up_config = m.get('JavaStartUpConfig')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('LimitEphemeralStorage') is not None:
            self.limit_ephemeral_storage = m.get('LimitEphemeralStorage')
        if m.get('Liveness') is not None:
            self.liveness = m.get('Liveness')
        if m.get('LocalVolume') is not None:
            self.local_volume = m.get('LocalVolume')
        if m.get('LosslessRuleAligned') is not None:
            self.lossless_rule_aligned = m.get('LosslessRuleAligned')
        if m.get('LosslessRuleDelayTime') is not None:
            self.lossless_rule_delay_time = m.get('LosslessRuleDelayTime')
        if m.get('LosslessRuleFuncType') is not None:
            self.lossless_rule_func_type = m.get('LosslessRuleFuncType')
        if m.get('LosslessRuleRelated') is not None:
            self.lossless_rule_related = m.get('LosslessRuleRelated')
        if m.get('LosslessRuleWarmupTime') is not None:
            self.lossless_rule_warmup_time = m.get('LosslessRuleWarmupTime')
        if m.get('McpuLimit') is not None:
            self.mcpu_limit = m.get('McpuLimit')
        if m.get('McpuRequest') is not None:
            self.mcpu_request = m.get('McpuRequest')
        if m.get('MemoryLimit') is not None:
            self.memory_limit = m.get('MemoryLimit')
        if m.get('MemoryRequest') is not None:
            self.memory_request = m.get('MemoryRequest')
        if m.get('MountDescs') is not None:
            self.mount_descs = m.get('MountDescs')
        if m.get('NasId') is not None:
            self.nas_id = m.get('NasId')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('PackageVersionId') is not None:
            self.package_version_id = m.get('PackageVersionId')
        if m.get('PostStart') is not None:
            self.post_start = m.get('PostStart')
        if m.get('PreStop') is not None:
            self.pre_stop = m.get('PreStop')
        if m.get('PvcMountDescs') is not None:
            self.pvc_mount_descs = m.get('PvcMountDescs')
        if m.get('Readiness') is not None:
            self.readiness = m.get('Readiness')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('RequestsEphemeralStorage') is not None:
            self.requests_ephemeral_storage = m.get('RequestsEphemeralStorage')
        if m.get('RuntimeClassName') is not None:
            self.runtime_class_name = m.get('RuntimeClassName')
        if m.get('Sidecars') is not None:
            self.sidecars = m.get('Sidecars')
        if m.get('SlsConfigs') is not None:
            self.sls_configs = m.get('SlsConfigs')
        if m.get('Startup') is not None:
            self.startup = m.get('Startup')
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        if m.get('TerminateGracePeriod') is not None:
            self.terminate_grace_period = m.get('TerminateGracePeriod')
        if m.get('TrafficControlStrategy') is not None:
            self.traffic_control_strategy = m.get('TrafficControlStrategy')
        if m.get('UpdateStrategy') is not None:
            self.update_strategy = m.get('UpdateStrategy')
        if m.get('UriEncoding') is not None:
            self.uri_encoding = m.get('UriEncoding')
        if m.get('UseBodyEncoding') is not None:
            self.use_body_encoding = m.get('UseBodyEncoding')
        if m.get('UserBaseImageUrl') is not None:
            self.user_base_image_url = m.get('UserBaseImageUrl')
        if m.get('VolumesStr') is not None:
            self.volumes_str = m.get('VolumesStr')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        if m.get('WebContainerConfig') is not None:
            self.web_container_config = m.get('WebContainerConfig')
        return self


class DeployK8sApplicationResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process. You can call the GetChangeOrderInfo operation to query the change process ID. For more information, see [GetChangeOrderInfo](https://help.aliyun.com/document_detail/62072.html).
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeployK8sApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeployK8sApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeployK8sApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAppInstanceListRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        with_node_info: bool = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the ID of the application. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # Specifies whether to return the information about the node in which the pod resides.
        # 
        # *   `true`: returns the information about the node in which the pod resides
        # *   `false`: does not return the information about the node in which the pod resides
        self.with_node_info = with_node_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.with_node_info is not None:
            result['WithNodeInfo'] = self.with_node_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('WithNodeInfo') is not None:
            self.with_node_info = m.get('WithNodeInfo')
        return self


class DescribeAppInstanceListResponseBodyInstanceList(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        canary: bool = None,
        group_id: str = None,
        group_name: str = None,
        node_labels: str = None,
        node_name: str = None,
        pod_raw: str = None,
        version: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # Indicates whether the application was released in canary release mode.
        # 
        # *   `true`: The application was released in canary release mode.
        # *   `false`: The application was not released in canary release mode
        self.canary = canary
        # The ID of the instance group to which the application is deployed.
        self.group_id = group_id
        # The name of the instance group to which the application is deployed.
        self.group_name = group_name
        # The labels of the node. The value is a JSON string.
        self.node_labels = node_labels
        # The name of the node.
        self.node_name = node_name
        # The information about the pod. The value is a JSON string.
        self.pod_raw = pod_raw
        # The deployment package version of the node.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.canary is not None:
            result['Canary'] = self.canary
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.node_labels is not None:
            result['NodeLabels'] = self.node_labels
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.pod_raw is not None:
            result['PodRaw'] = self.pod_raw
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Canary') is not None:
            self.canary = m.get('Canary')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('NodeLabels') is not None:
            self.node_labels = m.get('NodeLabels')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('PodRaw') is not None:
            self.pod_raw = m.get('PodRaw')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribeAppInstanceListResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        instance_list: List[DescribeAppInstanceListResponseBodyInstanceList] = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The application instances.
        self.instance_list = instance_list
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.instance_list:
            for k in self.instance_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['InstanceList'] = []
        if self.instance_list is not None:
            for k in self.instance_list:
                result['InstanceList'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.instance_list = []
        if m.get('InstanceList') is not None:
            for k in m.get('InstanceList'):
                temp_model = DescribeAppInstanceListResponseBodyInstanceList()
                self.instance_list.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAppInstanceListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAppInstanceListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAppInstanceListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApplicationScalingRulesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies(TeaModel):
    def __init__(
        self,
        period_seconds: int = None,
        type: str = None,
        value: str = None,
    ):
        self.period_seconds = period_seconds
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.period_seconds is not None:
            result['PeriodSeconds'] = self.period_seconds
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PeriodSeconds') is not None:
            self.period_seconds = m.get('PeriodSeconds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown(TeaModel):
    def __init__(
        self,
        policies: List[DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies] = None,
        select_policy: str = None,
        stabilization_window_seconds: int = None,
    ):
        self.policies = policies
        self.select_policy = select_policy
        self.stabilization_window_seconds = stabilization_window_seconds

    def validate(self):
        if self.policies:
            for k in self.policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Policies'] = []
        if self.policies is not None:
            for k in self.policies:
                result['Policies'].append(k.to_map() if k else None)
        if self.select_policy is not None:
            result['SelectPolicy'] = self.select_policy
        if self.stabilization_window_seconds is not None:
            result['StabilizationWindowSeconds'] = self.stabilization_window_seconds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.policies = []
        if m.get('Policies') is not None:
            for k in m.get('Policies'):
                temp_model = DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies()
                self.policies.append(temp_model.from_map(k))
        if m.get('SelectPolicy') is not None:
            self.select_policy = m.get('SelectPolicy')
        if m.get('StabilizationWindowSeconds') is not None:
            self.stabilization_window_seconds = m.get('StabilizationWindowSeconds')
        return self


class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies(TeaModel):
    def __init__(
        self,
        period_seconds: int = None,
        type: str = None,
        value: str = None,
    ):
        self.period_seconds = period_seconds
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.period_seconds is not None:
            result['PeriodSeconds'] = self.period_seconds
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PeriodSeconds') is not None:
            self.period_seconds = m.get('PeriodSeconds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp(TeaModel):
    def __init__(
        self,
        policies: List[DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies] = None,
        select_policy: str = None,
        stabilization_window_seconds: int = None,
    ):
        self.policies = policies
        self.select_policy = select_policy
        self.stabilization_window_seconds = stabilization_window_seconds

    def validate(self):
        if self.policies:
            for k in self.policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Policies'] = []
        if self.policies is not None:
            for k in self.policies:
                result['Policies'].append(k.to_map() if k else None)
        if self.select_policy is not None:
            result['SelectPolicy'] = self.select_policy
        if self.stabilization_window_seconds is not None:
            result['StabilizationWindowSeconds'] = self.stabilization_window_seconds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.policies = []
        if m.get('Policies') is not None:
            for k in m.get('Policies'):
                temp_model = DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies()
                self.policies.append(temp_model.from_map(k))
        if m.get('SelectPolicy') is not None:
            self.select_policy = m.get('SelectPolicy')
        if m.get('StabilizationWindowSeconds') is not None:
            self.stabilization_window_seconds = m.get('StabilizationWindowSeconds')
        return self


class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviour(TeaModel):
    def __init__(
        self,
        scale_down: DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown = None,
        scale_up: DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp = None,
    ):
        self.scale_down = scale_down
        self.scale_up = scale_up

    def validate(self):
        if self.scale_down:
            self.scale_down.validate()
        if self.scale_up:
            self.scale_up.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.scale_down is not None:
            result['ScaleDown'] = self.scale_down.to_map()
        if self.scale_up is not None:
            result['ScaleUp'] = self.scale_up.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ScaleDown') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown()
            self.scale_down = temp_model.from_map(m['ScaleDown'])
        if m.get('ScaleUp') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp()
            self.scale_up = temp_model.from_map(m['ScaleUp'])
        return self


class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics(TeaModel):
    def __init__(
        self,
        metric_target_average_utilization: int = None,
        metric_type: str = None,
    ):
        # This parameter is deprecated.
        self.metric_target_average_utilization = metric_target_average_utilization
        # This parameter is deprecated.
        self.metric_type = metric_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_target_average_utilization is not None:
            result['MetricTargetAverageUtilization'] = self.metric_target_average_utilization
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetricTargetAverageUtilization') is not None:
            self.metric_target_average_utilization = m.get('MetricTargetAverageUtilization')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        return self


class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric(TeaModel):
    def __init__(
        self,
        max_replicas: int = None,
        metrics: List[DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics] = None,
        min_replicas: int = None,
    ):
        # This parameter is deprecated.
        self.max_replicas = max_replicas
        # This parameter is deprecated.
        self.metrics = metrics
        # This parameter is deprecated.
        self.min_replicas = min_replicas

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics()
                self.metrics.append(temp_model.from_map(k))
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        return self


class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers(TeaModel):
    def __init__(
        self,
        meta_data: str = None,
        name: str = None,
        type: str = None,
    ):
        # The metadata of the trigger.
        self.meta_data = meta_data
        # The name of the trigger.
        self.name = name
        # The type of the trigger. Valid values: cron and app_metric.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.meta_data is not None:
            result['MetaData'] = self.meta_data
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetaData') is not None:
            self.meta_data = m.get('MetaData')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger(TeaModel):
    def __init__(
        self,
        max_replicas: int = None,
        min_replicas: int = None,
        triggers: List[DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers] = None,
    ):
        # The maximum number of replicas. The upper limit is 1000.
        self.max_replicas = max_replicas
        # The minimum number of replicas. The lower limit is 0.
        self.min_replicas = min_replicas
        # The configurations of the trigger.
        self.triggers = triggers

    def validate(self):
        if self.triggers:
            for k in self.triggers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        result['Triggers'] = []
        if self.triggers is not None:
            for k in self.triggers:
                result['Triggers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        self.triggers = []
        if m.get('Triggers') is not None:
            for k in m.get('Triggers'):
                temp_model = DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers()
                self.triggers.append(temp_model.from_map(k))
        return self


class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        behaviour: DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviour = None,
        create_time: int = None,
        last_disable_time: int = None,
        max_replicas: int = None,
        metric: DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric = None,
        min_replicas: int = None,
        scale_rule_enabled: bool = None,
        scale_rule_name: str = None,
        scale_rule_type: str = None,
        trigger: DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger = None,
        update_time: int = None,
    ):
        # The ID of the application to which the auto scaling policy belongs.
        self.app_id = app_id
        self.behaviour = behaviour
        # The time when the auto scaling policy was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The time when the auto scaling policy was last disabled. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.last_disable_time = last_disable_time
        # This parameter is deprecated.
        self.max_replicas = max_replicas
        # This parameter is deprecated.
        self.metric = metric
        # This parameter is deprecated.
        self.min_replicas = min_replicas
        # Indicates whether the auto scaling policy is enabled. Valid values:
        # 
        # *   **true**: The auto scaling policy is enabled.
        # *   **false**: The auto scaling policy is disabled.
        self.scale_rule_enabled = scale_rule_enabled
        # The name of the auto scaling policy.
        self.scale_rule_name = scale_rule_name
        # The type of the auto scaling policy. The value is fixed to trigger.
        self.scale_rule_type = scale_rule_type
        # The configurations of the trigger.
        self.trigger = trigger
        # The time when the auto scaling policy was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time

    def validate(self):
        if self.behaviour:
            self.behaviour.validate()
        if self.metric:
            self.metric.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.behaviour is not None:
            result['Behaviour'] = self.behaviour.to_map()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_disable_time is not None:
            result['LastDisableTime'] = self.last_disable_time
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.metric is not None:
            result['Metric'] = self.metric.to_map()
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        if self.scale_rule_enabled is not None:
            result['ScaleRuleEnabled'] = self.scale_rule_enabled
        if self.scale_rule_name is not None:
            result['ScaleRuleName'] = self.scale_rule_name
        if self.scale_rule_type is not None:
            result['ScaleRuleType'] = self.scale_rule_type
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Behaviour') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviour()
            self.behaviour = temp_model.from_map(m['Behaviour'])
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastDisableTime') is not None:
            self.last_disable_time = m.get('LastDisableTime')
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('Metric') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric()
            self.metric = temp_model.from_map(m['Metric'])
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        if m.get('ScaleRuleEnabled') is not None:
            self.scale_rule_enabled = m.get('ScaleRuleEnabled')
        if m.get('ScaleRuleName') is not None:
            self.scale_rule_name = m.get('ScaleRuleName')
        if m.get('ScaleRuleType') is not None:
            self.scale_rule_type = m.get('ScaleRuleType')
        if m.get('Trigger') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeApplicationScalingRulesResponseBodyAppScalingRules(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        result: List[DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult] = None,
        total_size: int = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # The number of auto scaling policies returned per page.
        self.page_size = page_size
        # The information about auto scaling policies.
        self.result = result
        # The total number of auto scaling policies.
        self.total_size = total_size

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Result'] = []
        if self.result is not None:
            for k in self.result:
                result['Result'].append(k.to_map() if k else None)
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.result = []
        if m.get('Result') is not None:
            for k in m.get('Result'):
                temp_model = DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult()
                self.result.append(temp_model.from_map(k))
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class DescribeApplicationScalingRulesResponseBody(TeaModel):
    def __init__(
        self,
        app_scaling_rules: DescribeApplicationScalingRulesResponseBodyAppScalingRules = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The auto scaling policies of the application.
        self.app_scaling_rules = app_scaling_rules
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.app_scaling_rules:
            self.app_scaling_rules.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_scaling_rules is not None:
            result['AppScalingRules'] = self.app_scaling_rules.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppScalingRules') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBodyAppScalingRules()
            self.app_scaling_rules = temp_model.from_map(m['AppScalingRules'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeApplicationScalingRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApplicationScalingRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableApplicationScalingRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        scaling_rule_name: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        self.app_id = app_id
        # The name of the auto scaling policy.
        self.scaling_rule_name = scaling_rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        return self


class DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics(TeaModel):
    def __init__(
        self,
        metric_target_average_utilization: int = None,
        metric_type: str = None,
    ):
        # This parameter is deprecated.
        self.metric_target_average_utilization = metric_target_average_utilization
        # This parameter is deprecated.
        self.metric_type = metric_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_target_average_utilization is not None:
            result['MetricTargetAverageUtilization'] = self.metric_target_average_utilization
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetricTargetAverageUtilization') is not None:
            self.metric_target_average_utilization = m.get('MetricTargetAverageUtilization')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        return self


class DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric(TeaModel):
    def __init__(
        self,
        max_replicas: int = None,
        metrics: List[DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics] = None,
        min_replicas: int = None,
    ):
        # This parameter is deprecated.
        self.max_replicas = max_replicas
        # This parameter is deprecated.
        self.metrics = metrics
        # This parameter is deprecated.
        self.min_replicas = min_replicas

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics()
                self.metrics.append(temp_model.from_map(k))
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        return self


class DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers(TeaModel):
    def __init__(
        self,
        meta_data: str = None,
        name: str = None,
        type: str = None,
    ):
        # The metadata of the trigger.
        self.meta_data = meta_data
        # The name of the trigger.
        self.name = name
        # The type of the trigger. Valid values: cron and app_metric.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.meta_data is not None:
            result['MetaData'] = self.meta_data
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetaData') is not None:
            self.meta_data = m.get('MetaData')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger(TeaModel):
    def __init__(
        self,
        max_replicas: int = None,
        min_replicas: int = None,
        triggers: List[DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers] = None,
    ):
        # The maximum number of replicas. The upper limit is 1000.
        self.max_replicas = max_replicas
        # The minimum number of replicas. The lower limit is 0.
        self.min_replicas = min_replicas
        # The information about the trigger.
        self.triggers = triggers

    def validate(self):
        if self.triggers:
            for k in self.triggers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        result['Triggers'] = []
        if self.triggers is not None:
            for k in self.triggers:
                result['Triggers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        self.triggers = []
        if m.get('Triggers') is not None:
            for k in m.get('Triggers'):
                temp_model = DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers()
                self.triggers.append(temp_model.from_map(k))
        return self


class DisableApplicationScalingRuleResponseBodyAppScalingRule(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        create_time: int = None,
        last_disable_time: int = None,
        max_replicas: int = None,
        metric: DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric = None,
        min_replicas: int = None,
        scale_rule_enabled: bool = None,
        scale_rule_name: str = None,
        scale_rule_type: str = None,
        trigger: DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger = None,
        update_time: int = None,
    ):
        # The ID of the application to which the auto scaling policy belongs.
        self.app_id = app_id
        # The time when the auto scaling policy was created.
        self.create_time = create_time
        # The time when the auto scaling policy was last disabled.
        self.last_disable_time = last_disable_time
        # This parameter is deprecated.
        self.max_replicas = max_replicas
        # This parameter is deprecated.
        self.metric = metric
        # This parameter is deprecated.
        self.min_replicas = min_replicas
        # Indicates whether the auto scaling policy is enabled. Valid values:
        # 
        # *   **true**: The auto scaling policy is enabled.
        # *   **false**: The auto scaling policy is disabled.
        self.scale_rule_enabled = scale_rule_enabled
        # The name of the auto scaling policy.
        self.scale_rule_name = scale_rule_name
        # The type of the auto scaling policy. The value is fixed to trigger.
        self.scale_rule_type = scale_rule_type
        # The configurations of the trigger.
        self.trigger = trigger
        # The time when the auto scaling policy was last modified.
        self.update_time = update_time

    def validate(self):
        if self.metric:
            self.metric.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_disable_time is not None:
            result['LastDisableTime'] = self.last_disable_time
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.metric is not None:
            result['Metric'] = self.metric.to_map()
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        if self.scale_rule_enabled is not None:
            result['ScaleRuleEnabled'] = self.scale_rule_enabled
        if self.scale_rule_name is not None:
            result['ScaleRuleName'] = self.scale_rule_name
        if self.scale_rule_type is not None:
            result['ScaleRuleType'] = self.scale_rule_type
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastDisableTime') is not None:
            self.last_disable_time = m.get('LastDisableTime')
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('Metric') is not None:
            temp_model = DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric()
            self.metric = temp_model.from_map(m['Metric'])
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        if m.get('ScaleRuleEnabled') is not None:
            self.scale_rule_enabled = m.get('ScaleRuleEnabled')
        if m.get('ScaleRuleName') is not None:
            self.scale_rule_name = m.get('ScaleRuleName')
        if m.get('ScaleRuleType') is not None:
            self.scale_rule_type = m.get('ScaleRuleType')
        if m.get('Trigger') is not None:
            temp_model = DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DisableApplicationScalingRuleResponseBody(TeaModel):
    def __init__(
        self,
        app_scaling_rule: DisableApplicationScalingRuleResponseBodyAppScalingRule = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The information about the auto scaling policy.
        self.app_scaling_rule = app_scaling_rule
        # The HTTP status code.
        self.code = code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.app_scaling_rule:
            self.app_scaling_rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_scaling_rule is not None:
            result['AppScalingRule'] = self.app_scaling_rule.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppScalingRule') is not None:
            temp_model = DisableApplicationScalingRuleResponseBodyAppScalingRule()
            self.app_scaling_rule = temp_model.from_map(m['AppScalingRule'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DisableApplicationScalingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableApplicationScalingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableApplicationScalingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableApplicationScalingRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        scaling_rule_name: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        self.app_id = app_id
        # The name of the auto scaling policy.
        self.scaling_rule_name = scaling_rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        return self


class EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics(TeaModel):
    def __init__(
        self,
        metric_target_average_utilization: int = None,
        metric_type: str = None,
    ):
        # This parameter is deprecated.
        self.metric_target_average_utilization = metric_target_average_utilization
        # This parameter is deprecated.
        self.metric_type = metric_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_target_average_utilization is not None:
            result['MetricTargetAverageUtilization'] = self.metric_target_average_utilization
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetricTargetAverageUtilization') is not None:
            self.metric_target_average_utilization = m.get('MetricTargetAverageUtilization')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        return self


class EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric(TeaModel):
    def __init__(
        self,
        max_replicas: int = None,
        metrics: List[EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics] = None,
        min_replicas: int = None,
    ):
        # This parameter is deprecated.
        self.max_replicas = max_replicas
        # This parameter is deprecated.
        self.metrics = metrics
        # This parameter is deprecated.
        self.min_replicas = min_replicas

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics()
                self.metrics.append(temp_model.from_map(k))
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        return self


class EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers(TeaModel):
    def __init__(
        self,
        meta_data: str = None,
        name: str = None,
        type: str = None,
    ):
        # The metadata of the trigger.
        self.meta_data = meta_data
        # The name of the trigger.
        self.name = name
        # The type of the trigger. Valid values: cron and app_metric.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.meta_data is not None:
            result['MetaData'] = self.meta_data
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetaData') is not None:
            self.meta_data = m.get('MetaData')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger(TeaModel):
    def __init__(
        self,
        max_replicas: int = None,
        min_replicas: int = None,
        triggers: List[EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers] = None,
    ):
        # The maximum number of replicas. The upper limit is 1000.
        self.max_replicas = max_replicas
        # The minimum number of replicas. The lower limit is 0.
        self.min_replicas = min_replicas
        # The list of triggers.
        self.triggers = triggers

    def validate(self):
        if self.triggers:
            for k in self.triggers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        result['Triggers'] = []
        if self.triggers is not None:
            for k in self.triggers:
                result['Triggers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        self.triggers = []
        if m.get('Triggers') is not None:
            for k in m.get('Triggers'):
                temp_model = EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers()
                self.triggers.append(temp_model.from_map(k))
        return self


class EnableApplicationScalingRuleResponseBodyAppScalingRule(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        create_time: int = None,
        last_disable_time: int = None,
        max_replicas: int = None,
        metric: EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric = None,
        min_replicas: int = None,
        scale_rule_enabled: bool = None,
        scale_rule_name: str = None,
        scale_rule_type: str = None,
        trigger: EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger = None,
        update_time: int = None,
    ):
        # The ID of the application to which the auto scaling policy belongs.
        self.app_id = app_id
        # The time when the auto scaling policy was created.
        self.create_time = create_time
        # The time when the auto scaling policy was last disabled.
        self.last_disable_time = last_disable_time
        # This parameter is deprecated.
        self.max_replicas = max_replicas
        # This parameter is deprecated.
        self.metric = metric
        # This parameter is deprecated.
        self.min_replicas = min_replicas
        # Indicates whether the auto scaling policy is enabled. Valid values:
        # 
        # *   **true**: The auto scaling policy is enabled.
        # *   **false**: The auto scaling policy is disabled.
        self.scale_rule_enabled = scale_rule_enabled
        # The name of the auto scaling policy.
        self.scale_rule_name = scale_rule_name
        # The type of the auto scaling policy. The value is fixed to trigger.
        self.scale_rule_type = scale_rule_type
        # The configurations of the trigger.
        self.trigger = trigger
        # The time when the auto scaling policy was last modified.
        self.update_time = update_time

    def validate(self):
        if self.metric:
            self.metric.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_disable_time is not None:
            result['LastDisableTime'] = self.last_disable_time
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.metric is not None:
            result['Metric'] = self.metric.to_map()
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        if self.scale_rule_enabled is not None:
            result['ScaleRuleEnabled'] = self.scale_rule_enabled
        if self.scale_rule_name is not None:
            result['ScaleRuleName'] = self.scale_rule_name
        if self.scale_rule_type is not None:
            result['ScaleRuleType'] = self.scale_rule_type
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastDisableTime') is not None:
            self.last_disable_time = m.get('LastDisableTime')
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('Metric') is not None:
            temp_model = EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric()
            self.metric = temp_model.from_map(m['Metric'])
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        if m.get('ScaleRuleEnabled') is not None:
            self.scale_rule_enabled = m.get('ScaleRuleEnabled')
        if m.get('ScaleRuleName') is not None:
            self.scale_rule_name = m.get('ScaleRuleName')
        if m.get('ScaleRuleType') is not None:
            self.scale_rule_type = m.get('ScaleRuleType')
        if m.get('Trigger') is not None:
            temp_model = EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class EnableApplicationScalingRuleResponseBody(TeaModel):
    def __init__(
        self,
        app_scaling_rule: EnableApplicationScalingRuleResponseBodyAppScalingRule = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The information about the auto scaling policy.
        self.app_scaling_rule = app_scaling_rule
        # The HTTP status code.
        self.code = code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.app_scaling_rule:
            self.app_scaling_rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_scaling_rule is not None:
            result['AppScalingRule'] = self.app_scaling_rule.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppScalingRule') is not None:
            temp_model = EnableApplicationScalingRuleResponseBodyAppScalingRule()
            self.app_scaling_rule = temp_model.from_map(m['AppScalingRule'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class EnableApplicationScalingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableApplicationScalingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableApplicationScalingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAppDeploymentRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class GetAppDeploymentResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The information about the Deployment of the application. The value is a JSON string.
        self.data = data
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAppDeploymentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAppDeploymentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAppDeploymentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class GetApplicationResponseBodyApplication(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_phase: str = None,
        application_type: str = None,
        build_package_id: int = None,
        cluster_id: str = None,
        cluster_type: str = None,
        cpu: int = None,
        create_time: int = None,
        description: str = None,
        dockerize: bool = None,
        email: str = None,
        enable_port_check: bool = None,
        enable_url_check: bool = None,
        ext_slb_id: str = None,
        ext_slb_ip: str = None,
        ext_slb_name: str = None,
        have_manage_access: str = None,
        health_check_url: str = None,
        instance_count: int = None,
        memory: int = None,
        name: str = None,
        name_space: str = None,
        owner: str = None,
        port: int = None,
        region_id: str = None,
        resource_group_id: str = None,
        running_instance_count: int = None,
        slb_id: str = None,
        slb_info: str = None,
        slb_ip: str = None,
        slb_name: str = None,
        slb_port: int = None,
        user_id: str = None,
        workload_type: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The current status of the Kubernetes application, which is used to determine whether the application is in a stable state. If the application is in an unstable state, related configuration operations are prohibited. Valid values:
        # 
        # *   ready: The application is in the ready state and can be changed.
        # *   progressive: The application is being changed.
        # *   pending: The application change is blocked.
        # *   failed: The application fails to be changed.
        # 
        # In these states, ready is a stable state and other states are unstable.
        self.app_phase = app_phase
        # The deployment type of the application. Valid values:
        # 
        # *   War: The application is deployed by using a WAR package.
        # *   FatJar: The application is deployed by using a JAR package.
        # *   Empty: The application is not deployed.
        self.application_type = application_type
        # The build package number of Enterprise Distributed Application Service (EDAS) Container.
        self.build_package_id = build_package_id
        # The ID of the ECS cluster in which the application is deployed.
        self.cluster_id = cluster_id
        # The type of the cluster. Valid values:
        # 
        # *   0: regular Docker cluster
        # *   1: Swarm cluster
        # *   2: ECS cluster
        # *   3: Kubernetes cluster
        # *   4: cluster in which Pandora automatically registers applications
        self.cluster_type = cluster_type
        # The number of CPU cores.
        self.cpu = cpu
        # The time when the application was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The description of the application.
        self.description = description
        # Indicates whether the application is a Docker application. Valid values:
        # 
        # *   false: The application is not a Docker application.
        # *   true: The application is a Docker application.
        self.dockerize = dockerize
        # The email address of the account.
        self.email = email
        # Indicates whether the port health check is enabled. Valid values:
        # 
        # *   true: The port health check is enabled.
        # *   false: The port health check is disabled.
        # 
        # If the port health check is enabled, EDAS checks whether a port exists during application startup. If the port exists, the application is considered to have started.
        self.enable_port_check = enable_port_check
        # Indicates whether the URL health check is enabled. Valid values:
        # 
        # *   true: The URL health check is enabled.
        # *   false: The URL health check is disabled.
        # 
        # If the URL health check is enabled, EDAS attempts to detect the specified URL during application startup. If EDAS detects the specified URL, the application is considered to have started.
        self.enable_url_check = enable_url_check
        # The ID of the Internet-facing SLB instance that is bound to the application.
        self.ext_slb_id = ext_slb_id
        # The IP address of the Internet-facing Server Load Balancer (SLB) instance that is bound to the application.
        self.ext_slb_ip = ext_slb_ip
        # The name of the Internet-facing SLB instance that is bound to the application.
        self.ext_slb_name = ext_slb_name
        self.have_manage_access = have_manage_access
        # The health check URL of the application.
        self.health_check_url = health_check_url
        # The number of instances deployed with the application.
        self.instance_count = instance_count
        # The memory size of the application instance. Unit: MB.
        self.memory = memory
        # The name of the application.
        self.name = name
        # The namespace to which the application belongs.
        self.name_space = name_space
        # The ID of the user who created the application.
        self.owner = owner
        # The service port of the application.
        self.port = port
        # The ID of the region in which the application is deployed.
        self.region_id = region_id
        self.resource_group_id = resource_group_id
        # The number of running instances for the application.
        self.running_instance_count = running_instance_count
        # The ID of the internal-facing SLB instance that is bound to the application.
        self.slb_id = slb_id
        # The information about the internal-facing SLB instance that is bound to the application.
        self.slb_info = slb_info
        # The IP address of the internal-facing SLB instance that is bound to the application.
        self.slb_ip = slb_ip
        # The name of the internal-facing SLB instance that is bound to the application.
        self.slb_name = slb_name
        # The port of the internal-facing SLB instance that is bound to the application.
        self.slb_port = slb_port
        # The ID of the Alibaba Cloud account.
        self.user_id = user_id
        self.workload_type = workload_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_phase is not None:
            result['AppPhase'] = self.app_phase
        if self.application_type is not None:
            result['ApplicationType'] = self.application_type
        if self.build_package_id is not None:
            result['BuildPackageId'] = self.build_package_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.dockerize is not None:
            result['Dockerize'] = self.dockerize
        if self.email is not None:
            result['Email'] = self.email
        if self.enable_port_check is not None:
            result['EnablePortCheck'] = self.enable_port_check
        if self.enable_url_check is not None:
            result['EnableUrlCheck'] = self.enable_url_check
        if self.ext_slb_id is not None:
            result['ExtSlbId'] = self.ext_slb_id
        if self.ext_slb_ip is not None:
            result['ExtSlbIp'] = self.ext_slb_ip
        if self.ext_slb_name is not None:
            result['ExtSlbName'] = self.ext_slb_name
        if self.have_manage_access is not None:
            result['HaveManageAccess'] = self.have_manage_access
        if self.health_check_url is not None:
            result['HealthCheckUrl'] = self.health_check_url
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.name is not None:
            result['Name'] = self.name
        if self.name_space is not None:
            result['NameSpace'] = self.name_space
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.port is not None:
            result['Port'] = self.port
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.running_instance_count is not None:
            result['RunningInstanceCount'] = self.running_instance_count
        if self.slb_id is not None:
            result['SlbId'] = self.slb_id
        if self.slb_info is not None:
            result['SlbInfo'] = self.slb_info
        if self.slb_ip is not None:
            result['SlbIp'] = self.slb_ip
        if self.slb_name is not None:
            result['SlbName'] = self.slb_name
        if self.slb_port is not None:
            result['SlbPort'] = self.slb_port
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.workload_type is not None:
            result['WorkloadType'] = self.workload_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppPhase') is not None:
            self.app_phase = m.get('AppPhase')
        if m.get('ApplicationType') is not None:
            self.application_type = m.get('ApplicationType')
        if m.get('BuildPackageId') is not None:
            self.build_package_id = m.get('BuildPackageId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Dockerize') is not None:
            self.dockerize = m.get('Dockerize')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('EnablePortCheck') is not None:
            self.enable_port_check = m.get('EnablePortCheck')
        if m.get('EnableUrlCheck') is not None:
            self.enable_url_check = m.get('EnableUrlCheck')
        if m.get('ExtSlbId') is not None:
            self.ext_slb_id = m.get('ExtSlbId')
        if m.get('ExtSlbIp') is not None:
            self.ext_slb_ip = m.get('ExtSlbIp')
        if m.get('ExtSlbName') is not None:
            self.ext_slb_name = m.get('ExtSlbName')
        if m.get('HaveManageAccess') is not None:
            self.have_manage_access = m.get('HaveManageAccess')
        if m.get('HealthCheckUrl') is not None:
            self.health_check_url = m.get('HealthCheckUrl')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NameSpace') is not None:
            self.name_space = m.get('NameSpace')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('RunningInstanceCount') is not None:
            self.running_instance_count = m.get('RunningInstanceCount')
        if m.get('SlbId') is not None:
            self.slb_id = m.get('SlbId')
        if m.get('SlbInfo') is not None:
            self.slb_info = m.get('SlbInfo')
        if m.get('SlbIp') is not None:
            self.slb_ip = m.get('SlbIp')
        if m.get('SlbName') is not None:
            self.slb_name = m.get('SlbName')
        if m.get('SlbPort') is not None:
            self.slb_port = m.get('SlbPort')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('WorkloadType') is not None:
            self.workload_type = m.get('WorkloadType')
        return self


class GetApplicationResponseBody(TeaModel):
    def __init__(
        self,
        application: GetApplicationResponseBodyApplication = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The details of the application.
        self.application = application
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.application:
            self.application.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application is not None:
            result['Application'] = self.application.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Application') is not None:
            temp_model = GetApplicationResponseBodyApplication()
            self.application = temp_model.from_map(m['Application'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetChangeOrderInfoRequest(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change process.
        # 
        # This parameter is required.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO(TeaModel):
    def __init__(
        self,
        retry_type: int = None,
        show_manual_ignorance: bool = None,
        task_error_code: str = None,
        task_error_ignorance: int = None,
        task_error_message: str = None,
        task_id: str = None,
        task_message: str = None,
        task_name: str = None,
        task_status: str = None,
    ):
        # The type of the retry policy. Value 0 indicates no retry, value 1 indicates automatic retry, and value 2 indicates manual retry.
        self.retry_type = retry_type
        # Indicates whether errors that occur in the change process are ignored. Valid values:``
        # 
        # *   true: Errors that occur in the change process are ignored. This parameter can be set to true only when URL health checks are performed.
        # *   false: Errors that occur in the change process are not ignored.
        self.show_manual_ignorance = show_manual_ignorance
        # Error codes
        self.task_error_code = task_error_code
        # Indicates whether the task is error-tolerant. If the task can tolerate errors, the errors that occur in the change process are ignored and the next task is executed.
        # 
        # *   0: The task is not error-tolerant.
        # *   1: The task is error-tolerant.
        self.task_error_ignorance = task_error_ignorance
        # The error message for the task.
        self.task_error_message = task_error_message
        # The ID of the task.
        self.task_id = task_id
        # Task information
        self.task_message = task_message
        # The name of the task.
        self.task_name = task_name
        # The state of the task. Valid values:
        # 
        # *   0: ready
        # *   1: in progress
        # *   2: successful
        # *   3: failed
        # *   6: terminated
        # *   8: wait for manual confirmation to trigger the next batch during a manual phased release
        # *   9: wait to trigger the next batch during an automatic phased release
        # *   10: failed due to a system exception
        self.task_status = task_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.retry_type is not None:
            result['RetryType'] = self.retry_type
        if self.show_manual_ignorance is not None:
            result['ShowManualIgnorance'] = self.show_manual_ignorance
        if self.task_error_code is not None:
            result['TaskErrorCode'] = self.task_error_code
        if self.task_error_ignorance is not None:
            result['TaskErrorIgnorance'] = self.task_error_ignorance
        if self.task_error_message is not None:
            result['TaskErrorMessage'] = self.task_error_message
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_message is not None:
            result['TaskMessage'] = self.task_message
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RetryType') is not None:
            self.retry_type = m.get('RetryType')
        if m.get('ShowManualIgnorance') is not None:
            self.show_manual_ignorance = m.get('ShowManualIgnorance')
        if m.get('TaskErrorCode') is not None:
            self.task_error_code = m.get('TaskErrorCode')
        if m.get('TaskErrorIgnorance') is not None:
            self.task_error_ignorance = m.get('TaskErrorIgnorance')
        if m.get('TaskErrorMessage') is not None:
            self.task_error_message = m.get('TaskErrorMessage')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskMessage') is not None:
            self.task_message = m.get('TaskMessage')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        return self


class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList(TeaModel):
    def __init__(
        self,
        task_info_dto: List[GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO] = None,
    ):
        self.task_info_dto = task_info_dto

    def validate(self):
        if self.task_info_dto:
            for k in self.task_info_dto:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskInfoDTO'] = []
        if self.task_info_dto is not None:
            for k in self.task_info_dto:
                result['TaskInfoDTO'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task_info_dto = []
        if m.get('TaskInfoDTO') is not None:
            for k in m.get('TaskInfoDTO'):
                temp_model = GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO()
                self.task_info_dto.append(temp_model.from_map(k))
        return self


class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO(TeaModel):
    def __init__(
        self,
        stage_id: str = None,
        stage_name: str = None,
        stage_status: int = None,
        task_list: GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList = None,
    ):
        # The ID of the stage.
        self.stage_id = stage_id
        # The name of the stage.
        self.stage_name = stage_name
        # The status of the stage. Valid values:
        # 
        # *   0: ready
        # *   1: in progress
        # *   2: successful
        # *   3: failed
        # *   6: terminated
        # *   8: wait for manual confirmation to trigger the next batch during a manual phased release
        # *   9: wait to trigger the next batch during an automatic phased release
        # *   10: failed due to a system exception
        self.stage_status = stage_status
        # The information about the task.
        self.task_list = task_list

    def validate(self):
        if self.task_list:
            self.task_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.stage_id is not None:
            result['StageId'] = self.stage_id
        if self.stage_name is not None:
            result['StageName'] = self.stage_name
        if self.stage_status is not None:
            result['StageStatus'] = self.stage_status
        if self.task_list is not None:
            result['TaskList'] = self.task_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('StageId') is not None:
            self.stage_id = m.get('StageId')
        if m.get('StageName') is not None:
            self.stage_name = m.get('StageName')
        if m.get('StageStatus') is not None:
            self.stage_status = m.get('StageStatus')
        if m.get('TaskList') is not None:
            temp_model = GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList()
            self.task_list = temp_model.from_map(m['TaskList'])
        return self


class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList(TeaModel):
    def __init__(
        self,
        stage_detail_dto: List[GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO] = None,
    ):
        self.stage_detail_dto = stage_detail_dto

    def validate(self):
        if self.stage_detail_dto:
            for k in self.stage_detail_dto:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StageDetailDTO'] = []
        if self.stage_detail_dto is not None:
            for k in self.stage_detail_dto:
                result['StageDetailDTO'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.stage_detail_dto = []
        if m.get('StageDetailDTO') is not None:
            for k in m.get('StageDetailDTO'):
                temp_model = GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO()
                self.stage_detail_dto.append(temp_model.from_map(k))
        return self


class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO(TeaModel):
    def __init__(
        self,
        finish_time: str = None,
        stage_id: str = None,
        stage_message: str = None,
        stage_name: str = None,
        start_time: str = None,
        status: int = None,
    ):
        # The time when the execution stopped.
        self.finish_time = finish_time
        # The ID of the stage.
        self.stage_id = stage_id
        # The information about the stage.
        self.stage_message = stage_message
        # The name of the stage.
        self.stage_name = stage_name
        # The time when the execution was started.
        self.start_time = start_time
        # The state of the stage. Valid values:
        # 
        # *   0: ready
        # *   1: in progress
        # *   2: successful
        # *   3: failed
        # *   6: terminated
        # *   8: wait for manual confirmation to trigger the next batch during a manual phased release
        # *   9: wait to trigger the next batch during an automatic phased release
        # *   10: failed due to a system exception
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.stage_id is not None:
            result['StageId'] = self.stage_id
        if self.stage_message is not None:
            result['StageMessage'] = self.stage_message
        if self.stage_name is not None:
            result['StageName'] = self.stage_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('StageId') is not None:
            self.stage_id = m.get('StageId')
        if m.get('StageMessage') is not None:
            self.stage_message = m.get('StageMessage')
        if m.get('StageName') is not None:
            self.stage_name = m.get('StageName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList(TeaModel):
    def __init__(
        self,
        instance_stage_dto: List[GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO] = None,
    ):
        self.instance_stage_dto = instance_stage_dto

    def validate(self):
        if self.instance_stage_dto:
            for k in self.instance_stage_dto:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceStageDTO'] = []
        if self.instance_stage_dto is not None:
            for k in self.instance_stage_dto:
                result['InstanceStageDTO'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_stage_dto = []
        if m.get('InstanceStageDTO') is not None:
            for k in m.get('InstanceStageDTO'):
                temp_model = GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO()
                self.instance_stage_dto.append(temp_model.from_map(k))
        return self


class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO(TeaModel):
    def __init__(
        self,
        instance_ip: str = None,
        instance_name: str = None,
        instance_stage_dtolist: GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList = None,
        pod_name: str = None,
        pod_status: str = None,
        status: int = None,
    ):
        # The IP address of the ECS instance.
        self.instance_ip = instance_ip
        # The name of the ECS instance.
        self.instance_name = instance_name
        # The results of the task executed on the ECS instance in each stage.
        self.instance_stage_dtolist = instance_stage_dtolist
        # The name of the node.
        self.pod_name = pod_name
        # The state of the pod.
        self.pod_status = pod_status
        # The running state. Valid values:
        # 
        # *   0: ready
        # *   1: in progress
        # *   2: successful
        # *   3: failed
        # *   6: terminated
        # *   8: wait for manual confirmation to trigger the next batch during a manual phased release
        # *   9: wait to trigger the next batch during an automatic phased release
        # *   10: failed due to a system exception
        self.status = status

    def validate(self):
        if self.instance_stage_dtolist:
            self.instance_stage_dtolist.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ip is not None:
            result['InstanceIp'] = self.instance_ip
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_stage_dtolist is not None:
            result['InstanceStageDTOList'] = self.instance_stage_dtolist.to_map()
        if self.pod_name is not None:
            result['PodName'] = self.pod_name
        if self.pod_status is not None:
            result['PodStatus'] = self.pod_status
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIp') is not None:
            self.instance_ip = m.get('InstanceIp')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceStageDTOList') is not None:
            temp_model = GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList()
            self.instance_stage_dtolist = temp_model.from_map(m['InstanceStageDTOList'])
        if m.get('PodName') is not None:
            self.pod_name = m.get('PodName')
        if m.get('PodStatus') is not None:
            self.pod_status = m.get('PodStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList(TeaModel):
    def __init__(
        self,
        instance_dto: List[GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO] = None,
    ):
        self.instance_dto = instance_dto

    def validate(self):
        if self.instance_dto:
            for k in self.instance_dto:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceDTO'] = []
        if self.instance_dto is not None:
            for k in self.instance_dto:
                result['InstanceDTO'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_dto = []
        if m.get('InstanceDTO') is not None:
            for k in m.get('InstanceDTO'):
                temp_model = GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO()
                self.instance_dto.append(temp_model.from_map(k))
        return self


class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage(TeaModel):
    def __init__(
        self,
        message: str = None,
        stage_id: str = None,
        stage_name: str = None,
        status: int = None,
    ):
        # The execution result in the stage.
        self.message = message
        # The ID of the stage.
        self.stage_id = stage_id
        # Phase Name
        self.stage_name = stage_name
        # The running state. Valid values:
        # 
        # *   0: ready
        # *   1: in progress
        # *   2: successful
        # *   3: failed
        # *   6: terminated
        # *   8: wait for manual confirmation to trigger the next batch during a manual phased release
        # *   9: wait to trigger the next batch during an automatic phased release
        # *   10: failed due to a system exception
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.stage_id is not None:
            result['StageId'] = self.stage_id
        if self.stage_name is not None:
            result['StageName'] = self.stage_name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('StageId') is not None:
            self.stage_id = m.get('StageId')
        if m.get('StageName') is not None:
            self.stage_name = m.get('StageName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO(TeaModel):
    def __init__(
        self,
        instance_dtolist: GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList = None,
        service_stage: GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage = None,
    ):
        # The results of the task executed on each Elastic Compute Service (ECS) instance in each stage.
        self.instance_dtolist = instance_dtolist
        # The results of tasks executed in each service-oriented stage.
        self.service_stage = service_stage

    def validate(self):
        if self.instance_dtolist:
            self.instance_dtolist.validate()
        if self.service_stage:
            self.service_stage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_dtolist is not None:
            result['InstanceDTOList'] = self.instance_dtolist.to_map()
        if self.service_stage is not None:
            result['ServiceStage'] = self.service_stage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceDTOList') is not None:
            temp_model = GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList()
            self.instance_dtolist = temp_model.from_map(m['InstanceDTOList'])
        if m.get('ServiceStage') is not None:
            temp_model = GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage()
            self.service_stage = temp_model.from_map(m['ServiceStage'])
        return self


class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO(TeaModel):
    def __init__(
        self,
        stage_id: str = None,
        stage_name: str = None,
        stage_result_dto: GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO = None,
        status: int = None,
    ):
        # The ID of the stage.
        self.stage_id = stage_id
        # The name of the stage.
        self.stage_name = stage_name
        # The results of the task executed in the stage.
        self.stage_result_dto = stage_result_dto
        # The state of the stage. Valid values:
        # 
        # *   0: ready
        # *   1: in progress
        # *   2: successful
        # *   3: failed
        # *   6: terminated
        # *   8: wait for manual confirmation to trigger the next batch during a manual phased release
        # *   9: wait to trigger the next batch during an automatic phased release
        # *   10: failed due to a system exception
        self.status = status

    def validate(self):
        if self.stage_result_dto:
            self.stage_result_dto.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.stage_id is not None:
            result['StageId'] = self.stage_id
        if self.stage_name is not None:
            result['StageName'] = self.stage_name
        if self.stage_result_dto is not None:
            result['StageResultDTO'] = self.stage_result_dto.to_map()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('StageId') is not None:
            self.stage_id = m.get('StageId')
        if m.get('StageName') is not None:
            self.stage_name = m.get('StageName')
        if m.get('StageResultDTO') is not None:
            temp_model = GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO()
            self.stage_result_dto = temp_model.from_map(m['StageResultDTO'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList(TeaModel):
    def __init__(
        self,
        stage_info_dto: List[GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO] = None,
    ):
        self.stage_info_dto = stage_info_dto

    def validate(self):
        if self.stage_info_dto:
            for k in self.stage_info_dto:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StageInfoDTO'] = []
        if self.stage_info_dto is not None:
            for k in self.stage_info_dto:
                result['StageInfoDTO'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.stage_info_dto = []
        if m.get('StageInfoDTO') is not None:
            for k in m.get('StageInfoDTO'):
                temp_model = GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO()
                self.stage_info_dto.append(temp_model.from_map(k))
        return self


class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        pipeline_name: str = None,
        pipeline_status: int = None,
        stage_detail_list: GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList = None,
        stage_list: GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList = None,
        start_time: str = None,
        update_time: str = None,
    ):
        # The ID of each batch for the change during the phased release.
        self.pipeline_id = pipeline_id
        # The name of the batch.
        self.pipeline_name = pipeline_name
        # The state of the change task. Valid values:
        # 
        # *   0: ready
        # *   1: in progress
        # *   2: successful
        # *   3: failed
        # *   6: terminated
        # *   8: wait for manual confirmation to trigger the next batch during a manual phased release
        # *   9: wait to trigger the next batch during an automatic phased release
        # *   10: failed due to a system exception
        self.pipeline_status = pipeline_status
        # The execution results in each stage.
        self.stage_detail_list = stage_detail_list
        # The stages of the change process.
        self.stage_list = stage_list
        # The time when the change task was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.start_time = start_time
        # The time when the change task was updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time

    def validate(self):
        if self.stage_detail_list:
            self.stage_detail_list.validate()
        if self.stage_list:
            self.stage_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.pipeline_name is not None:
            result['PipelineName'] = self.pipeline_name
        if self.pipeline_status is not None:
            result['PipelineStatus'] = self.pipeline_status
        if self.stage_detail_list is not None:
            result['StageDetailList'] = self.stage_detail_list.to_map()
        if self.stage_list is not None:
            result['StageList'] = self.stage_list.to_map()
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('PipelineName') is not None:
            self.pipeline_name = m.get('PipelineName')
        if m.get('PipelineStatus') is not None:
            self.pipeline_status = m.get('PipelineStatus')
        if m.get('StageDetailList') is not None:
            temp_model = GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList()
            self.stage_detail_list = temp_model.from_map(m['StageDetailList'])
        if m.get('StageList') is not None:
            temp_model = GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList()
            self.stage_list = temp_model.from_map(m['StageList'])
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList(TeaModel):
    def __init__(
        self,
        pipeline_info: List[GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo] = None,
    ):
        self.pipeline_info = pipeline_info

    def validate(self):
        if self.pipeline_info:
            for k in self.pipeline_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PipelineInfo'] = []
        if self.pipeline_info is not None:
            for k in self.pipeline_info:
                result['PipelineInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.pipeline_info = []
        if m.get('PipelineInfo') is not None:
            for k in m.get('PipelineInfo'):
                temp_model = GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo()
                self.pipeline_info.append(temp_model.from_map(k))
        return self


class GetChangeOrderInfoResponseBodyChangeOrderInfoTargets(TeaModel):
    def __init__(
        self,
        items: List[str] = None,
    ):
        self.items = items

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.items is not None:
            result['Items'] = self.items
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Items') is not None:
            self.items = m.get('Items')
        return self


class GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl(TeaModel):
    def __init__(
        self,
        routes: str = None,
        rules: str = None,
        tips: str = None,
    ):
        # The route forwarding policy.
        self.routes = routes
        # The traffic routing rules.
        self.rules = rules
        # The description of throttling rules.
        self.tips = tips

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.routes is not None:
            result['Routes'] = self.routes
        if self.rules is not None:
            result['Rules'] = self.rules
        if self.tips is not None:
            result['Tips'] = self.tips
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Routes') is not None:
            self.routes = m.get('Routes')
        if m.get('Rules') is not None:
            self.rules = m.get('Rules')
        if m.get('Tips') is not None:
            self.tips = m.get('Tips')
        return self


class GetChangeOrderInfoResponseBodyChangeOrderInfo(TeaModel):
    def __init__(
        self,
        batch_count: int = None,
        batch_type: str = None,
        change_order_description: str = None,
        change_order_id: str = None,
        co_type: str = None,
        create_time: str = None,
        create_user_id: str = None,
        desc: str = None,
        pipeline_info_list: GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList = None,
        status: int = None,
        support_rollback: bool = None,
        targets: GetChangeOrderInfoResponseBodyChangeOrderInfoTargets = None,
        traffic_control: GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl = None,
    ):
        # The number of batches for the change.
        self.batch_count = batch_count
        # Indicates whether the change for the next batch is automatically or manually triggered when phased release is performed. Valid values:
        # 
        # *   Automatic: The change for the next batch is automatically triggered.
        # *   Manual: The change for the next batch is manually triggered.
        self.batch_type = batch_type
        # The description of the change process.
        self.change_order_description = change_order_description
        # The ID of the change process.
        self.change_order_id = change_order_id
        # The type of the change process.
        self.co_type = co_type
        # The time when the change process is created.
        self.create_time = create_time
        # The person in charge of the change process.
        self.create_user_id = create_user_id
        # The description of the change process.
        self.desc = desc
        # The information about the batches of the change task.
        self.pipeline_info_list = pipeline_info_list
        # The state of the change process. Valid values:
        # 
        # *   0: ready
        # *   1: in progress
        # *   2: successful
        # *   3: failed
        # *   6: terminated
        # *   7: partially executed
        # *   8: wait for manual confirmation to trigger the next batch during a manual phased release
        # *   9: wait to trigger the next batch during an automatic phased release
        # *   10: failed due to a system exception
        self.status = status
        # Indicates whether rollbacks are allowed. Valid values:
        # 
        # *   true: Rollbacks are allowed.
        # *   false: Rollbacks are not allowed.
        self.support_rollback = support_rollback
        self.targets = targets
        # The throttling rules.
        self.traffic_control = traffic_control

    def validate(self):
        if self.pipeline_info_list:
            self.pipeline_info_list.validate()
        if self.targets:
            self.targets.validate()
        if self.traffic_control:
            self.traffic_control.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_count is not None:
            result['BatchCount'] = self.batch_count
        if self.batch_type is not None:
            result['BatchType'] = self.batch_type
        if self.change_order_description is not None:
            result['ChangeOrderDescription'] = self.change_order_description
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.co_type is not None:
            result['CoType'] = self.co_type
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user_id is not None:
            result['CreateUserId'] = self.create_user_id
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.pipeline_info_list is not None:
            result['PipelineInfoList'] = self.pipeline_info_list.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.support_rollback is not None:
            result['SupportRollback'] = self.support_rollback
        if self.targets is not None:
            result['Targets'] = self.targets.to_map()
        if self.traffic_control is not None:
            result['TrafficControl'] = self.traffic_control.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BatchCount') is not None:
            self.batch_count = m.get('BatchCount')
        if m.get('BatchType') is not None:
            self.batch_type = m.get('BatchType')
        if m.get('ChangeOrderDescription') is not None:
            self.change_order_description = m.get('ChangeOrderDescription')
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('CoType') is not None:
            self.co_type = m.get('CoType')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUserId') is not None:
            self.create_user_id = m.get('CreateUserId')
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('PipelineInfoList') is not None:
            temp_model = GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList()
            self.pipeline_info_list = temp_model.from_map(m['PipelineInfoList'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SupportRollback') is not None:
            self.support_rollback = m.get('SupportRollback')
        if m.get('Targets') is not None:
            temp_model = GetChangeOrderInfoResponseBodyChangeOrderInfoTargets()
            self.targets = temp_model.from_map(m['Targets'])
        if m.get('TrafficControl') is not None:
            temp_model = GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl()
            self.traffic_control = temp_model.from_map(m['TrafficControl'])
        return self


class GetChangeOrderInfoResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        change_order_info: GetChangeOrderInfoResponseBodyChangeOrderInfo = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The details about the change process.
        self.change_order_info = change_order_info

    def validate(self):
        if self.change_order_info:
            self.change_order_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.change_order_info is not None:
            result['changeOrderInfo'] = self.change_order_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('changeOrderInfo') is not None:
            temp_model = GetChangeOrderInfoResponseBodyChangeOrderInfo()
            self.change_order_info = temp_model.from_map(m['changeOrderInfo'])
        return self


class GetChangeOrderInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetChangeOrderInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetChangeOrderInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetClusterRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
    ):
        # The ID of the cluster in Enterprise Distributed Application Service (EDAS). You can call the ListCluster operation to query the cluster ID. For more information, see [ListCluster](https://help.aliyun.com/document_detail/154995.html).
        # 
        # This parameter is required.
        self.cluster_id = cluster_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        return self


class GetClusterResponseBodyCluster(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_import_status: int = None,
        cluster_name: str = None,
        cluster_type: int = None,
        cpu: int = None,
        cpu_used: int = None,
        create_time: int = None,
        cs_cluster_id: str = None,
        description: str = None,
        iaas_provider: str = None,
        mem: int = None,
        mem_used: int = None,
        network_mode: int = None,
        node_num: int = None,
        oversold_factor: int = None,
        region_id: str = None,
        sub_cluster_type: str = None,
        update_time: int = None,
        vpc_id: str = None,
    ):
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The import status of the cluster. Valid values:
        # 
        # *   1: The cluster is imported.
        # *   2: The cluster fails to be imported.
        # *   3: The cluster is being imported.
        # *   4: The cluster is deleted.
        # *   0: The cluster is not imported.
        self.cluster_import_status = cluster_import_status
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The type of the cluster. Valid values:
        # 
        # *   0: regular Docker cluster
        # *   1: Swarm cluster
        # *   2: Elastic Compute Service (ECS) cluster
        # *   3: self-managed Kubernetes cluster in EDAS
        # *   4: cluster in which Pandora automatically registers applications
        # *   5: ACK cluster
        self.cluster_type = cluster_type
        # The total number of CPU cores.
        self.cpu = cpu
        # The number of used CPU cores.
        self.cpu_used = cpu_used
        # The time when the cluster was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The ID of the Container Service for Kubernetes (ACK) cluster.
        self.cs_cluster_id = cs_cluster_id
        # The description of the cluster.
        self.description = description
        # The provider of Infrastructure as a Service (IaaS) resources used in the cluster.
        self.iaas_provider = iaas_provider
        # The total size of memory. Unit: MB.
        self.mem = mem
        # The size of used memory. Unit: MB.
        self.mem_used = mem_used
        # The network type of the cluster. Valid values:
        # 
        # *   1: classic network
        # *   2: virtual private cloud (VPC)
        self.network_mode = network_mode
        # The number of ECS instances.
        self.node_num = node_num
        # The overcommit ratio supported by a Docker cluster. Valid values:
        # 
        # *   1: 1:1, which means that resources are not overcommitted.
        # *   2: 1:2, which means that resources are overcommitted by 1:2.
        # *   4: 1:4, which means that resources are overcommitted by 1:4.
        # *   8: 1:8, which means that resources are overcommitted by 1:8.
        self.oversold_factor = oversold_factor
        # The ID of the region where the cluster resides.
        self.region_id = region_id
        # The subtype of the Kubernetes cluster. Valid values: ManagedKubernetes, Ask, and ExternalKubernetes. ManagedKubernetes refers to the ACK cluster. Ask refers to the Serverless Kubernetes (ASK) cluster. ExternalKubernetes refers to the external cluster.
        self.sub_cluster_type = sub_cluster_type
        # The time when the cluster was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_import_status is not None:
            result['ClusterImportStatus'] = self.cluster_import_status
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.cpu_used is not None:
            result['CpuUsed'] = self.cpu_used
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.cs_cluster_id is not None:
            result['CsClusterId'] = self.cs_cluster_id
        if self.description is not None:
            result['Description'] = self.description
        if self.iaas_provider is not None:
            result['IaasProvider'] = self.iaas_provider
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.mem_used is not None:
            result['MemUsed'] = self.mem_used
        if self.network_mode is not None:
            result['NetworkMode'] = self.network_mode
        if self.node_num is not None:
            result['NodeNum'] = self.node_num
        if self.oversold_factor is not None:
            result['OversoldFactor'] = self.oversold_factor
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.sub_cluster_type is not None:
            result['SubClusterType'] = self.sub_cluster_type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterImportStatus') is not None:
            self.cluster_import_status = m.get('ClusterImportStatus')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CpuUsed') is not None:
            self.cpu_used = m.get('CpuUsed')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CsClusterId') is not None:
            self.cs_cluster_id = m.get('CsClusterId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IaasProvider') is not None:
            self.iaas_provider = m.get('IaasProvider')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('MemUsed') is not None:
            self.mem_used = m.get('MemUsed')
        if m.get('NetworkMode') is not None:
            self.network_mode = m.get('NetworkMode')
        if m.get('NodeNum') is not None:
            self.node_num = m.get('NodeNum')
        if m.get('OversoldFactor') is not None:
            self.oversold_factor = m.get('OversoldFactor')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SubClusterType') is not None:
            self.sub_cluster_type = m.get('SubClusterType')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class GetClusterResponseBody(TeaModel):
    def __init__(
        self,
        cluster: GetClusterResponseBodyCluster = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The information about the cluster.
        self.cluster = cluster
        # The HTTP status code that is returned.
        self.code = code
        # The detailed information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.cluster:
            self.cluster.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster is not None:
            result['Cluster'] = self.cluster.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cluster') is not None:
            temp_model = GetClusterResponseBodyCluster()
            self.cluster = temp_model.from_map(m['Cluster'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetClusterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetClusterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetContainerConfigurationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group_id: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the instance group.
        # 
        # *   If this parameter is specified, this operation queries the Tomcat configuration of the instance group.
        # *   If this parameter is not specified, this operation queries the Tomcat configuration of the application.
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class GetContainerConfigurationResponseBodyContainerConfiguration(TeaModel):
    def __init__(
        self,
        context_path: str = None,
        http_port: int = None,
        max_threads: int = None,
        uriencoding: str = None,
        use_body_encoding: bool = None,
    ):
        # The context path of the Tomcat container.
        self.context_path = context_path
        # The application port number for the Tomcat container. The value specified in the application configuration is returned.
        self.http_port = http_port
        # The maximum number of threads in the Tomcat container.
        # 
        # *   If no instance group is specified, the configuration of the application is returned.
        # *   If no application is specified, the default configuration is returned.
        self.max_threads = max_threads
        # The Uniform Resource Identifier (URI) encoding scheme. Valid values: ISO-8859-1, GBK, GB2312, and UTF-8.
        # 
        # *   If no instance group is specified, the configuration of the application is returned.
        # *   If no application is specified, the default configuration is returned.
        self.uriencoding = uriencoding
        # Indicates whether useBodyEncodingForURI is enabled in the Tomcat container.
        # 
        # *   If no instance group is specified, the configuration of the application is returned.
        # *   If no application is specified, the default configuration is returned.
        self.use_body_encoding = use_body_encoding

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.context_path is not None:
            result['ContextPath'] = self.context_path
        if self.http_port is not None:
            result['HttpPort'] = self.http_port
        if self.max_threads is not None:
            result['MaxThreads'] = self.max_threads
        if self.uriencoding is not None:
            result['URIEncoding'] = self.uriencoding
        if self.use_body_encoding is not None:
            result['UseBodyEncoding'] = self.use_body_encoding
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContextPath') is not None:
            self.context_path = m.get('ContextPath')
        if m.get('HttpPort') is not None:
            self.http_port = m.get('HttpPort')
        if m.get('MaxThreads') is not None:
            self.max_threads = m.get('MaxThreads')
        if m.get('URIEncoding') is not None:
            self.uriencoding = m.get('URIEncoding')
        if m.get('UseBodyEncoding') is not None:
            self.use_body_encoding = m.get('UseBodyEncoding')
        return self


class GetContainerConfigurationResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        container_configuration: GetContainerConfigurationResponseBodyContainerConfiguration = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The Tomcat configuration.
        self.container_configuration = container_configuration
        # The message returned for the request.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.container_configuration:
            self.container_configuration.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.container_configuration is not None:
            result['ContainerConfiguration'] = self.container_configuration.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ContainerConfiguration') is not None:
            temp_model = GetContainerConfigurationResponseBodyContainerConfiguration()
            self.container_configuration = temp_model.from_map(m['ContainerConfiguration'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetContainerConfigurationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetContainerConfigurationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetContainerConfigurationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetJavaStartUpConfigRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class GetJavaStartUpConfigResponseBodyJavaStartUpConfig(TeaModel):
    def __init__(
        self,
        original_configs: str = None,
        start_up_args: str = None,
    ):
        # The displayed startup parameter configuration.
        self.original_configs = original_configs
        # The effective startup parameter configuration.
        self.start_up_args = start_up_args

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.original_configs is not None:
            result['OriginalConfigs'] = self.original_configs
        if self.start_up_args is not None:
            result['StartUpArgs'] = self.start_up_args
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OriginalConfigs') is not None:
            self.original_configs = m.get('OriginalConfigs')
        if m.get('StartUpArgs') is not None:
            self.start_up_args = m.get('StartUpArgs')
        return self


class GetJavaStartUpConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        java_start_up_config: GetJavaStartUpConfigResponseBodyJavaStartUpConfig = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The configuration of Java startup parameters.
        self.java_start_up_config = java_start_up_config
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.java_start_up_config:
            self.java_start_up_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.java_start_up_config is not None:
            result['JavaStartUpConfig'] = self.java_start_up_config.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('JavaStartUpConfig') is not None:
            temp_model = GetJavaStartUpConfigResponseBodyJavaStartUpConfig()
            self.java_start_up_config = temp_model.from_map(m['JavaStartUpConfig'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetJavaStartUpConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetJavaStartUpConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetJavaStartUpConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetJvmConfigurationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group_id: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the instance group.
        # 
        # *   If an ID is specified, this operation queries the JVM configuration information of the instance group.
        # *   If an ID is not specified, this operation queries the JVM configuration information of the application.
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class GetJvmConfigurationResponseBodyJvmConfiguration(TeaModel):
    def __init__(
        self,
        max_heap_size: int = None,
        max_perm_size: int = None,
        min_heap_size: int = None,
        options: str = None,
    ):
        # The maximum size of the heap memory. Unit: MB.
        self.max_heap_size = max_heap_size
        # The size of the permanent generation heap memory. Unit: MB.
        self.max_perm_size = max_perm_size
        # The initial size of the heap memory. Unit: MB.
        self.min_heap_size = min_heap_size
        # The custom parameter.
        self.options = options

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_heap_size is not None:
            result['MaxHeapSize'] = self.max_heap_size
        if self.max_perm_size is not None:
            result['MaxPermSize'] = self.max_perm_size
        if self.min_heap_size is not None:
            result['MinHeapSize'] = self.min_heap_size
        if self.options is not None:
            result['Options'] = self.options
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxHeapSize') is not None:
            self.max_heap_size = m.get('MaxHeapSize')
        if m.get('MaxPermSize') is not None:
            self.max_perm_size = m.get('MaxPermSize')
        if m.get('MinHeapSize') is not None:
            self.min_heap_size = m.get('MinHeapSize')
        if m.get('Options') is not None:
            self.options = m.get('Options')
        return self


class GetJvmConfigurationResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        jvm_configuration: GetJvmConfigurationResponseBodyJvmConfiguration = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The JVM configuration of the application or instance group.
        self.jvm_configuration = jvm_configuration
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.jvm_configuration:
            self.jvm_configuration.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.jvm_configuration is not None:
            result['JvmConfiguration'] = self.jvm_configuration.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('JvmConfiguration') is not None:
            temp_model = GetJvmConfigurationResponseBodyJvmConfiguration()
            self.jvm_configuration = temp_model.from_map(m['JvmConfiguration'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetJvmConfigurationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetJvmConfigurationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetJvmConfigurationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetK8sAppPrecheckResultRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        cluster_id: str = None,
        namespace: str = None,
    ):
        # The name of the application.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The ID of the cluster in Enterprise Distributed Application Service (EDAS).
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The namespace of the Kubernetes cluster.
        # 
        # This parameter is required.
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        return self


class GetK8sAppPrecheckResultResponseBodyDataJobResults(TeaModel):
    def __init__(
        self,
        interrupted: bool = None,
        name: str = None,
        pass_: bool = None,
        reason: str = None,
    ):
        # Specifies whether the precheck of the item was interrupted:
        # 
        # *   true: The precheck of the item was interrupted.
        # *   false: The precheck of the item was not interrupted.
        self.interrupted = interrupted
        # The name of the precheck item.
        self.name = name
        # Indicates whether the precheck item passed the precheck:
        # 
        # *   true: The precheck item passed the precheck.
        # *   false: The precheck item failed the precheck.
        self.pass_ = pass_
        # The reason why the precheck item failed the precheck or the precheck of the item was interrupted. This parameter is left empty when the application passed the precheck.
        self.reason = reason

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interrupted is not None:
            result['Interrupted'] = self.interrupted
        if self.name is not None:
            result['Name'] = self.name
        if self.pass_ is not None:
            result['Pass'] = self.pass_
        if self.reason is not None:
            result['Reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Interrupted') is not None:
            self.interrupted = m.get('Interrupted')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Pass') is not None:
            self.pass_ = m.get('Pass')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        return self


class GetK8sAppPrecheckResultResponseBodyData(TeaModel):
    def __init__(
        self,
        job_results: List[GetK8sAppPrecheckResultResponseBodyDataJobResults] = None,
        reason: str = None,
        status: str = None,
    ):
        # The precheck result for the application change.
        self.job_results = job_results
        # The reason why the application failed the precheck. This parameter is left empty when the application passed the precheck.
        self.reason = reason
        # The precheck state for the application change. Valid values:
        # 
        # *   checking: The application is being prechecked.
        # *   pass: The application passed the precheck.
        # *   failed: The application failed the precheck.
        self.status = status

    def validate(self):
        if self.job_results:
            for k in self.job_results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JobResults'] = []
        if self.job_results is not None:
            for k in self.job_results:
                result['JobResults'].append(k.to_map() if k else None)
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.job_results = []
        if m.get('JobResults') is not None:
            for k in m.get('JobResults'):
                temp_model = GetK8sAppPrecheckResultResponseBodyDataJobResults()
                self.job_results.append(temp_model.from_map(k))
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetK8sAppPrecheckResultResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: GetK8sAppPrecheckResultResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The data that is returned.
        self.data = data
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetK8sAppPrecheckResultResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetK8sAppPrecheckResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetK8sAppPrecheckResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetK8sAppPrecheckResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetK8sApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        from_: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The source from which data is queried.
        # 
        # *   If you leave this parameter empty, a common query is performed.
        # *   If you set the value to deploy, you query application information from the deployment page.
        self.from_ = from_

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.from_ is not None:
            result['From'] = self.from_
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        return self


class GetK8sApplicationResponseBodyApplcationAppCmdArgs(TeaModel):
    def __init__(
        self,
        cmd_arg: List[str] = None,
    ):
        self.cmd_arg = cmd_arg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cmd_arg is not None:
            result['CmdArg'] = self.cmd_arg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CmdArg') is not None:
            self.cmd_arg = m.get('CmdArg')
        return self


class GetK8sApplicationResponseBodyApplcationAppEnvListEnv(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # The name of the environment variable.
        self.name = name
        # The value of the environment variable.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetK8sApplicationResponseBodyApplcationAppEnvList(TeaModel):
    def __init__(
        self,
        env: List[GetK8sApplicationResponseBodyApplcationAppEnvListEnv] = None,
    ):
        self.env = env

    def validate(self):
        if self.env:
            for k in self.env:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Env'] = []
        if self.env is not None:
            for k in self.env:
                result['Env'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.env = []
        if m.get('Env') is not None:
            for k in m.get('Env'):
                temp_model = GetK8sApplicationResponseBodyApplcationAppEnvListEnv()
                self.env.append(temp_model.from_map(k))
        return self


class GetK8sApplicationResponseBodyApplcationApp(TeaModel):
    def __init__(
        self,
        annotations: str = None,
        app_id: str = None,
        application_name: str = None,
        application_type: str = None,
        buildpack_id: int = None,
        cluster_id: str = None,
        cmd: str = None,
        cmd_args: GetK8sApplicationResponseBodyApplcationAppCmdArgs = None,
        cs_cluster_id: str = None,
        deploy_type: str = None,
        develop_type: str = None,
        edas_container_version: str = None,
        enable_empty_push_reject: bool = None,
        enable_lossless_rule: bool = None,
        env_list: GetK8sApplicationResponseBodyApplcationAppEnvList = None,
        feature_annotations: str = None,
        instances: int = None,
        instances_before_scaling: int = None,
        k_8s_namespace: str = None,
        labels: str = None,
        limit_cpu_m: int = None,
        limit_ephemeral_storage: str = None,
        limit_mem: int = None,
        lossless_rule_aligned: bool = None,
        lossless_rule_delay_time: int = None,
        lossless_rule_func_type: int = None,
        lossless_rule_related: bool = None,
        lossless_rule_warmup_time: int = None,
        region_id: str = None,
        request_cpu_m: int = None,
        request_ephemeral_storage: str = None,
        request_mem: int = None,
        slb_info: str = None,
        tomcat_version: str = None,
        workload_type: str = None,
    ):
        # The annotation of an application pod.
        self.annotations = annotations
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        self.app_id = app_id
        # The name of the application.
        self.application_name = application_name
        # The type of the application.
        self.application_type = application_type
        # The build package number of Enterprise Distributed Application Service (EDAS) Container.
        self.buildpack_id = buildpack_id
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The startup command.
        self.cmd = cmd
        # The list of commands.
        self.cmd_args = cmd_args
        # The ID of the cluster to which the container belongs.
        self.cs_cluster_id = cs_cluster_id
        # The deployment type of the application. Example: Image.
        self.deploy_type = deploy_type
        # The application type. Valid values:
        # 
        # *   General: native Java application
        # *   Pandora: Pandora application
        # *   Multilingual: multilingual application
        self.develop_type = develop_type
        # The version of EDAS Container.
        self.edas_container_version = edas_container_version
        # Indicates whether the Empty List Protection feature is enabled for the application.
        self.enable_empty_push_reject = enable_empty_push_reject
        # Indicates whether the Graceful Release feature is enabled for the application.
        self.enable_lossless_rule = enable_lossless_rule
        # The list of environment variables.
        self.env_list = env_list
        # The feature annotations. Possible values:
        # 
        # *   base.combination.edas: enables EDAS integrated management solution.
        # *   base.combination.arms: enables ARMS monitoring.
        # *   base.combination.mse: enables MSE microservices governance.
        # *   base.combination.none: enables lifecycle management.
        self.feature_annotations = feature_annotations
        # The number of application instances.
        self.instances = instances
        # The number of application instances before the last auto scaling operation.
        self.instances_before_scaling = instances_before_scaling
        # The namespace of the Kubernetes cluster.
        self.k_8s_namespace = k_8s_namespace
        # The label of an application pod.
        self.labels = labels
        # The maximum number of CPU cores allowed. Unit: millicores. 1,000 millicores equal one CPU core.
        self.limit_cpu_m = limit_cpu_m
        # The maximum size of space required by ephemeral storage. Unit: GB. Value 0 indicates that no limit is set on the space size.
        self.limit_ephemeral_storage = limit_ephemeral_storage
        # The maximum size of the memory allowed. Unit: MiB.
        self.limit_mem = limit_mem
        # Indicates whether the Graceful Rolling Release and Configure Complete Service Registration before Readiness Probing feature is enabled for the application.
        self.lossless_rule_aligned = lossless_rule_aligned
        # The delay of service registration. Unit: seconds.
        self.lossless_rule_delay_time = lossless_rule_delay_time
        # The number of prefetching curves.
        self.lossless_rule_func_type = lossless_rule_func_type
        # Indicates whether the Graceful Rolling Release and Configure Complete Service Prefetching before Readiness Probing feature is enabled for the application.
        self.lossless_rule_related = lossless_rule_related
        # The service prefetching duration. Unit: seconds.
        self.lossless_rule_warmup_time = lossless_rule_warmup_time
        # The ID of the region.
        self.region_id = region_id
        # The number of requested CPU cores. Unit: millicores. 1,000 millicores equal one CPU core.
        self.request_cpu_m = request_cpu_m
        # The size of space reserved for ephemeral storage resources. Unit: GB. Value 0 indicates that no limit is set on the space size.
        self.request_ephemeral_storage = request_ephemeral_storage
        # The size of the reserved memory. Unit: MiB.
        self.request_mem = request_mem
        # The configuration information about the Server Load Balancer (SLB).
        self.slb_info = slb_info
        # The version of Apache Tomcat.
        self.tomcat_version = tomcat_version
        # The workload type. Valid values: Deployment and StatefulSet. If you do not specify this parameter, Deployment is used.
        self.workload_type = workload_type

    def validate(self):
        if self.cmd_args:
            self.cmd_args.validate()
        if self.env_list:
            self.env_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotations is not None:
            result['Annotations'] = self.annotations
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        if self.application_type is not None:
            result['ApplicationType'] = self.application_type
        if self.buildpack_id is not None:
            result['BuildpackId'] = self.buildpack_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cmd is not None:
            result['Cmd'] = self.cmd
        if self.cmd_args is not None:
            result['CmdArgs'] = self.cmd_args.to_map()
        if self.cs_cluster_id is not None:
            result['CsClusterId'] = self.cs_cluster_id
        if self.deploy_type is not None:
            result['DeployType'] = self.deploy_type
        if self.develop_type is not None:
            result['DevelopType'] = self.develop_type
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.enable_empty_push_reject is not None:
            result['EnableEmptyPushReject'] = self.enable_empty_push_reject
        if self.enable_lossless_rule is not None:
            result['EnableLosslessRule'] = self.enable_lossless_rule
        if self.env_list is not None:
            result['EnvList'] = self.env_list.to_map()
        if self.feature_annotations is not None:
            result['FeatureAnnotations'] = self.feature_annotations
        if self.instances is not None:
            result['Instances'] = self.instances
        if self.instances_before_scaling is not None:
            result['InstancesBeforeScaling'] = self.instances_before_scaling
        if self.k_8s_namespace is not None:
            result['K8sNamespace'] = self.k_8s_namespace
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.limit_cpu_m is not None:
            result['LimitCpuM'] = self.limit_cpu_m
        if self.limit_ephemeral_storage is not None:
            result['LimitEphemeralStorage'] = self.limit_ephemeral_storage
        if self.limit_mem is not None:
            result['LimitMem'] = self.limit_mem
        if self.lossless_rule_aligned is not None:
            result['LosslessRuleAligned'] = self.lossless_rule_aligned
        if self.lossless_rule_delay_time is not None:
            result['LosslessRuleDelayTime'] = self.lossless_rule_delay_time
        if self.lossless_rule_func_type is not None:
            result['LosslessRuleFuncType'] = self.lossless_rule_func_type
        if self.lossless_rule_related is not None:
            result['LosslessRuleRelated'] = self.lossless_rule_related
        if self.lossless_rule_warmup_time is not None:
            result['LosslessRuleWarmupTime'] = self.lossless_rule_warmup_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.request_cpu_m is not None:
            result['RequestCpuM'] = self.request_cpu_m
        if self.request_ephemeral_storage is not None:
            result['RequestEphemeralStorage'] = self.request_ephemeral_storage
        if self.request_mem is not None:
            result['RequestMem'] = self.request_mem
        if self.slb_info is not None:
            result['SlbInfo'] = self.slb_info
        if self.tomcat_version is not None:
            result['TomcatVersion'] = self.tomcat_version
        if self.workload_type is not None:
            result['WorkloadType'] = self.workload_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Annotations') is not None:
            self.annotations = m.get('Annotations')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        if m.get('ApplicationType') is not None:
            self.application_type = m.get('ApplicationType')
        if m.get('BuildpackId') is not None:
            self.buildpack_id = m.get('BuildpackId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Cmd') is not None:
            self.cmd = m.get('Cmd')
        if m.get('CmdArgs') is not None:
            temp_model = GetK8sApplicationResponseBodyApplcationAppCmdArgs()
            self.cmd_args = temp_model.from_map(m['CmdArgs'])
        if m.get('CsClusterId') is not None:
            self.cs_cluster_id = m.get('CsClusterId')
        if m.get('DeployType') is not None:
            self.deploy_type = m.get('DeployType')
        if m.get('DevelopType') is not None:
            self.develop_type = m.get('DevelopType')
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('EnableEmptyPushReject') is not None:
            self.enable_empty_push_reject = m.get('EnableEmptyPushReject')
        if m.get('EnableLosslessRule') is not None:
            self.enable_lossless_rule = m.get('EnableLosslessRule')
        if m.get('EnvList') is not None:
            temp_model = GetK8sApplicationResponseBodyApplcationAppEnvList()
            self.env_list = temp_model.from_map(m['EnvList'])
        if m.get('FeatureAnnotations') is not None:
            self.feature_annotations = m.get('FeatureAnnotations')
        if m.get('Instances') is not None:
            self.instances = m.get('Instances')
        if m.get('InstancesBeforeScaling') is not None:
            self.instances_before_scaling = m.get('InstancesBeforeScaling')
        if m.get('K8sNamespace') is not None:
            self.k_8s_namespace = m.get('K8sNamespace')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('LimitCpuM') is not None:
            self.limit_cpu_m = m.get('LimitCpuM')
        if m.get('LimitEphemeralStorage') is not None:
            self.limit_ephemeral_storage = m.get('LimitEphemeralStorage')
        if m.get('LimitMem') is not None:
            self.limit_mem = m.get('LimitMem')
        if m.get('LosslessRuleAligned') is not None:
            self.lossless_rule_aligned = m.get('LosslessRuleAligned')
        if m.get('LosslessRuleDelayTime') is not None:
            self.lossless_rule_delay_time = m.get('LosslessRuleDelayTime')
        if m.get('LosslessRuleFuncType') is not None:
            self.lossless_rule_func_type = m.get('LosslessRuleFuncType')
        if m.get('LosslessRuleRelated') is not None:
            self.lossless_rule_related = m.get('LosslessRuleRelated')
        if m.get('LosslessRuleWarmupTime') is not None:
            self.lossless_rule_warmup_time = m.get('LosslessRuleWarmupTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequestCpuM') is not None:
            self.request_cpu_m = m.get('RequestCpuM')
        if m.get('RequestEphemeralStorage') is not None:
            self.request_ephemeral_storage = m.get('RequestEphemeralStorage')
        if m.get('RequestMem') is not None:
            self.request_mem = m.get('RequestMem')
        if m.get('SlbInfo') is not None:
            self.slb_info = m.get('SlbInfo')
        if m.get('TomcatVersion') is not None:
            self.tomcat_version = m.get('TomcatVersion')
        if m.get('WorkloadType') is not None:
            self.workload_type = m.get('WorkloadType')
        return self


class GetK8sApplicationResponseBodyApplcationConf(TeaModel):
    def __init__(
        self,
        affinity: str = None,
        ahas_enabled: bool = None,
        deploy_across_nodes: str = None,
        deploy_across_zones: str = None,
        jar_start_args: str = None,
        jar_start_options: str = None,
        k_8s_cmd: str = None,
        k_8s_cmd_args: str = None,
        k_8s_localvolume_info: str = None,
        k_8s_nas_info: str = None,
        k_8s_volume_info: str = None,
        liveness: str = None,
        post_start: str = None,
        pre_stop: str = None,
        readiness: str = None,
        runtime_class_name: str = None,
        tolerations: str = None,
        user_base_image_url: str = None,
    ):
        # The affinity configuration of the pod.
        self.affinity = affinity
        # Indicates whether the application is connected to Application High Availability Service (AHAS).
        self.ahas_enabled = ahas_enabled
        # Indicates whether the application instances are deployed across nodes.
        # 
        # *   Value `true` indicates that the application instances are deployed across nodes.
        # *   Other values indicate that the application instances are not deployed across nodes.
        self.deploy_across_nodes = deploy_across_nodes
        # Indicates whether the application instances are deployed across zones.
        # 
        # *   Value `true` indicates that the application instances are deployed across zones.
        # *   Other values indicate that the application instances are not deployed across zones.
        self.deploy_across_zones = deploy_across_zones
        # The startup parameters for a JAR application. This parameter is deprecated.
        self.jar_start_args = jar_start_args
        # The startup options for a JAR application. This parameter is deprecated.
        self.jar_start_options = jar_start_options
        # The startup command.
        self.k_8s_cmd = k_8s_cmd
        # The parameters of the startup command.
        self.k_8s_cmd_args = k_8s_cmd_args
        # The information about the local storage.
        self.k_8s_localvolume_info = k_8s_localvolume_info
        # The information about the File Storage NAS (NAS) storage.
        self.k_8s_nas_info = k_8s_nas_info
        # The information about the storage.
        self.k_8s_volume_info = k_8s_volume_info
        # The information about the liveness check on the container.
        self.liveness = liveness
        # The script executed after the container is started.
        self.post_start = post_start
        # The script executed before the container is stopped.
        self.pre_stop = pre_stop
        # The information about the readiness check on the container.
        self.readiness = readiness
        # The type of the container runtime. This parameter is applicable only to clusters that use sandboxed containers.
        self.runtime_class_name = runtime_class_name
        # The scheduling tolerance configuration of the pod.
        self.tolerations = tolerations
        # The URL of the base image. If you use a custom Java Development Kit (JDK) runtime, you must specify this parameter.
        self.user_base_image_url = user_base_image_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affinity is not None:
            result['Affinity'] = self.affinity
        if self.ahas_enabled is not None:
            result['AhasEnabled'] = self.ahas_enabled
        if self.deploy_across_nodes is not None:
            result['DeployAcrossNodes'] = self.deploy_across_nodes
        if self.deploy_across_zones is not None:
            result['DeployAcrossZones'] = self.deploy_across_zones
        if self.jar_start_args is not None:
            result['JarStartArgs'] = self.jar_start_args
        if self.jar_start_options is not None:
            result['JarStartOptions'] = self.jar_start_options
        if self.k_8s_cmd is not None:
            result['K8sCmd'] = self.k_8s_cmd
        if self.k_8s_cmd_args is not None:
            result['K8sCmdArgs'] = self.k_8s_cmd_args
        if self.k_8s_localvolume_info is not None:
            result['K8sLocalvolumeInfo'] = self.k_8s_localvolume_info
        if self.k_8s_nas_info is not None:
            result['K8sNasInfo'] = self.k_8s_nas_info
        if self.k_8s_volume_info is not None:
            result['K8sVolumeInfo'] = self.k_8s_volume_info
        if self.liveness is not None:
            result['Liveness'] = self.liveness
        if self.post_start is not None:
            result['PostStart'] = self.post_start
        if self.pre_stop is not None:
            result['PreStop'] = self.pre_stop
        if self.readiness is not None:
            result['Readiness'] = self.readiness
        if self.runtime_class_name is not None:
            result['RuntimeClassName'] = self.runtime_class_name
        if self.tolerations is not None:
            result['Tolerations'] = self.tolerations
        if self.user_base_image_url is not None:
            result['UserBaseImageUrl'] = self.user_base_image_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Affinity') is not None:
            self.affinity = m.get('Affinity')
        if m.get('AhasEnabled') is not None:
            self.ahas_enabled = m.get('AhasEnabled')
        if m.get('DeployAcrossNodes') is not None:
            self.deploy_across_nodes = m.get('DeployAcrossNodes')
        if m.get('DeployAcrossZones') is not None:
            self.deploy_across_zones = m.get('DeployAcrossZones')
        if m.get('JarStartArgs') is not None:
            self.jar_start_args = m.get('JarStartArgs')
        if m.get('JarStartOptions') is not None:
            self.jar_start_options = m.get('JarStartOptions')
        if m.get('K8sCmd') is not None:
            self.k_8s_cmd = m.get('K8sCmd')
        if m.get('K8sCmdArgs') is not None:
            self.k_8s_cmd_args = m.get('K8sCmdArgs')
        if m.get('K8sLocalvolumeInfo') is not None:
            self.k_8s_localvolume_info = m.get('K8sLocalvolumeInfo')
        if m.get('K8sNasInfo') is not None:
            self.k_8s_nas_info = m.get('K8sNasInfo')
        if m.get('K8sVolumeInfo') is not None:
            self.k_8s_volume_info = m.get('K8sVolumeInfo')
        if m.get('Liveness') is not None:
            self.liveness = m.get('Liveness')
        if m.get('PostStart') is not None:
            self.post_start = m.get('PostStart')
        if m.get('PreStop') is not None:
            self.pre_stop = m.get('PreStop')
        if m.get('Readiness') is not None:
            self.readiness = m.get('Readiness')
        if m.get('RuntimeClassName') is not None:
            self.runtime_class_name = m.get('RuntimeClassName')
        if m.get('Tolerations') is not None:
            self.tolerations = m.get('Tolerations')
        if m.get('UserBaseImageUrl') is not None:
            self.user_base_image_url = m.get('UserBaseImageUrl')
        return self


class GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents(TeaModel):
    def __init__(
        self,
        component_id: str = None,
        component_key: str = None,
        type: str = None,
    ):
        # The component ID.
        self.component_id = component_id
        # The keyword that is included in the component name.
        self.component_key = component_key
        # The component type. Valid values:
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.component_id is not None:
            result['ComponentId'] = self.component_id
        if self.component_key is not None:
            result['ComponentKey'] = self.component_key
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComponentId') is not None:
            self.component_id = m.get('ComponentId')
        if m.get('ComponentKey') is not None:
            self.component_key = m.get('ComponentKey')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents(TeaModel):
    def __init__(
        self,
        components: List[GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents] = None,
    ):
        self.components = components

    def validate(self):
        if self.components:
            for k in self.components:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Components'] = []
        if self.components is not None:
            for k in self.components:
                result['Components'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.components = []
        if m.get('Components') is not None:
            for k in m.get('Components'):
                temp_model = GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents()
                self.components.append(temp_model.from_map(k))
        return self


class GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup(TeaModel):
    def __init__(
        self,
        components: GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents = None,
        env: str = None,
        env_from: str = None,
    ):
        # The information about the component.
        self.components = components
        # The environment variable. This parameter is different from the EnvList parameter. This parameter specifies the referenced configuration of the ConfigMap or Secret.
        self.env = env
        # The source of the environment variable.
        self.env_from = env_from

    def validate(self):
        if self.components:
            self.components.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.components is not None:
            result['Components'] = self.components.to_map()
        if self.env is not None:
            result['Env'] = self.env
        if self.env_from is not None:
            result['EnvFrom'] = self.env_from
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Components') is not None:
            temp_model = GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents()
            self.components = temp_model.from_map(m['Components'])
        if m.get('Env') is not None:
            self.env = m.get('Env')
        if m.get('EnvFrom') is not None:
            self.env_from = m.get('EnvFrom')
        return self


class GetK8sApplicationResponseBodyApplcationDeployGroups(TeaModel):
    def __init__(
        self,
        deploy_group: List[GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup] = None,
    ):
        self.deploy_group = deploy_group

    def validate(self):
        if self.deploy_group:
            for k in self.deploy_group:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeployGroup'] = []
        if self.deploy_group is not None:
            for k in self.deploy_group:
                result['DeployGroup'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.deploy_group = []
        if m.get('DeployGroup') is not None:
            for k in m.get('DeployGroup'):
                temp_model = GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup()
                self.deploy_group.append(temp_model.from_map(k))
        return self


class GetK8sApplicationResponseBodyApplcationImageInfo(TeaModel):
    def __init__(
        self,
        image_url: str = None,
        region_id: str = None,
        repo_id: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
        repo_origin_type: str = None,
        tag: str = None,
    ):
        # The URL of the image.
        self.image_url = image_url
        # The region ID of the image repository.
        self.region_id = region_id
        # The ID of the image repository.
        self.repo_id = repo_id
        # The name of the image repository.
        self.repo_name = repo_name
        # The namespace to which the image repository belongs.
        self.repo_namespace = repo_namespace
        # The source type of the image repository.
        self.repo_origin_type = repo_origin_type
        # The tag of the image.
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_origin_type is not None:
            result['RepoOriginType'] = self.repo_origin_type
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoOriginType') is not None:
            self.repo_origin_type = m.get('RepoOriginType')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class GetK8sApplicationResponseBodyApplcationLatestVersion(TeaModel):
    def __init__(
        self,
        package_version: str = None,
        url: str = None,
        war_url: str = None,
    ):
        # The version of the deployment package.
        self.package_version = package_version
        # The URL of the deployment package. This parameter is required if you use a FatJar or WAR package to deploy the application.
        self.url = url
        # The URL of the deployment package. This parameter is required if you use a FatJar or WAR package to deploy the application.
        self.war_url = war_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.url is not None:
            result['Url'] = self.url
        if self.war_url is not None:
            result['WarUrl'] = self.war_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('WarUrl') is not None:
            self.war_url = m.get('WarUrl')
        return self


class GetK8sApplicationResponseBodyApplcation(TeaModel):
    def __init__(
        self,
        app: GetK8sApplicationResponseBodyApplcationApp = None,
        app_id: str = None,
        conf: GetK8sApplicationResponseBodyApplcationConf = None,
        deploy_groups: GetK8sApplicationResponseBodyApplcationDeployGroups = None,
        image_info: GetK8sApplicationResponseBodyApplcationImageInfo = None,
        latest_version: GetK8sApplicationResponseBodyApplcationLatestVersion = None,
    ):
        # The basic information about the application.
        self.app = app
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        self.app_id = app_id
        # The configurations.
        self.conf = conf
        # The information about the instance group in which the application is deployed.
        self.deploy_groups = deploy_groups
        # The information about the image.
        self.image_info = image_info
        # The information about the latest version.
        self.latest_version = latest_version

    def validate(self):
        if self.app:
            self.app.validate()
        if self.conf:
            self.conf.validate()
        if self.deploy_groups:
            self.deploy_groups.validate()
        if self.image_info:
            self.image_info.validate()
        if self.latest_version:
            self.latest_version.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app.to_map()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.conf is not None:
            result['Conf'] = self.conf.to_map()
        if self.deploy_groups is not None:
            result['DeployGroups'] = self.deploy_groups.to_map()
        if self.image_info is not None:
            result['ImageInfo'] = self.image_info.to_map()
        if self.latest_version is not None:
            result['LatestVersion'] = self.latest_version.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            temp_model = GetK8sApplicationResponseBodyApplcationApp()
            self.app = temp_model.from_map(m['App'])
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Conf') is not None:
            temp_model = GetK8sApplicationResponseBodyApplcationConf()
            self.conf = temp_model.from_map(m['Conf'])
        if m.get('DeployGroups') is not None:
            temp_model = GetK8sApplicationResponseBodyApplcationDeployGroups()
            self.deploy_groups = temp_model.from_map(m['DeployGroups'])
        if m.get('ImageInfo') is not None:
            temp_model = GetK8sApplicationResponseBodyApplcationImageInfo()
            self.image_info = temp_model.from_map(m['ImageInfo'])
        if m.get('LatestVersion') is not None:
            temp_model = GetK8sApplicationResponseBodyApplcationLatestVersion()
            self.latest_version = temp_model.from_map(m['LatestVersion'])
        return self


class GetK8sApplicationResponseBody(TeaModel):
    def __init__(
        self,
        applcation: GetK8sApplicationResponseBodyApplcation = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The information about the application.
        self.applcation = applcation
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.applcation:
            self.applcation.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.applcation is not None:
            result['Applcation'] = self.applcation.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Applcation') is not None:
            temp_model = GetK8sApplicationResponseBodyApplcation()
            self.applcation = temp_model.from_map(m['Applcation'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetK8sApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetK8sApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetK8sApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetK8sClusterRequest(TeaModel):
    def __init__(
        self,
        cluster_type: int = None,
        current_page: int = None,
        page_size: int = None,
        region_tag: str = None,
        sub_cluster_type: str = None,
    ):
        # The type of the Kubernetes cluster. Valid values:
        # 
        # *   5: ACK cluster
        # *   7: self-managed Kubernetes cluster
        self.cluster_type = cluster_type
        # The number of the page to return. Default value: 1.
        self.current_page = current_page
        # The number of entries to return on each page. Default value: 1000.
        self.page_size = page_size
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_tag = region_tag
        # The subtype of the cluster. Valid values:
        # 
        # *   Ask: Serverless Kubernetes cluster
        # *   ManagedKubernetes: ACK cluster
        self.sub_cluster_type = sub_cluster_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_tag is not None:
            result['RegionTag'] = self.region_tag
        if self.sub_cluster_type is not None:
            result['SubClusterType'] = self.sub_cluster_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionTag') is not None:
            self.region_tag = m.get('RegionTag')
        if m.get('SubClusterType') is not None:
            self.sub_cluster_type = m.get('SubClusterType')
        return self


class GetK8sClusterResponseBodyClusterPageClusterListCluster(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_import_status: int = None,
        cluster_name: str = None,
        cluster_status: int = None,
        cluster_type: int = None,
        cpu: int = None,
        cs_cluster_id: str = None,
        cs_cluster_status: str = None,
        description: str = None,
        mem: int = None,
        network_mode: int = None,
        node_num: int = None,
        region_id: str = None,
        sub_cluster_type: str = None,
        sub_net_cidr: str = None,
        vpc_id: str = None,
        vswitch_id: str = None,
    ):
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The import state of the cluster. Valid values:
        # 
        # *   0: The cluster is not imported.
        # *   1: The cluster is imported.
        # *   2: The cluster fails to be imported.
        # *   3: The cluster is being imported.
        # *   4: The cluster is deleted.
        self.cluster_import_status = cluster_import_status
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The status of the cluster. Valid values:
        # 
        # *   1: The cluster runs as expected.
        # *   2: The cluster does not run as expected.
        # *   3: The cluster is offline.
        self.cluster_status = cluster_status
        # The type of the cluster. Valid values:
        # 
        # *   2: Elastic Compute Service (ECS) cluster
        # *   5: ACK cluster or Serverless Kubernetes cluster
        self.cluster_type = cluster_type
        # The total number of CPU cores.
        self.cpu = cpu
        # The ID of the ACK cluster.
        self.cs_cluster_id = cs_cluster_id
        # The state of the ACK cluster. Valid values:
        # 
        # *   initial: The cluster is being initialized.
        # *   failed: The cluster fails to be created.
        # *   running: The cluster is running.
        # *   updating: The cluster is being updated.
        # *   scaling: The cluster is being scaled out.
        # *   removing: Nodes are being removed from the cluster.
        # *   upgrading: The cluster is being upgraded.
        # *   deleting: The cluster is being deleted.
        # *   delete_failed: The cluster fails to be deleted.
        # *   deleted: The cluster is deleted. The deleted cluster is invisible to users.
        self.cs_cluster_status = cs_cluster_status
        # The description of the cluster.
        self.description = description
        # The total size of memory. Unit: MB.
        self.mem = mem
        # The network type of the cluster. Valid values:
        # 
        # *   1: classic network
        # *   2: VPC
        self.network_mode = network_mode
        # The number of nodes.
        self.node_num = node_num
        # The ID of the namespace.
        self.region_id = region_id
        # The subtype of the cluster. Valid values:
        # 
        # *   Ask: Serverless Kubernetes cluster
        # *   ManagedKubernetes: ACK cluster
        self.sub_cluster_type = sub_cluster_type
        # The CIDR block of the subnet.
        self.sub_net_cidr = sub_net_cidr
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id
        # The ID of the vSwitch.
        self.vswitch_id = vswitch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_import_status is not None:
            result['ClusterImportStatus'] = self.cluster_import_status
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_status is not None:
            result['ClusterStatus'] = self.cluster_status
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.cs_cluster_id is not None:
            result['CsClusterId'] = self.cs_cluster_id
        if self.cs_cluster_status is not None:
            result['CsClusterStatus'] = self.cs_cluster_status
        if self.description is not None:
            result['Description'] = self.description
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.network_mode is not None:
            result['NetworkMode'] = self.network_mode
        if self.node_num is not None:
            result['NodeNum'] = self.node_num
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.sub_cluster_type is not None:
            result['SubClusterType'] = self.sub_cluster_type
        if self.sub_net_cidr is not None:
            result['SubNetCidr'] = self.sub_net_cidr
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vswitch_id is not None:
            result['VswitchId'] = self.vswitch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterImportStatus') is not None:
            self.cluster_import_status = m.get('ClusterImportStatus')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterStatus') is not None:
            self.cluster_status = m.get('ClusterStatus')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CsClusterId') is not None:
            self.cs_cluster_id = m.get('CsClusterId')
        if m.get('CsClusterStatus') is not None:
            self.cs_cluster_status = m.get('CsClusterStatus')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('NetworkMode') is not None:
            self.network_mode = m.get('NetworkMode')
        if m.get('NodeNum') is not None:
            self.node_num = m.get('NodeNum')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SubClusterType') is not None:
            self.sub_cluster_type = m.get('SubClusterType')
        if m.get('SubNetCidr') is not None:
            self.sub_net_cidr = m.get('SubNetCidr')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VswitchId') is not None:
            self.vswitch_id = m.get('VswitchId')
        return self


class GetK8sClusterResponseBodyClusterPageClusterList(TeaModel):
    def __init__(
        self,
        cluster: List[GetK8sClusterResponseBodyClusterPageClusterListCluster] = None,
    ):
        self.cluster = cluster

    def validate(self):
        if self.cluster:
            for k in self.cluster:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Cluster'] = []
        if self.cluster is not None:
            for k in self.cluster:
                result['Cluster'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cluster = []
        if m.get('Cluster') is not None:
            for k in m.get('Cluster'):
                temp_model = GetK8sClusterResponseBodyClusterPageClusterListCluster()
                self.cluster.append(temp_model.from_map(k))
        return self


class GetK8sClusterResponseBodyClusterPage(TeaModel):
    def __init__(
        self,
        cluster_list: GetK8sClusterResponseBodyClusterPageClusterList = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The list of clusters.
        self.cluster_list = cluster_list
        # The number of the returned page. Default value: 1.
        self.current_page = current_page
        # The number of entries returned per page. Default value: 1000.
        self.page_size = page_size
        # The total number of pages that are returned.
        self.total_size = total_size

    def validate(self):
        if self.cluster_list:
            self.cluster_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_list is not None:
            result['ClusterList'] = self.cluster_list.to_map()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterList') is not None:
            temp_model = GetK8sClusterResponseBodyClusterPageClusterList()
            self.cluster_list = temp_model.from_map(m['ClusterList'])
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class GetK8sClusterResponseBody(TeaModel):
    def __init__(
        self,
        cluster_page: GetK8sClusterResponseBodyClusterPage = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The cluster data that is returned by page.
        self.cluster_page = cluster_page
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.cluster_page:
            self.cluster_page.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_page is not None:
            result['ClusterPage'] = self.cluster_page.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterPage') is not None:
            temp_model = GetK8sClusterResponseBodyClusterPage()
            self.cluster_page = temp_model.from_map(m['ClusterPage'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetK8sClusterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetK8sClusterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetK8sClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetK8sServicesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class GetK8sServicesResponseBodyServicesServicePorts(TeaModel):
    def __init__(
        self,
        node_port: int = None,
        port: int = None,
        protocol: str = None,
        target_port: str = None,
    ):
        # The port of the node.
        self.node_port = node_port
        # The frontend service port.
        self.port = port
        # The protocol of the service.
        self.protocol = protocol
        # The backend container port.
        self.target_port = target_port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_port is not None:
            result['NodePort'] = self.node_port
        if self.port is not None:
            result['Port'] = self.port
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.target_port is not None:
            result['TargetPort'] = self.target_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodePort') is not None:
            self.node_port = m.get('NodePort')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('TargetPort') is not None:
            self.target_port = m.get('TargetPort')
        return self


class GetK8sServicesResponseBodyServices(TeaModel):
    def __init__(
        self,
        cluster_ip: str = None,
        name: str = None,
        service_ports: List[GetK8sServicesResponseBodyServicesServicePorts] = None,
        type: str = None,
    ):
        # The IP address of the service in the Kubernetes cluster.
        self.cluster_ip = cluster_ip
        # The name of the service.
        self.name = name
        # The mapping of service ports.
        self.service_ports = service_ports
        # The type of the service.
        self.type = type

    def validate(self):
        if self.service_ports:
            for k in self.service_ports:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_ip is not None:
            result['ClusterIP'] = self.cluster_ip
        if self.name is not None:
            result['Name'] = self.name
        result['ServicePorts'] = []
        if self.service_ports is not None:
            for k in self.service_ports:
                result['ServicePorts'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterIP') is not None:
            self.cluster_ip = m.get('ClusterIP')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.service_ports = []
        if m.get('ServicePorts') is not None:
            for k in m.get('ServicePorts'):
                temp_model = GetK8sServicesResponseBodyServicesServicePorts()
                self.service_ports.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetK8sServicesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        services: List[GetK8sServicesResponseBodyServices] = None,
    ):
        # The ID of the change process.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The list of services in the Kubernetes cluster.
        self.services = services

    def validate(self):
        if self.services:
            for k in self.services:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Services'] = []
        if self.services is not None:
            for k in self.services:
                result['Services'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.services = []
        if m.get('Services') is not None:
            for k in m.get('Services'):
                temp_model = GetK8sServicesResponseBodyServices()
                self.services.append(temp_model.from_map(k))
        return self


class GetK8sServicesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetK8sServicesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetK8sServicesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPackageStorageCredentialResponseBodyCredential(TeaModel):
    def __init__(
        self,
        access_key_id: str = None,
        access_key_secret: str = None,
        bucket: str = None,
        expiration: str = None,
        key_prefix: str = None,
        oss_internal_endpoint: str = None,
        oss_public_endpoint: str = None,
        oss_vpc_endpoint: str = None,
        region_id: str = None,
        security_token: str = None,
    ):
        # The AccessKey ID of your account.
        self.access_key_id = access_key_id
        # The AccessKey secret of your account.
        self.access_key_secret = access_key_secret
        # The name of the OSS bucket.
        self.bucket = bucket
        # The time when the STS credential expires. Example: 2019-11-10T07:20:19Z.
        self.expiration = expiration
        # The object key prefix in Object Storage Service (OSS).
        self.key_prefix = key_prefix
        # The private endpoint of OSS.
        self.oss_internal_endpoint = oss_internal_endpoint
        # The public endpoint of OSS.
        self.oss_public_endpoint = oss_public_endpoint
        # The VPC endpoint of OSS.
        self.oss_vpc_endpoint = oss_vpc_endpoint
        # The ID of the region.
        self.region_id = region_id
        # The security token issued by STS.
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key_id is not None:
            result['AccessKeyId'] = self.access_key_id
        if self.access_key_secret is not None:
            result['AccessKeySecret'] = self.access_key_secret
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.expiration is not None:
            result['Expiration'] = self.expiration
        if self.key_prefix is not None:
            result['KeyPrefix'] = self.key_prefix
        if self.oss_internal_endpoint is not None:
            result['OssInternalEndpoint'] = self.oss_internal_endpoint
        if self.oss_public_endpoint is not None:
            result['OssPublicEndpoint'] = self.oss_public_endpoint
        if self.oss_vpc_endpoint is not None:
            result['OssVpcEndpoint'] = self.oss_vpc_endpoint
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessKeyId') is not None:
            self.access_key_id = m.get('AccessKeyId')
        if m.get('AccessKeySecret') is not None:
            self.access_key_secret = m.get('AccessKeySecret')
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Expiration') is not None:
            self.expiration = m.get('Expiration')
        if m.get('KeyPrefix') is not None:
            self.key_prefix = m.get('KeyPrefix')
        if m.get('OssInternalEndpoint') is not None:
            self.oss_internal_endpoint = m.get('OssInternalEndpoint')
        if m.get('OssPublicEndpoint') is not None:
            self.oss_public_endpoint = m.get('OssPublicEndpoint')
        if m.get('OssVpcEndpoint') is not None:
            self.oss_vpc_endpoint = m.get('OssVpcEndpoint')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class GetPackageStorageCredentialResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        credential: GetPackageStorageCredentialResponseBodyCredential = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The STS credential.
        self.credential = credential
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.credential:
            self.credential.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.credential is not None:
            result['Credential'] = self.credential.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Credential') is not None:
            temp_model = GetPackageStorageCredentialResponseBodyCredential()
            self.credential = temp_model.from_map(m['Credential'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetPackageStorageCredentialResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPackageStorageCredentialResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPackageStorageCredentialResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetScalingRulesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group_id: str = None,
        mode: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the instance group to which the application is deployed.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The type of the scaling rule. You can leave this parameter empty. Valid values:
        # 
        # *   SCALE_IN: scale-in rules
        # *   SCALE_OUT: scale-out rules
        self.mode = mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.mode is not None:
            result['Mode'] = self.mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        return self


class GetScalingRulesResponseBodyDataRuleListRule(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        cond: str = None,
        cpu: int = None,
        create_time: int = None,
        duration: int = None,
        enable: bool = None,
        group_id: str = None,
        inst_num: int = None,
        load_num: int = None,
        metric_type: str = None,
        mode: str = None,
        multi_az_policy: str = None,
        resource_from: str = None,
        rt: int = None,
        spec_id: str = None,
        step: int = None,
        template_id: str = None,
        template_version: int = None,
        update_time: int = None,
        v_switch_ids: str = None,
        vpc_id: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The relationship among the conditions that trigger the scaling rule.
        # 
        # *   OR: one of the conditions
        # *   AND: all conditions
        self.cond = cond
        # The minimum CPU utilization that triggers the scaling rule.
        self.cpu = cpu
        # The time when the scaling rule was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The duration of the scaling rule. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.duration = duration
        # Indicates whether scale-ins or scale-outs are allowed. Valid values:
        # 
        # *   true: Scale-ins or scale-outs are allowed.
        # *   false: Scale-ins or scale-outs are disallowed.
        self.enable = enable
        # The ID of the instance group to which the application is deployed.
        self.group_id = group_id
        # The maximum number of instances in the group when a scale-out is performed, or the minimum number of instances in the group when a scale-in is performed.
        self.inst_num = inst_num
        # The system load that triggers the scaling rule. The system load is evaluated based on the number of processes that are being executed by CPUs and the number of processes that wait to be executed by CPUs.
        self.load_num = load_num
        # The type of the metric.
        self.metric_type = metric_type
        # The type of the scaling rule. Valid values:
        # 
        # *   SCALE_IN: scale-in rules
        # *   SCALE_OUT: scale-out rules
        self.mode = mode
        # The policy of auto scaling across multiple zones. Valid values:
        # 
        # *   PRIORITY: The vSwitch that is first selected has the highest priority.
        # *   BALANCE: This policy evenly distributes instances across zones in which the vSwitches reside.
        self.multi_az_policy = multi_az_policy
        # The source of the instance that you want to add during a scale-out. Valid values:
        # 
        # *   NEW: Elastic resources are used.
        # *   AVAILABLE: The existing resources are used.
        # *   AVAILABLE_FIRST: The existing resources are used first.
        self.resource_from = resource_from
        # The service latency that triggers the scaling rule. Unit: milliseconds.
        self.rt = rt
        # The ID of the specification.
        self.spec_id = spec_id
        # The number of instances that are added during each scale-out or removed during each scale-in.
        self.step = step
        # The ID of the launch template.
        self.template_id = template_id
        # The version of the launch template.
        self.template_version = template_version
        # The time when the scaling rule was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time
        # The IDs of the vSwitches. The IDs of multiple vSwitches are separated by commas (,).
        self.v_switch_ids = v_switch_ids
        # The ID of the VPC.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.cond is not None:
            result['Cond'] = self.cond
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.inst_num is not None:
            result['InstNum'] = self.inst_num
        if self.load_num is not None:
            result['LoadNum'] = self.load_num
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.multi_az_policy is not None:
            result['MultiAzPolicy'] = self.multi_az_policy
        if self.resource_from is not None:
            result['ResourceFrom'] = self.resource_from
        if self.rt is not None:
            result['Rt'] = self.rt
        if self.spec_id is not None:
            result['SpecId'] = self.spec_id
        if self.step is not None:
            result['Step'] = self.step
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_version is not None:
            result['TemplateVersion'] = self.template_version
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.v_switch_ids is not None:
            result['VSwitchIds'] = self.v_switch_ids
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Cond') is not None:
            self.cond = m.get('Cond')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstNum') is not None:
            self.inst_num = m.get('InstNum')
        if m.get('LoadNum') is not None:
            self.load_num = m.get('LoadNum')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('MultiAzPolicy') is not None:
            self.multi_az_policy = m.get('MultiAzPolicy')
        if m.get('ResourceFrom') is not None:
            self.resource_from = m.get('ResourceFrom')
        if m.get('Rt') is not None:
            self.rt = m.get('Rt')
        if m.get('SpecId') is not None:
            self.spec_id = m.get('SpecId')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateVersion') is not None:
            self.template_version = m.get('TemplateVersion')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('VSwitchIds') is not None:
            self.v_switch_ids = m.get('VSwitchIds')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class GetScalingRulesResponseBodyDataRuleList(TeaModel):
    def __init__(
        self,
        rule: List[GetScalingRulesResponseBodyDataRuleListRule] = None,
    ):
        self.rule = rule

    def validate(self):
        if self.rule:
            for k in self.rule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Rule'] = []
        if self.rule is not None:
            for k in self.rule:
                result['Rule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.rule = []
        if m.get('Rule') is not None:
            for k in m.get('Rule'):
                temp_model = GetScalingRulesResponseBodyDataRuleListRule()
                self.rule.append(temp_model.from_map(k))
        return self


class GetScalingRulesResponseBodyData(TeaModel):
    def __init__(
        self,
        cluster_type: int = None,
        oversold_factor: int = None,
        rule_list: GetScalingRulesResponseBodyDataRuleList = None,
        update_time: int = None,
        vpc_id: str = None,
    ):
        # The type of the cluster. Valid values:
        # 
        # *   0: regular Docker cluster
        # *   1: Swarm cluster (deprecated)
        # *   2: Elastic Compute Service (ECS) cluster
        # *   3: self-managed Kubernetes cluster in EDAS
        # *   4: cluster in which Pandora automatically registers applications
        # *   5: Container Service for Kubernetes (ACK) clusters
        self.cluster_type = cluster_type
        # The overcommit ratio supported by a Docker cluster. Valid values:
        # 
        # *   1: 1:1, which means that resources are not overcommitted.
        # *   2: 1:2, which means that resources are overcommitted by 1:2.
        # *   4: 1:4, which means that resources are overcommitted by 1:4.
        # *   8: 1:8, which means that resources are overcommitted by 1:8.
        self.oversold_factor = oversold_factor
        # The array data of the scaling rule.
        self.rule_list = rule_list
        # The time when the scaling rule was last updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id

    def validate(self):
        if self.rule_list:
            self.rule_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.oversold_factor is not None:
            result['OversoldFactor'] = self.oversold_factor
        if self.rule_list is not None:
            result['RuleList'] = self.rule_list.to_map()
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('OversoldFactor') is not None:
            self.oversold_factor = m.get('OversoldFactor')
        if m.get('RuleList') is not None:
            temp_model = GetScalingRulesResponseBodyDataRuleList()
            self.rule_list = temp_model.from_map(m['RuleList'])
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class GetScalingRulesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: GetScalingRulesResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        update_time: int = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The data that is returned.
        self.data = data
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The time when the scaling rule was last updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetScalingRulesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class GetScalingRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetScalingRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetScalingRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSecureTokenRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
    ):
        # The ID of the namespace, such as cn-beijing or cn-beijing:prod````.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class GetSecureTokenResponseBodySecureToken(TeaModel):
    def __init__(
        self,
        access_key: str = None,
        address_server_host: str = None,
        belong_region: str = None,
        description: str = None,
        edas_id: str = None,
        id: int = None,
        mse_instance_id: str = None,
        mse_internet_address: str = None,
        mse_intranet_address: str = None,
        mse_registry_type: str = None,
        region_id: str = None,
        region_name: str = None,
        secret_key: str = None,
        tenant_id: str = None,
        user_id: str = None,
    ):
        # The AccessKey ID used in the namespace.
        self.access_key = access_key
        # The address of Address Server associated with the namespace.
        self.address_server_host = address_server_host
        # The ID of the region.
        self.belong_region = belong_region
        # The description of the namespace.
        self.description = description
        # The ID of the Alibaba Cloud account that activated Enterprise Distributed Application Service (EDAS).
        self.edas_id = edas_id
        # The ID of the security token.
        self.id = id
        # The ID of the MSE instance.
        self.mse_instance_id = mse_instance_id
        # The public endpoint of the MSE registry.
        self.mse_internet_address = mse_internet_address
        # The private endpoint of the MSE registry.
        self.mse_intranet_address = mse_intranet_address
        # The type of the Microservices Engine (MSE) registry.
        # 
        # *   default: the shared registry of EDAS
        # *   exclusive_mse: MSE Nacos registry
        self.mse_registry_type = mse_registry_type
        # The ID of the region where the namespace resides.
        self.region_id = region_id
        # The name of the region where the namespace resides.
        self.region_name = region_name
        # The AccessKey secret used in the namespace.
        self.secret_key = secret_key
        # The tenant ID of the namespace.
        self.tenant_id = tenant_id
        # The ID of the user.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key is not None:
            result['AccessKey'] = self.access_key
        if self.address_server_host is not None:
            result['AddressServerHost'] = self.address_server_host
        if self.belong_region is not None:
            result['BelongRegion'] = self.belong_region
        if self.description is not None:
            result['Description'] = self.description
        if self.edas_id is not None:
            result['EdasId'] = self.edas_id
        if self.id is not None:
            result['Id'] = self.id
        if self.mse_instance_id is not None:
            result['MseInstanceId'] = self.mse_instance_id
        if self.mse_internet_address is not None:
            result['MseInternetAddress'] = self.mse_internet_address
        if self.mse_intranet_address is not None:
            result['MseIntranetAddress'] = self.mse_intranet_address
        if self.mse_registry_type is not None:
            result['MseRegistryType'] = self.mse_registry_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.region_name is not None:
            result['RegionName'] = self.region_name
        if self.secret_key is not None:
            result['SecretKey'] = self.secret_key
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessKey') is not None:
            self.access_key = m.get('AccessKey')
        if m.get('AddressServerHost') is not None:
            self.address_server_host = m.get('AddressServerHost')
        if m.get('BelongRegion') is not None:
            self.belong_region = m.get('BelongRegion')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EdasId') is not None:
            self.edas_id = m.get('EdasId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MseInstanceId') is not None:
            self.mse_instance_id = m.get('MseInstanceId')
        if m.get('MseInternetAddress') is not None:
            self.mse_internet_address = m.get('MseInternetAddress')
        if m.get('MseIntranetAddress') is not None:
            self.mse_intranet_address = m.get('MseIntranetAddress')
        if m.get('MseRegistryType') is not None:
            self.mse_registry_type = m.get('MseRegistryType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegionName') is not None:
            self.region_name = m.get('RegionName')
        if m.get('SecretKey') is not None:
            self.secret_key = m.get('SecretKey')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetSecureTokenResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        secure_token: GetSecureTokenResponseBodySecureToken = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The message returned for the request.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The returned security token.
        self.secure_token = secure_token

    def validate(self):
        if self.secure_token:
            self.secure_token.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.secure_token is not None:
            result['SecureToken'] = self.secure_token.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecureToken') is not None:
            temp_model = GetSecureTokenResponseBodySecureToken()
            self.secure_token = temp_model.from_map(m['SecureToken'])
        return self


class GetSecureTokenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSecureTokenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSecureTokenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetServiceConsumersPageRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group: str = None,
        ip: str = None,
        namespace: str = None,
        origin: str = None,
        page: int = None,
        region: str = None,
        registry_type: str = None,
        service_id: str = None,
        service_name: str = None,
        service_type: str = None,
        service_version: str = None,
        size: int = None,
        source: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The service group.
        self.group = group
        # The IP address of the service provider. Fuzzy searches are supported.
        self.ip = ip
        # The ID of the namespace.
        self.namespace = namespace
        # The source of the data. Valid values:
        # 
        # *   agent: Use this value if you use the service query feature of the latest version to pass the query result.
        # *   registry: Use this value if you use the service query feature of the earlier version to pass the query result.
        self.origin = origin
        # The number of the page to return.
        self.page = page
        # The ID of the region.
        self.region = region
        # The type of the service registry. This parameter is deprecated. You can ignore it.
        self.registry_type = registry_type
        # The ID of the service. This parameter is deprecated. You can ignore it.
        self.service_id = service_id
        # The name of the service.
        self.service_name = service_name
        # The type of the service.
        self.service_type = service_type
        # The version of the service.
        self.service_version = service_version
        # The number of entries returned per page.
        self.size = size
        # The source of the service. Set the value to edas.
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['appId'] = self.app_id
        if self.group is not None:
            result['group'] = self.group
        if self.ip is not None:
            result['ip'] = self.ip
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.origin is not None:
            result['origin'] = self.origin
        if self.page is not None:
            result['page'] = self.page
        if self.region is not None:
            result['region'] = self.region
        if self.registry_type is not None:
            result['registryType'] = self.registry_type
        if self.service_id is not None:
            result['serviceId'] = self.service_id
        if self.service_name is not None:
            result['serviceName'] = self.service_name
        if self.service_type is not None:
            result['serviceType'] = self.service_type
        if self.service_version is not None:
            result['serviceVersion'] = self.service_version
        if self.size is not None:
            result['size'] = self.size
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('appId') is not None:
            self.app_id = m.get('appId')
        if m.get('group') is not None:
            self.group = m.get('group')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('origin') is not None:
            self.origin = m.get('origin')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('registryType') is not None:
            self.registry_type = m.get('registryType')
        if m.get('serviceId') is not None:
            self.service_id = m.get('serviceId')
        if m.get('serviceName') is not None:
            self.service_name = m.get('serviceName')
        if m.get('serviceType') is not None:
            self.service_type = m.get('serviceType')
        if m.get('serviceVersion') is not None:
            self.service_version = m.get('serviceVersion')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class GetServiceConsumersPageResponseBodyDataContent(TeaModel):
    def __init__(
        self,
        edas_app_name: str = None,
        edass_app_id: str = None,
        ip: str = None,
    ):
        # The name of the service consumer.
        self.edas_app_name = edas_app_name
        # The ID of the service consumer.
        self.edass_app_id = edass_app_id
        # The IP address of the service consumer.
        self.ip = ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.edas_app_name is not None:
            result['EdasAppName'] = self.edas_app_name
        if self.edass_app_id is not None:
            result['EdassAppId'] = self.edass_app_id
        if self.ip is not None:
            result['Ip'] = self.ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EdasAppName') is not None:
            self.edas_app_name = m.get('EdasAppName')
        if m.get('EdassAppId') is not None:
            self.edass_app_id = m.get('EdassAppId')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        return self


class GetServiceConsumersPageResponseBodyData(TeaModel):
    def __init__(
        self,
        content: List[GetServiceConsumersPageResponseBodyDataContent] = None,
        size: int = None,
        total_elements: int = None,
        total_pages: int = None,
    ):
        # The data array that is returned.
        self.content = content
        # The number of entries to return on each page.
        self.size = size
        # The total number of returned entries.
        self.total_elements = total_elements
        # The total number of returned pages.
        self.total_pages = total_pages

    def validate(self):
        if self.content:
            for k in self.content:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Content'] = []
        if self.content is not None:
            for k in self.content:
                result['Content'].append(k.to_map() if k else None)
        if self.size is not None:
            result['Size'] = self.size
        if self.total_elements is not None:
            result['TotalElements'] = self.total_elements
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.content = []
        if m.get('Content') is not None:
            for k in m.get('Content'):
                temp_model = GetServiceConsumersPageResponseBodyDataContent()
                self.content.append(temp_model.from_map(k))
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('TotalElements') is not None:
            self.total_elements = m.get('TotalElements')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class GetServiceConsumersPageResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: GetServiceConsumersPageResponseBodyData = None,
        message: str = None,
        success: bool = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The data that is returned.
        self.data = data
        # The message that is returned for the request.
        self.message = message
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetServiceConsumersPageResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetServiceConsumersPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetServiceConsumersPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetServiceConsumersPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetServiceDetailRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group: str = None,
        ip: str = None,
        namespace: str = None,
        origin: str = None,
        region: str = None,
        registry_type: str = None,
        service_id: str = None,
        service_name: str = None,
        service_type: str = None,
        service_version: str = None,
        source: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The group to which the service belongs.
        self.group = group
        # The IP address of the service provider. Fuzzy searches are supported.
        self.ip = ip
        # The ID of the namespace.
        self.namespace = namespace
        # The source of the data. Valid values:
        # 
        # *   agent: Use this value if you use the service query feature of the latest version to pass the query result.
        # *   registry: Use this value if you use the service query feature of the earlier version to pass the query result.
        self.origin = origin
        # The region ID of the service.
        self.region = region
        # The type of the service registry. This parameter is deprecated. You can ignore it.
        self.registry_type = registry_type
        # The ID of the service. This parameter is deprecated. You can ignore it.
        self.service_id = service_id
        # The name of the service.
        self.service_name = service_name
        # The type of the service. Valid values:
        # 
        # *   dubbo
        # *   springCloud
        # *   hsf
        # *   istio
        self.service_type = service_type
        # The version of the service.
        self.service_version = service_version
        # The source of the service. Set the value to edas.
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['appId'] = self.app_id
        if self.group is not None:
            result['group'] = self.group
        if self.ip is not None:
            result['ip'] = self.ip
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.origin is not None:
            result['origin'] = self.origin
        if self.region is not None:
            result['region'] = self.region
        if self.registry_type is not None:
            result['registryType'] = self.registry_type
        if self.service_id is not None:
            result['serviceId'] = self.service_id
        if self.service_name is not None:
            result['serviceName'] = self.service_name
        if self.service_type is not None:
            result['serviceType'] = self.service_type
        if self.service_version is not None:
            result['serviceVersion'] = self.service_version
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('appId') is not None:
            self.app_id = m.get('appId')
        if m.get('group') is not None:
            self.group = m.get('group')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('origin') is not None:
            self.origin = m.get('origin')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('registryType') is not None:
            self.registry_type = m.get('registryType')
        if m.get('serviceId') is not None:
            self.service_id = m.get('serviceId')
        if m.get('serviceName') is not None:
            self.service_name = m.get('serviceName')
        if m.get('serviceType') is not None:
            self.service_type = m.get('serviceType')
        if m.get('serviceVersion') is not None:
            self.service_version = m.get('serviceVersion')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class GetServiceDetailResponseBodyDataMethodsReturnDefinition(TeaModel):
    def __init__(
        self,
        id: str = None,
        type: str = None,
    ):
        # The ID of the return value.
        self.id = id
        # The type of the response.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetServiceDetailResponseBodyDataMethods(TeaModel):
    def __init__(
        self,
        method_controller: str = None,
        name: str = None,
        name_detail: str = None,
        parameter_definitions: str = None,
        parameter_details: str = None,
        parameter_names: str = None,
        parameter_types: str = None,
        paths: str = None,
        request_methods: str = None,
        return_definition: GetServiceDetailResponseBodyDataMethodsReturnDefinition = None,
        return_details: str = None,
        return_type: str = None,
    ):
        # The controllers.
        self.method_controller = method_controller
        # The name of the service.
        self.name = name
        # The specific name.
        self.name_detail = name_detail
        # The parameter definitions.
        self.parameter_definitions = parameter_definitions
        # The parameter details.
        self.parameter_details = parameter_details
        # The parameter names.
        self.parameter_names = parameter_names
        # The parameter types.
        self.parameter_types = parameter_types
        # The method paths.
        self.paths = paths
        # The request methods.
        self.request_methods = request_methods
        # The definition of the value returned by the method.
        self.return_definition = return_definition
        # The response details.
        self.return_details = return_details
        # The type of the response.
        self.return_type = return_type

    def validate(self):
        if self.return_definition:
            self.return_definition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.method_controller is not None:
            result['MethodController'] = self.method_controller
        if self.name is not None:
            result['Name'] = self.name
        if self.name_detail is not None:
            result['NameDetail'] = self.name_detail
        if self.parameter_definitions is not None:
            result['ParameterDefinitions'] = self.parameter_definitions
        if self.parameter_details is not None:
            result['ParameterDetails'] = self.parameter_details
        if self.parameter_names is not None:
            result['ParameterNames'] = self.parameter_names
        if self.parameter_types is not None:
            result['ParameterTypes'] = self.parameter_types
        if self.paths is not None:
            result['Paths'] = self.paths
        if self.request_methods is not None:
            result['RequestMethods'] = self.request_methods
        if self.return_definition is not None:
            result['ReturnDefinition'] = self.return_definition.to_map()
        if self.return_details is not None:
            result['ReturnDetails'] = self.return_details
        if self.return_type is not None:
            result['ReturnType'] = self.return_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MethodController') is not None:
            self.method_controller = m.get('MethodController')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NameDetail') is not None:
            self.name_detail = m.get('NameDetail')
        if m.get('ParameterDefinitions') is not None:
            self.parameter_definitions = m.get('ParameterDefinitions')
        if m.get('ParameterDetails') is not None:
            self.parameter_details = m.get('ParameterDetails')
        if m.get('ParameterNames') is not None:
            self.parameter_names = m.get('ParameterNames')
        if m.get('ParameterTypes') is not None:
            self.parameter_types = m.get('ParameterTypes')
        if m.get('Paths') is not None:
            self.paths = m.get('Paths')
        if m.get('RequestMethods') is not None:
            self.request_methods = m.get('RequestMethods')
        if m.get('ReturnDefinition') is not None:
            temp_model = GetServiceDetailResponseBodyDataMethodsReturnDefinition()
            self.return_definition = temp_model.from_map(m['ReturnDefinition'])
        if m.get('ReturnDetails') is not None:
            self.return_details = m.get('ReturnDetails')
        if m.get('ReturnType') is not None:
            self.return_type = m.get('ReturnType')
        return self


class GetServiceDetailResponseBodyData(TeaModel):
    def __init__(
        self,
        dubbo_application_name: str = None,
        edas_app_name: str = None,
        group: str = None,
        metadata: str = None,
        methods: List[GetServiceDetailResponseBodyDataMethods] = None,
        registry_type: str = None,
        service_name: str = None,
        service_type: str = None,
        spring_application_name: str = None,
        version: str = None,
    ):
        # The name of the Dubbo application.
        self.dubbo_application_name = dubbo_application_name
        # The name of the Enterprise Distributed Application Service (EDAS) application.
        self.edas_app_name = edas_app_name
        # The group.
        self.group = group
        # The metadata.
        self.metadata = metadata
        # The methods.
        self.methods = methods
        # The type of the service registry.
        self.registry_type = registry_type
        # The name of the service.
        self.service_name = service_name
        # The type of the service.
        self.service_type = service_type
        # The name of the Spring application.
        self.spring_application_name = spring_application_name
        # The version number.
        self.version = version

    def validate(self):
        if self.methods:
            for k in self.methods:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dubbo_application_name is not None:
            result['DubboApplicationName'] = self.dubbo_application_name
        if self.edas_app_name is not None:
            result['EdasAppName'] = self.edas_app_name
        if self.group is not None:
            result['Group'] = self.group
        if self.metadata is not None:
            result['Metadata'] = self.metadata
        result['Methods'] = []
        if self.methods is not None:
            for k in self.methods:
                result['Methods'].append(k.to_map() if k else None)
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.service_type is not None:
            result['ServiceType'] = self.service_type
        if self.spring_application_name is not None:
            result['SpringApplicationName'] = self.spring_application_name
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DubboApplicationName') is not None:
            self.dubbo_application_name = m.get('DubboApplicationName')
        if m.get('EdasAppName') is not None:
            self.edas_app_name = m.get('EdasAppName')
        if m.get('Group') is not None:
            self.group = m.get('Group')
        if m.get('Metadata') is not None:
            self.metadata = m.get('Metadata')
        self.methods = []
        if m.get('Methods') is not None:
            for k in m.get('Methods'):
                temp_model = GetServiceDetailResponseBodyDataMethods()
                self.methods.append(temp_model.from_map(k))
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('ServiceType') is not None:
            self.service_type = m.get('ServiceType')
        if m.get('SpringApplicationName') is not None:
            self.spring_application_name = m.get('SpringApplicationName')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class GetServiceDetailResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: GetServiceDetailResponseBodyData = None,
        message: str = None,
        success: bool = None,
    ):
        # The HTTP status code returned.
        self.code = code
        # The data structure.
        self.data = data
        # The message returned for the request.
        self.message = message
        # Indicates whether the call was successful.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetServiceDetailResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetServiceDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetServiceDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetServiceDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetServiceListPageRequest(TeaModel):
    def __init__(
        self,
        namespace: str = None,
        origin: str = None,
        page: int = None,
        region: str = None,
        search_type: str = None,
        search_value: str = None,
        service_type: str = None,
        side: str = None,
        size: int = None,
    ):
        # The namespace.
        self.namespace = namespace
        # The source of the data. Valid values:
        # 
        # *   `agent`: Use this value if you use the service query feature of the latest version to pass the query result.
        # *   `registry`: Use this value if you use the service query feature of the earlier version to pass the query result.
        self.origin = origin
        # The number of the page to return. Pages start from Page 0.
        self.page = page
        # The ID of the region.
        self.region = region
        # The type of the service. Valid values:
        # 
        # *   `app`: searches by application.
        # *   `service`: searches by service.
        # *   `providerIp`: searches by IP address.
        self.search_type = search_type
        # The keyword used for the search.
        # 
        # *   Set this parameter to the ID of the application if you set the searchType parameter to app.``
        # *   Set this parameter to the name of the service if you set the serachType parameter to service.``
        # *   Set this parameter to the IP address of the application if you set the searchType parameter to providerIp.
        self.search_value = search_value
        # The type of the service. Valid values:
        # 
        # *   `dubbo`
        # *   `springCloud`
        # *   `hsf`
        # *   `istio`
        self.service_type = service_type
        # Specifies the provider side or the consumer side. Valid values:
        # 
        # *   provider
        # *   consumer
        self.side = side
        # The number of entries to return on each page.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.origin is not None:
            result['origin'] = self.origin
        if self.page is not None:
            result['page'] = self.page
        if self.region is not None:
            result['region'] = self.region
        if self.search_type is not None:
            result['searchType'] = self.search_type
        if self.search_value is not None:
            result['searchValue'] = self.search_value
        if self.service_type is not None:
            result['serviceType'] = self.service_type
        if self.side is not None:
            result['side'] = self.side
        if self.size is not None:
            result['size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('origin') is not None:
            self.origin = m.get('origin')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('searchType') is not None:
            self.search_type = m.get('searchType')
        if m.get('searchValue') is not None:
            self.search_value = m.get('searchValue')
        if m.get('serviceType') is not None:
            self.service_type = m.get('serviceType')
        if m.get('side') is not None:
            self.side = m.get('side')
        if m.get('size') is not None:
            self.size = m.get('size')
        return self


class GetServiceListPageResponseBodyDataContent(TeaModel):
    def __init__(
        self,
        edas_app_id: str = None,
        edas_app_name: str = None,
        group: str = None,
        instance_num: int = None,
        register_type: str = None,
        service_id: str = None,
        service_name: str = None,
        version: str = None,
    ):
        # The ID of the application.
        self.edas_app_id = edas_app_id
        # The name of the application.
        self.edas_app_name = edas_app_name
        # The service group.
        self.group = group
        # The number of instances.
        self.instance_num = instance_num
        # The type of the service registry.
        self.register_type = register_type
        # The ID of the service.
        self.service_id = service_id
        # The name of the service.
        self.service_name = service_name
        # The version number.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.edas_app_id is not None:
            result['EdasAppId'] = self.edas_app_id
        if self.edas_app_name is not None:
            result['EdasAppName'] = self.edas_app_name
        if self.group is not None:
            result['Group'] = self.group
        if self.instance_num is not None:
            result['InstanceNum'] = self.instance_num
        if self.register_type is not None:
            result['RegisterType'] = self.register_type
        if self.service_id is not None:
            result['ServiceId'] = self.service_id
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EdasAppId') is not None:
            self.edas_app_id = m.get('EdasAppId')
        if m.get('EdasAppName') is not None:
            self.edas_app_name = m.get('EdasAppName')
        if m.get('Group') is not None:
            self.group = m.get('Group')
        if m.get('InstanceNum') is not None:
            self.instance_num = m.get('InstanceNum')
        if m.get('RegisterType') is not None:
            self.register_type = m.get('RegisterType')
        if m.get('ServiceId') is not None:
            self.service_id = m.get('ServiceId')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class GetServiceListPageResponseBodyData(TeaModel):
    def __init__(
        self,
        content: List[GetServiceListPageResponseBodyDataContent] = None,
        size: int = None,
        total_elements: int = None,
        total_pages: int = None,
    ):
        # The data array that is returned.
        self.content = content
        # The number of entries returned per page.
        self.size = size
        # The total number of returned entries.
        self.total_elements = total_elements
        # The total number of returned pages.
        self.total_pages = total_pages

    def validate(self):
        if self.content:
            for k in self.content:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Content'] = []
        if self.content is not None:
            for k in self.content:
                result['Content'].append(k.to_map() if k else None)
        if self.size is not None:
            result['Size'] = self.size
        if self.total_elements is not None:
            result['TotalElements'] = self.total_elements
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.content = []
        if m.get('Content') is not None:
            for k in m.get('Content'):
                temp_model = GetServiceListPageResponseBodyDataContent()
                self.content.append(temp_model.from_map(k))
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('TotalElements') is not None:
            self.total_elements = m.get('TotalElements')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class GetServiceListPageResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: GetServiceListPageResponseBodyData = None,
        message: str = None,
        success: bool = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The returned data.
        self.data = data
        # The message that is returned for the request.
        self.message = message
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetServiceListPageResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetServiceListPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetServiceListPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetServiceListPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetServiceMethodPageRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group: str = None,
        ip: str = None,
        method_controller: str = None,
        name: str = None,
        namespace: str = None,
        origin: str = None,
        page_number: int = None,
        page_size: int = None,
        path: str = None,
        region: str = None,
        registry_type: str = None,
        service_id: str = None,
        service_name: str = None,
        service_type: str = None,
        service_version: str = None,
        source: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The group to which the service belongs.
        self.group = group
        # The IP address of the service.
        self.ip = ip
        # The controller method.
        self.method_controller = method_controller
        # The name of the method.
        self.name = name
        # The ID of the namespace.
        self.namespace = namespace
        # The source of the data. Valid values:
        # 
        # *   agent: Use this value if you use the service query feature of the latest version to pass the query result.
        # *   registry: Use this value if you use the service query feature of the earlier version to pass the query result.
        self.origin = origin
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The request path.
        self.path = path
        # The ID of the region.
        self.region = region
        # The type of the service registry.
        self.registry_type = registry_type
        # The ID of the service.
        self.service_id = service_id
        # The name of the service.
        self.service_name = service_name
        # The type of the service. Valid values:
        # 
        # *   dubbo: Dubbo service
        # *   springCloud: Spring Cloud service
        # *   hsf: High-speed Service Framework (HSF) service
        self.service_type = service_type
        # The version of the service.
        self.service_version = service_version
        # The source of the service. Set the value to edas.
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['appId'] = self.app_id
        if self.group is not None:
            result['group'] = self.group
        if self.ip is not None:
            result['ip'] = self.ip
        if self.method_controller is not None:
            result['methodController'] = self.method_controller
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.origin is not None:
            result['origin'] = self.origin
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.path is not None:
            result['path'] = self.path
        if self.region is not None:
            result['region'] = self.region
        if self.registry_type is not None:
            result['registryType'] = self.registry_type
        if self.service_id is not None:
            result['serviceId'] = self.service_id
        if self.service_name is not None:
            result['serviceName'] = self.service_name
        if self.service_type is not None:
            result['serviceType'] = self.service_type
        if self.service_version is not None:
            result['serviceVersion'] = self.service_version
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('appId') is not None:
            self.app_id = m.get('appId')
        if m.get('group') is not None:
            self.group = m.get('group')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('methodController') is not None:
            self.method_controller = m.get('methodController')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('origin') is not None:
            self.origin = m.get('origin')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('registryType') is not None:
            self.registry_type = m.get('registryType')
        if m.get('serviceId') is not None:
            self.service_id = m.get('serviceId')
        if m.get('serviceName') is not None:
            self.service_name = m.get('serviceName')
        if m.get('serviceType') is not None:
            self.service_type = m.get('serviceType')
        if m.get('serviceVersion') is not None:
            self.service_version = m.get('serviceVersion')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class GetServiceMethodPageResponseBodyDataResultReturnDefinition(TeaModel):
    def __init__(
        self,
        id: str = None,
        type: str = None,
    ):
        # The ID of the return value.
        self.id = id
        # The data format of the response.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetServiceMethodPageResponseBodyDataResult(TeaModel):
    def __init__(
        self,
        method_controller: str = None,
        name: str = None,
        name_detail: str = None,
        parameter_definitions: str = None,
        parameter_details: str = None,
        parameter_names: str = None,
        parameter_types: str = None,
        paths: str = None,
        request_methods: str = None,
        return_definition: GetServiceMethodPageResponseBodyDataResultReturnDefinition = None,
        return_details: str = None,
        return_type: str = None,
    ):
        # The method.
        self.method_controller = method_controller
        # The name of the method.
        self.name = name
        # The details of the method.
        self.name_detail = name_detail
        # The definition of the parameter.
        self.parameter_definitions = parameter_definitions
        # The details of the parameters.
        self.parameter_details = parameter_details
        # The name of the parameter.
        self.parameter_names = parameter_names
        # The data type of the parameter.
        self.parameter_types = parameter_types
        # The method path.
        self.paths = paths
        # The request method.
        self.request_methods = request_methods
        # The return value.
        self.return_definition = return_definition
        # The details of the response.
        self.return_details = return_details
        # The data format of the response.
        self.return_type = return_type

    def validate(self):
        if self.return_definition:
            self.return_definition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.method_controller is not None:
            result['MethodController'] = self.method_controller
        if self.name is not None:
            result['Name'] = self.name
        if self.name_detail is not None:
            result['NameDetail'] = self.name_detail
        if self.parameter_definitions is not None:
            result['ParameterDefinitions'] = self.parameter_definitions
        if self.parameter_details is not None:
            result['ParameterDetails'] = self.parameter_details
        if self.parameter_names is not None:
            result['ParameterNames'] = self.parameter_names
        if self.parameter_types is not None:
            result['ParameterTypes'] = self.parameter_types
        if self.paths is not None:
            result['Paths'] = self.paths
        if self.request_methods is not None:
            result['RequestMethods'] = self.request_methods
        if self.return_definition is not None:
            result['ReturnDefinition'] = self.return_definition.to_map()
        if self.return_details is not None:
            result['ReturnDetails'] = self.return_details
        if self.return_type is not None:
            result['ReturnType'] = self.return_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MethodController') is not None:
            self.method_controller = m.get('MethodController')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NameDetail') is not None:
            self.name_detail = m.get('NameDetail')
        if m.get('ParameterDefinitions') is not None:
            self.parameter_definitions = m.get('ParameterDefinitions')
        if m.get('ParameterDetails') is not None:
            self.parameter_details = m.get('ParameterDetails')
        if m.get('ParameterNames') is not None:
            self.parameter_names = m.get('ParameterNames')
        if m.get('ParameterTypes') is not None:
            self.parameter_types = m.get('ParameterTypes')
        if m.get('Paths') is not None:
            self.paths = m.get('Paths')
        if m.get('RequestMethods') is not None:
            self.request_methods = m.get('RequestMethods')
        if m.get('ReturnDefinition') is not None:
            temp_model = GetServiceMethodPageResponseBodyDataResultReturnDefinition()
            self.return_definition = temp_model.from_map(m['ReturnDefinition'])
        if m.get('ReturnDetails') is not None:
            self.return_details = m.get('ReturnDetails')
        if m.get('ReturnType') is not None:
            self.return_type = m.get('ReturnType')
        return self


class GetServiceMethodPageResponseBodyData(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        result: List[GetServiceMethodPageResponseBodyDataResult] = None,
        total_size: int = None,
    ):
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The data about the method.
        self.result = result
        # The total number of entries.
        self.total_size = total_size

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Result'] = []
        if self.result is not None:
            for k in self.result:
                result['Result'].append(k.to_map() if k else None)
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.result = []
        if m.get('Result') is not None:
            for k in m.get('Result'):
                temp_model = GetServiceMethodPageResponseBodyDataResult()
                self.result.append(temp_model.from_map(k))
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class GetServiceMethodPageResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetServiceMethodPageResponseBodyData = None,
        http_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The data that is returned.
        self.data = data
        # The HTTP status code that is returned.
        self.http_code = http_code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_code is not None:
            result['HttpCode'] = self.http_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetServiceMethodPageResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpCode') is not None:
            self.http_code = m.get('HttpCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetServiceMethodPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetServiceMethodPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetServiceMethodPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetServiceProvidersPageRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group: str = None,
        ip: str = None,
        namespace: str = None,
        origin: str = None,
        page: int = None,
        region: str = None,
        registry_type: str = None,
        service_id: str = None,
        service_name: str = None,
        service_type: str = None,
        service_version: str = None,
        size: int = None,
        source: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The group to which the service belongs.
        self.group = group
        # The IP address of the service provider. Fuzzy searches are supported.
        self.ip = ip
        # The ID of the namespace.
        self.namespace = namespace
        # The source of data. Valid values:
        # 
        # *   agent: Use this value if you use the service query feature of the latest version to pass the query result.
        # *   registry: Use this value if you use the service query feature of the earlier version to pass the query result.
        self.origin = origin
        # The number of the page to return. Pages start from Page 0.
        self.page = page
        # The ID of the region.
        self.region = region
        # The type of the service registry. This parameter is deprecated. You can ignore it.
        self.registry_type = registry_type
        # The ID of the service. This parameter is deprecated. You can ignore it.
        self.service_id = service_id
        # The name of the service.
        self.service_name = service_name
        # The type of the service. Valid values:
        # 
        # *   dubbo: Dubbo service
        # *   springCloud: Spring Cloud service
        # *   hsf: High-speed Service Framework (HSF) service
        self.service_type = service_type
        # The version of the service.
        self.service_version = service_version
        # The number of entries to return on each page.
        self.size = size
        # The source of the service. Set the value to edas.
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['appId'] = self.app_id
        if self.group is not None:
            result['group'] = self.group
        if self.ip is not None:
            result['ip'] = self.ip
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.origin is not None:
            result['origin'] = self.origin
        if self.page is not None:
            result['page'] = self.page
        if self.region is not None:
            result['region'] = self.region
        if self.registry_type is not None:
            result['registryType'] = self.registry_type
        if self.service_id is not None:
            result['serviceId'] = self.service_id
        if self.service_name is not None:
            result['serviceName'] = self.service_name
        if self.service_type is not None:
            result['serviceType'] = self.service_type
        if self.service_version is not None:
            result['serviceVersion'] = self.service_version
        if self.size is not None:
            result['size'] = self.size
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('appId') is not None:
            self.app_id = m.get('appId')
        if m.get('group') is not None:
            self.group = m.get('group')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('origin') is not None:
            self.origin = m.get('origin')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('registryType') is not None:
            self.registry_type = m.get('registryType')
        if m.get('serviceId') is not None:
            self.service_id = m.get('serviceId')
        if m.get('serviceName') is not None:
            self.service_name = m.get('serviceName')
        if m.get('serviceType') is not None:
            self.service_type = m.get('serviceType')
        if m.get('serviceVersion') is not None:
            self.service_version = m.get('serviceVersion')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class GetServiceProvidersPageResponseBodyDataContent(TeaModel):
    def __init__(
        self,
        iannotations: str = None,
        ip: str = None,
        port: str = None,
        serialize_type: str = None,
        timeout: str = None,
    ):
        # The remarks of the service provider.
        self.iannotations = iannotations
        # The IP address of the service provider.
        self.ip = ip
        # The port number of the service provider.
        self.port = port
        # The serialization type.
        self.serialize_type = serialize_type
        # The service timeout period.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iannotations is not None:
            result['Iannotations'] = self.iannotations
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.port is not None:
            result['Port'] = self.port
        if self.serialize_type is not None:
            result['SerializeType'] = self.serialize_type
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Iannotations') is not None:
            self.iannotations = m.get('Iannotations')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SerializeType') is not None:
            self.serialize_type = m.get('SerializeType')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class GetServiceProvidersPageResponseBodyData(TeaModel):
    def __init__(
        self,
        content: List[GetServiceProvidersPageResponseBodyDataContent] = None,
        size: int = None,
        total_elements: int = None,
        total_pages: int = None,
    ):
        # The data array returned.
        self.content = content
        # The number of entries returned per page.
        self.size = size
        # The total number of returned entries.
        self.total_elements = total_elements
        # The total number of returned pages.
        self.total_pages = total_pages

    def validate(self):
        if self.content:
            for k in self.content:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Content'] = []
        if self.content is not None:
            for k in self.content:
                result['Content'].append(k.to_map() if k else None)
        if self.size is not None:
            result['Size'] = self.size
        if self.total_elements is not None:
            result['TotalElements'] = self.total_elements
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.content = []
        if m.get('Content') is not None:
            for k in m.get('Content'):
                temp_model = GetServiceProvidersPageResponseBodyDataContent()
                self.content.append(temp_model.from_map(k))
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('TotalElements') is not None:
            self.total_elements = m.get('TotalElements')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class GetServiceProvidersPageResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: GetServiceProvidersPageResponseBodyData = None,
        message: str = None,
        success: bool = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The data structure.
        self.data = data
        # The message returned for the request.
        self.message = message
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetServiceProvidersPageResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetServiceProvidersPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetServiceProvidersPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetServiceProvidersPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWebContainerConfigRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class GetWebContainerConfigResponseBodyWebContainerConfig(TeaModel):
    def __init__(
        self,
        context_input_type: str = None,
        context_path: str = None,
        http_port: int = None,
        max_threads: int = None,
        server_xml: str = None,
        uri_encoding: str = None,
        use_advanced_server_xml: bool = None,
        use_body_encoding: bool = None,
        use_default_config: bool = None,
    ):
        # The type of the context path.
        self.context_input_type = context_input_type
        # The context path.
        self.context_path = context_path
        # The HTTP service port.
        self.http_port = http_port
        # The maximum number of threads.
        self.max_threads = max_threads
        # The content of the server.xml file customized by using advanced configurations.
        self.server_xml = server_xml
        # The URI encoding scheme.
        self.uri_encoding = uri_encoding
        # Indicates whether advanced configurations are used to customize the server.xml file.
        self.use_advanced_server_xml = use_advanced_server_xml
        # Indicates whether the encoding scheme specified in the request body is used for uniform resource identifier (URI) query parameters.
        self.use_body_encoding = use_body_encoding
        # Indicates whether the default configurations are used.
        self.use_default_config = use_default_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.context_input_type is not None:
            result['ContextInputType'] = self.context_input_type
        if self.context_path is not None:
            result['ContextPath'] = self.context_path
        if self.http_port is not None:
            result['HttpPort'] = self.http_port
        if self.max_threads is not None:
            result['MaxThreads'] = self.max_threads
        if self.server_xml is not None:
            result['ServerXml'] = self.server_xml
        if self.uri_encoding is not None:
            result['UriEncoding'] = self.uri_encoding
        if self.use_advanced_server_xml is not None:
            result['UseAdvancedServerXml'] = self.use_advanced_server_xml
        if self.use_body_encoding is not None:
            result['UseBodyEncoding'] = self.use_body_encoding
        if self.use_default_config is not None:
            result['UseDefaultConfig'] = self.use_default_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContextInputType') is not None:
            self.context_input_type = m.get('ContextInputType')
        if m.get('ContextPath') is not None:
            self.context_path = m.get('ContextPath')
        if m.get('HttpPort') is not None:
            self.http_port = m.get('HttpPort')
        if m.get('MaxThreads') is not None:
            self.max_threads = m.get('MaxThreads')
        if m.get('ServerXml') is not None:
            self.server_xml = m.get('ServerXml')
        if m.get('UriEncoding') is not None:
            self.uri_encoding = m.get('UriEncoding')
        if m.get('UseAdvancedServerXml') is not None:
            self.use_advanced_server_xml = m.get('UseAdvancedServerXml')
        if m.get('UseBodyEncoding') is not None:
            self.use_body_encoding = m.get('UseBodyEncoding')
        if m.get('UseDefaultConfig') is not None:
            self.use_default_config = m.get('UseDefaultConfig')
        return self


class GetWebContainerConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        web_container_config: GetWebContainerConfigResponseBodyWebContainerConfig = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The Tomcat configurations of the application.
        self.web_container_config = web_container_config

    def validate(self):
        if self.web_container_config:
            self.web_container_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.web_container_config is not None:
            result['WebContainerConfig'] = self.web_container_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('WebContainerConfig') is not None:
            temp_model = GetWebContainerConfigResponseBodyWebContainerConfig()
            self.web_container_config = temp_model.from_map(m['WebContainerConfig'])
        return self


class GetWebContainerConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWebContainerConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWebContainerConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportK8sClusterRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        enable_asm: bool = None,
        mode: int = None,
        namespace_id: str = None,
    ):
        # The ID of the ACK cluster or serverless Kubernetes cluster. You can obtain the cluster ID by calling the GetK8sCluster operation. For more information, see [GetK8sCluster](https://help.aliyun.com/document_detail/181437.html).
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # Specifies whether to enable the integration with Alibaba Cloud Service Mesh (ASM). Valid values:
        # 
        # *   true: Enables the integration with ASM.
        # *   false: Disables the integration with ASM.
        self.enable_asm = enable_asm
        # You can ignore this parameter.
        self.mode = mode
        # The ID of the namespace. It is in the format of `Region ID:Identifier of the microservices namespace`. Example: `cn-hangzhou:doc`.
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.enable_asm is not None:
            result['EnableAsm'] = self.enable_asm
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('EnableAsm') is not None:
            self.enable_asm = m.get('EnableAsm')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class ImportK8sClusterResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The ID of the cluster in EDAS.
        self.data = data
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ImportK8sClusterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportK8sClusterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportK8sClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InsertApplicationRequest(TeaModel):
    def __init__(
        self,
        application_name: str = None,
        build_pack_id: int = None,
        cluster_id: str = None,
        component_ids: str = None,
        cpu: int = None,
        description: str = None,
        ecu_info: str = None,
        enable_port_check: bool = None,
        enable_url_check: bool = None,
        health_check_url: str = None,
        hooks: str = None,
        jdk: str = None,
        jvm_options: str = None,
        logical_region_id: str = None,
        max_heap_size: int = None,
        max_perm_size: int = None,
        mem: int = None,
        min_heap_size: int = None,
        package_type: str = None,
        reserved_port_str: str = None,
        resource_group_id: str = None,
        web_container: str = None,
    ):
        # The name of the application. The name can contain only digits, letters, hyphens (-), and underscores (_) and must start with a letter. The name can be up to 36 characters in length.
        # 
        # This parameter is required.
        self.application_name = application_name
        # The build package number of EDAS Container. This parameter is required if you create a High-Speed Service Framework (HSF) application. You can query the build package number by using one of the following methods:
        # 
        # *   Call the ListBuildPack operation. For more information, see [ListBuildPack](https://help.aliyun.com/document_detail/149391.html).
        # *   Obtain the value in the **Build package number** column of the [Release notes for EDAS Container](https://help.aliyun.com/document_detail/92614.html) topic.
        self.build_pack_id = build_pack_id
        # The ID of the ECS cluster in which you want to create the application. If you specify an ID, the application is created in the specified ECS cluster. If you leave this parameter empty, the application is created in the default cluster. We recommend that you specify this parameter.
        self.cluster_id = cluster_id
        # The ID of the application component. You can call the ListComponents operation to query the component IDs. For more information, see [ListComponents](https://help.aliyun.com/document_detail/97502.html).
        # 
        # This parameter is required if the application runs in Apache Tomcat or in a standard Java application runtime environment. The Apache Tomcat application runtime environment is applicable to Dubbo applications that are deployed by using WAR packages. A standard Java application runtime environment is applicable to Spring Boot or Spring Cloud applications that are deployed by using JAR packages.
        # 
        # Valid values for common application components:
        # 
        # *   4: Apache Tomcat 7.0.91
        # *   7: Apache Tomcat 8.5.42
        # *   5: OpenJDK 1.8.x
        # *   6: OpenJDK 1.7.x
        # 
        # This parameter is available only for Java SDK 2.57.3 or later, or Python SDK 2.57.3 or later. Assume that you use an SDK that is not provided by EDAS, for example, aliyun-python-sdk-core, aliyun-java-sdk-core, and Alibaba Cloud CLI. In this case, you can directly specify this parameter.
        self.component_ids = component_ids
        # The number of CPU cores that can be used by the application container in a Swarm cluster. \\*\\*This parameter is deprecated.\\*\\*\
        self.cpu = cpu
        # The description of the application.
        self.description = description
        # The value of `ecu_id` of the ECS instance to be added during scale-out. The ECU ID is the unique identity for an ECS instance that is imported to EDAS. Separate multiple values of `ecu_id` with commas (,). You can call the ListScaleOutEcu operation to query the value of `ecu_id`. For more information, see [ListScaleOutEcu](https://help.aliyun.com/document_detail/149371.html).
        self.ecu_info = ecu_info
        # Specifies whether to enable the port health check. Valid values:
        # 
        # *   **true**: enable the port health check.
        # *   **false**: does not enable the port health check.
        self.enable_port_check = enable_port_check
        # Specifies whether to enable the URL health check. Valid values:
        # 
        # *   **true**: enables the URL health check.
        # *   **false**: does not enable the URL health check.
        self.enable_url_check = enable_url_check
        # The health check URL of the application. This parameter is equivalent to the HealthCheckURL parameter.
        self.health_check_url = health_check_url
        # The script to mount. Set the value in the JSON format. Example: `[{"ignoreFail":false,"name":"postprepareInstanceEnvironmentOnScaleOut","script":"ls"},{"ignoreFail":true,"name":"postdeleteInstanceDataOnScaleIn","script":""},{"ignoreFail":true,"name":"prestartInstance","script":""},{"ignoreFail":true,"name":"poststartInstance","script":""},{"ignoreFail":true,"name":"prestopInstance","script":""},{"ignoreFail":true,"name":"poststopInstance","script":""}]`
        self.hooks = hooks
        # The version of the Java Development Kit (JDK) used to deploy the application. **This parameter is deprecated.
        self.jdk = jdk
        # The custom parameters.
        self.jvm_options = jvm_options
        # The ID of the microservices namespace. To query the ID of a microservices namespace, you can choose **Resource Management** > **Microservice Namespaces** in the left-side navigation pane of the EDAS console or call the ListUserDefineRegion operation. For more information, see [ListUserDefineRegion](https://help.aliyun.com/document_detail/149377.html).
        # 
        # *   This parameter is required if the cluster you specify is not deployed in the default microservices namespace. Otherwise, the message `application regionId is different with cluster regionId!` appears.
        # *   If the cluster you specify is deployed in the default microservices namespace, you do not need to specify this parameter. Set this parameter to the ID of the microservices namespace in which the cluster you specify is deployed.
        self.logical_region_id = logical_region_id
        # The maximum size of the heap memory. Unit: MB.
        self.max_heap_size = max_heap_size
        # The size of the permanent generation heap memory. Unit: MB.
        self.max_perm_size = max_perm_size
        # The memory size that can be used by the application container in a Swarm cluster. \\*\\*This parameter is deprecated.\\*\\*\
        self.mem = mem
        # The initial size of the heap memory. Unit: MB.
        self.min_heap_size = min_heap_size
        # The type of the application deployment package. Valid values: war and jar.
        self.package_type = package_type
        # The reserved port for the application. This parameter is deprecated.
        self.reserved_port_str = reserved_port_str
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The version of Apache Tomcat. **This parameter is deprecated.
        self.web_container = web_container

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        if self.build_pack_id is not None:
            result['BuildPackId'] = self.build_pack_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.component_ids is not None:
            result['ComponentIds'] = self.component_ids
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.description is not None:
            result['Description'] = self.description
        if self.ecu_info is not None:
            result['EcuInfo'] = self.ecu_info
        if self.enable_port_check is not None:
            result['EnablePortCheck'] = self.enable_port_check
        if self.enable_url_check is not None:
            result['EnableUrlCheck'] = self.enable_url_check
        if self.health_check_url is not None:
            result['HealthCheckUrl'] = self.health_check_url
        if self.hooks is not None:
            result['Hooks'] = self.hooks
        if self.jdk is not None:
            result['Jdk'] = self.jdk
        if self.jvm_options is not None:
            result['JvmOptions'] = self.jvm_options
        if self.logical_region_id is not None:
            result['LogicalRegionId'] = self.logical_region_id
        if self.max_heap_size is not None:
            result['MaxHeapSize'] = self.max_heap_size
        if self.max_perm_size is not None:
            result['MaxPermSize'] = self.max_perm_size
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.min_heap_size is not None:
            result['MinHeapSize'] = self.min_heap_size
        if self.package_type is not None:
            result['PackageType'] = self.package_type
        if self.reserved_port_str is not None:
            result['ReservedPortStr'] = self.reserved_port_str
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        if m.get('BuildPackId') is not None:
            self.build_pack_id = m.get('BuildPackId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ComponentIds') is not None:
            self.component_ids = m.get('ComponentIds')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EcuInfo') is not None:
            self.ecu_info = m.get('EcuInfo')
        if m.get('EnablePortCheck') is not None:
            self.enable_port_check = m.get('EnablePortCheck')
        if m.get('EnableUrlCheck') is not None:
            self.enable_url_check = m.get('EnableUrlCheck')
        if m.get('HealthCheckUrl') is not None:
            self.health_check_url = m.get('HealthCheckUrl')
        if m.get('Hooks') is not None:
            self.hooks = m.get('Hooks')
        if m.get('Jdk') is not None:
            self.jdk = m.get('Jdk')
        if m.get('JvmOptions') is not None:
            self.jvm_options = m.get('JvmOptions')
        if m.get('LogicalRegionId') is not None:
            self.logical_region_id = m.get('LogicalRegionId')
        if m.get('MaxHeapSize') is not None:
            self.max_heap_size = m.get('MaxHeapSize')
        if m.get('MaxPermSize') is not None:
            self.max_perm_size = m.get('MaxPermSize')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('MinHeapSize') is not None:
            self.min_heap_size = m.get('MinHeapSize')
        if m.get('PackageType') is not None:
            self.package_type = m.get('PackageType')
        if m.get('ReservedPortStr') is not None:
            self.reserved_port_str = m.get('ReservedPortStr')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        return self


class InsertApplicationResponseBodyApplicationInfo(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        change_order_id: str = None,
        dockerize: bool = None,
        owner: str = None,
        port: int = None,
        region_name: str = None,
        user_id: str = None,
    ):
        # The ID of the application. The ID is the unique identifier of the application in EDAS.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        # The ID of the change process.
        self.change_order_id = change_order_id
        # Indicates whether the application is a Docker application. Valid values:
        # 
        # *   **true**: The application is a Docker application.
        # *   **false**: The application is not a Docker application.
        self.dockerize = dockerize
        # The owner of the application. The owner is the user who created the application.
        self.owner = owner
        # The port used by the created application. Default value: 8080. You can call the UpdateContainerConfiguration operation to change the port. For more information, see [UpdateContainerConfiguration](https://help.aliyun.com/document_detail/149403.html).
        self.port = port
        # The name of the region.
        self.region_name = region_name
        # The ID of the user who created the application.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.dockerize is not None:
            result['Dockerize'] = self.dockerize
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.port is not None:
            result['Port'] = self.port
        if self.region_name is not None:
            result['RegionName'] = self.region_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Dockerize') is not None:
            self.dockerize = m.get('Dockerize')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('RegionName') is not None:
            self.region_name = m.get('RegionName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class InsertApplicationResponseBody(TeaModel):
    def __init__(
        self,
        application_info: InsertApplicationResponseBodyApplicationInfo = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The information about the created application.
        self.application_info = application_info
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.application_info:
            self.application_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_info is not None:
            result['ApplicationInfo'] = self.application_info.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationInfo') is not None:
            temp_model = InsertApplicationResponseBodyApplicationInfo()
            self.application_info = temp_model.from_map(m['ApplicationInfo'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InsertApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InsertApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InsertApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InsertClusterRequest(TeaModel):
    def __init__(
        self,
        cluster_name: str = None,
        cluster_type: int = None,
        iaas_provider: str = None,
        logical_region_id: str = None,
        network_mode: int = None,
        oversold_factor: int = None,
        vpc_id: str = None,
    ):
        # The name of the cluster.
        # 
        # This parameter is required.
        self.cluster_name = cluster_name
        # The type of the cluster. Valid values:
        # 
        # *   2: Elastic Compute Service (ECS) cluster
        # *   3: self-managed Kubernetes cluster in Enterprise Distributed Application Service (EDAS)
        # *   5: Kubernetes cluster
        # 
        # This parameter is required.
        self.cluster_type = cluster_type
        # The provider of Infrastructure as a Service (IaaS) resources that are used in the cluster.
        # 
        # When you use Alibaba Cloud, set the value to `ALIYUN`. The value is case-sensitive.
        self.iaas_provider = iaas_provider
        # The ID of the custom namespace. The ID is in the `physical region ID:custom namespace identifier` format. Example: `cn-hangzhou:test`.
        self.logical_region_id = logical_region_id
        # The network type of the cluster. Valid values:
        # 
        # *   1: classic network
        # *   2: virtual private cloud (VPC)
        # 
        # This parameter is required.
        self.network_mode = network_mode
        # **This parameter is deprecated.** The CPU overcommit ratio supported by a Docker cluster. Valid values:
        # 
        # *   2: 1:2, which means that resources are overcommitted by 1:2.
        # *   4: 1:4, which means that resources are overcommitted by 1:4.
        # *   8: 1:8, which means that resources are overcommitted by 1:8.
        self.oversold_factor = oversold_factor
        # The ID of the VPC. This parameter is required if you set the NetworkMode parameter to 2.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.iaas_provider is not None:
            result['IaasProvider'] = self.iaas_provider
        if self.logical_region_id is not None:
            result['LogicalRegionId'] = self.logical_region_id
        if self.network_mode is not None:
            result['NetworkMode'] = self.network_mode
        if self.oversold_factor is not None:
            result['OversoldFactor'] = self.oversold_factor
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('IaasProvider') is not None:
            self.iaas_provider = m.get('IaasProvider')
        if m.get('LogicalRegionId') is not None:
            self.logical_region_id = m.get('LogicalRegionId')
        if m.get('NetworkMode') is not None:
            self.network_mode = m.get('NetworkMode')
        if m.get('OversoldFactor') is not None:
            self.oversold_factor = m.get('OversoldFactor')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class InsertClusterResponseBodyCluster(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_name: str = None,
        cluster_type: int = None,
        iaas_provider: str = None,
        network_mode: int = None,
        oversold_factor: int = None,
        region_id: str = None,
        vpc_id: str = None,
    ):
        # The ID of cluster.
        self.cluster_id = cluster_id
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The type of the cluster. Valid values:
        # 
        # *   2: ECS cluster
        # *   3: self-managed Kubernetes cluster in EDAS
        # *   5: Kubernetes cluster
        self.cluster_type = cluster_type
        # The provider of the IaaS resources that are used in the cluster.
        self.iaas_provider = iaas_provider
        # The network type of the cluster. Valid values:
        # 
        # *   1: classic network
        # *   2\\. VPC
        self.network_mode = network_mode
        # **This parameter is deprecated.** The CPU overcommit ratio supported by the Docker cluster. Valid values:
        # 
        # *   2: 1:2, which means that resources are overcommitted by 1:2.
        # *   4: 1:4, which means that resources are overcommitted by 1:4.
        # *   8: 1:8, which means that resources are overcommitted by 1:8.
        self.oversold_factor = oversold_factor
        # The ID of the region in which the cluster resides.
        self.region_id = region_id
        # The ID of the VPC.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.iaas_provider is not None:
            result['IaasProvider'] = self.iaas_provider
        if self.network_mode is not None:
            result['NetworkMode'] = self.network_mode
        if self.oversold_factor is not None:
            result['OversoldFactor'] = self.oversold_factor
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('IaasProvider') is not None:
            self.iaas_provider = m.get('IaasProvider')
        if m.get('NetworkMode') is not None:
            self.network_mode = m.get('NetworkMode')
        if m.get('OversoldFactor') is not None:
            self.oversold_factor = m.get('OversoldFactor')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class InsertClusterResponseBody(TeaModel):
    def __init__(
        self,
        cluster: InsertClusterResponseBodyCluster = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The information about the cluster that was created.
        self.cluster = cluster
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.cluster:
            self.cluster.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster is not None:
            result['Cluster'] = self.cluster.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cluster') is not None:
            temp_model = InsertClusterResponseBodyCluster()
            self.cluster = temp_model.from_map(m['Cluster'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InsertClusterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InsertClusterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InsertClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InsertClusterMemberRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        instance_ids: str = None,
        password: str = None,
    ):
        # The ID of the cluster into which you want to import ECS instances.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The ID of the ECS instance that you want to import into the cluster. Separate multiple IDs with commas (,).
        # 
        # This parameter is required.
        self.instance_ids = instance_ids
        # The logon password of the ECS instance that you want to import into the cluster.
        # 
        # This parameter is required.
        self.password = password

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['clusterId'] = self.cluster_id
        if self.instance_ids is not None:
            result['instanceIds'] = self.instance_ids
        if self.password is not None:
            result['password'] = self.password
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clusterId') is not None:
            self.cluster_id = m.get('clusterId')
        if m.get('instanceIds') is not None:
            self.instance_ids = m.get('instanceIds')
        if m.get('password') is not None:
            self.password = m.get('password')
        return self


class InsertClusterMemberResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code.
        self.code = code
        # The data returned for the request.
        self.data = data
        # The additional information returned.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InsertClusterMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InsertClusterMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InsertClusterMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InsertDeployGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group_name: str = None,
        init_package_version_id: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The name of the instance group. The name can be up to 64 characters in length.
        # 
        # This parameter is required.
        self.group_name = group_name
        # The version of the initial deployment package associated with the instance group. You can call the ListHistoryDeployVersion operation to query the version. For more information, see [ListHistoryDeployVersion](https://help.aliyun.com/document_detail/149392.html).
        self.init_package_version_id = init_package_version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.init_package_version_id is not None:
            result['InitPackageVersionId'] = self.init_package_version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('InitPackageVersionId') is not None:
            self.init_package_version_id = m.get('InitPackageVersionId')
        return self


class InsertDeployGroupResponseBodyDeployGroupEntity(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_version_id: str = None,
        cluster_id: str = None,
        create_time: int = None,
        group_name: str = None,
        group_type: int = None,
        id: str = None,
        package_version_id: str = None,
        update_time: int = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The version of the deployment package for the application.
        # 
        # *   If the application is deployed, a string of random numbers is returned.
        # *   If the application is not deployed, the return value is empty.
        self.app_version_id = app_version_id
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The time when the instance group was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The name of the instance group.
        self.group_name = group_name
        # The type of the instance group. Valid values:
        # 
        # *   0: the default group.
        # *   1: a group for which canary traffic management is not enabled.
        # *   2: a group for which canary traffic management is enabled.
        self.group_type = group_type
        # The ID of the instance group.
        self.id = id
        # The version of the deployment package that was used to deploy an application in the instance group.
        # 
        # *   If an application is deployed in the instance group, a string of random numbers is returned.
        # *   If no application is deployed in the instance group, the return value is empty.
        self.package_version_id = package_version_id
        # The time when the instance group was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_version_id is not None:
            result['AppVersionId'] = self.app_version_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.id is not None:
            result['Id'] = self.id
        if self.package_version_id is not None:
            result['PackageVersionId'] = self.package_version_id
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppVersionId') is not None:
            self.app_version_id = m.get('AppVersionId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PackageVersionId') is not None:
            self.package_version_id = m.get('PackageVersionId')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class InsertDeployGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        deploy_group_entity: InsertDeployGroupResponseBodyDeployGroupEntity = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The information about the instance group.
        self.deploy_group_entity = deploy_group_entity
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.deploy_group_entity:
            self.deploy_group_entity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.deploy_group_entity is not None:
            result['DeployGroupEntity'] = self.deploy_group_entity.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DeployGroupEntity') is not None:
            temp_model = InsertDeployGroupResponseBodyDeployGroupEntity()
            self.deploy_group_entity = temp_model.from_map(m['DeployGroupEntity'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InsertDeployGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InsertDeployGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InsertDeployGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InsertK8sApplicationRequest(TeaModel):
    def __init__(
        self,
        annotations: str = None,
        app_config: str = None,
        app_name: str = None,
        app_template_name: str = None,
        application_description: str = None,
        build_pack_id: str = None,
        cluster_id: str = None,
        command: str = None,
        command_args: str = None,
        config_mount_descs: str = None,
        container_registry_id: str = None,
        cs_cluster_id: str = None,
        custom_affinity: str = None,
        custom_agent_version: str = None,
        custom_tolerations: str = None,
        deploy_across_nodes: str = None,
        deploy_across_zones: str = None,
        edas_container_version: str = None,
        empty_dirs: str = None,
        enable_ahas: bool = None,
        enable_asm: bool = None,
        enable_empty_push_reject: bool = None,
        enable_lossless_rule: bool = None,
        env_froms: str = None,
        envs: str = None,
        feature_config: str = None,
        image_platforms: str = None,
        image_url: str = None,
        init_containers: str = None,
        internet_slb_id: str = None,
        internet_slb_port: int = None,
        internet_slb_protocol: str = None,
        internet_target_port: int = None,
        intranet_slb_id: str = None,
        intranet_slb_port: int = None,
        intranet_slb_protocol: str = None,
        intranet_target_port: int = None,
        is_multilingual_app: bool = None,
        jdk: str = None,
        java_start_up_config: str = None,
        labels: str = None,
        limit_cpu: int = None,
        limit_ephemeral_storage: int = None,
        limit_mem: int = None,
        limitm_cpu: int = None,
        liveness: str = None,
        local_volume: str = None,
        logical_region_id: str = None,
        lossless_rule_aligned: bool = None,
        lossless_rule_delay_time: int = None,
        lossless_rule_func_type: int = None,
        lossless_rule_related: bool = None,
        lossless_rule_warmup_time: int = None,
        mount_descs: str = None,
        namespace: str = None,
        nas_id: str = None,
        package_type: str = None,
        package_url: str = None,
        package_version: str = None,
        post_start: str = None,
        pre_stop: str = None,
        pvc_mount_descs: str = None,
        readiness: str = None,
        replicas: int = None,
        repo_id: str = None,
        requests_cpu: int = None,
        requests_ephemeral_storage: int = None,
        requests_mem: int = None,
        requestsm_cpu: int = None,
        resource_group_id: str = None,
        runtime_class_name: str = None,
        secret_name: str = None,
        service_configs: str = None,
        sidecars: str = None,
        sls_configs: str = None,
        startup: str = None,
        storage_type: str = None,
        terminate_grace_period: int = None,
        timeout: int = None,
        uri_encoding: str = None,
        use_body_encoding: bool = None,
        user_base_image_url: str = None,
        web_container: str = None,
        web_container_config: str = None,
        workload_type: str = None,
    ):
        # The annotation of an application pod.
        self.annotations = annotations
        # The application configuration when the application template is used. Set this parameter to a JSON array.
        self.app_config = app_config
        # The name of the application. The name must start with a letter, and can contain digits, letters, and hyphens (-). It can be up to 36 characters in length.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The name of the template used to create the application. If you specify an application template when you create an application, the application template and the AppConfig parameter are used to configure the application. Other configurations are ignored.
        self.app_template_name = app_template_name
        # The description of the application.
        self.application_description = application_description
        # The version of `EDAS Container`. The value of this parameter conflicts with that of the `EdasContainerVersion` parameter. We recommend that you use the `EdasContainerVersion` parameter.
        self.build_pack_id = build_pack_id
        # The ID of the cluster. You can call the ListCluster operation to query the cluster ID. For more information, see [ListCluster](https://help.aliyun.com/document_detail/154995.html).
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The application startup command. If you specify this parameter, the value of this parameter will replace the startup command in the image.
        self.command = command
        # The arguments in the command. The parameter value is a JSON array of strings. An example is `[{"argument":"-c"},{"argument":"test"}]`, where `-c` and `test` are two arguments that can be set.
        self.command_args = command_args
        # The configuration for mounting a Kubernetes ConfigMap or Secret to a directory in an elastic container instance. The following parameters are included in the configuration:
        # 
        # *   name: the name of the Kubernetes ConfigMap or Secret.
        # *   type: the type of the API object that you want to mount. You can mount a Kubernetes ConfigMap or Secret.
        # *   mountPath: the mount path. The mount path must be an absolute path that starts with a forward slash (/).
        self.config_mount_descs = config_mount_descs
        # The ID of the repository used to build the image repository. If this parameter is left empty, the default repository provided by EDAS is used. Only the default repository provided by EDAS is supported.
        self.container_registry_id = container_registry_id
        # The ID of the cluster. This parameter is required only when you create the application in a cluster that has not been imported.
        self.cs_cluster_id = cs_cluster_id
        # The custom affinity.
        self.custom_affinity = custom_affinity
        self.custom_agent_version = custom_agent_version
        # The custom tolerances.
        self.custom_tolerations = custom_tolerations
        # Specifies whether to distribute application instances across nodes. Value `true` indicates that application instances are distributed across nodes. Other values indicate that application instances are not distributed across nodes.
        self.deploy_across_nodes = deploy_across_nodes
        # Specifies whether to distribute application instances across zones. Value `true` indicates that application instances are distributed across zones. Other values indicate that application instances are not distributed across zones.
        self.deploy_across_zones = deploy_across_zones
        # The version of `EDAS Container` on which the deployment package of the application depends.
        # 
        # > This parameter is unavailable if you deploy applications by using images.
        self.edas_container_version = edas_container_version
        # The configuration for mounting a Kubernetes emptyDir volume to a directory in an elastic container instance. The following parameters are included in the configuration:
        # 
        # *   mountPath: The mount path in the container. This parameter is required.
        # *   readOnly: (Optional) The mount mode. Value true indicates the read-only mode. Value false indicates the read and write mode. Default value: false.
        # *   subPathExpr: (Optional) The regular expression that is used to match the subdirectory.
        self.empty_dirs = empty_dirs
        # Specifies whether to enable access to Application High Availability Service (AHAS). Valid values:
        # 
        # *   true: enables access to AHAS.
        # *   false: does not enable access to AHAS.
        self.enable_ahas = enable_ahas
        # Specifies whether to activate Alibaba Cloud Service Mesh (ASM). Set this parameter to true only when you create the application in a cluster that has not been imported and you need to use ASM.
        self.enable_asm = enable_asm
        # Specifies whether to enable the empty list protection feature. Valid values:
        # 
        # *   true: enables the empty list protection feature.
        # *   false: disables the empty list protection feature.
        self.enable_empty_push_reject = enable_empty_push_reject
        # Specifies whether to enable graceful start rules. Valid values:
        # 
        # *   true: enables graceful start rules.
        # *   false: disables graceful start rules.
        self.enable_lossless_rule = enable_lossless_rule
        # The Kubernetes environment variables that are configured in EnvFrom mode. A ConfigMap or Secret is mounted to a directory. Each key corresponds to a file in the directory, and the content of the file is the value of the key.
        # 
        # The following parameters are included in the configuration:
        # 
        # *   configMapRef: the ConfigMap that is referenced. The following parameter is contained:
        # 
        #     *   name: the name of the ConfigMap.
        # 
        # *   secretRef: the Secret that is referenced. The following parameter is contained:
        # 
        #     *   name: the name of the Secret.
        self.env_froms = env_froms
        # The environment variables that are used to deploy the application. The value must be a JSON array. Valid values: regular environment variables, Kubernetes ConfigMap environment variables, or Kubernetes Secret environment variables. Specify regular environment variables in the following format:
        # 
        # `{"name":"x", "value": "y"}`
        # 
        # Specify Kubernetes ConfigMap environment variables in the following format to reference values from ConfigMaps:
        # 
        # `{ "name": "x2", "valueFrom": { "configMapKeyRef": { "name": "my-config", "key": "y2" } } }`
        # 
        # Specify Kubernetes Secret environment variables in the following format to reference values from Secrets:
        # 
        # `{ "name": "x3", "valueFrom": { "secretKeyRef": { "name": "my-secret", "key": "y3" } } }`
        # 
        # >  If you want to cancel this configuration, set this parameter to an empty JSON array in the format of "[]".
        self.envs = envs
        self.feature_config = feature_config
        # Mirror the target platform architecture, which is effective when deployed using war or jar. Enter an example:
        # 
        # - Specify x86 64 architecture: Linux/amd64
        # - Specify ARM 64 architecture: Linux/arm64
        # - Specify the construction of dual architecture images: Linux/amd64, Linux/arm64
        # - Do not input: default schema
        self.image_platforms = image_platforms
        # The URL of the image. This parameter is required if you set the `PackageType` parameter to `Image`.
        self.image_url = image_url
        # Set the initialization container for the application Pod. Support setting the format YAML for container configuration, which is the value of Init container YAML configured with base64 encoding.
        self.init_containers = init_containers
        # The ID of the Internet-facing SLB instance. If you do not specify this parameter, EDAS automatically purchases a new SLB instance for you.
        self.internet_slb_id = internet_slb_id
        # The frontend port of the Internet-facing SLB instance. Valid values: 1 to 65535.
        self.internet_slb_port = internet_slb_port
        # The protocol used by the Internet-facing SLB instance. Valid values: TCP, HTTP, and HTTPS.
        self.internet_slb_protocol = internet_slb_protocol
        # The backend port of the internal-facing SLB instance. This port also serves as the service port of the application. Valid values: 1 to 65535.
        self.internet_target_port = internet_target_port
        # The ID of the internal-facing SLB instance. If you do not specify this parameter, Enterprise Distributed Application Service (EDAS) automatically purchases a new SLB instance for you.
        self.intranet_slb_id = intranet_slb_id
        # The frontend port of the internal-facing SLB instance. Valid values: 1 to 65535.
        self.intranet_slb_port = intranet_slb_port
        # The protocol used by the internal-facing SLB instance. Valid values: TCP, HTTP, and HTTPS.
        self.intranet_slb_protocol = intranet_slb_protocol
        # The backend port of the internal-facing Server Load Balancer (SLB) instance. This port also serves as the service port of the application. Valid values: 1 to 65535.
        self.intranet_target_port = intranet_target_port
        # Specifies whether the application is a multi-language application.
        self.is_multilingual_app = is_multilingual_app
        # The version of the Java Development Kit (JDK) on which the deployment package of the application depends. Valid values: Open JDK 7 and Open JDK 8. This parameter is unavailable if you deploy applications by using images.
        self.jdk = jdk
        # The configuration of Java startup parameters for a Java application. These startup parameters involve the memory, application, garbage collection (GC) policy, tools, service registration and discovery, and custom configurations. Appropriate parameter settings help reduce the GC overheads, shorten the server response time, and improve the throughput. Set this parameter to a JSON string. In the example, original indicates the configuration value, and startup indicates a startup parameter. The system automatically concatenates all startup values as the settings of Java startup parameters for the application. To delete this configuration, leave the parameter value empty by entering `""` or `"{}"`. The following parameters are included in the configuration:
        # 
        # *   InitialHeapSize: the initial size of the heap memory.
        # *   MaxHeapSize: the maximum size of the heap memory.
        # *   CustomParams: the custom parameters, such as JVM -D parameters.
        # *   Other parameters: You can view the JSON structure submitted by the frontend.
        self.java_start_up_config = java_start_up_config
        # The label of an application pod.
        self.labels = labels
        # The maximum number of CPU cores allowed for each application instance when the application is running. Unit: cores. If the LimitmCpu parameter is specified, you can ignore this parameter.
        self.limit_cpu = limit_cpu
        # The maximum size of space required by ephemeral storage. Unit: GB. Value 0 indicates that no limit is set on the space size.
        self.limit_ephemeral_storage = limit_ephemeral_storage
        # The maximum size of memory allowed for each application instance when the application is running. Unit: MB. The value of LimitMem must be greater than that of RequestsMem.
        self.limit_mem = limit_mem
        # The maximum number of CPU cores allowed for each application instance when the application is running. Unit: millicores. Value 0 indicates that no limit is set on CPU cores.
        self.limitm_cpu = limitm_cpu
        # The configuration for the liveness check on the container. Example: `{"failureThreshold": 3,"initialDelaySeconds": 5,"successThreshold": 1,"timeoutSeconds": 1,"tcpSocket":{"host":"", "port":8080}}`.
        # 
        # If you want to cancel this configuration, leave the parameter value empty by entering `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
        self.liveness = liveness
        # The configurations that are used when the host files are mounted to the container on which the application is running. Example: `[{"type":"","nodePath":"/localfiles","mountPath":"/app/files"},{"type":"Directory","nodePath":"/mnt","mountPath":"/app/storage"}\\]`. Description:
        # 
        # *   `nodePath`: the host path.
        # *   `mountPath`: the path in the container.
        # *   `type`: the mounting type.
        self.local_volume = local_volume
        # The ID of the EDAS namespace. This parameter is required for a non-default namespace.
        self.logical_region_id = logical_region_id
        # Specifies whether to enable the graceful rolling deployment mode and ensure that the service is registered before the readiness check. Valid values:
        # 
        # *   true: provides port 55199 and the /health path for the health check in a non-intrusive manner. When the service is registered, the system returns HTTP 200 status code. Otherwise, the system returns HTTP 500 status code.
        # 
        #     **\
        # 
        #     **Note**If you set both the `LosslessRuleRelated` parameter and this parameter to `true`, the operation checks whether the service prefetching is complete.
        # 
        # *   false: does not check whether the service is registered.
        self.lossless_rule_aligned = lossless_rule_aligned
        # The delay of service registration. Valid values: 0 to 86400. Unit: seconds.
        self.lossless_rule_delay_time = lossless_rule_delay_time
        # The number of prefetching curves. Valid values: 0 to 20. The default value is 2, which is suitable for common prefetching scenarios. This value indicates that the received traffic of the provider during prefetching is displayed as a quadratic curve.
        self.lossless_rule_func_type = lossless_rule_func_type
        # Specifies whether to enable the graceful rolling deployment mode and ensure that the service prefetching is complete before the readiness check. Valid values:
        # 
        # *   true: provides port 55199 and the /health path for the health check in a non-intrusive manner. When the service prefetching is complete, the system returns HTTP 200 status code. Otherwise, the system returns HTTP 500 status code.
        # *   false: does not check whether the service prefetching is complete.
        self.lossless_rule_related = lossless_rule_related
        # The service prefetching duration. Valid values: 0 to 86400. Unit: seconds.
        self.lossless_rule_warmup_time = lossless_rule_warmup_time
        # The description of the NAS mounting configuration. Set this parameter to a serialized JSON string. Example: `[{"nasPath": "/k8s","mountPath": "/mnt"},{"nasPath": "/files","mountPath": "/app/files"}\\]`. The `nasPath` parameter specifies the file storage path, and the `mountPath` parameter specifies the path to mount the file system to the container where the application is running.
        self.mount_descs = mount_descs
        # The namespace of the Kubernetes cluster. This parameter specifies the Kubernetes namespace in which your application is deployed. By default, the default namespace is used.
        self.namespace = namespace
        # The ID of the Network Attached Storage (NAS) file system that you want to mount to the application. If you do not specify this parameter but specify the MountDescs parameter, a NAS file system is automatically purchased and mounted to the vSwitch in the VPC.
        self.nas_id = nas_id
        # The type of the deployment package. Valid values: FatJar, WAR, and Image.
        self.package_type = package_type
        # The URL of the deployment package. This parameter is required if you use a FatJar or WAR package to deploy the application.
        # 
        # > The version of EDAS SDK for Java or Python must be V2.44.0 or later.
        self.package_url = package_url
        # The version of the deployment package. This parameter is required if you use a FatJar or WAR package to deploy the application. You must specify a version.
        # 
        # > The version of EDAS SDK for Java or Python must be V2.44.0 or later.
        self.package_version = package_version
        # The post-start script. Example: `{"exec":{"command":["cat","/etc/group"\\]}}`.
        # 
        # If you want to cancel this configuration, leave this parameter empty by setting it to `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
        self.post_start = post_start
        # The pre-stop script. Example: `{"tcpSocket":{"host":"", "port":8080}}`.
        # 
        # If you want to cancel this configuration, leave this parameter empty by setting it to `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
        self.pre_stop = pre_stop
        # The configuration for mounting a Kubernetes PersistentVolumeClaim (PVC) volume to a directory in an elastic container instance. The following parameters are included in the configuration:
        # 
        # *   pvcName: the name of the PVC volume. Make sure that the PVC volume is an existing volume and is in the Bound state.
        # 
        # *   mountPaths: the directory to which you want to mount the PVC volume. You can configure multiple directories. You can set the following two parameters for each mount directory:
        # 
        #     *   mountPath: the mount path. The mount path must be an absolute path that starts with a forward slash (/).
        #     *   readOnly: the mount mode. Value true indicates the read-only mode. Value false indicates the read and write mode. Default value: false.
        self.pvc_mount_descs = pvc_mount_descs
        # The configuration for the readiness check on the container. If the check fails, the traffic that passes through the Kubernetes Service is not transmitted to the container. Example: \\`{"failureThreshold": 3,"initialDelaySeconds": 5,"successThreshold": 1,"timeoutSeconds": 1,"httpGet": {"path": "/consumer","port": 8080,"scheme": "HTTP","httpHeaders": \[{"name": "test","value": "testvalue"}\\\\]}}\\`.``
        # 
        # If you want to cancel this configuration, leave the parameter value empty by entering `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
        self.readiness = readiness
        # The number of application instances.
        self.replicas = replicas
        # The ID of the image repository.
        self.repo_id = repo_id
        # The maximum number of CPU cores allowed for each application instance when the application is created. Unit: cores. Value 0 indicates that no limit is set on CPU cores. If the RequestsmCpu parameter is specified, the value of the RequestsmCpu parameter is used. You can ignore this parameter.
        self.requests_cpu = requests_cpu
        # The minimum size of space required by ephemeral storage. Unit: GB. Value 0 indicates that no limit is set on the space size.
        self.requests_ephemeral_storage = requests_ephemeral_storage
        # The maximum size of memory allowed for each application instance when the application is created. Unit: MB. Value 0 indicates that no limit is set on the memory size. The value of RequestsMem cannot be greater than that of LimitMem.
        self.requests_mem = requests_mem
        # The maximum number of CPU cores allowed for each application instance when the application is created. Unit: millicores.
        self.requestsm_cpu = requestsm_cpu
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The type of the container runtime. This parameter is applicable only to clusters that use sandboxed containers.
        self.runtime_class_name = runtime_class_name
        # The name of the credential that is used to pull the images specified by the user. You must configure the Secret.
        self.secret_name = secret_name
        # The configurations of services in a Kubernetes cluster.
        self.service_configs = service_configs
        # Set up a Sidecar container for the application Pod. Support setting the format YAML for container configuration, which is the value of Sidecar container YAML configured with base64 encoding.
        self.sidecars = sidecars
        # The Logstore configuration. To delete this configuration, leave the parameter value empty by entering `""` or `"{}"`.
        # 
        # *   The following parameters are included in the configuration:
        # 
        #     *   type: the collection type. Set this parameter to file to specify the file type. Set this parameter to stdout to specify the standard output type.
        # 
        #     *   logstore: the name of the Logstore. Make sure that the name of the Logstore is unique in the cluster. The name must comply with the following rules:
        # 
        #         *   The name can contain only lowercase letters, digits, hyphens (-), and underscores (_).
        #         *   The name must start and end with a lowercase letter or a digit.
        #         *   The name must be 3 to 63 characters in length. If you leave this parameter empty, the system automatically generates a name.
        # 
        #     *   LogDir: If the standard output type is used, the collection path is stdout.log. If the file type is used, the collection path is the path of the collected file. Wildcards (\\*) are supported. The collection path must match the following regular expression: `^/(.+)/(.*)^/$`.
        self.sls_configs = sls_configs
        # The startup probe can be used to detect the viability of slow start containers, avoiding them from being killed before startup. The format is as follows: {"FailureThreshold": 3, "initialDelaySeconds": 5, "SuccessThreshold": 1, "timeoutSeconds": 1, "https Get": {"path": "/consumer", "port": 8080, "scheme": "HTTP", "https Headers": [{"name": "test", "value": "testvalue"}]}.
        # 
        # If set to "" or {}, it means delete, and if not set, it means ignore.
        self.startup = startup
        # The storage type of the NAS file system.
        # 
        # *   Valid values for General-purpose NAS file systems: Capacity and Performance.
        # *   Valid values for Extreme NAS file systems: Standard and Advance.
        # 
        # You can set this parameter only to Performance.
        self.storage_type = storage_type
        # Set the grace stop timeout for the application. Unit: seconds.
        self.terminate_grace_period = terminate_grace_period
        # The timeout period of the change process. Valid values: 1 to 1800. Unit: seconds. If you do not specify this Unidentifiedparameter, the default value 1800 is used.
        self.timeout = timeout
        # The URI encoding scheme. Valid values: ISO-8859-1, GBK, GB2312, and UTF-8.
        # 
        # > If you do not specify this parameter in the application configurations, the default URI encoding scheme in the Tomcat container is applied.
        self.uri_encoding = uri_encoding
        # Specifies whether to use the encoding scheme specified in the request body for URI query parameters.
        # 
        # > If this parameter is not specified in application configuration, the default value false is applied.
        self.use_body_encoding = use_body_encoding
        # When using custom JDK runtime, it is necessary to configure the basic image address. The address needs to be publicly accessible, and the EDAS server will pull the image to build the application image.
        self.user_base_image_url = user_base_image_url
        # The version of the Tomcat container on which the deployment package of the application depends. This parameter is applicable to Spring Cloud and Dubbo applications that you deploy by using WAR packages. This parameter is unavailable if you deploy applications by using images.
        self.web_container = web_container
        # The configuration of the Tomcat container. If you want to cancel this configuration, set this parameter to "" or "{}". The following parameters are included in the configuration:
        # 
        # *   useDefaultConfig: specifies whether to use the default configuration. Value true indicates that the default configuration is used. Value false indicates that the custom configuration is used. If the default configuration is used, the following parameters do not take effect:
        # 
        # *   contextInputType: the type of the access path for the application. Valid values:
        # 
        #     *   war: The access path is the name of the WAR package. You do not need to specify a custom path.
        #     *   root: The access path for the application is `/`. You do not need to specify a custom path.
        #     *   custom: If you select this option, you must specify a custom path for the contextPath parameter.
        # 
        # *   contextPath: the custom access path for the application. This parameter is required only when you set the contextInputType parameter to custom.
        # 
        # *   httpPort: the port number. The port number ranges from 1024 to 65535. Though the admin permissions are configured for the container, the root permissions are required to perform operations on ports whose number is less than 1024. Enter a value that ranges from 1024 to 65535 because the container has only the admin permissions. If you do not configure this parameter, the default port number 8080 is used.
        # 
        # *   maxThreads: the maximum number of connections in the connection pool. Default value: 400.
        # 
        #     **\
        # 
        #     **Note**This parameter significantly affects application performance. We recommend that you consult with technical support before you set this parameter.
        # 
        # *   uriEncoding: the URI encoding scheme in the Tomcat container. Valid values: UTF-8, ISO-8859-1, GBK, and GB2312. If you do not specify this parameter, the default value ISO-8859-1 is used.
        # 
        # *   useBodyEncoding: specifies whether to use the encoding scheme specified in the request body for URI query parameters.
        # 
        # *   useAdvancedServerXml: specifies whether to use advanced configurations to customize the server.xml file. If the preceding parameter types and specific parameters cannot meet your requirements, you can use advanced configurations to customize the server.xml file of Tomcat.
        # 
        # *   serverXml: the content of the server.xml file customized by using advanced configurations. This parameter takes effect only when you set the useAdvancedServerXml parameter to true.
        self.web_container_config = web_container_config
        # The type of Workload when creating an application is currently only supported for the Deployment type.
        self.workload_type = workload_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotations is not None:
            result['Annotations'] = self.annotations
        if self.app_config is not None:
            result['AppConfig'] = self.app_config
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.app_template_name is not None:
            result['AppTemplateName'] = self.app_template_name
        if self.application_description is not None:
            result['ApplicationDescription'] = self.application_description
        if self.build_pack_id is not None:
            result['BuildPackId'] = self.build_pack_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        if self.config_mount_descs is not None:
            result['ConfigMountDescs'] = self.config_mount_descs
        if self.container_registry_id is not None:
            result['ContainerRegistryId'] = self.container_registry_id
        if self.cs_cluster_id is not None:
            result['CsClusterId'] = self.cs_cluster_id
        if self.custom_affinity is not None:
            result['CustomAffinity'] = self.custom_affinity
        if self.custom_agent_version is not None:
            result['CustomAgentVersion'] = self.custom_agent_version
        if self.custom_tolerations is not None:
            result['CustomTolerations'] = self.custom_tolerations
        if self.deploy_across_nodes is not None:
            result['DeployAcrossNodes'] = self.deploy_across_nodes
        if self.deploy_across_zones is not None:
            result['DeployAcrossZones'] = self.deploy_across_zones
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.empty_dirs is not None:
            result['EmptyDirs'] = self.empty_dirs
        if self.enable_ahas is not None:
            result['EnableAhas'] = self.enable_ahas
        if self.enable_asm is not None:
            result['EnableAsm'] = self.enable_asm
        if self.enable_empty_push_reject is not None:
            result['EnableEmptyPushReject'] = self.enable_empty_push_reject
        if self.enable_lossless_rule is not None:
            result['EnableLosslessRule'] = self.enable_lossless_rule
        if self.env_froms is not None:
            result['EnvFroms'] = self.env_froms
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.feature_config is not None:
            result['FeatureConfig'] = self.feature_config
        if self.image_platforms is not None:
            result['ImagePlatforms'] = self.image_platforms
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.init_containers is not None:
            result['InitContainers'] = self.init_containers
        if self.internet_slb_id is not None:
            result['InternetSlbId'] = self.internet_slb_id
        if self.internet_slb_port is not None:
            result['InternetSlbPort'] = self.internet_slb_port
        if self.internet_slb_protocol is not None:
            result['InternetSlbProtocol'] = self.internet_slb_protocol
        if self.internet_target_port is not None:
            result['InternetTargetPort'] = self.internet_target_port
        if self.intranet_slb_id is not None:
            result['IntranetSlbId'] = self.intranet_slb_id
        if self.intranet_slb_port is not None:
            result['IntranetSlbPort'] = self.intranet_slb_port
        if self.intranet_slb_protocol is not None:
            result['IntranetSlbProtocol'] = self.intranet_slb_protocol
        if self.intranet_target_port is not None:
            result['IntranetTargetPort'] = self.intranet_target_port
        if self.is_multilingual_app is not None:
            result['IsMultilingualApp'] = self.is_multilingual_app
        if self.jdk is not None:
            result['JDK'] = self.jdk
        if self.java_start_up_config is not None:
            result['JavaStartUpConfig'] = self.java_start_up_config
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.limit_cpu is not None:
            result['LimitCpu'] = self.limit_cpu
        if self.limit_ephemeral_storage is not None:
            result['LimitEphemeralStorage'] = self.limit_ephemeral_storage
        if self.limit_mem is not None:
            result['LimitMem'] = self.limit_mem
        if self.limitm_cpu is not None:
            result['LimitmCpu'] = self.limitm_cpu
        if self.liveness is not None:
            result['Liveness'] = self.liveness
        if self.local_volume is not None:
            result['LocalVolume'] = self.local_volume
        if self.logical_region_id is not None:
            result['LogicalRegionId'] = self.logical_region_id
        if self.lossless_rule_aligned is not None:
            result['LosslessRuleAligned'] = self.lossless_rule_aligned
        if self.lossless_rule_delay_time is not None:
            result['LosslessRuleDelayTime'] = self.lossless_rule_delay_time
        if self.lossless_rule_func_type is not None:
            result['LosslessRuleFuncType'] = self.lossless_rule_func_type
        if self.lossless_rule_related is not None:
            result['LosslessRuleRelated'] = self.lossless_rule_related
        if self.lossless_rule_warmup_time is not None:
            result['LosslessRuleWarmupTime'] = self.lossless_rule_warmup_time
        if self.mount_descs is not None:
            result['MountDescs'] = self.mount_descs
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.nas_id is not None:
            result['NasId'] = self.nas_id
        if self.package_type is not None:
            result['PackageType'] = self.package_type
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.post_start is not None:
            result['PostStart'] = self.post_start
        if self.pre_stop is not None:
            result['PreStop'] = self.pre_stop
        if self.pvc_mount_descs is not None:
            result['PvcMountDescs'] = self.pvc_mount_descs
        if self.readiness is not None:
            result['Readiness'] = self.readiness
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.requests_cpu is not None:
            result['RequestsCpu'] = self.requests_cpu
        if self.requests_ephemeral_storage is not None:
            result['RequestsEphemeralStorage'] = self.requests_ephemeral_storage
        if self.requests_mem is not None:
            result['RequestsMem'] = self.requests_mem
        if self.requestsm_cpu is not None:
            result['RequestsmCpu'] = self.requestsm_cpu
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.runtime_class_name is not None:
            result['RuntimeClassName'] = self.runtime_class_name
        if self.secret_name is not None:
            result['SecretName'] = self.secret_name
        if self.service_configs is not None:
            result['ServiceConfigs'] = self.service_configs
        if self.sidecars is not None:
            result['Sidecars'] = self.sidecars
        if self.sls_configs is not None:
            result['SlsConfigs'] = self.sls_configs
        if self.startup is not None:
            result['Startup'] = self.startup
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        if self.terminate_grace_period is not None:
            result['TerminateGracePeriod'] = self.terminate_grace_period
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.uri_encoding is not None:
            result['UriEncoding'] = self.uri_encoding
        if self.use_body_encoding is not None:
            result['UseBodyEncoding'] = self.use_body_encoding
        if self.user_base_image_url is not None:
            result['UserBaseImageUrl'] = self.user_base_image_url
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        if self.web_container_config is not None:
            result['WebContainerConfig'] = self.web_container_config
        if self.workload_type is not None:
            result['WorkloadType'] = self.workload_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Annotations') is not None:
            self.annotations = m.get('Annotations')
        if m.get('AppConfig') is not None:
            self.app_config = m.get('AppConfig')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AppTemplateName') is not None:
            self.app_template_name = m.get('AppTemplateName')
        if m.get('ApplicationDescription') is not None:
            self.application_description = m.get('ApplicationDescription')
        if m.get('BuildPackId') is not None:
            self.build_pack_id = m.get('BuildPackId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        if m.get('ConfigMountDescs') is not None:
            self.config_mount_descs = m.get('ConfigMountDescs')
        if m.get('ContainerRegistryId') is not None:
            self.container_registry_id = m.get('ContainerRegistryId')
        if m.get('CsClusterId') is not None:
            self.cs_cluster_id = m.get('CsClusterId')
        if m.get('CustomAffinity') is not None:
            self.custom_affinity = m.get('CustomAffinity')
        if m.get('CustomAgentVersion') is not None:
            self.custom_agent_version = m.get('CustomAgentVersion')
        if m.get('CustomTolerations') is not None:
            self.custom_tolerations = m.get('CustomTolerations')
        if m.get('DeployAcrossNodes') is not None:
            self.deploy_across_nodes = m.get('DeployAcrossNodes')
        if m.get('DeployAcrossZones') is not None:
            self.deploy_across_zones = m.get('DeployAcrossZones')
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('EmptyDirs') is not None:
            self.empty_dirs = m.get('EmptyDirs')
        if m.get('EnableAhas') is not None:
            self.enable_ahas = m.get('EnableAhas')
        if m.get('EnableAsm') is not None:
            self.enable_asm = m.get('EnableAsm')
        if m.get('EnableEmptyPushReject') is not None:
            self.enable_empty_push_reject = m.get('EnableEmptyPushReject')
        if m.get('EnableLosslessRule') is not None:
            self.enable_lossless_rule = m.get('EnableLosslessRule')
        if m.get('EnvFroms') is not None:
            self.env_froms = m.get('EnvFroms')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('FeatureConfig') is not None:
            self.feature_config = m.get('FeatureConfig')
        if m.get('ImagePlatforms') is not None:
            self.image_platforms = m.get('ImagePlatforms')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('InitContainers') is not None:
            self.init_containers = m.get('InitContainers')
        if m.get('InternetSlbId') is not None:
            self.internet_slb_id = m.get('InternetSlbId')
        if m.get('InternetSlbPort') is not None:
            self.internet_slb_port = m.get('InternetSlbPort')
        if m.get('InternetSlbProtocol') is not None:
            self.internet_slb_protocol = m.get('InternetSlbProtocol')
        if m.get('InternetTargetPort') is not None:
            self.internet_target_port = m.get('InternetTargetPort')
        if m.get('IntranetSlbId') is not None:
            self.intranet_slb_id = m.get('IntranetSlbId')
        if m.get('IntranetSlbPort') is not None:
            self.intranet_slb_port = m.get('IntranetSlbPort')
        if m.get('IntranetSlbProtocol') is not None:
            self.intranet_slb_protocol = m.get('IntranetSlbProtocol')
        if m.get('IntranetTargetPort') is not None:
            self.intranet_target_port = m.get('IntranetTargetPort')
        if m.get('IsMultilingualApp') is not None:
            self.is_multilingual_app = m.get('IsMultilingualApp')
        if m.get('JDK') is not None:
            self.jdk = m.get('JDK')
        if m.get('JavaStartUpConfig') is not None:
            self.java_start_up_config = m.get('JavaStartUpConfig')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('LimitCpu') is not None:
            self.limit_cpu = m.get('LimitCpu')
        if m.get('LimitEphemeralStorage') is not None:
            self.limit_ephemeral_storage = m.get('LimitEphemeralStorage')
        if m.get('LimitMem') is not None:
            self.limit_mem = m.get('LimitMem')
        if m.get('LimitmCpu') is not None:
            self.limitm_cpu = m.get('LimitmCpu')
        if m.get('Liveness') is not None:
            self.liveness = m.get('Liveness')
        if m.get('LocalVolume') is not None:
            self.local_volume = m.get('LocalVolume')
        if m.get('LogicalRegionId') is not None:
            self.logical_region_id = m.get('LogicalRegionId')
        if m.get('LosslessRuleAligned') is not None:
            self.lossless_rule_aligned = m.get('LosslessRuleAligned')
        if m.get('LosslessRuleDelayTime') is not None:
            self.lossless_rule_delay_time = m.get('LosslessRuleDelayTime')
        if m.get('LosslessRuleFuncType') is not None:
            self.lossless_rule_func_type = m.get('LosslessRuleFuncType')
        if m.get('LosslessRuleRelated') is not None:
            self.lossless_rule_related = m.get('LosslessRuleRelated')
        if m.get('LosslessRuleWarmupTime') is not None:
            self.lossless_rule_warmup_time = m.get('LosslessRuleWarmupTime')
        if m.get('MountDescs') is not None:
            self.mount_descs = m.get('MountDescs')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NasId') is not None:
            self.nas_id = m.get('NasId')
        if m.get('PackageType') is not None:
            self.package_type = m.get('PackageType')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('PostStart') is not None:
            self.post_start = m.get('PostStart')
        if m.get('PreStop') is not None:
            self.pre_stop = m.get('PreStop')
        if m.get('PvcMountDescs') is not None:
            self.pvc_mount_descs = m.get('PvcMountDescs')
        if m.get('Readiness') is not None:
            self.readiness = m.get('Readiness')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RequestsCpu') is not None:
            self.requests_cpu = m.get('RequestsCpu')
        if m.get('RequestsEphemeralStorage') is not None:
            self.requests_ephemeral_storage = m.get('RequestsEphemeralStorage')
        if m.get('RequestsMem') is not None:
            self.requests_mem = m.get('RequestsMem')
        if m.get('RequestsmCpu') is not None:
            self.requestsm_cpu = m.get('RequestsmCpu')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('RuntimeClassName') is not None:
            self.runtime_class_name = m.get('RuntimeClassName')
        if m.get('SecretName') is not None:
            self.secret_name = m.get('SecretName')
        if m.get('ServiceConfigs') is not None:
            self.service_configs = m.get('ServiceConfigs')
        if m.get('Sidecars') is not None:
            self.sidecars = m.get('Sidecars')
        if m.get('SlsConfigs') is not None:
            self.sls_configs = m.get('SlsConfigs')
        if m.get('Startup') is not None:
            self.startup = m.get('Startup')
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        if m.get('TerminateGracePeriod') is not None:
            self.terminate_grace_period = m.get('TerminateGracePeriod')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('UriEncoding') is not None:
            self.uri_encoding = m.get('UriEncoding')
        if m.get('UseBodyEncoding') is not None:
            self.use_body_encoding = m.get('UseBodyEncoding')
        if m.get('UserBaseImageUrl') is not None:
            self.user_base_image_url = m.get('UserBaseImageUrl')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        if m.get('WebContainerConfig') is not None:
            self.web_container_config = m.get('WebContainerConfig')
        if m.get('WorkloadType') is not None:
            self.workload_type = m.get('WorkloadType')
        return self


class InsertK8sApplicationResponseBodyApplicationInfo(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        change_order_id: str = None,
        cluster_type: int = None,
        dockerize: bool = None,
        edas_id: str = None,
        owner: str = None,
        region_id: str = None,
        user_id: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        # The ID of the change process. You can call the GetChangeOrderInfo operation to query the change process ID. For more information, see [GetChangeOrderInfo](https://help.aliyun.com/document_detail/62072.html).
        self.change_order_id = change_order_id
        # The type of the cluster. Valid values:
        # 
        # *   0: regular Docker cluster
        # *   1: Swarm cluster (discontinued)
        # *   2: Elastic Compute Service (ECS) cluster
        # *   3: self-managed Kubernetes cluster in EDAS (discontinued)
        # *   4: cluster in which Pandora automatically registers applications
        # *   5: ACK cluster and serverless Kubernetes cluster
        self.cluster_type = cluster_type
        # Indicates whether the application is a Docker application.
        # 
        # *   true: The application is a Docker application.
        # *   false: The application is not a Docker application.
        self.dockerize = dockerize
        # The ID of the user to which the application belongs. This ID is generated by EDAS.
        self.edas_id = edas_id
        # The owner of the application.
        self.owner = owner
        # The ID of the region.
        self.region_id = region_id
        # The ID of the Alibaba Cloud account to which the application belongs.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.dockerize is not None:
            result['Dockerize'] = self.dockerize
        if self.edas_id is not None:
            result['EdasId'] = self.edas_id
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('Dockerize') is not None:
            self.dockerize = m.get('Dockerize')
        if m.get('EdasId') is not None:
            self.edas_id = m.get('EdasId')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class InsertK8sApplicationResponseBody(TeaModel):
    def __init__(
        self,
        application_info: InsertK8sApplicationResponseBodyApplicationInfo = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The details of the application.
        self.application_info = application_info
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.application_info:
            self.application_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_info is not None:
            result['ApplicationInfo'] = self.application_info.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationInfo') is not None:
            temp_model = InsertK8sApplicationResponseBodyApplicationInfo()
            self.application_info = temp_model.from_map(m['ApplicationInfo'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InsertK8sApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InsertK8sApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InsertK8sApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InsertOrUpdateRegionRequest(TeaModel):
    def __init__(
        self,
        debug_enable: bool = None,
        description: str = None,
        id: int = None,
        mse_instance_id: str = None,
        region_name: str = None,
        region_tag: str = None,
        registry_type: str = None,
    ):
        # Specifies whether to enable remote debugging. Valid values:
        # 
        # *   true: enables remote debugging.
        # *   false: disables remote debugging.
        self.debug_enable = debug_enable
        # The description of the namespace. The description can be up to 128 characters in length.
        self.description = description
        # Specifies whether to create or modify the namespace. If this parameter is left empty or is set to 0, the namespace is created. Otherwise, the namespace is modified.
        self.id = id
        # The ID of the MSE registry.
        self.mse_instance_id = mse_instance_id
        # The name of the namespace. The name can be up to 63 characters in length.
        # 
        # This parameter is required.
        self.region_name = region_name
        # The ID of the namespace.
        # 
        # *   The ID of a custom namespace is in the `Region ID:Namespace identifier` format. Example: cn-beijing:tdy218.
        # *   The ID of the default namespace is in the `region ID` format. Example: cn-beijing.
        # 
        # This parameter is required.
        self.region_tag = region_tag
        # The type of the registry.
        # 
        # *   default: the shared registry of Enterprise Distributed Application Service (EDAS)
        # *   exclusive_mse: a Microservices Engine (MSE) registry
        self.registry_type = registry_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.debug_enable is not None:
            result['DebugEnable'] = self.debug_enable
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.mse_instance_id is not None:
            result['MseInstanceId'] = self.mse_instance_id
        if self.region_name is not None:
            result['RegionName'] = self.region_name
        if self.region_tag is not None:
            result['RegionTag'] = self.region_tag
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DebugEnable') is not None:
            self.debug_enable = m.get('DebugEnable')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MseInstanceId') is not None:
            self.mse_instance_id = m.get('MseInstanceId')
        if m.get('RegionName') is not None:
            self.region_name = m.get('RegionName')
        if m.get('RegionTag') is not None:
            self.region_tag = m.get('RegionTag')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        return self


class InsertOrUpdateRegionResponseBodyUserDefineRegionEntity(TeaModel):
    def __init__(
        self,
        belong_region: str = None,
        debug_enable: bool = None,
        description: str = None,
        id: int = None,
        region_id: str = None,
        region_name: str = None,
        user_id: str = None,
    ):
        # The ID of the region to which the namespace belongs.
        self.belong_region = belong_region
        # Indicates whether remote debugging is enabled. Valid values:
        # 
        # *   true: Remote debugging is enabled.
        # *   false: Remote debugging is disabled.
        self.debug_enable = debug_enable
        # The description of the namespace.
        self.description = description
        # Indicates whether the namespace is created or modified. If this parameter is left empty or 0 is returned, the namespace is created. Otherwise, the namespace is modified.
        self.id = id
        # The ID of the namespace.
        # 
        # *   The ID of a custom namespace is in the `region ID:namespace identifier` format. Example: cn-beijing:tdy218.
        # *   The ID of the default namespace is in the `region ID` format. Example: cn-beijing.
        self.region_id = region_id
        # The name of the namespace.
        self.region_name = region_name
        # The ID of the Alibaba Cloud account to which the custom namespace belongs.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.belong_region is not None:
            result['BelongRegion'] = self.belong_region
        if self.debug_enable is not None:
            result['DebugEnable'] = self.debug_enable
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.region_name is not None:
            result['RegionName'] = self.region_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BelongRegion') is not None:
            self.belong_region = m.get('BelongRegion')
        if m.get('DebugEnable') is not None:
            self.debug_enable = m.get('DebugEnable')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegionName') is not None:
            self.region_name = m.get('RegionName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class InsertOrUpdateRegionResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        user_define_region_entity: InsertOrUpdateRegionResponseBodyUserDefineRegionEntity = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The information about the custom namespace.
        self.user_define_region_entity = user_define_region_entity

    def validate(self):
        if self.user_define_region_entity:
            self.user_define_region_entity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.user_define_region_entity is not None:
            result['UserDefineRegionEntity'] = self.user_define_region_entity.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UserDefineRegionEntity') is not None:
            temp_model = InsertOrUpdateRegionResponseBodyUserDefineRegionEntity()
            self.user_define_region_entity = temp_model.from_map(m['UserDefineRegionEntity'])
        return self


class InsertOrUpdateRegionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InsertOrUpdateRegionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InsertOrUpdateRegionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InsertRoleRequest(TeaModel):
    def __init__(
        self,
        action_data: str = None,
        role_name: str = None,
    ):
        # The set of permissions to be granted to the role. The value is in the format of `Permission group ID 1:Permission serial number 1;...;Permission group ID n:Permission serial number n`. Example: `1:1;1:2;2:1;2:2`. For more information about permission groups and permission serial numbers, see [ListAuthority](https://help.aliyun.com/document_detail/149409.html).
        # 
        # This parameter is required.
        self.action_data = action_data
        # The name of the role.
        # 
        # This parameter is required.
        self.role_name = role_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_data is not None:
            result['ActionData'] = self.action_data
        if self.role_name is not None:
            result['RoleName'] = self.role_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionData') is not None:
            self.action_data = m.get('ActionData')
        if m.get('RoleName') is not None:
            self.role_name = m.get('RoleName')
        return self


class InsertRoleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        role_id: int = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The ID of the role.
        self.role_id = role_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        return self


class InsertRoleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InsertRoleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InsertRoleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InsertServiceGroupRequest(TeaModel):
    def __init__(
        self,
        group_name: str = None,
    ):
        # The name of the service group that you want to create.
        # 
        # This parameter is required.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class InsertServiceGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InsertServiceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InsertServiceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InsertServiceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InsertSwimmingLaneRequest(TeaModel):
    def __init__(
        self,
        app_infos: str = None,
        enable_rules: bool = None,
        entry_rules: str = None,
        group_id: int = None,
        logical_region_id: str = None,
        name: str = None,
        tag: str = None,
    ):
        # The information about applications related to the lane.
        self.app_infos = app_infos
        # Specifies whether to enable the throttling rule.
        self.enable_rules = enable_rules
        # The throttling conditions.
        # 
        # This parameter is required.
        self.entry_rules = entry_rules
        # The ID of the lane group.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The ID of the custom namespace. The ID is in the `physical region ID:custom namespace identifier` format. Example: `cn-hangzhou:test`.
        # 
        # This parameter is required.
        self.logical_region_id = logical_region_id
        # The name of the lane.
        # 
        # This parameter is required.
        self.name = name
        # The tag.
        # 
        # This parameter is required.
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_infos is not None:
            result['AppInfos'] = self.app_infos
        if self.enable_rules is not None:
            result['EnableRules'] = self.enable_rules
        if self.entry_rules is not None:
            result['EntryRules'] = self.entry_rules
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.logical_region_id is not None:
            result['LogicalRegionId'] = self.logical_region_id
        if self.name is not None:
            result['Name'] = self.name
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppInfos') is not None:
            self.app_infos = m.get('AppInfos')
        if m.get('EnableRules') is not None:
            self.enable_rules = m.get('EnableRules')
        if m.get('EntryRules') is not None:
            self.entry_rules = m.get('EntryRules')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('LogicalRegionId') is not None:
            self.logical_region_id = m.get('LogicalRegionId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        lane_id: int = None,
        rules: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        # The ID of the lane.
        self.lane_id = lane_id
        # The association rule.
        self.rules = rules

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.lane_id is not None:
            result['LaneId'] = self.lane_id
        if self.rules is not None:
            result['Rules'] = self.rules
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('LaneId') is not None:
            self.lane_id = m.get('LaneId')
        if m.get('Rules') is not None:
            self.rules = m.get('Rules')
        return self


class InsertSwimmingLaneResponseBodyData(TeaModel):
    def __init__(
        self,
        app_infos: str = None,
        entry_rule: str = None,
        group_id: int = None,
        id: int = None,
        name: str = None,
        namespace_id: str = None,
        swimming_lane_app_relation_ship_list: List[InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList] = None,
        tag: str = None,
    ):
        # The applications that are associated with lanes.
        self.app_infos = app_infos
        # The throttling rule for the lane.
        # 
        # priority: the priority of the throttling rule for the lane. Valid values: 1 to 100.
        # 
        # path: the path that is matched by the throttling rule for the lane.
        # 
        # restItems: conditions to be met.
        # 
        # condition: the relationship among the conditions to be met.
        # 
        # *   AND: all conditions
        # *   OR: one of the conditions
        # 
        # restItems.type: the type of the rule. Valid values:
        # 
        # *   header: matches by request header.
        # *   cookie: matches by request cookie.
        # *   param: matches by request parameters.
        # 
        # restItems.name: the key that matches the rule.
        # 
        # restItems.value: the value that matches the rule.
        # 
        # restItems.cond: the condition that matches the rule. Valid values:
        # 
        # *   "==": The parameter value is equal to the value that you enter in the Value field.
        # *   "!=": The parameter value is not equal to the value that you enter in the Value field.
        # *   ">": The parameter value is greater than the value that you enter in the Value field.
        # *   "<": The parameter value is less than the value that you enter in the Value field.
        # *   ">=": The parameter value is greater than or equal to the value that you enter in the Value field.
        # *   "<=": The parameter value is less than or equal to the value that you enter in the Value field.
        # *   "in": The parameter value is within the values that you enter in the Value field.
        # 
        # restItems.operator: the type of the value. Valid values:
        # 
        # *   rawvalue: the initial value
        # *   mod: the reminder obtained by performing modulo operation
        # *   list: the value from the list
        self.entry_rule = entry_rule
        # The ID of the lane group.
        self.group_id = group_id
        # The ID of the lane.
        self.id = id
        # The name of the lane.
        self.name = name
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The association relationships between lanes and applications.
        self.swimming_lane_app_relation_ship_list = swimming_lane_app_relation_ship_list
        # The tag of the lane.
        self.tag = tag

    def validate(self):
        if self.swimming_lane_app_relation_ship_list:
            for k in self.swimming_lane_app_relation_ship_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_infos is not None:
            result['AppInfos'] = self.app_infos
        if self.entry_rule is not None:
            result['EntryRule'] = self.entry_rule
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        result['SwimmingLaneAppRelationShipList'] = []
        if self.swimming_lane_app_relation_ship_list is not None:
            for k in self.swimming_lane_app_relation_ship_list:
                result['SwimmingLaneAppRelationShipList'].append(k.to_map() if k else None)
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppInfos') is not None:
            self.app_infos = m.get('AppInfos')
        if m.get('EntryRule') is not None:
            self.entry_rule = m.get('EntryRule')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        self.swimming_lane_app_relation_ship_list = []
        if m.get('SwimmingLaneAppRelationShipList') is not None:
            for k in m.get('SwimmingLaneAppRelationShipList'):
                temp_model = InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList()
                self.swimming_lane_app_relation_ship_list.append(temp_model.from_map(k))
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class InsertSwimmingLaneResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: InsertSwimmingLaneResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The data that is returned.
        self.data = data
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = InsertSwimmingLaneResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InsertSwimmingLaneResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InsertSwimmingLaneResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InsertSwimmingLaneResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InsertSwimmingLaneGroupRequest(TeaModel):
    def __init__(
        self,
        app_ids: str = None,
        entry_app: str = None,
        logical_region_id: str = None,
        name: str = None,
    ):
        # IDs of all applications that are related to the lane group. Separate multiple applications with commas (,).
        # 
        # This parameter is required.
        self.app_ids = app_ids
        # The ingress application. The application is in the EDAS:{application ID} format.
        # 
        # This parameter is required.
        self.entry_app = entry_app
        # The ID of the custom namespace. The ID is in the physical region ID:custom namespace identifier format. Example: cn-hangzhou:test.
        # 
        # This parameter is required.
        self.logical_region_id = logical_region_id
        # The name of the lane group.
        # 
        # This parameter is required.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_ids is not None:
            result['AppIds'] = self.app_ids
        if self.entry_app is not None:
            result['EntryApp'] = self.entry_app
        if self.logical_region_id is not None:
            result['LogicalRegionId'] = self.logical_region_id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppIds') is not None:
            self.app_ids = m.get('AppIds')
        if m.get('EntryApp') is not None:
            self.entry_app = m.get('EntryApp')
        if m.get('LogicalRegionId') is not None:
            self.logical_region_id = m.get('LogicalRegionId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        return self


class InsertSwimmingLaneGroupResponseBodyDataApplicationList(TeaModel):
    def __init__(
        self,
        application: List[InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication] = None,
    ):
        self.application = application

    def validate(self):
        if self.application:
            for k in self.application:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Application'] = []
        if self.application is not None:
            for k in self.application:
                result['Application'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.application = []
        if m.get('Application') is not None:
            for k in m.get('Application'):
                temp_model = InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication()
                self.application.append(temp_model.from_map(k))
        return self


class InsertSwimmingLaneGroupResponseBodyDataEntryApplication(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        return self


class InsertSwimmingLaneGroupResponseBodyData(TeaModel):
    def __init__(
        self,
        application_list: InsertSwimmingLaneGroupResponseBodyDataApplicationList = None,
        entry_application: InsertSwimmingLaneGroupResponseBodyDataEntryApplication = None,
        id: int = None,
        name: str = None,
        namespace_id: str = None,
    ):
        # The list of all applications that are related to the lane group.
        self.application_list = application_list
        # The information about the Enterprise Distributed Application Service (EDAS) ingress gateway.
        self.entry_application = entry_application
        # The ID of the lane group.
        self.id = id
        # The name of the lane group.
        self.name = name
        # The ID of the namespace.
        self.namespace_id = namespace_id

    def validate(self):
        if self.application_list:
            self.application_list.validate()
        if self.entry_application:
            self.entry_application.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_list is not None:
            result['ApplicationList'] = self.application_list.to_map()
        if self.entry_application is not None:
            result['EntryApplication'] = self.entry_application.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationList') is not None:
            temp_model = InsertSwimmingLaneGroupResponseBodyDataApplicationList()
            self.application_list = temp_model.from_map(m['ApplicationList'])
        if m.get('EntryApplication') is not None:
            temp_model = InsertSwimmingLaneGroupResponseBodyDataEntryApplication()
            self.entry_application = temp_model.from_map(m['EntryApplication'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class InsertSwimmingLaneGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: InsertSwimmingLaneGroupResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The data that is returned.
        self.data = data
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = InsertSwimmingLaneGroupResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InsertSwimmingLaneGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InsertSwimmingLaneGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InsertSwimmingLaneGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InstallAgentRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        do_async: bool = None,
        instance_ids: str = None,
    ):
        # The ID of the cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # This parameter is discontinued.
        self.do_async = do_async
        # The ID of the ECS instance. Separate multiple IDs with commas (,). Example: instanceId1,instanceId2.
        # 
        # This parameter is required.
        self.instance_ids = instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.do_async is not None:
            result['DoAsync'] = self.do_async
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DoAsync') is not None:
            self.do_async = m.get('DoAsync')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class InstallAgentResponseBodyExecutionResultListExecutionResult(TeaModel):
    def __init__(
        self,
        finished_time: str = None,
        instance_id: str = None,
        invoke_record_status: str = None,
        status: str = None,
        success: bool = None,
    ):
        # The time when the installation was complete.
        self.finished_time = finished_time
        # The ID of the instance.
        self.instance_id = instance_id
        # The state of the installation.
        self.invoke_record_status = invoke_record_status
        # The state of the installation command.
        self.status = status
        # Indicates whether the installation was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.finished_time is not None:
            result['FinishedTime'] = self.finished_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.invoke_record_status is not None:
            result['InvokeRecordStatus'] = self.invoke_record_status
        if self.status is not None:
            result['Status'] = self.status
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FinishedTime') is not None:
            self.finished_time = m.get('FinishedTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InvokeRecordStatus') is not None:
            self.invoke_record_status = m.get('InvokeRecordStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class InstallAgentResponseBodyExecutionResultList(TeaModel):
    def __init__(
        self,
        execution_result: List[InstallAgentResponseBodyExecutionResultListExecutionResult] = None,
    ):
        self.execution_result = execution_result

    def validate(self):
        if self.execution_result:
            for k in self.execution_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ExecutionResult'] = []
        if self.execution_result is not None:
            for k in self.execution_result:
                result['ExecutionResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.execution_result = []
        if m.get('ExecutionResult') is not None:
            for k in m.get('ExecutionResult'):
                temp_model = InstallAgentResponseBodyExecutionResultListExecutionResult()
                self.execution_result.append(temp_model.from_map(k))
        return self


class InstallAgentResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        execution_result_list: InstallAgentResponseBodyExecutionResultList = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The execution result.
        self.execution_result_list = execution_result_list
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.execution_result_list:
            self.execution_result_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.execution_result_list is not None:
            result['ExecutionResultList'] = self.execution_result_list.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExecutionResultList') is not None:
            temp_model = InstallAgentResponseBodyExecutionResultList()
            self.execution_result_list = temp_model.from_map(m['ExecutionResultList'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InstallAgentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InstallAgentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InstallAgentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAliyunRegionResponseBodyRegionEntityListRegionEntity(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
    ):
        # The ID of the region.
        self.id = id
        # The name of the region.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListAliyunRegionResponseBodyRegionEntityList(TeaModel):
    def __init__(
        self,
        region_entity: List[ListAliyunRegionResponseBodyRegionEntityListRegionEntity] = None,
    ):
        self.region_entity = region_entity

    def validate(self):
        if self.region_entity:
            for k in self.region_entity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RegionEntity'] = []
        if self.region_entity is not None:
            for k in self.region_entity:
                result['RegionEntity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.region_entity = []
        if m.get('RegionEntity') is not None:
            for k in m.get('RegionEntity'):
                temp_model = ListAliyunRegionResponseBodyRegionEntityListRegionEntity()
                self.region_entity.append(temp_model.from_map(k))
        return self


class ListAliyunRegionResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        region_entity_list: ListAliyunRegionResponseBodyRegionEntityList = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The details of the regions.
        self.region_entity_list = region_entity_list
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.region_entity_list:
            self.region_entity_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.region_entity_list is not None:
            result['RegionEntityList'] = self.region_entity_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RegionEntityList') is not None:
            temp_model = ListAliyunRegionResponseBodyRegionEntityList()
            self.region_entity_list = temp_model.from_map(m['RegionEntityList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAliyunRegionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAliyunRegionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAliyunRegionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListApplicationRequest(TeaModel):
    def __init__(
        self,
        app_ids: str = None,
        app_name: str = None,
        cluster_id: str = None,
        current_page: int = None,
        logical_region_id: str = None,
        logical_region_id_filter: str = None,
        page_size: int = None,
        resource_group_id: str = None,
    ):
        # The application IDs.
        self.app_ids = app_ids
        # The name of the application. Specify this parameter if you want to filter applications by application name.
        self.app_name = app_name
        # The cluster ID. Specify this parameter if you want to filter applications by cluster.
        self.cluster_id = cluster_id
        # The page number. Default value: 1.
        self.current_page = current_page
        # The namespace ID. Specify this parameter if you want to filter applications by namespace.
        self.logical_region_id = logical_region_id
        # The ID of the namespace that you use in the exact search to filter applications.
        self.logical_region_id_filter = logical_region_id_filter
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the resource group. Specify this parameter if you want to filter applications by resource group.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_ids is not None:
            result['AppIds'] = self.app_ids
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.logical_region_id is not None:
            result['LogicalRegionId'] = self.logical_region_id
        if self.logical_region_id_filter is not None:
            result['LogicalRegionIdFilter'] = self.logical_region_id_filter
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppIds') is not None:
            self.app_ids = m.get('AppIds')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('LogicalRegionId') is not None:
            self.logical_region_id = m.get('LogicalRegionId')
        if m.get('LogicalRegionIdFilter') is not None:
            self.logical_region_id_filter = m.get('LogicalRegionIdFilter')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListApplicationResponseBodyApplicationListApplication(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        application_type: str = None,
        build_package_id: int = None,
        cluster_id: str = None,
        cluster_type: int = None,
        create_time: int = None,
        ext_slb_ip: str = None,
        ext_slb_listener_port: int = None,
        instances: int = None,
        k_8s_namespace: str = None,
        name: str = None,
        namespace_id: str = None,
        port: int = None,
        region_id: str = None,
        resource_group_id: str = None,
        running_instance_count: int = None,
        slb_ip: str = None,
        slb_listener_port: int = None,
        slb_port: int = None,
        state: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The deployment type of the application. Valid values:
        # 
        # *   War: The application is deployed by using a WAR package.
        # *   FatJar: The application is deployed by using a JAR package.
        # *   Image: The application is deployed by using an image.
        # *   If this parameter is empty, the application is not deployed.
        self.application_type = application_type
        # The build package number of Enterprise Distributed Application Service (EDAS) Container.
        self.build_package_id = build_package_id
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The type of the cluster in which the application is deployed. Valid values:
        # 
        # *   **2**: Elastic Compute Service (ECS) cluster
        # *   **3**: self-managed Kubernetes cluster in EDAS
        # *   **5**: Container Service for Kubernetes (ACK) cluster
        self.cluster_type = cluster_type
        # The time when the application was created.
        self.create_time = create_time
        # The IP address of the Internet-facing SLB instance.
        self.ext_slb_ip = ext_slb_ip
        # The listener port of the Internet-facing SLB instance.
        self.ext_slb_listener_port = ext_slb_listener_port
        # The number of application instances.
        self.instances = instances
        # The namespace of the Kubernetes cluster.
        self.k_8s_namespace = k_8s_namespace
        # The name of the application.
        self.name = name
        # The ID of the microservices namespace.
        self.namespace_id = namespace_id
        # The service port of the application.
        self.port = port
        # The region ID of the application.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The number of running application instances.
        self.running_instance_count = running_instance_count
        # The IP address of the internal-facing Server Load Balancer (SLB) instance.
        self.slb_ip = slb_ip
        # The listener port of the internal-facing SLB instance.
        self.slb_listener_port = slb_listener_port
        # The port of the internal-facing SLB instance.
        self.slb_port = slb_port
        # The state of the application. Valid values:
        # 
        # *   RUNNING: The application is running.
        # *   STOPPED: The application is stopped.
        # *   DEPLOYING: The application is being deployed.
        # *   DELETING: The application is being deleted.
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.application_type is not None:
            result['ApplicationType'] = self.application_type
        if self.build_package_id is not None:
            result['BuildPackageId'] = self.build_package_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.ext_slb_ip is not None:
            result['ExtSlbIp'] = self.ext_slb_ip
        if self.ext_slb_listener_port is not None:
            result['ExtSlbListenerPort'] = self.ext_slb_listener_port
        if self.instances is not None:
            result['Instances'] = self.instances
        if self.k_8s_namespace is not None:
            result['K8sNamespace'] = self.k_8s_namespace
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.port is not None:
            result['Port'] = self.port
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.running_instance_count is not None:
            result['RunningInstanceCount'] = self.running_instance_count
        if self.slb_ip is not None:
            result['SlbIp'] = self.slb_ip
        if self.slb_listener_port is not None:
            result['SlbListenerPort'] = self.slb_listener_port
        if self.slb_port is not None:
            result['SlbPort'] = self.slb_port
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ApplicationType') is not None:
            self.application_type = m.get('ApplicationType')
        if m.get('BuildPackageId') is not None:
            self.build_package_id = m.get('BuildPackageId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('ExtSlbIp') is not None:
            self.ext_slb_ip = m.get('ExtSlbIp')
        if m.get('ExtSlbListenerPort') is not None:
            self.ext_slb_listener_port = m.get('ExtSlbListenerPort')
        if m.get('Instances') is not None:
            self.instances = m.get('Instances')
        if m.get('K8sNamespace') is not None:
            self.k_8s_namespace = m.get('K8sNamespace')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('RunningInstanceCount') is not None:
            self.running_instance_count = m.get('RunningInstanceCount')
        if m.get('SlbIp') is not None:
            self.slb_ip = m.get('SlbIp')
        if m.get('SlbListenerPort') is not None:
            self.slb_listener_port = m.get('SlbListenerPort')
        if m.get('SlbPort') is not None:
            self.slb_port = m.get('SlbPort')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListApplicationResponseBodyApplicationList(TeaModel):
    def __init__(
        self,
        application: List[ListApplicationResponseBodyApplicationListApplication] = None,
    ):
        self.application = application

    def validate(self):
        if self.application:
            for k in self.application:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Application'] = []
        if self.application is not None:
            for k in self.application:
                result['Application'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.application = []
        if m.get('Application') is not None:
            for k in m.get('Application'):
                temp_model = ListApplicationResponseBodyApplicationListApplication()
                self.application.append(temp_model.from_map(k))
        return self


class ListApplicationResponseBody(TeaModel):
    def __init__(
        self,
        application_list: ListApplicationResponseBodyApplicationList = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The information about applications.
        self.application_list = application_list
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.application_list:
            self.application_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_list is not None:
            result['ApplicationList'] = self.application_list.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationList') is not None:
            temp_model = ListApplicationResponseBodyApplicationList()
            self.application_list = temp_model.from_map(m['ApplicationList'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListApplicationEcuRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        logical_region_id: str = None,
    ):
        # The ID of the application whose ECUs you want to query. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        self.app_id = app_id
        # The ID of the microservices namespace.
        self.logical_region_id = logical_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.logical_region_id is not None:
            result['LogicalRegionId'] = self.logical_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('LogicalRegionId') is not None:
            self.logical_region_id = m.get('LogicalRegionId')
        return self


class ListApplicationEcuResponseBodyEcuInfoListEcuEntity(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        available_cpu: int = None,
        available_mem: int = None,
        cpu: int = None,
        create_time: int = None,
        docker_env: bool = None,
        ecu_id: str = None,
        heartbeat_time: int = None,
        instance_id: str = None,
        ip_addr: str = None,
        mem: int = None,
        name: str = None,
        online: bool = None,
        region_id: str = None,
        update_time: int = None,
        user_id: str = None,
        vpc_id: str = None,
        zone_id: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The number of available CPU cores.
        self.available_cpu = available_cpu
        # The size of available memory. Unit: MB.
        self.available_mem = available_mem
        # The total number of CPU cores.
        self.cpu = cpu
        # The time when the ECU was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # Indicates whether Docker is installed. Valid values:
        # 
        # *   true: Docker is installed.
        # *   false: Docker is not installed.
        self.docker_env = docker_env
        # The unique ID of the ECU. To query the ID, you can run the `dmidecode` command on the ECS instance that corresponds to the ECU.
        self.ecu_id = ecu_id
        # The time when the last heartbeat detection was performed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.heartbeat_time = heartbeat_time
        # The ID of the Elastic Compute Service (ECS) instance.
        self.instance_id = instance_id
        # The internal IP address allocated to the ECU.
        self.ip_addr = ip_addr
        # The total size of memory. Unit: MB.
        self.mem = mem
        # The name of the ECU.
        self.name = name
        # Indicates whether the ECU is online. Valid values:
        # 
        # *   true: The ECU is online.
        # *   false: The ECU is offline.
        self.online = online
        # The ID of the region.
        self.region_id = region_id
        # The time when the ECU was updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time
        # The ID of the Alibaba Cloud account to which the ECU belongs.
        self.user_id = user_id
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id
        # The ID of the zone.
        self.zone_id = zone_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.available_cpu is not None:
            result['AvailableCpu'] = self.available_cpu
        if self.available_mem is not None:
            result['AvailableMem'] = self.available_mem
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.docker_env is not None:
            result['DockerEnv'] = self.docker_env
        if self.ecu_id is not None:
            result['EcuId'] = self.ecu_id
        if self.heartbeat_time is not None:
            result['HeartbeatTime'] = self.heartbeat_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ip_addr is not None:
            result['IpAddr'] = self.ip_addr
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.name is not None:
            result['Name'] = self.name
        if self.online is not None:
            result['Online'] = self.online
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AvailableCpu') is not None:
            self.available_cpu = m.get('AvailableCpu')
        if m.get('AvailableMem') is not None:
            self.available_mem = m.get('AvailableMem')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DockerEnv') is not None:
            self.docker_env = m.get('DockerEnv')
        if m.get('EcuId') is not None:
            self.ecu_id = m.get('EcuId')
        if m.get('HeartbeatTime') is not None:
            self.heartbeat_time = m.get('HeartbeatTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IpAddr') is not None:
            self.ip_addr = m.get('IpAddr')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Online') is not None:
            self.online = m.get('Online')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class ListApplicationEcuResponseBodyEcuInfoList(TeaModel):
    def __init__(
        self,
        ecu_entity: List[ListApplicationEcuResponseBodyEcuInfoListEcuEntity] = None,
    ):
        self.ecu_entity = ecu_entity

    def validate(self):
        if self.ecu_entity:
            for k in self.ecu_entity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EcuEntity'] = []
        if self.ecu_entity is not None:
            for k in self.ecu_entity:
                result['EcuEntity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ecu_entity = []
        if m.get('EcuEntity') is not None:
            for k in m.get('EcuEntity'):
                temp_model = ListApplicationEcuResponseBodyEcuInfoListEcuEntity()
                self.ecu_entity.append(temp_model.from_map(k))
        return self


class ListApplicationEcuResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        ecu_info_list: ListApplicationEcuResponseBodyEcuInfoList = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The information about ECUs.
        self.ecu_info_list = ecu_info_list
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.ecu_info_list:
            self.ecu_info_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.ecu_info_list is not None:
            result['EcuInfoList'] = self.ecu_info_list.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EcuInfoList') is not None:
            temp_model = ListApplicationEcuResponseBodyEcuInfoList()
            self.ecu_info_list = temp_model.from_map(m['EcuInfoList'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListApplicationEcuResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListApplicationEcuResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListApplicationEcuResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAuthorityResponseBodyAuthorityListAuthorityActionListAction(TeaModel):
    def __init__(
        self,
        code: str = None,
        description: str = None,
        group_id: str = None,
        name: str = None,
    ):
        # The code of the permission.
        self.code = code
        # The description of the permission.
        self.description = description
        # The ID of the permission group.
        self.group_id = group_id
        # The name of the permission.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.description is not None:
            result['Description'] = self.description
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListAuthorityResponseBodyAuthorityListAuthorityActionList(TeaModel):
    def __init__(
        self,
        action: List[ListAuthorityResponseBodyAuthorityListAuthorityActionListAction] = None,
    ):
        self.action = action

    def validate(self):
        if self.action:
            for k in self.action:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Action'] = []
        if self.action is not None:
            for k in self.action:
                result['Action'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.action = []
        if m.get('Action') is not None:
            for k in m.get('Action'):
                temp_model = ListAuthorityResponseBodyAuthorityListAuthorityActionListAction()
                self.action.append(temp_model.from_map(k))
        return self


class ListAuthorityResponseBodyAuthorityListAuthority(TeaModel):
    def __init__(
        self,
        action_list: ListAuthorityResponseBodyAuthorityListAuthorityActionList = None,
        description: str = None,
        group_id: str = None,
        name: str = None,
    ):
        # The set of permissions.
        self.action_list = action_list
        # The description of the permission group.
        self.description = description
        # The ID of the permission group.
        self.group_id = group_id
        # The name of the permission group.
        self.name = name

    def validate(self):
        if self.action_list:
            self.action_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_list is not None:
            result['ActionList'] = self.action_list.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionList') is not None:
            temp_model = ListAuthorityResponseBodyAuthorityListAuthorityActionList()
            self.action_list = temp_model.from_map(m['ActionList'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListAuthorityResponseBodyAuthorityList(TeaModel):
    def __init__(
        self,
        authority: List[ListAuthorityResponseBodyAuthorityListAuthority] = None,
    ):
        self.authority = authority

    def validate(self):
        if self.authority:
            for k in self.authority:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Authority'] = []
        if self.authority is not None:
            for k in self.authority:
                result['Authority'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.authority = []
        if m.get('Authority') is not None:
            for k in m.get('Authority'):
                temp_model = ListAuthorityResponseBodyAuthorityListAuthority()
                self.authority.append(temp_model.from_map(k))
        return self


class ListAuthorityResponseBody(TeaModel):
    def __init__(
        self,
        authority_list: ListAuthorityResponseBodyAuthorityList = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The permissions.
        self.authority_list = authority_list
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.authority_list:
            self.authority_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authority_list is not None:
            result['AuthorityList'] = self.authority_list.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthorityList') is not None:
            temp_model = ListAuthorityResponseBodyAuthorityList()
            self.authority_list = temp_model.from_map(m['AuthorityList'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAuthorityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAuthorityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAuthorityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListBuildPackResponseBodyBuildPackListBuildPack(TeaModel):
    def __init__(
        self,
        config_id: int = None,
        disabled: bool = None,
        feature: str = None,
        image_id: str = None,
        multiple_tenant: bool = None,
        pack_version: str = None,
        pandora_desc: str = None,
        pandora_download_url: str = None,
        pandora_version: str = None,
        plugin_info: str = None,
        script_name: str = None,
        script_version: str = None,
        support_features: str = None,
        tengine_download_url: str = None,
        tengine_image_id: str = None,
        tomcat_desc: str = None,
        tomcat_download_url: str = None,
        tomcat_path: str = None,
        tomcat_version: str = None,
        with_tengine: bool = None,
    ):
        # The build package number of EDAS Container.
        self.config_id = config_id
        # Indicates whether the EDAS Container version is disabled. A disabled version cannot be configured for use.
        self.disabled = disabled
        # The features of the EDAS Container version, which are released for public preview.
        self.feature = feature
        # The ID of the base image that corresponds to EDAS Container.
        self.image_id = image_id
        # Indicates whether EDAS Container supports multitenancy.
        self.multiple_tenant = multiple_tenant
        # The version of the application.
        self.pack_version = pack_version
        # The description of the Pandora container.
        self.pandora_desc = pandora_desc
        # The download URL of the Pandora installer.
        self.pandora_download_url = pandora_download_url
        # The version of the Pandora container.
        self.pandora_version = pandora_version
        # The description of the plug-in.
        self.plugin_info = plugin_info
        # The name of the Shell script that runs EDAS Container.
        self.script_name = script_name
        # The version of the Shell script that runs EDAS Container.
        self.script_version = script_version
        # The features supported by EDAS Container.
        self.support_features = support_features
        # The download URL of the Tengine installer.
        self.tengine_download_url = tengine_download_url
        # The ID of the Tengine image that corresponds to EDAS Container.
        self.tengine_image_id = tengine_image_id
        # The description of the Tomcat container.
        self.tomcat_desc = tomcat_desc
        # The download URL of the Tomcat installer.
        self.tomcat_download_url = tomcat_download_url
        # The directory of the Tomcat container.
        self.tomcat_path = tomcat_path
        # The version of the Tomcat container.
        self.tomcat_version = tomcat_version
        # Indicates whether EDAS Container supports traffic management.
        self.with_tengine = with_tengine

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.feature is not None:
            result['Feature'] = self.feature
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.multiple_tenant is not None:
            result['MultipleTenant'] = self.multiple_tenant
        if self.pack_version is not None:
            result['PackVersion'] = self.pack_version
        if self.pandora_desc is not None:
            result['PandoraDesc'] = self.pandora_desc
        if self.pandora_download_url is not None:
            result['PandoraDownloadUrl'] = self.pandora_download_url
        if self.pandora_version is not None:
            result['PandoraVersion'] = self.pandora_version
        if self.plugin_info is not None:
            result['PluginInfo'] = self.plugin_info
        if self.script_name is not None:
            result['ScriptName'] = self.script_name
        if self.script_version is not None:
            result['ScriptVersion'] = self.script_version
        if self.support_features is not None:
            result['SupportFeatures'] = self.support_features
        if self.tengine_download_url is not None:
            result['TengineDownloadUrl'] = self.tengine_download_url
        if self.tengine_image_id is not None:
            result['TengineImageId'] = self.tengine_image_id
        if self.tomcat_desc is not None:
            result['TomcatDesc'] = self.tomcat_desc
        if self.tomcat_download_url is not None:
            result['TomcatDownloadUrl'] = self.tomcat_download_url
        if self.tomcat_path is not None:
            result['TomcatPath'] = self.tomcat_path
        if self.tomcat_version is not None:
            result['TomcatVersion'] = self.tomcat_version
        if self.with_tengine is not None:
            result['WithTengine'] = self.with_tengine
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('Feature') is not None:
            self.feature = m.get('Feature')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('MultipleTenant') is not None:
            self.multiple_tenant = m.get('MultipleTenant')
        if m.get('PackVersion') is not None:
            self.pack_version = m.get('PackVersion')
        if m.get('PandoraDesc') is not None:
            self.pandora_desc = m.get('PandoraDesc')
        if m.get('PandoraDownloadUrl') is not None:
            self.pandora_download_url = m.get('PandoraDownloadUrl')
        if m.get('PandoraVersion') is not None:
            self.pandora_version = m.get('PandoraVersion')
        if m.get('PluginInfo') is not None:
            self.plugin_info = m.get('PluginInfo')
        if m.get('ScriptName') is not None:
            self.script_name = m.get('ScriptName')
        if m.get('ScriptVersion') is not None:
            self.script_version = m.get('ScriptVersion')
        if m.get('SupportFeatures') is not None:
            self.support_features = m.get('SupportFeatures')
        if m.get('TengineDownloadUrl') is not None:
            self.tengine_download_url = m.get('TengineDownloadUrl')
        if m.get('TengineImageId') is not None:
            self.tengine_image_id = m.get('TengineImageId')
        if m.get('TomcatDesc') is not None:
            self.tomcat_desc = m.get('TomcatDesc')
        if m.get('TomcatDownloadUrl') is not None:
            self.tomcat_download_url = m.get('TomcatDownloadUrl')
        if m.get('TomcatPath') is not None:
            self.tomcat_path = m.get('TomcatPath')
        if m.get('TomcatVersion') is not None:
            self.tomcat_version = m.get('TomcatVersion')
        if m.get('WithTengine') is not None:
            self.with_tengine = m.get('WithTengine')
        return self


class ListBuildPackResponseBodyBuildPackList(TeaModel):
    def __init__(
        self,
        build_pack: List[ListBuildPackResponseBodyBuildPackListBuildPack] = None,
    ):
        self.build_pack = build_pack

    def validate(self):
        if self.build_pack:
            for k in self.build_pack:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BuildPack'] = []
        if self.build_pack is not None:
            for k in self.build_pack:
                result['BuildPack'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.build_pack = []
        if m.get('BuildPack') is not None:
            for k in m.get('BuildPack'):
                temp_model = ListBuildPackResponseBodyBuildPackListBuildPack()
                self.build_pack.append(temp_model.from_map(k))
        return self


class ListBuildPackResponseBody(TeaModel):
    def __init__(
        self,
        build_pack_list: ListBuildPackResponseBodyBuildPackList = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The returned versions of EDAS Container.
        self.build_pack_list = build_pack_list
        # code
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.build_pack_list:
            self.build_pack_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.build_pack_list is not None:
            result['BuildPackList'] = self.build_pack_list.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BuildPackList') is not None:
            temp_model = ListBuildPackResponseBodyBuildPackList()
            self.build_pack_list = temp_model.from_map(m['BuildPackList'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListBuildPackResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListBuildPackResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListBuildPackResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListClusterRequest(TeaModel):
    def __init__(
        self,
        logical_region_id: str = None,
        resource_group_id: str = None,
    ):
        # The ID of the namespace. You can call the ListUserDefineRegion operation to query the namespace ID. For more information, see [ListUserDefineRegion](https://help.aliyun.com/document_detail/149377.html).
        # 
        # *   If this parameter is left empty, the clusters in the default namespace are queried.
        # *   If this parameter is specified, the clusters in the specified namespace are queried.
        self.logical_region_id = logical_region_id
        # The ID of the resource group. You can call the ListResourceGroup operation to query the resource group ID. For more information, see [ListResourceGroup](https://help.aliyun.com/document_detail/62055.html).
        # 
        # *   If this parameter is left empty, the clusters in the default resource group are queried.
        # *   If this parameter is specified, the clusters in the specified resource group are queried.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logical_region_id is not None:
            result['LogicalRegionId'] = self.logical_region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LogicalRegionId') is not None:
            self.logical_region_id = m.get('LogicalRegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListClusterResponseBodyClusterListCluster(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_name: str = None,
        cluster_type: int = None,
        cpu: int = None,
        cpu_used: int = None,
        create_time: int = None,
        cs_cluster_id: str = None,
        description: str = None,
        iaas_provider: str = None,
        mem: int = None,
        mem_used: int = None,
        network_mode: int = None,
        node_num: int = None,
        oversold_factor: int = None,
        region_id: str = None,
        resource_group_id: str = None,
        update_time: int = None,
        vpc_id: str = None,
    ):
        # The ID of the cluster in EDAS.
        self.cluster_id = cluster_id
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The type of the cluster. Valid values:
        # 
        # *   0: regular Docker cluster
        # *   1: Swarm cluster
        # *   2: Elastic Compute Service (ECS) cluster
        # *   3: self-managed Kubernetes cluster in Enterprise Distributed Application Service (EDAS)
        # *   4: cluster in which Pandora automatically registers applications
        # *   5: ACK cluster
        self.cluster_type = cluster_type
        # The total number of CPU cores.
        self.cpu = cpu
        # The number of used CPU cores.
        self.cpu_used = cpu_used
        # The timestamp when the cluster was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The ID of the cluster in Container Service for Kubernetes (ACK).
        self.cs_cluster_id = cs_cluster_id
        # The description of the cluster.
        self.description = description
        # The provider of the cluster.
        self.iaas_provider = iaas_provider
        # The total size of memory. Unit: MB.
        self.mem = mem
        # The size of used memory. Unit: MB.
        self.mem_used = mem_used
        # The network type of the cluster. Valid values:
        # 
        # *   1: classic network
        # *   2: virtual private cloud (VPC)
        self.network_mode = network_mode
        # The number of instances.
        self.node_num = node_num
        # The CPU overcommit ratio that is supported by a Docker cluster. Valid values:
        # 
        # *   1: 1:1, which means that CPU resources are not overcommitted.
        # *   2: 1:2, which means that CPU resources are overcommitted by 1:2.
        # *   4: 1:4, which means that CPU resources are overcommitted by 1:4.
        # *   8: 1:8, which means that CPU resources are overcommitted by 1:8.
        self.oversold_factor = oversold_factor
        # The ID of the region.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The timestamp when the cluster was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time
        # VPC ID
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.cpu_used is not None:
            result['CpuUsed'] = self.cpu_used
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.cs_cluster_id is not None:
            result['CsClusterId'] = self.cs_cluster_id
        if self.description is not None:
            result['Description'] = self.description
        if self.iaas_provider is not None:
            result['IaasProvider'] = self.iaas_provider
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.mem_used is not None:
            result['MemUsed'] = self.mem_used
        if self.network_mode is not None:
            result['NetworkMode'] = self.network_mode
        if self.node_num is not None:
            result['NodeNum'] = self.node_num
        if self.oversold_factor is not None:
            result['OversoldFactor'] = self.oversold_factor
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CpuUsed') is not None:
            self.cpu_used = m.get('CpuUsed')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CsClusterId') is not None:
            self.cs_cluster_id = m.get('CsClusterId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IaasProvider') is not None:
            self.iaas_provider = m.get('IaasProvider')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('MemUsed') is not None:
            self.mem_used = m.get('MemUsed')
        if m.get('NetworkMode') is not None:
            self.network_mode = m.get('NetworkMode')
        if m.get('NodeNum') is not None:
            self.node_num = m.get('NodeNum')
        if m.get('OversoldFactor') is not None:
            self.oversold_factor = m.get('OversoldFactor')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class ListClusterResponseBodyClusterList(TeaModel):
    def __init__(
        self,
        cluster: List[ListClusterResponseBodyClusterListCluster] = None,
    ):
        self.cluster = cluster

    def validate(self):
        if self.cluster:
            for k in self.cluster:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Cluster'] = []
        if self.cluster is not None:
            for k in self.cluster:
                result['Cluster'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cluster = []
        if m.get('Cluster') is not None:
            for k in m.get('Cluster'):
                temp_model = ListClusterResponseBodyClusterListCluster()
                self.cluster.append(temp_model.from_map(k))
        return self


class ListClusterResponseBody(TeaModel):
    def __init__(
        self,
        cluster_list: ListClusterResponseBodyClusterList = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The clusters.
        self.cluster_list = cluster_list
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.cluster_list:
            self.cluster_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_list is not None:
            result['ClusterList'] = self.cluster_list.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterList') is not None:
            temp_model = ListClusterResponseBodyClusterList()
            self.cluster_list = temp_model.from_map(m['ClusterList'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListClusterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListClusterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListClusterMembersRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        current_page: int = None,
        ecs_list: str = None,
        page_size: int = None,
    ):
        # The ID of the cluster. You can call the ListCluster operation to query the cluster ID. For more information, see [ListCluster](https://help.aliyun.com/document_detail/154995.html).
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The number of the page to return. If you do not specify this parameter, the first page is returned.
        self.current_page = current_page
        # The number of ECS instances.
        self.ecs_list = ecs_list
        # The number of ECS instances to return on each page. If you do not specify this parameter, all ECS instances in the specified cluster are returned on one page.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.ecs_list is not None:
            result['EcsList'] = self.ecs_list
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('EcsList') is not None:
            self.ecs_list = m.get('EcsList')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_member_id: str = None,
        create_time: int = None,
        ecs_id: str = None,
        ecu_id: str = None,
        private_ip: str = None,
        status: int = None,
        update_time: int = None,
    ):
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The ID of the ECS instance in the cluster.
        self.cluster_member_id = cluster_member_id
        # The timestamp when the ECS instance was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The ID of the ECS instance.
        self.ecs_id = ecs_id
        # The unique ID of the elastic compute unit (ECU). You can run the `dmidecode` command on the ECS instance to query the ECU ID.
        self.ecu_id = ecu_id
        # The private IP address for the ECS instance.
        self.private_ip = private_ip
        # The state of the ECS instance. Valid values:
        # 
        # *   1: The instance is running.
        # *   0: The instance is being converted.
        # *   \\-1: The instance fails to be converted.
        # *   \\-2: The instance is offline.
        self.status = status
        # The timestamp when the ECS instance was updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_member_id is not None:
            result['ClusterMemberId'] = self.cluster_member_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.ecs_id is not None:
            result['EcsId'] = self.ecs_id
        if self.ecu_id is not None:
            result['EcuId'] = self.ecu_id
        if self.private_ip is not None:
            result['PrivateIp'] = self.private_ip
        if self.status is not None:
            result['Status'] = self.status
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterMemberId') is not None:
            self.cluster_member_id = m.get('ClusterMemberId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('EcsId') is not None:
            self.ecs_id = m.get('EcsId')
        if m.get('EcuId') is not None:
            self.ecu_id = m.get('EcuId')
        if m.get('PrivateIp') is not None:
            self.private_ip = m.get('PrivateIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class ListClusterMembersResponseBodyClusterMemberPageClusterMemberList(TeaModel):
    def __init__(
        self,
        cluster_member: List[ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember] = None,
    ):
        self.cluster_member = cluster_member

    def validate(self):
        if self.cluster_member:
            for k in self.cluster_member:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ClusterMember'] = []
        if self.cluster_member is not None:
            for k in self.cluster_member:
                result['ClusterMember'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cluster_member = []
        if m.get('ClusterMember') is not None:
            for k in m.get('ClusterMember'):
                temp_model = ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember()
                self.cluster_member.append(temp_model.from_map(k))
        return self


class ListClusterMembersResponseBodyClusterMemberPage(TeaModel):
    def __init__(
        self,
        cluster_member_list: ListClusterMembersResponseBodyClusterMemberPageClusterMemberList = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The list of ECS instances in the cluster.
        self.cluster_member_list = cluster_member_list
        # The page number of the returned page. If this parameter is not returned, the first page is returned.
        self.current_page = current_page
        # The number of ECS instances returned per page.
        self.page_size = page_size
        # The total number of pages returned when all ECS instances are returned based on the specified PageSize parameter.
        self.total_size = total_size

    def validate(self):
        if self.cluster_member_list:
            self.cluster_member_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_member_list is not None:
            result['ClusterMemberList'] = self.cluster_member_list.to_map()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterMemberList') is not None:
            temp_model = ListClusterMembersResponseBodyClusterMemberPageClusterMemberList()
            self.cluster_member_list = temp_model.from_map(m['ClusterMemberList'])
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListClusterMembersResponseBody(TeaModel):
    def __init__(
        self,
        cluster_member_page: ListClusterMembersResponseBodyClusterMemberPage = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The information about the ECS instances in the cluster.
        self.cluster_member_page = cluster_member_page
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.cluster_member_page:
            self.cluster_member_page.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_member_page is not None:
            result['ClusterMemberPage'] = self.cluster_member_page.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterMemberPage') is not None:
            temp_model = ListClusterMembersResponseBodyClusterMemberPage()
            self.cluster_member_page = temp_model.from_map(m['ClusterMemberPage'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListClusterMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListClusterMembersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListClusterMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListComponentsResponseBodyComponentListComponent(TeaModel):
    def __init__(
        self,
        component_id: str = None,
        component_key: str = None,
        desc: str = None,
        expired: bool = None,
        type: str = None,
        version: str = None,
    ):
        # The ID of the component.
        self.component_id = component_id
        # The key of the component.
        self.component_key = component_key
        # The description of the component.
        self.desc = desc
        # Indicates whether the component has expired. Valid values:
        # 
        # *   false: The component has not expired.
        # *   true: The component has expired.
        self.expired = expired
        # The type of the component. Valid values:
        # 
        # *   JDK
        # *   TOMCAT
        # *   TENGINE
        self.type = type
        # The version of the component.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.component_id is not None:
            result['ComponentId'] = self.component_id
        if self.component_key is not None:
            result['ComponentKey'] = self.component_key
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.expired is not None:
            result['Expired'] = self.expired
        if self.type is not None:
            result['Type'] = self.type
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComponentId') is not None:
            self.component_id = m.get('ComponentId')
        if m.get('ComponentKey') is not None:
            self.component_key = m.get('ComponentKey')
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('Expired') is not None:
            self.expired = m.get('Expired')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListComponentsResponseBodyComponentList(TeaModel):
    def __init__(
        self,
        component: List[ListComponentsResponseBodyComponentListComponent] = None,
    ):
        self.component = component

    def validate(self):
        if self.component:
            for k in self.component:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Component'] = []
        if self.component is not None:
            for k in self.component:
                result['Component'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.component = []
        if m.get('Component') is not None:
            for k in m.get('Component'):
                temp_model = ListComponentsResponseBodyComponentListComponent()
                self.component.append(temp_model.from_map(k))
        return self


class ListComponentsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        component_list: ListComponentsResponseBodyComponentList = None,
        message: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The components.
        self.component_list = component_list
        # The message that is returned.
        self.message = message

    def validate(self):
        if self.component_list:
            self.component_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.component_list is not None:
            result['ComponentList'] = self.component_list.to_map()
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ComponentList') is not None:
            temp_model = ListComponentsResponseBodyComponentList()
            self.component_list = temp_model.from_map(m['ComponentList'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class ListComponentsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListComponentsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListComponentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListConfigTemplatesRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        id: int = None,
        name: str = None,
        page_size: int = None,
    ):
        # The number of the page to return. Pages start from Page 1.
        self.current_page = current_page
        # The ID of the configuration template.
        self.id = id
        # The name of the configuration template.
        self.name = name
        # The number of entries to return on each page.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListConfigTemplatesResponseBodyDataResult(TeaModel):
    def __init__(
        self,
        content: str = None,
        description: str = None,
        format: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: str = None,
        name: str = None,
    ):
        # The content of the configuration template.
        self.content = content
        # The description of the configuration template.
        self.description = description
        # The data format of the configuration template.
        self.format = format
        # The time when the configuration template was created.
        self.gmt_create = gmt_create
        # The time when the configuration template was updated.
        self.gmt_modified = gmt_modified
        # The ID of the configuration template.
        self.id = id
        # The name of the configuration template.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.description is not None:
            result['Description'] = self.description
        if self.format is not None:
            result['Format'] = self.format
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListConfigTemplatesResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        result: List[ListConfigTemplatesResponseBodyDataResult] = None,
        total_size: int = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The configuration templates.
        self.result = result
        # The total number of configuration templates.
        self.total_size = total_size

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Result'] = []
        if self.result is not None:
            for k in self.result:
                result['Result'].append(k.to_map() if k else None)
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.result = []
        if m.get('Result') is not None:
            for k in m.get('Result'):
                temp_model = ListConfigTemplatesResponseBodyDataResult()
                self.result.append(temp_model.from_map(k))
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListConfigTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: ListConfigTemplatesResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The result of the request.
        self.data = data
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListConfigTemplatesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListConfigTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListConfigTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListConfigTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListConsumedServicesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups(TeaModel):
    def __init__(
        self,
        group: List[str] = None,
    ):
        self.group = group

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group is not None:
            result['group'] = self.group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('group') is not None:
            self.group = m.get('group')
        return self


class ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps(TeaModel):
    def __init__(
        self,
        ip: List[str] = None,
    ):
        self.ip = ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['ip'] = self.ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        return self


class ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        docker_application: bool = None,
        group_2ip: str = None,
        groups: ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups = None,
        ips: ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps = None,
        name: str = None,
        type: str = None,
        version: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # Indicates whether the application runs in a Docker container. Valid values:
        # 
        # *   true: The application runs in a Docker container.
        # *   false: The application does not run in a Docker container.
        self.docker_application = docker_application
        # A reserved parameter.
        self.group_2ip = group_2ip
        self.groups = groups
        self.ips = ips
        # The name of the consumed service.
        self.name = name
        # The type of the consumed service.
        self.type = type
        # The version of the consumed service.
        self.version = version

    def validate(self):
        if self.groups:
            self.groups.validate()
        if self.ips:
            self.ips.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.docker_application is not None:
            result['DockerApplication'] = self.docker_application
        if self.group_2ip is not None:
            result['Group2Ip'] = self.group_2ip
        if self.groups is not None:
            result['Groups'] = self.groups.to_map()
        if self.ips is not None:
            result['Ips'] = self.ips.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DockerApplication') is not None:
            self.docker_application = m.get('DockerApplication')
        if m.get('Group2Ip') is not None:
            self.group_2ip = m.get('Group2Ip')
        if m.get('Groups') is not None:
            temp_model = ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups()
            self.groups = temp_model.from_map(m['Groups'])
        if m.get('Ips') is not None:
            temp_model = ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps()
            self.ips = temp_model.from_map(m['Ips'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListConsumedServicesResponseBodyConsumedServicesList(TeaModel):
    def __init__(
        self,
        list_consumed_services: List[ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices] = None,
    ):
        self.list_consumed_services = list_consumed_services

    def validate(self):
        if self.list_consumed_services:
            for k in self.list_consumed_services:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ListConsumedServices'] = []
        if self.list_consumed_services is not None:
            for k in self.list_consumed_services:
                result['ListConsumedServices'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list_consumed_services = []
        if m.get('ListConsumedServices') is not None:
            for k in m.get('ListConsumedServices'):
                temp_model = ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices()
                self.list_consumed_services.append(temp_model.from_map(k))
        return self


class ListConsumedServicesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        consumed_services_list: ListConsumedServicesResponseBodyConsumedServicesList = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The information about consumed services.
        self.consumed_services_list = consumed_services_list
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.consumed_services_list:
            self.consumed_services_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.consumed_services_list is not None:
            result['ConsumedServicesList'] = self.consumed_services_list.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ConsumedServicesList') is not None:
            temp_model = ListConsumedServicesResponseBodyConsumedServicesList()
            self.consumed_services_list = temp_model.from_map(m['ConsumedServicesList'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListConsumedServicesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListConsumedServicesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListConsumedServicesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListConvertableEcuRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
    ):
        # The ID of the cluster. You can call the ListCluster operation to query the cluster ID. For more information, see [ListCluster](https://help.aliyun.com/document_detail/154995.html).
        # 
        # This parameter is required.
        self.cluster_id = cluster_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['clusterId'] = self.cluster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clusterId') is not None:
            self.cluster_id = m.get('clusterId')
        return self


class ListConvertableEcuResponseBodyInstanceListInstance(TeaModel):
    def __init__(
        self,
        cpu: int = None,
        ecu_id: str = None,
        eip: str = None,
        expired: bool = None,
        inner_ip: str = None,
        instance_id: str = None,
        instance_name: str = None,
        mem: int = None,
        private_ip: str = None,
        public_ip: str = None,
        region_id: str = None,
        status: str = None,
        vpc_id: str = None,
        vpc_name: str = None,
    ):
        # The number of CPU cores of the ECS instance.
        self.cpu = cpu
        # The ID of the elastic compute units (ECU).
        self.ecu_id = ecu_id
        # The elastic IP address (EIP) associated with the ECS instance. The EIP can be changed.
        self.eip = eip
        # Indicates whether the ECS instance has expired.
        self.expired = expired
        # The private IP address of the ECS instance. This parameter is valid only when the ECS instance is deployed in a VPC.
        self.inner_ip = inner_ip
        # The ID of the ECS instance.
        self.instance_id = instance_id
        # The name of the ECS instance.
        self.instance_name = instance_name
        # The size of memory for the ECS instance.
        self.mem = mem
        # The private IP address of the ECS instance. This parameter is valid only when the ECS instance is deployed in a VPC.
        self.private_ip = private_ip
        # The public IP address of the ECS instance. This IP address can be used only by the ECS instance.
        self.public_ip = public_ip
        # The ID of the region where the ECS instance is located.
        self.region_id = region_id
        # The state of the instance. Valid values:
        # 
        # *   Pending: The instance is being created.
        # *   Running: The instance is running.
        # *   Starting: The instance is being started.
        # *   Stopping: The instance is being stopped.
        # *   Stopped: The instance is stopped.
        self.status = status
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id
        # The name of the VPC.
        self.vpc_name = vpc_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.ecu_id is not None:
            result['EcuId'] = self.ecu_id
        if self.eip is not None:
            result['Eip'] = self.eip
        if self.expired is not None:
            result['Expired'] = self.expired
        if self.inner_ip is not None:
            result['InnerIp'] = self.inner_ip
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.private_ip is not None:
            result['PrivateIp'] = self.private_ip
        if self.public_ip is not None:
            result['PublicIp'] = self.public_ip
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vpc_name is not None:
            result['VpcName'] = self.vpc_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('EcuId') is not None:
            self.ecu_id = m.get('EcuId')
        if m.get('Eip') is not None:
            self.eip = m.get('Eip')
        if m.get('Expired') is not None:
            self.expired = m.get('Expired')
        if m.get('InnerIp') is not None:
            self.inner_ip = m.get('InnerIp')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('PrivateIp') is not None:
            self.private_ip = m.get('PrivateIp')
        if m.get('PublicIp') is not None:
            self.public_ip = m.get('PublicIp')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VpcName') is not None:
            self.vpc_name = m.get('VpcName')
        return self


class ListConvertableEcuResponseBodyInstanceList(TeaModel):
    def __init__(
        self,
        instance: List[ListConvertableEcuResponseBodyInstanceListInstance] = None,
    ):
        self.instance = instance

    def validate(self):
        if self.instance:
            for k in self.instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instance'] = []
        if self.instance is not None:
            for k in self.instance:
                result['Instance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance = []
        if m.get('Instance') is not None:
            for k in m.get('Instance'):
                temp_model = ListConvertableEcuResponseBodyInstanceListInstance()
                self.instance.append(temp_model.from_map(k))
        return self


class ListConvertableEcuResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        instance_list: ListConvertableEcuResponseBodyInstanceList = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The ECS instances that can be imported to the cluster.
        self.instance_list = instance_list
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.instance_list:
            self.instance_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.instance_list is not None:
            result['InstanceList'] = self.instance_list.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('InstanceList') is not None:
            temp_model = ListConvertableEcuResponseBodyInstanceList()
            self.instance_list = temp_model.from_map(m['InstanceList'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListConvertableEcuResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListConvertableEcuResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListConvertableEcuResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDeployGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class ListDeployGroupResponseBodyDeployGroupListDeployGroup(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_version_id: str = None,
        base_component_meta_name: str = None,
        cluster_id: str = None,
        cluster_name: str = None,
        cpu_limit: str = None,
        cpu_request: str = None,
        create_time: int = None,
        cs_cluster_id: str = None,
        deployment_name: str = None,
        env: str = None,
        ephemeral_storage_limit: str = None,
        ephemeral_storage_request: str = None,
        group_id: str = None,
        group_name: str = None,
        group_type: int = None,
        labels: str = None,
        last_update_time: int = None,
        memory_limit: str = None,
        memory_request: str = None,
        name_space: str = None,
        package_public_url: str = None,
        package_url: str = None,
        package_version: str = None,
        package_version_id: str = None,
        post_start: str = None,
        pre_stop: str = None,
        reversion: str = None,
        selector: str = None,
        status: str = None,
        strategy: str = None,
        update_time: int = None,
        vext_server_group_id: str = None,
        vserver_group_id: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The ID of the change process for application deployment in the instance group.
        self.app_version_id = app_version_id
        # The name of the basic component.
        self.base_component_meta_name = base_component_meta_name
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The maximum number of CPU cores allowed for each application instance when the application is running.
        self.cpu_limit = cpu_limit
        # The number of CPU cores requested for each application instance when the application is running. Unit: cores. Value 0 indicates that no limit is set on CPU cores.
        self.cpu_request = cpu_request
        # The time when the application was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The ID of the Container Service for Kubernetes (ACK) cluster.
        self.cs_cluster_id = cs_cluster_id
        # The name of the deployment.
        self.deployment_name = deployment_name
        # The ID of the ACK cluster.
        self.env = env
        # The maximum size of space required by ephemeral storage. Unit: GB. Value 0 indicates that no limit is set on the space size.
        self.ephemeral_storage_limit = ephemeral_storage_limit
        # The minimum size of space required by ephemeral storage. Unit: GB. Value 0 indicates that no limit is set on the space size.
        self.ephemeral_storage_request = ephemeral_storage_request
        # The ID of the instance group.
        self.group_id = group_id
        # The name of the instance group.
        self.group_name = group_name
        # The type of the instance group. Valid values:
        # 
        # *   0: default group.
        # *   1: Canary release is disabled for traffic management.
        # *   2: Canary release is enabled for traffic management.
        self.group_type = group_type
        # The tag.
        self.labels = labels
        # The time when the application was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.last_update_time = last_update_time
        # The maximum size of memory allowed for each application instance when the application is running. Unit: MB. Value 0 indicates that no limit is set on the memory size.
        self.memory_limit = memory_limit
        # The size of memory requested for each application instance when the application is running. Unit: MB. Value 0 indicates that no limit is set on the memory size.
        self.memory_request = memory_request
        # The namespace.
        self.name_space = name_space
        # The external download URL of the deployment package.
        self.package_public_url = package_public_url
        # The URL of the deployment package.
        self.package_url = package_url
        # The version of the deployment package.
        self.package_version = package_version
        # The version of the deployment package that was used to deploy an application in the instance group.
        self.package_version_id = package_version_id
        # The post-start script.
        self.post_start = post_start
        # The pre-stop script.
        self.pre_stop = pre_stop
        # The version of the application. The value progressively increases in the range of 0 to 7.
        self.reversion = reversion
        # The ID of the application deployed in the ACK cluster in Enterprise Distributed Application Service (EDAS).
        self.selector = selector
        # The state of the application instance group. Valid values:
        # 
        # *   0: ready
        # *   1: in progress
        # *   2: successful
        # *   3: failed
        # *   6: terminated
        # *   10: failed due to a system exception
        self.status = status
        # The throttling policy. This parameter is reserved.
        self.strategy = strategy
        # The time when the application was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time
        # The ID of the vServer group of the Internet-facing SLB instance associated with the instance group.
        self.vext_server_group_id = vext_server_group_id
        # The ID of the vServer group of the internal-facing Server Load Balancer (SLB) instance associated with the instance group.
        self.vserver_group_id = vserver_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_version_id is not None:
            result['AppVersionId'] = self.app_version_id
        if self.base_component_meta_name is not None:
            result['BaseComponentMetaName'] = self.base_component_meta_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cpu_limit is not None:
            result['CpuLimit'] = self.cpu_limit
        if self.cpu_request is not None:
            result['CpuRequest'] = self.cpu_request
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.cs_cluster_id is not None:
            result['CsClusterId'] = self.cs_cluster_id
        if self.deployment_name is not None:
            result['DeploymentName'] = self.deployment_name
        if self.env is not None:
            result['Env'] = self.env
        if self.ephemeral_storage_limit is not None:
            result['EphemeralStorageLimit'] = self.ephemeral_storage_limit
        if self.ephemeral_storage_request is not None:
            result['EphemeralStorageRequest'] = self.ephemeral_storage_request
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.last_update_time is not None:
            result['LastUpdateTime'] = self.last_update_time
        if self.memory_limit is not None:
            result['MemoryLimit'] = self.memory_limit
        if self.memory_request is not None:
            result['MemoryRequest'] = self.memory_request
        if self.name_space is not None:
            result['NameSpace'] = self.name_space
        if self.package_public_url is not None:
            result['PackagePublicUrl'] = self.package_public_url
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.package_version_id is not None:
            result['PackageVersionId'] = self.package_version_id
        if self.post_start is not None:
            result['PostStart'] = self.post_start
        if self.pre_stop is not None:
            result['PreStop'] = self.pre_stop
        if self.reversion is not None:
            result['Reversion'] = self.reversion
        if self.selector is not None:
            result['Selector'] = self.selector
        if self.status is not None:
            result['Status'] = self.status
        if self.strategy is not None:
            result['Strategy'] = self.strategy
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.vext_server_group_id is not None:
            result['VExtServerGroupId'] = self.vext_server_group_id
        if self.vserver_group_id is not None:
            result['VServerGroupId'] = self.vserver_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppVersionId') is not None:
            self.app_version_id = m.get('AppVersionId')
        if m.get('BaseComponentMetaName') is not None:
            self.base_component_meta_name = m.get('BaseComponentMetaName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('CpuLimit') is not None:
            self.cpu_limit = m.get('CpuLimit')
        if m.get('CpuRequest') is not None:
            self.cpu_request = m.get('CpuRequest')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CsClusterId') is not None:
            self.cs_cluster_id = m.get('CsClusterId')
        if m.get('DeploymentName') is not None:
            self.deployment_name = m.get('DeploymentName')
        if m.get('Env') is not None:
            self.env = m.get('Env')
        if m.get('EphemeralStorageLimit') is not None:
            self.ephemeral_storage_limit = m.get('EphemeralStorageLimit')
        if m.get('EphemeralStorageRequest') is not None:
            self.ephemeral_storage_request = m.get('EphemeralStorageRequest')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('LastUpdateTime') is not None:
            self.last_update_time = m.get('LastUpdateTime')
        if m.get('MemoryLimit') is not None:
            self.memory_limit = m.get('MemoryLimit')
        if m.get('MemoryRequest') is not None:
            self.memory_request = m.get('MemoryRequest')
        if m.get('NameSpace') is not None:
            self.name_space = m.get('NameSpace')
        if m.get('PackagePublicUrl') is not None:
            self.package_public_url = m.get('PackagePublicUrl')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('PackageVersionId') is not None:
            self.package_version_id = m.get('PackageVersionId')
        if m.get('PostStart') is not None:
            self.post_start = m.get('PostStart')
        if m.get('PreStop') is not None:
            self.pre_stop = m.get('PreStop')
        if m.get('Reversion') is not None:
            self.reversion = m.get('Reversion')
        if m.get('Selector') is not None:
            self.selector = m.get('Selector')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Strategy') is not None:
            self.strategy = m.get('Strategy')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('VExtServerGroupId') is not None:
            self.vext_server_group_id = m.get('VExtServerGroupId')
        if m.get('VServerGroupId') is not None:
            self.vserver_group_id = m.get('VServerGroupId')
        return self


class ListDeployGroupResponseBodyDeployGroupList(TeaModel):
    def __init__(
        self,
        deploy_group: List[ListDeployGroupResponseBodyDeployGroupListDeployGroup] = None,
    ):
        self.deploy_group = deploy_group

    def validate(self):
        if self.deploy_group:
            for k in self.deploy_group:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeployGroup'] = []
        if self.deploy_group is not None:
            for k in self.deploy_group:
                result['DeployGroup'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.deploy_group = []
        if m.get('DeployGroup') is not None:
            for k in m.get('DeployGroup'):
                temp_model = ListDeployGroupResponseBodyDeployGroupListDeployGroup()
                self.deploy_group.append(temp_model.from_map(k))
        return self


class ListDeployGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        deploy_group_list: ListDeployGroupResponseBodyDeployGroupList = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The information about the instance group in which the application is deployed.
        self.deploy_group_list = deploy_group_list
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.deploy_group_list:
            self.deploy_group_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.deploy_group_list is not None:
            result['DeployGroupList'] = self.deploy_group_list.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DeployGroupList') is not None:
            temp_model = ListDeployGroupResponseBodyDeployGroupList()
            self.deploy_group_list = temp_model.from_map(m['DeployGroupList'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDeployGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDeployGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDeployGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEcsNotInClusterRequest(TeaModel):
    def __init__(
        self,
        network_mode: int = None,
        vpc_id: str = None,
    ):
        # The network type. Valid values:
        # 
        # *   1: classic network
        # *   2: virtual private cloud (VPC)
        # 
        # This parameter is required.
        self.network_mode = network_mode
        # The ID of the VPC. This parameter is required if the NetworkMode parameter is set to 2.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_mode is not None:
            result['NetworkMode'] = self.network_mode
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkMode') is not None:
            self.network_mode = m.get('NetworkMode')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity(TeaModel):
    def __init__(
        self,
        cpu: int = None,
        eip: str = None,
        expired: bool = None,
        inner_ip: str = None,
        instance_id: str = None,
        instance_name: str = None,
        mem: int = None,
        private_ip: str = None,
        public_ip: str = None,
        region_id: str = None,
        status: str = None,
        vpc_id: str = None,
        vpc_name: str = None,
    ):
        # The number of CPU cores.
        self.cpu = cpu
        # The elastic IP address (EIP) associated with the ECS instance.
        self.eip = eip
        # Indicates whether the ECS instance has expired. Valid values:
        # 
        # *   **true**: The ECS instance has expired.
        # *   **false**: The ECS instance has not expired.
        self.expired = expired
        # The private IP address of the ECS instance.
        self.inner_ip = inner_ip
        # The ID of the ECS instance.
        self.instance_id = instance_id
        # The name of the ECS instance.
        self.instance_name = instance_name
        # The size of memory. Unit: bytes.
        self.mem = mem
        # The private IP address of the ECS instance.
        self.private_ip = private_ip
        # The public IP address of the ECS instance.
        self.public_ip = public_ip
        # The ID of the region where the ECS instance is located.
        self.region_id = region_id
        # The status of the ECS instance. Valid values:
        # 
        # *   **Pending**: The ECS instance is being created.
        # *   **Running**: The ECS instance is running.
        # *   **Starting**: The ECS instance is being started.
        # *   **Stopping**: The ECS instance is being stopped.
        # *   **Stopped**: The ECS instance is stopped.
        self.status = status
        # The ID of the VPC.
        self.vpc_id = vpc_id
        # The name of the VPC.
        self.vpc_name = vpc_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.eip is not None:
            result['Eip'] = self.eip
        if self.expired is not None:
            result['Expired'] = self.expired
        if self.inner_ip is not None:
            result['InnerIp'] = self.inner_ip
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.private_ip is not None:
            result['PrivateIp'] = self.private_ip
        if self.public_ip is not None:
            result['PublicIp'] = self.public_ip
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vpc_name is not None:
            result['VpcName'] = self.vpc_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Eip') is not None:
            self.eip = m.get('Eip')
        if m.get('Expired') is not None:
            self.expired = m.get('Expired')
        if m.get('InnerIp') is not None:
            self.inner_ip = m.get('InnerIp')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('PrivateIp') is not None:
            self.private_ip = m.get('PrivateIp')
        if m.get('PublicIp') is not None:
            self.public_ip = m.get('PublicIp')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VpcName') is not None:
            self.vpc_name = m.get('VpcName')
        return self


class ListEcsNotInClusterResponseBodyEcsEntityList(TeaModel):
    def __init__(
        self,
        ecs_entity: List[ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity] = None,
    ):
        self.ecs_entity = ecs_entity

    def validate(self):
        if self.ecs_entity:
            for k in self.ecs_entity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EcsEntity'] = []
        if self.ecs_entity is not None:
            for k in self.ecs_entity:
                result['EcsEntity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ecs_entity = []
        if m.get('EcsEntity') is not None:
            for k in m.get('EcsEntity'):
                temp_model = ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity()
                self.ecs_entity.append(temp_model.from_map(k))
        return self


class ListEcsNotInClusterResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        ecs_entity_list: ListEcsNotInClusterResponseBodyEcsEntityList = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The information about ECS instances.
        self.ecs_entity_list = ecs_entity_list
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.ecs_entity_list:
            self.ecs_entity_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.ecs_entity_list is not None:
            result['EcsEntityList'] = self.ecs_entity_list.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EcsEntityList') is not None:
            temp_model = ListEcsNotInClusterResponseBodyEcsEntityList()
            self.ecs_entity_list = temp_model.from_map(m['EcsEntityList'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListEcsNotInClusterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEcsNotInClusterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEcsNotInClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEcuByRegionRequest(TeaModel):
    def __init__(
        self,
        act: str = None,
        logical_region_id: str = None,
    ):
        # Set the value to `pop-query`.
        # 
        # This parameter is required.
        self.act = act
        # The ID of the namespace.
        # 
        # *   The ID of a custom namespace is in the `region ID:namespace identifier` format. Example: cn-beijing:tdy218.
        # *   The ID of the default namespace is in the `region ID` format. Example: cn-beijing.
        self.logical_region_id = logical_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.act is not None:
            result['Act'] = self.act
        if self.logical_region_id is not None:
            result['LogicalRegionId'] = self.logical_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Act') is not None:
            self.act = m.get('Act')
        if m.get('LogicalRegionId') is not None:
            self.logical_region_id = m.get('LogicalRegionId')
        return self


class ListEcuByRegionResponseBodyEcuEntityListEcuEntity(TeaModel):
    def __init__(
        self,
        available_cpu: int = None,
        available_mem: int = None,
        cpu: int = None,
        create_time: int = None,
        docker_env: bool = None,
        ecu_id: str = None,
        heartbeat_time: int = None,
        instance_id: str = None,
        ip_addr: str = None,
        mem: int = None,
        name: str = None,
        online: bool = None,
        region_id: str = None,
        update_time: int = None,
        user_id: str = None,
        vpc_id: str = None,
        zone_id: str = None,
    ):
        # The number of available CPU cores for the ECU.
        self.available_cpu = available_cpu
        # The size of available memory for the ECU. Unit: MB.
        self.available_mem = available_mem
        # The total number of CPU cores.
        self.cpu = cpu
        # The timestamp when the ECU was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # Indicates whether Docker is installed. Valid values:
        # 
        # *   true: Docker is installed.
        # *   false: Docker is not installed.
        self.docker_env = docker_env
        # The unique ID of the ECU. To query the ID, you can run the `dmidecode` command on the ECS instance that corresponds to the ECU.
        self.ecu_id = ecu_id
        # The timestamp when the last heartbeat detection was performed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.heartbeat_time = heartbeat_time
        # The ID of the ECU.
        self.instance_id = instance_id
        # The private IP address of the ECU.
        self.ip_addr = ip_addr
        # The total size of memory. Unit: MB.
        self.mem = mem
        # The name of the ECU.
        self.name = name
        # Indicates whether the ECU is online. Valid values:
        # 
        # *   true: The ECU is online.
        # *   false: The ECU is offline.
        self.online = online
        # The ID of the region in which the ECU resides.
        self.region_id = region_id
        # The timestamp when the ECU was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time
        # The ID of the Alibaba Cloud account.
        self.user_id = user_id
        # The ID of the virtual private cloud (VPC) in which the ECU resides.
        self.vpc_id = vpc_id
        # The ID of the zone in which the ECU resides.
        self.zone_id = zone_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_cpu is not None:
            result['AvailableCpu'] = self.available_cpu
        if self.available_mem is not None:
            result['AvailableMem'] = self.available_mem
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.docker_env is not None:
            result['DockerEnv'] = self.docker_env
        if self.ecu_id is not None:
            result['EcuId'] = self.ecu_id
        if self.heartbeat_time is not None:
            result['HeartbeatTime'] = self.heartbeat_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ip_addr is not None:
            result['IpAddr'] = self.ip_addr
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.name is not None:
            result['Name'] = self.name
        if self.online is not None:
            result['Online'] = self.online
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvailableCpu') is not None:
            self.available_cpu = m.get('AvailableCpu')
        if m.get('AvailableMem') is not None:
            self.available_mem = m.get('AvailableMem')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DockerEnv') is not None:
            self.docker_env = m.get('DockerEnv')
        if m.get('EcuId') is not None:
            self.ecu_id = m.get('EcuId')
        if m.get('HeartbeatTime') is not None:
            self.heartbeat_time = m.get('HeartbeatTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IpAddr') is not None:
            self.ip_addr = m.get('IpAddr')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Online') is not None:
            self.online = m.get('Online')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class ListEcuByRegionResponseBodyEcuEntityList(TeaModel):
    def __init__(
        self,
        ecu_entity: List[ListEcuByRegionResponseBodyEcuEntityListEcuEntity] = None,
    ):
        self.ecu_entity = ecu_entity

    def validate(self):
        if self.ecu_entity:
            for k in self.ecu_entity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EcuEntity'] = []
        if self.ecu_entity is not None:
            for k in self.ecu_entity:
                result['EcuEntity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ecu_entity = []
        if m.get('EcuEntity') is not None:
            for k in m.get('EcuEntity'):
                temp_model = ListEcuByRegionResponseBodyEcuEntityListEcuEntity()
                self.ecu_entity.append(temp_model.from_map(k))
        return self


class ListEcuByRegionResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        ecu_entity_list: ListEcuByRegionResponseBodyEcuEntityList = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The information about ECUs.
        self.ecu_entity_list = ecu_entity_list
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.ecu_entity_list:
            self.ecu_entity_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.ecu_entity_list is not None:
            result['EcuEntityList'] = self.ecu_entity_list.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EcuEntityList') is not None:
            temp_model = ListEcuByRegionResponseBodyEcuEntityList()
            self.ecu_entity_list = temp_model.from_map(m['EcuEntityList'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListEcuByRegionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEcuByRegionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEcuByRegionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHistoryDeployVersionRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        create_time: int = None,
        description: str = None,
        id: str = None,
        package_version: str = None,
        public_url: str = None,
        type: str = None,
        update_time: int = None,
        war_url: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The time when the deployment package was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The description of the deployment package.
        self.description = description
        # The unique ID of the deployment package.
        self.id = id
        # The version of the application that was released by using the deployment package. This version can be used to call the RollbackApplication operation.
        self.package_version = package_version
        # The URL of the deployment package.
        self.public_url = public_url
        # The deployment mode of the application. Valid values:
        # 
        # *   url: The application is deployed by using a JAR or WAR package.
        # *   image: The application is deployed by using an image.
        self.type = type
        # The time when the deployment package was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time
        # The URL of the deployment package.
        self.war_url = war_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.public_url is not None:
            result['PublicUrl'] = self.public_url
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.war_url is not None:
            result['WarUrl'] = self.war_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('PublicUrl') is not None:
            self.public_url = m.get('PublicUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('WarUrl') is not None:
            self.war_url = m.get('WarUrl')
        return self


class ListHistoryDeployVersionResponseBodyPackageVersionList(TeaModel):
    def __init__(
        self,
        package_version: List[ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion] = None,
    ):
        self.package_version = package_version

    def validate(self):
        if self.package_version:
            for k in self.package_version:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PackageVersion'] = []
        if self.package_version is not None:
            for k in self.package_version:
                result['PackageVersion'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.package_version = []
        if m.get('PackageVersion') is not None:
            for k in m.get('PackageVersion'):
                temp_model = ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion()
                self.package_version.append(temp_model.from_map(k))
        return self


class ListHistoryDeployVersionResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        package_version_list: ListHistoryDeployVersionResponseBodyPackageVersionList = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The information about historical deployment packages.
        self.package_version_list = package_version_list
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.package_version_list:
            self.package_version_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.package_version_list is not None:
            result['PackageVersionList'] = self.package_version_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PackageVersionList') is not None:
            temp_model = ListHistoryDeployVersionResponseBodyPackageVersionList()
            self.package_version_list = temp_model.from_map(m['PackageVersionList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListHistoryDeployVersionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListHistoryDeployVersionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHistoryDeployVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListK8sConfigMapsRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        condition: Dict[str, Any] = None,
        namespace: str = None,
        page_no: int = None,
        page_size: int = None,
        region_id: str = None,
        show_related_apps: bool = None,
    ):
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The filter conditions. Set this parameter to a JSON string in the format of {"field":"Name", "pattern":"configmap-"}.
        self.condition = condition
        # The namespace of the Kubernetes cluster.
        self.namespace = namespace
        # The number of the page to return. Pages start from Page 0.
        self.page_no = page_no
        # The number of entries to return on each page.
        self.page_size = page_size
        # The ID of the region.
        self.region_id = region_id
        # Specifies whether to return a list of applications that use a ConfigMap. Valid values: true and false.
        self.show_related_apps = show_related_apps

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.show_related_apps is not None:
            result['ShowRelatedApps'] = self.show_related_apps
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ShowRelatedApps') is not None:
            self.show_related_apps = m.get('ShowRelatedApps')
        return self


class ListK8sConfigMapsResponseBodyResultConfigMapsData(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The user-defined key that is stored in the ConfigMap.
        self.key = key
        # The user-defined value that is stored in the ConfigMap.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        return self


class ListK8sConfigMapsResponseBodyResultConfigMaps(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_name: str = None,
        creation_time: str = None,
        data: List[ListK8sConfigMapsResponseBodyResultConfigMapsData] = None,
        name: str = None,
        namespace: str = None,
        related_apps: List[ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps] = None,
    ):
        # The ID of the Kubernetes cluster. You can obtain the cluster ID by calling the GetK8sCluster operation. For more information, see [GetK8sCluster](https://help.aliyun.com/document_detail/181437.html).
        self.cluster_id = cluster_id
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The time when the ConfigMaps were created. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
        self.creation_time = creation_time
        # The information about ConfigMaps.
        self.data = data
        # The name of the ConfigMap.
        self.name = name
        # The namespace of the Kubernetes cluster.
        self.namespace = namespace
        # The related applications.
        self.related_apps = related_apps

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.related_apps:
            for k in self.related_apps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        result['RelatedApps'] = []
        if self.related_apps is not None:
            for k in self.related_apps:
                result['RelatedApps'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListK8sConfigMapsResponseBodyResultConfigMapsData()
                self.data.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        self.related_apps = []
        if m.get('RelatedApps') is not None:
            for k in m.get('RelatedApps'):
                temp_model = ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps()
                self.related_apps.append(temp_model.from_map(k))
        return self


class ListK8sConfigMapsResponseBodyResult(TeaModel):
    def __init__(
        self,
        config_maps: List[ListK8sConfigMapsResponseBodyResultConfigMaps] = None,
        total: int = None,
    ):
        # The information about ConfigMaps.
        self.config_maps = config_maps
        # The total number of entries that are returned.
        self.total = total

    def validate(self):
        if self.config_maps:
            for k in self.config_maps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConfigMaps'] = []
        if self.config_maps is not None:
            for k in self.config_maps:
                result['ConfigMaps'].append(k.to_map() if k else None)
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.config_maps = []
        if m.get('ConfigMaps') is not None:
            for k in m.get('ConfigMaps'):
                temp_model = ListK8sConfigMapsResponseBodyResultConfigMaps()
                self.config_maps.append(temp_model.from_map(k))
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListK8sConfigMapsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        result: ListK8sConfigMapsResponseBodyResult = None,
    ):
        # The HTTP status code.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The query results that are returned.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = ListK8sConfigMapsResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class ListK8sConfigMapsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListK8sConfigMapsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListK8sConfigMapsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListK8sIngressRulesRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        condition: str = None,
        namespace: str = None,
        region_id: str = None,
    ):
        # The cluster ID.
        self.cluster_id = cluster_id
        # The filter conditions. Set the value to a JSON string in the format of {"field":"Name", "pattern":"my-"}, where:
        # 
        # *   field: the parameter to be matched. Valid values: Name and ClusterName.
        # *   pattern: the content to be matched.
        # 
        # For example, a value of {"field":"Name", "pattern":"my-"} indicates that the specified filter conditions match the routing rules whose names start with my-.
        self.condition = condition
        # The namespace of the Kubernetes cluster.
        self.namespace = namespace
        # The ID of the region where the cluster resides.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListK8sIngressRulesResponseBodyDataIngressConfsRulesPathsBackend(TeaModel):
    def __init__(
        self,
        service_name: str = None,
        service_port: str = None,
    ):
        # The name of the backend Service.
        self.service_name = service_name
        # The port of the backend Service.
        self.service_port = service_port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.service_port is not None:
            result['ServicePort'] = self.service_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('ServicePort') is not None:
            self.service_port = m.get('ServicePort')
        return self


class ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        backend: ListK8sIngressRulesResponseBodyDataIngressConfsRulesPathsBackend = None,
        collect_rate: int = None,
        path: str = None,
        path_type: str = None,
        status: str = None,
    ):
        # The ID of the EDAS application.
        self.app_id = app_id
        # The name of the EDAS application.
        self.app_name = app_name
        # The configurations of the backend Service.
        self.backend = backend
        # The collection rate that is set based on the trace query feature. You can add a trace ID to a gateway to use the trace query feature of EDAS.
        self.collect_rate = collect_rate
        # The path to be accessed.
        self.path = path
        # The path type that determines how a path is matched.
        # 
        # *   ImplementationSpecific (default)
        # *   Exact
        # *   Prefix
        self.path_type = path_type
        # The state of the Ingress. Valid values:
        # 
        # *   **Normal**: The Ingress works as expected.
        # *   **ServiceNotFound**: The backend Service does not exist.
        # *   **InvalidServicePort**: The Service port is invalid.
        # *   **NotManagedService**: The Service is not managed by EDAS.
        # *   **Unknown**: An unknown error occurred.
        self.status = status

    def validate(self):
        if self.backend:
            self.backend.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.backend is not None:
            result['Backend'] = self.backend.to_map()
        if self.collect_rate is not None:
            result['CollectRate'] = self.collect_rate
        if self.path is not None:
            result['Path'] = self.path
        if self.path_type is not None:
            result['PathType'] = self.path_type
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Backend') is not None:
            temp_model = ListK8sIngressRulesResponseBodyDataIngressConfsRulesPathsBackend()
            self.backend = temp_model.from_map(m['Backend'])
        if m.get('CollectRate') is not None:
            self.collect_rate = m.get('CollectRate')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('PathType') is not None:
            self.path_type = m.get('PathType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListK8sIngressRulesResponseBodyDataIngressConfsRules(TeaModel):
    def __init__(
        self,
        enable_tls: bool = None,
        host: str = None,
        paths: List[ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths] = None,
        secret_name: str = None,
    ):
        # Indicates whether TLS is enabled. Valid values:
        # 
        # *   true
        # *   false
        self.enable_tls = enable_tls
        # The domain name to be accessed.
        self.host = host
        # The paths to be accessed.
        self.paths = paths
        # The name of the Secret that stores the Transport Layer Security (TLS) certificate.
        self.secret_name = secret_name

    def validate(self):
        if self.paths:
            for k in self.paths:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_tls is not None:
            result['EnableTls'] = self.enable_tls
        if self.host is not None:
            result['Host'] = self.host
        result['Paths'] = []
        if self.paths is not None:
            for k in self.paths:
                result['Paths'].append(k.to_map() if k else None)
        if self.secret_name is not None:
            result['SecretName'] = self.secret_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableTls') is not None:
            self.enable_tls = m.get('EnableTls')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        self.paths = []
        if m.get('Paths') is not None:
            for k in m.get('Paths'):
                temp_model = ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths()
                self.paths.append(temp_model.from_map(k))
        if m.get('SecretName') is not None:
            self.secret_name = m.get('SecretName')
        return self


class ListK8sIngressRulesResponseBodyDataIngressConfs(TeaModel):
    def __init__(
        self,
        alb_id: str = None,
        annotations: str = None,
        creation_time: str = None,
        dashboard_url: str = None,
        endpoint: str = None,
        ingress_type: str = None,
        labels: str = None,
        mse_gateway_id: str = None,
        mse_gateway_name: str = None,
        name: str = None,
        namespace: str = None,
        offical_basic_url: str = None,
        offical_request_url: str = None,
        rules: List[ListK8sIngressRulesResponseBodyDataIngressConfsRules] = None,
        ssl_redirect: bool = None,
    ):
        # The ID of the ALB instance.
        self.alb_id = alb_id
        # The annotations.
        self.annotations = annotations
        # The time when the Ingress was created.
        self.creation_time = creation_time
        # The monitoring URL of the Ingress.
        self.dashboard_url = dashboard_url
        # The IP address of the Ingress.
        self.endpoint = endpoint
        # The Ingress type. Valid values:
        # 
        # *   **NginxIngress**: NGINX Ingress controller
        # *   **AlbIngress**: ALB Ingress controller
        # 
        # Default value: NginxIngress.
        self.ingress_type = ingress_type
        # The tags.
        self.labels = labels
        # The ID of the MSE gateway.
        self.mse_gateway_id = mse_gateway_id
        # The name of the MSE gateway.
        self.mse_gateway_name = mse_gateway_name
        # The Ingress name.
        self.name = name
        # The Kubernetes namespace to which the Ingress belongs.
        self.namespace = namespace
        # The URL used for basic monitoring of the open source version.
        self.offical_basic_url = offical_basic_url
        # The URL used for request performance monitoring of the open source version.
        self.offical_request_url = offical_request_url
        # The routing rules.
        self.rules = rules
        # Indicates whether SSL redirection is enabled. Valid values:
        # 
        # *   true
        # *   false
        self.ssl_redirect = ssl_redirect

    def validate(self):
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alb_id is not None:
            result['AlbId'] = self.alb_id
        if self.annotations is not None:
            result['Annotations'] = self.annotations
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.dashboard_url is not None:
            result['DashboardUrl'] = self.dashboard_url
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.ingress_type is not None:
            result['IngressType'] = self.ingress_type
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.mse_gateway_id is not None:
            result['MseGatewayId'] = self.mse_gateway_id
        if self.mse_gateway_name is not None:
            result['MseGatewayName'] = self.mse_gateway_name
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.offical_basic_url is not None:
            result['OfficalBasicUrl'] = self.offical_basic_url
        if self.offical_request_url is not None:
            result['OfficalRequestUrl'] = self.offical_request_url
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        if self.ssl_redirect is not None:
            result['SslRedirect'] = self.ssl_redirect
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlbId') is not None:
            self.alb_id = m.get('AlbId')
        if m.get('Annotations') is not None:
            self.annotations = m.get('Annotations')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DashboardUrl') is not None:
            self.dashboard_url = m.get('DashboardUrl')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('IngressType') is not None:
            self.ingress_type = m.get('IngressType')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('MseGatewayId') is not None:
            self.mse_gateway_id = m.get('MseGatewayId')
        if m.get('MseGatewayName') is not None:
            self.mse_gateway_name = m.get('MseGatewayName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('OfficalBasicUrl') is not None:
            self.offical_basic_url = m.get('OfficalBasicUrl')
        if m.get('OfficalRequestUrl') is not None:
            self.offical_request_url = m.get('OfficalRequestUrl')
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = ListK8sIngressRulesResponseBodyDataIngressConfsRules()
                self.rules.append(temp_model.from_map(k))
        if m.get('SslRedirect') is not None:
            self.ssl_redirect = m.get('SslRedirect')
        return self


class ListK8sIngressRulesResponseBodyData(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_name: str = None,
        ingress_confs: List[ListK8sIngressRulesResponseBodyDataIngressConfs] = None,
        region_id: str = None,
    ):
        # The cluster ID.
        self.cluster_id = cluster_id
        # The cluster name.
        self.cluster_name = cluster_name
        # The Ingresses.
        self.ingress_confs = ingress_confs
        # The ID of the Alibaba Cloud region.
        self.region_id = region_id

    def validate(self):
        if self.ingress_confs:
            for k in self.ingress_confs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        result['IngressConfs'] = []
        if self.ingress_confs is not None:
            for k in self.ingress_confs:
                result['IngressConfs'].append(k.to_map() if k else None)
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        self.ingress_confs = []
        if m.get('IngressConfs') is not None:
            for k in m.get('IngressConfs'):
                temp_model = ListK8sIngressRulesResponseBodyDataIngressConfs()
                self.ingress_confs.append(temp_model.from_map(k))
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListK8sIngressRulesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[ListK8sIngressRulesResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The response data.
        self.data = data
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListK8sIngressRulesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListK8sIngressRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListK8sIngressRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListK8sIngressRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListK8sNamespacesRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
    ):
        # The ID of the cluster in Enterprise Distributed Application Service (EDAS).
        self.cluster_id = cluster_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        return self


class ListK8sNamespacesResponseBodyData(TeaModel):
    def __init__(
        self,
        namespace: str = None,
    ):
        # The namespaces of the Kubernetes cluster.
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        return self


class ListK8sNamespacesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[ListK8sNamespacesResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The data that is returned.
        self.data = data
        # The message returned for the request.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListK8sNamespacesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListK8sNamespacesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListK8sNamespacesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListK8sNamespacesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListK8sSecretsRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        condition: str = None,
        namespace: str = None,
        page_no: int = None,
        page_size: int = None,
        region_id: str = None,
        show_related_apps: bool = None,
    ):
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The filter conditions. Set this parameter to a JSON string in the format of {"field":"Name", "pattern":"configmap-"}.
        self.condition = condition
        # The namespace of the Kubernetes cluster.
        self.namespace = namespace
        # The number of the page to return. Pages start from Page 0.
        self.page_no = page_no
        # The number of entries to return on each page. The value 0 indicates that all entries are returned on one page.
        self.page_size = page_size
        # The ID of the region.
        self.region_id = region_id
        # Specifies whether to return a list of applications that use a Secret.
        self.show_related_apps = show_related_apps

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.show_related_apps is not None:
            result['ShowRelatedApps'] = self.show_related_apps
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ShowRelatedApps') is not None:
            self.show_related_apps = m.get('ShowRelatedApps')
        return self


class ListK8sSecretsResponseBodyResultSecretsCertDetail(TeaModel):
    def __init__(
        self,
        domain_names: List[str] = None,
        end_time: str = None,
        issuer: str = None,
        start_time: str = None,
        status: str = None,
    ):
        # Domain names that are associated with the SSL certificate.
        self.domain_names = domain_names
        # The time when the SSL certificate expired.
        self.end_time = end_time
        # The certificate authority (CA) that issued the SSL certificate.
        self.issuer = issuer
        # The time when the SSL certificate started to take effect.
        self.start_time = start_time
        # The state of the SSL certificate. Valid values:
        # 
        # *   normal: The SSL certificate is valid.
        # *   invalid: The SSL certificate is invalid.
        # *   expired: The SSL certificate has expired.
        # *   not_yet_valid: The SSL certificate is currently invalid.
        # *   about_to_expire: The SSL certificate is about to expire.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_names is not None:
            result['DomainNames'] = self.domain_names
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.issuer is not None:
            result['Issuer'] = self.issuer
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainNames') is not None:
            self.domain_names = m.get('DomainNames')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Issuer') is not None:
            self.issuer = m.get('Issuer')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListK8sSecretsResponseBodyResultSecretsData(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The user-defined key of the Kubernetes Secret.
        self.key = key
        # The user-defined value of the Kubernetes Secret.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListK8sSecretsResponseBodyResultSecretsRelatedApps(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        return self


class ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The name of the EDAS application.
        self.app_name = app_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        return self


class ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules(TeaModel):
    def __init__(
        self,
        name: str = None,
        namespace: str = None,
        related_apps: List[ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps] = None,
    ):
        # The name of the rule in the Ingress.
        self.name = name
        # The namespaces of the Kubernetes cluster.
        self.namespace = namespace
        # Aplications that are associated with the Ingress.
        self.related_apps = related_apps

    def validate(self):
        if self.related_apps:
            for k in self.related_apps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        result['RelatedApps'] = []
        if self.related_apps is not None:
            for k in self.related_apps:
                result['RelatedApps'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        self.related_apps = []
        if m.get('RelatedApps') is not None:
            for k in m.get('RelatedApps'):
                temp_model = ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps()
                self.related_apps.append(temp_model.from_map(k))
        return self


class ListK8sSecretsResponseBodyResultSecrets(TeaModel):
    def __init__(
        self,
        base_64encoded: bool = None,
        cert_detail: ListK8sSecretsResponseBodyResultSecretsCertDetail = None,
        cert_id: str = None,
        cert_region_id: str = None,
        cluster_id: str = None,
        cluster_name: str = None,
        creation_time: str = None,
        data: List[ListK8sSecretsResponseBodyResultSecretsData] = None,
        name: str = None,
        namespace: str = None,
        related_apps: List[ListK8sSecretsResponseBodyResultSecretsRelatedApps] = None,
        related_ingress_rules: List[ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules] = None,
        type: str = None,
    ):
        # Indicates whether the data is Base64-encoded. Valid values:
        # 
        # *   true: The data is Base64-encoded.
        # *   false: The data is not Base64-encoded.
        self.base_64encoded = base_64encoded
        # The details of the Secure Sockets Layer (SSL) certificate.
        self.cert_detail = cert_detail
        # The ID of the certificate provided by Alibaba Cloud Certificate Management Service.
        self.cert_id = cert_id
        # The region in which the certificate is stored.
        self.cert_region_id = cert_region_id
        # The ID of the cluster in Enterprise Distributed Application Service (EDAS).
        self.cluster_id = cluster_id
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The time when the Secret was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*hh:mm:ss*Z format. The time is displayed in UTC.
        self.creation_time = creation_time
        # The data of the Kubernetes Secret.
        self.data = data
        # The name of the Secret. The name must start with a letter, and can contain digits, letters, and hyphens (-). It can be up to 63 characters in length.
        self.name = name
        # The namespace of the Kubernetes cluster.
        self.namespace = namespace
        # Applications that use the Secret.
        self.related_apps = related_apps
        # Rules in the Ingress that is associated with the Secret.
        self.related_ingress_rules = related_ingress_rules
        # The type of the Secret. Valid values:
        # 
        # *   Opaque: user-defined data
        # *   kubernetes.io/tls: Transport Layer Security (TLS) certificate
        self.type = type

    def validate(self):
        if self.cert_detail:
            self.cert_detail.validate()
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.related_apps:
            for k in self.related_apps:
                if k:
                    k.validate()
        if self.related_ingress_rules:
            for k in self.related_ingress_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_64encoded is not None:
            result['Base64Encoded'] = self.base_64encoded
        if self.cert_detail is not None:
            result['CertDetail'] = self.cert_detail.to_map()
        if self.cert_id is not None:
            result['CertId'] = self.cert_id
        if self.cert_region_id is not None:
            result['CertRegionId'] = self.cert_region_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        result['RelatedApps'] = []
        if self.related_apps is not None:
            for k in self.related_apps:
                result['RelatedApps'].append(k.to_map() if k else None)
        result['RelatedIngressRules'] = []
        if self.related_ingress_rules is not None:
            for k in self.related_ingress_rules:
                result['RelatedIngressRules'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Base64Encoded') is not None:
            self.base_64encoded = m.get('Base64Encoded')
        if m.get('CertDetail') is not None:
            temp_model = ListK8sSecretsResponseBodyResultSecretsCertDetail()
            self.cert_detail = temp_model.from_map(m['CertDetail'])
        if m.get('CertId') is not None:
            self.cert_id = m.get('CertId')
        if m.get('CertRegionId') is not None:
            self.cert_region_id = m.get('CertRegionId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListK8sSecretsResponseBodyResultSecretsData()
                self.data.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        self.related_apps = []
        if m.get('RelatedApps') is not None:
            for k in m.get('RelatedApps'):
                temp_model = ListK8sSecretsResponseBodyResultSecretsRelatedApps()
                self.related_apps.append(temp_model.from_map(k))
        self.related_ingress_rules = []
        if m.get('RelatedIngressRules') is not None:
            for k in m.get('RelatedIngressRules'):
                temp_model = ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules()
                self.related_ingress_rules.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListK8sSecretsResponseBodyResult(TeaModel):
    def __init__(
        self,
        secrets: List[ListK8sSecretsResponseBodyResultSecrets] = None,
        total: int = None,
    ):
        # The information about Kubernetes Secrets.
        self.secrets = secrets
        # The total number of entries that are returned.
        self.total = total

    def validate(self):
        if self.secrets:
            for k in self.secrets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Secrets'] = []
        if self.secrets is not None:
            for k in self.secrets:
                result['Secrets'].append(k.to_map() if k else None)
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.secrets = []
        if m.get('Secrets') is not None:
            for k in m.get('Secrets'):
                temp_model = ListK8sSecretsResponseBodyResultSecrets()
                self.secrets.append(temp_model.from_map(k))
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListK8sSecretsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        result: ListK8sSecretsResponseBodyResult = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The returned query results of Kubernetes Secrets.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = ListK8sSecretsResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class ListK8sSecretsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListK8sSecretsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListK8sSecretsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMethodsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        service_name: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The name of the service.
        # 
        # This parameter is required.
        self.service_name = service_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        return self


class ListMethodsResponseBodyServiceMethodListServiceMethodInputParams(TeaModel):
    def __init__(
        self,
        input_param: List[str] = None,
    ):
        self.input_param = input_param

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_param is not None:
            result['InputParam'] = self.input_param
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputParam') is not None:
            self.input_param = m.get('InputParam')
        return self


class ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes(TeaModel):
    def __init__(
        self,
        param_type: List[str] = None,
    ):
        self.param_type = param_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.param_type is not None:
            result['ParamType'] = self.param_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ParamType') is not None:
            self.param_type = m.get('ParamType')
        return self


class ListMethodsResponseBodyServiceMethodListServiceMethod(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        input_params: ListMethodsResponseBodyServiceMethodListServiceMethodInputParams = None,
        method_name: str = None,
        output: str = None,
        param_types: ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes = None,
        service_name: str = None,
    ):
        # The name of the application.
        self.app_name = app_name
        self.input_params = input_params
        # The name of the service method.
        self.method_name = method_name
        # The return type of the service method.
        self.output = output
        self.param_types = param_types
        # The name of the service.
        self.service_name = service_name

    def validate(self):
        if self.input_params:
            self.input_params.validate()
        if self.param_types:
            self.param_types.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.input_params is not None:
            result['InputParams'] = self.input_params.to_map()
        if self.method_name is not None:
            result['MethodName'] = self.method_name
        if self.output is not None:
            result['Output'] = self.output
        if self.param_types is not None:
            result['ParamTypes'] = self.param_types.to_map()
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('InputParams') is not None:
            temp_model = ListMethodsResponseBodyServiceMethodListServiceMethodInputParams()
            self.input_params = temp_model.from_map(m['InputParams'])
        if m.get('MethodName') is not None:
            self.method_name = m.get('MethodName')
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('ParamTypes') is not None:
            temp_model = ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes()
            self.param_types = temp_model.from_map(m['ParamTypes'])
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        return self


class ListMethodsResponseBodyServiceMethodList(TeaModel):
    def __init__(
        self,
        service_method: List[ListMethodsResponseBodyServiceMethodListServiceMethod] = None,
    ):
        self.service_method = service_method

    def validate(self):
        if self.service_method:
            for k in self.service_method:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ServiceMethod'] = []
        if self.service_method is not None:
            for k in self.service_method:
                result['ServiceMethod'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.service_method = []
        if m.get('ServiceMethod') is not None:
            for k in m.get('ServiceMethod'):
                temp_model = ListMethodsResponseBodyServiceMethodListServiceMethod()
                self.service_method.append(temp_model.from_map(k))
        return self


class ListMethodsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        service_method_list: ListMethodsResponseBodyServiceMethodList = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The returned message that indicates whether the request is successful.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The information about service methods.
        self.service_method_list = service_method_list

    def validate(self):
        if self.service_method_list:
            self.service_method_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.service_method_list is not None:
            result['ServiceMethodList'] = self.service_method_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ServiceMethodList') is not None:
            temp_model = ListMethodsResponseBodyServiceMethodList()
            self.service_method_list = temp_model.from_map(m['ServiceMethodList'])
        return self


class ListMethodsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMethodsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMethodsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPublishedServicesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups(TeaModel):
    def __init__(
        self,
        group: List[str] = None,
    ):
        self.group = group

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group is not None:
            result['group'] = self.group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('group') is not None:
            self.group = m.get('group')
        return self


class ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps(TeaModel):
    def __init__(
        self,
        ip: List[str] = None,
    ):
        self.ip = ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['ip'] = self.ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        return self


class ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        docker_application: bool = None,
        group_2ip: str = None,
        groups: ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups = None,
        ips: ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps = None,
        name: str = None,
        type: str = None,
        version: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # Indicates whether the application runs in a Docker container. Valid values:
        # 
        # *   true: The application runs in a Docker container.
        # *   false: The application does not run in a Docker container.
        self.docker_application = docker_application
        # A reserved parameter.
        self.group_2ip = group_2ip
        self.groups = groups
        self.ips = ips
        # The name of the published service.
        self.name = name
        # The type of the published service.
        self.type = type
        # The version of the published services.
        self.version = version

    def validate(self):
        if self.groups:
            self.groups.validate()
        if self.ips:
            self.ips.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.docker_application is not None:
            result['DockerApplication'] = self.docker_application
        if self.group_2ip is not None:
            result['Group2Ip'] = self.group_2ip
        if self.groups is not None:
            result['Groups'] = self.groups.to_map()
        if self.ips is not None:
            result['Ips'] = self.ips.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DockerApplication') is not None:
            self.docker_application = m.get('DockerApplication')
        if m.get('Group2Ip') is not None:
            self.group_2ip = m.get('Group2Ip')
        if m.get('Groups') is not None:
            temp_model = ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups()
            self.groups = temp_model.from_map(m['Groups'])
        if m.get('Ips') is not None:
            temp_model = ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps()
            self.ips = temp_model.from_map(m['Ips'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListPublishedServicesResponseBodyPublishedServicesList(TeaModel):
    def __init__(
        self,
        list_published_services: List[ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices] = None,
    ):
        self.list_published_services = list_published_services

    def validate(self):
        if self.list_published_services:
            for k in self.list_published_services:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ListPublishedServices'] = []
        if self.list_published_services is not None:
            for k in self.list_published_services:
                result['ListPublishedServices'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list_published_services = []
        if m.get('ListPublishedServices') is not None:
            for k in m.get('ListPublishedServices'):
                temp_model = ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices()
                self.list_published_services.append(temp_model.from_map(k))
        return self


class ListPublishedServicesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        published_services_list: ListPublishedServicesResponseBodyPublishedServicesList = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The published services.
        self.published_services_list = published_services_list
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.published_services_list:
            self.published_services_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.published_services_list is not None:
            result['PublishedServicesList'] = self.published_services_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PublishedServicesList') is not None:
            temp_model = ListPublishedServicesResponseBodyPublishedServicesList()
            self.published_services_list = temp_model.from_map(m['PublishedServicesList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPublishedServicesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPublishedServicesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPublishedServicesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRecentChangeOrderRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        batch_count: int = None,
        batch_type: str = None,
        change_order_description: str = None,
        change_order_id: str = None,
        co_type: str = None,
        co_type_code: str = None,
        create_time: str = None,
        create_user_id: str = None,
        finish_time: str = None,
        group_id: str = None,
        source: str = None,
        status: int = None,
        user_id: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The number of batches for the change. Valid values: 1 to 5.
        self.batch_count = batch_count
        # The way in which the next batch is triggered during a phased release. Valid values:
        # 
        # *   Automatic
        # *   Manual
        self.batch_type = batch_type
        # The description of the change process.
        self.change_order_description = change_order_description
        # The unique ID of the change process.
        self.change_order_id = change_order_id
        # The type of the change process.
        self.co_type = co_type
        # The type of the change process.
        self.co_type_code = co_type_code
        # The time when the change process was created.
        self.create_time = create_time
        # The user who created the change process.
        self.create_user_id = create_user_id
        # The time when the change process ended.
        self.finish_time = finish_time
        # The ID of the application instance group on which the change was performed.
        self.group_id = group_id
        # The source of the change. Valid values:
        # 
        # *   console: the Enterprise Distributed Application Service (EDAS) console
        # *   pop: the POP API or tool
        self.source = source
        # The state of the change process. Valid values:
        # 
        # *   0: ready to start execution
        # *   1: in progress
        # *   2: successful
        # *   3: failed
        # *   6: terminated
        # *   8: waiting for manual confirmation (You can see the state when you manually confirm the execution of the next batch of the change.)
        # *   9: waiting for automatic execution
        # *   10: failed due to a system error
        self.status = status
        # The ID of the user who created the change process.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.batch_count is not None:
            result['BatchCount'] = self.batch_count
        if self.batch_type is not None:
            result['BatchType'] = self.batch_type
        if self.change_order_description is not None:
            result['ChangeOrderDescription'] = self.change_order_description
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.co_type is not None:
            result['CoType'] = self.co_type
        if self.co_type_code is not None:
            result['CoTypeCode'] = self.co_type_code
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user_id is not None:
            result['CreateUserId'] = self.create_user_id
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.source is not None:
            result['Source'] = self.source
        if self.status is not None:
            result['Status'] = self.status
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BatchCount') is not None:
            self.batch_count = m.get('BatchCount')
        if m.get('BatchType') is not None:
            self.batch_type = m.get('BatchType')
        if m.get('ChangeOrderDescription') is not None:
            self.change_order_description = m.get('ChangeOrderDescription')
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('CoType') is not None:
            self.co_type = m.get('CoType')
        if m.get('CoTypeCode') is not None:
            self.co_type_code = m.get('CoTypeCode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUserId') is not None:
            self.create_user_id = m.get('CreateUserId')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListRecentChangeOrderResponseBodyChangeOrderList(TeaModel):
    def __init__(
        self,
        change_order: List[ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder] = None,
    ):
        self.change_order = change_order

    def validate(self):
        if self.change_order:
            for k in self.change_order:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ChangeOrder'] = []
        if self.change_order is not None:
            for k in self.change_order:
                result['ChangeOrder'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.change_order = []
        if m.get('ChangeOrder') is not None:
            for k in m.get('ChangeOrder'):
                temp_model = ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder()
                self.change_order.append(temp_model.from_map(k))
        return self


class ListRecentChangeOrderResponseBody(TeaModel):
    def __init__(
        self,
        change_order_list: ListRecentChangeOrderResponseBodyChangeOrderList = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The information about change processes.
        self.change_order_list = change_order_list
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.change_order_list:
            self.change_order_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_list is not None:
            result['ChangeOrderList'] = self.change_order_list.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderList') is not None:
            temp_model = ListRecentChangeOrderResponseBodyChangeOrderList()
            self.change_order_list = temp_model.from_map(m['ChangeOrderList'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListRecentChangeOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRecentChangeOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRecentChangeOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity(TeaModel):
    def __init__(
        self,
        address: str = None,
        address_type: str = None,
        expired: bool = None,
        group_id: int = None,
        network_type: str = None,
        region_id: str = None,
        slb_id: str = None,
        slb_name: str = None,
        slb_status: str = None,
        user_id: str = None,
        vpc_id: str = None,
        vswitch_id: str = None,
    ):
        # The IP address of the SLB instance.
        self.address = address
        # The type of the IP address of the SLB instance. Valid values:
        # 
        # *   Internet: Users can connect to the SLB instance over the Internet.
        # *   Intranet: Users can connect to the SLB instance over the internal network.
        self.address_type = address_type
        # Indicates whether the SLB instance has expired. Valid values:
        # 
        # *   true: The SLB instance has expired.
        # *   false: The SLB instance has not expired.
        self.expired = expired
        # The ID of the group to which the SLB instance belongs.
        self.group_id = group_id
        # The network type of the SLB instance. Valid values:
        # 
        # *   Classic network
        # *   VPC
        self.network_type = network_type
        # The ID of the region.
        self.region_id = region_id
        # The unique ID of the SLB instance.
        self.slb_id = slb_id
        # The name of the SLB instance.
        self.slb_name = slb_name
        # The status of the SLB instance.
        self.slb_status = slb_status
        # The UID of the Alibaba Cloud account.
        self.user_id = user_id
        # The ID of the VPC.
        self.vpc_id = vpc_id
        # The ID of the vSwitch.
        self.vswitch_id = vswitch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.address_type is not None:
            result['AddressType'] = self.address_type
        if self.expired is not None:
            result['Expired'] = self.expired
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.slb_id is not None:
            result['SlbId'] = self.slb_id
        if self.slb_name is not None:
            result['SlbName'] = self.slb_name
        if self.slb_status is not None:
            result['SlbStatus'] = self.slb_status
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vswitch_id is not None:
            result['VswitchId'] = self.vswitch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AddressType') is not None:
            self.address_type = m.get('AddressType')
        if m.get('Expired') is not None:
            self.expired = m.get('Expired')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SlbId') is not None:
            self.slb_id = m.get('SlbId')
        if m.get('SlbName') is not None:
            self.slb_name = m.get('SlbName')
        if m.get('SlbStatus') is not None:
            self.slb_status = m.get('SlbStatus')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VswitchId') is not None:
            self.vswitch_id = m.get('VswitchId')
        return self


class ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList(TeaModel):
    def __init__(
        self,
        slb_entity: List[ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity] = None,
    ):
        self.slb_entity = slb_entity

    def validate(self):
        if self.slb_entity:
            for k in self.slb_entity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SlbEntity'] = []
        if self.slb_entity is not None:
            for k in self.slb_entity:
                result['SlbEntity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.slb_entity = []
        if m.get('SlbEntity') is not None:
            for k in m.get('SlbEntity'):
                temp_model = ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity()
                self.slb_entity.append(temp_model.from_map(k))
        return self


class ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity(TeaModel):
    def __init__(
        self,
        available_cpu: int = None,
        available_mem: int = None,
        cpu: int = None,
        create_time: int = None,
        docker_env: bool = None,
        ecu_id: str = None,
        heartbeat_time: int = None,
        instance_id: str = None,
        ip_addr: str = None,
        mem: int = None,
        name: str = None,
        online: bool = None,
        region_id: str = None,
        update_time: int = None,
        user_id: str = None,
        vpc_id: str = None,
        zone_id: str = None,
    ):
        # The number of available CPUs.
        self.available_cpu = available_cpu
        # The size of the available memory.
        self.available_mem = available_mem
        # The total number of CPU cores.
        self.cpu = cpu
        # The time when the ECU was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # Indicates whether Docker is installed. Valid values:
        # 
        # *   true: Docker is installed.
        # *   false: Docker is not installed.
        self.docker_env = docker_env
        # The unique ID of the elastic compute unit (ECU). You can run the `dmidecode` command on the ECS instance to query the ECU ID.
        self.ecu_id = ecu_id
        # The time when the last heartbeat detection was performed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.heartbeat_time = heartbeat_time
        # The ID of the instance.
        self.instance_id = instance_id
        # The private IP address of the ECU.
        self.ip_addr = ip_addr
        # The total size of memory. Unit: MB.
        self.mem = mem
        # The name of the ECU.
        self.name = name
        # Indicates whether the ECU is online. Valid values:
        # 
        # *   true: The ECU is online.
        # *   false: The ECU is offline.
        self.online = online
        # The ID of the region.
        self.region_id = region_id
        # The time when the ECU was updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time
        # The ID of the user associated with the ECU.
        self.user_id = user_id
        # The ID of the VPC.
        self.vpc_id = vpc_id
        # The ID of the zone.
        self.zone_id = zone_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_cpu is not None:
            result['AvailableCpu'] = self.available_cpu
        if self.available_mem is not None:
            result['AvailableMem'] = self.available_mem
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.docker_env is not None:
            result['DockerEnv'] = self.docker_env
        if self.ecu_id is not None:
            result['EcuId'] = self.ecu_id
        if self.heartbeat_time is not None:
            result['HeartbeatTime'] = self.heartbeat_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ip_addr is not None:
            result['IpAddr'] = self.ip_addr
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.name is not None:
            result['Name'] = self.name
        if self.online is not None:
            result['Online'] = self.online
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvailableCpu') is not None:
            self.available_cpu = m.get('AvailableCpu')
        if m.get('AvailableMem') is not None:
            self.available_mem = m.get('AvailableMem')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DockerEnv') is not None:
            self.docker_env = m.get('DockerEnv')
        if m.get('EcuId') is not None:
            self.ecu_id = m.get('EcuId')
        if m.get('HeartbeatTime') is not None:
            self.heartbeat_time = m.get('HeartbeatTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IpAddr') is not None:
            self.ip_addr = m.get('IpAddr')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Online') is not None:
            self.online = m.get('Online')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity(TeaModel):
    def __init__(
        self,
        cidrblock: str = None,
        description: str = None,
        ecs_num: int = None,
        expired: bool = None,
        region_id: str = None,
        status: str = None,
        user_id: str = None,
        vpc_id: str = None,
        vpc_name: str = None,
    ):
        # The IPv4 CIDR block of the vSwitch.
        self.cidrblock = cidrblock
        # The description of the VPC.
        self.description = description
        # The number of ECS instances that run in the VPC.
        self.ecs_num = ecs_num
        # Indicates whether the VPC has expired. Valid values:
        # 
        # *   true: The VPC has expired.
        # *   false: The VPC has not expired.
        self.expired = expired
        # The ID of the region.
        self.region_id = region_id
        # The status of the VPC.
        self.status = status
        # The ID of the user.
        self.user_id = user_id
        # The unique ID of the VPC.
        self.vpc_id = vpc_id
        # The name of the VPC.
        self.vpc_name = vpc_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidrblock is not None:
            result['Cidrblock'] = self.cidrblock
        if self.description is not None:
            result['Description'] = self.description
        if self.ecs_num is not None:
            result['EcsNum'] = self.ecs_num
        if self.expired is not None:
            result['Expired'] = self.expired
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vpc_name is not None:
            result['VpcName'] = self.vpc_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cidrblock') is not None:
            self.cidrblock = m.get('Cidrblock')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EcsNum') is not None:
            self.ecs_num = m.get('EcsNum')
        if m.get('Expired') is not None:
            self.expired = m.get('Expired')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VpcName') is not None:
            self.vpc_name = m.get('VpcName')
        return self


class ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity(TeaModel):
    def __init__(
        self,
        cpu: int = None,
        description: str = None,
        ecu_entity: ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity = None,
        eip: str = None,
        expired: bool = None,
        group_id: str = None,
        host_name: str = None,
        inner_ip: str = None,
        instance_id: str = None,
        instance_name: str = None,
        mem: int = None,
        private_ip: str = None,
        public_ip: str = None,
        region_id: str = None,
        serial_num: str = None,
        sg_id: str = None,
        status: str = None,
        user_id: str = None,
        vpc_entity: ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity = None,
        vpc_id: str = None,
        zone_id: str = None,
    ):
        # The total number of CPU cores.
        self.cpu = cpu
        # The description of the ECS instance.
        self.description = description
        # The elastic compute unit (ECU) that corresponds to the ECS instance.
        self.ecu_entity = ecu_entity
        # The elastic IP address (EIP).
        self.eip = eip
        # Indicates whether the ECS instance has expired. Valid values:
        # 
        # *   true: The ECS instance has expired.
        # *   false: The ECS instance has not expired.
        self.expired = expired
        # The ID of the resource group in Enterprise Distributed Application Service (EDAS).
        self.group_id = group_id
        # The name of the host.
        self.host_name = host_name
        # The private IP address.
        self.inner_ip = inner_ip
        # The ID of the ECS instance.
        self.instance_id = instance_id
        # The name of the ECS instance.
        self.instance_name = instance_name
        # The total size of memory. Unit: MB.
        self.mem = mem
        # The private IP address of the ECS instance.
        self.private_ip = private_ip
        # The public IP address.
        self.public_ip = public_ip
        # The ID of the region.
        self.region_id = region_id
        # The serial number of the ECS instance.
        self.serial_num = serial_num
        # The ID of the security group.
        self.sg_id = sg_id
        # The status of the ECS instance. Valid values:
        # 
        # *   Pending: The ECS instance is being created.
        # *   Running: The ECS instance is running.
        # *   Starting: The ECS instance is being started.
        # *   Stopping: The ECS instance is being stopped.
        # *   Stopped: The ECS instance is stopped.
        self.status = status
        # The ID of the user account.
        self.user_id = user_id
        # The VPCs.
        self.vpc_entity = vpc_entity
        # The unique ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id
        # The ID of the zone.
        self.zone_id = zone_id

    def validate(self):
        if self.ecu_entity:
            self.ecu_entity.validate()
        if self.vpc_entity:
            self.vpc_entity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.description is not None:
            result['Description'] = self.description
        if self.ecu_entity is not None:
            result['EcuEntity'] = self.ecu_entity.to_map()
        if self.eip is not None:
            result['Eip'] = self.eip
        if self.expired is not None:
            result['Expired'] = self.expired
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.inner_ip is not None:
            result['InnerIp'] = self.inner_ip
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.private_ip is not None:
            result['PrivateIp'] = self.private_ip
        if self.public_ip is not None:
            result['PublicIp'] = self.public_ip
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.serial_num is not None:
            result['SerialNum'] = self.serial_num
        if self.sg_id is not None:
            result['SgId'] = self.sg_id
        if self.status is not None:
            result['Status'] = self.status
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.vpc_entity is not None:
            result['VpcEntity'] = self.vpc_entity.to_map()
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EcuEntity') is not None:
            temp_model = ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity()
            self.ecu_entity = temp_model.from_map(m['EcuEntity'])
        if m.get('Eip') is not None:
            self.eip = m.get('Eip')
        if m.get('Expired') is not None:
            self.expired = m.get('Expired')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('InnerIp') is not None:
            self.inner_ip = m.get('InnerIp')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('PrivateIp') is not None:
            self.private_ip = m.get('PrivateIp')
        if m.get('PublicIp') is not None:
            self.public_ip = m.get('PublicIp')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SerialNum') is not None:
            self.serial_num = m.get('SerialNum')
        if m.get('SgId') is not None:
            self.sg_id = m.get('SgId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('VpcEntity') is not None:
            temp_model = ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity()
            self.vpc_entity = temp_model.from_map(m['VpcEntity'])
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList(TeaModel):
    def __init__(
        self,
        ecs_entity: List[ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity] = None,
    ):
        self.ecs_entity = ecs_entity

    def validate(self):
        if self.ecs_entity:
            for k in self.ecs_entity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EcsEntity'] = []
        if self.ecs_entity is not None:
            for k in self.ecs_entity:
                result['EcsEntity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ecs_entity = []
        if m.get('EcsEntity') is not None:
            for k in m.get('EcsEntity'):
                temp_model = ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity()
                self.ecs_entity.append(temp_model.from_map(k))
        return self


class ListResourceGroupResponseBodyResourceGroupListResGroupEntity(TeaModel):
    def __init__(
        self,
        admin_user_id: str = None,
        create_time: int = None,
        description: str = None,
        id: int = None,
        name: str = None,
        region_id: str = None,
        slb_list: ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList = None,
        update_time: int = None,
        ecs_list: ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList = None,
    ):
        # The UID of the Alibaba Cloud account.
        self.admin_user_id = admin_user_id
        # The time when the resource group was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The description of the resource group.
        self.description = description
        # The ID of the resource group.
        self.id = id
        # The name of the resource group.
        self.name = name
        # The ID of the region where the resource group belongs.
        self.region_id = region_id
        # The Server Load Balancer (SLB) instances.
        self.slb_list = slb_list
        # The time when the resource group was updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time
        # The Elastic Compute Service (ECS) instances.
        self.ecs_list = ecs_list

    def validate(self):
        if self.slb_list:
            self.slb_list.validate()
        if self.ecs_list:
            self.ecs_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.admin_user_id is not None:
            result['AdminUserId'] = self.admin_user_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.slb_list is not None:
            result['SlbList'] = self.slb_list.to_map()
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.ecs_list is not None:
            result['ecsList'] = self.ecs_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdminUserId') is not None:
            self.admin_user_id = m.get('AdminUserId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SlbList') is not None:
            temp_model = ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList()
            self.slb_list = temp_model.from_map(m['SlbList'])
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('ecsList') is not None:
            temp_model = ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList()
            self.ecs_list = temp_model.from_map(m['ecsList'])
        return self


class ListResourceGroupResponseBodyResourceGroupList(TeaModel):
    def __init__(
        self,
        res_group_entity: List[ListResourceGroupResponseBodyResourceGroupListResGroupEntity] = None,
    ):
        self.res_group_entity = res_group_entity

    def validate(self):
        if self.res_group_entity:
            for k in self.res_group_entity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ResGroupEntity'] = []
        if self.res_group_entity is not None:
            for k in self.res_group_entity:
                result['ResGroupEntity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.res_group_entity = []
        if m.get('ResGroupEntity') is not None:
            for k in m.get('ResGroupEntity'):
                temp_model = ListResourceGroupResponseBodyResourceGroupListResGroupEntity()
                self.res_group_entity.append(temp_model.from_map(k))
        return self


class ListResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        resource_group_list: ListResourceGroupResponseBodyResourceGroupList = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # For more information about how to define a resource group, see ResGroupEntity.
        self.resource_group_list = resource_group_list

    def validate(self):
        if self.resource_group_list:
            self.resource_group_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_group_list is not None:
            result['ResourceGroupList'] = self.resource_group_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourceGroupList') is not None:
            temp_model = ListResourceGroupResponseBodyResourceGroupList()
            self.resource_group_list = temp_model.from_map(m['ResourceGroupList'])
        return self


class ListResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRoleResponseBodyRoleListRoleItemActionListAction(TeaModel):
    def __init__(
        self,
        code: str = None,
        description: str = None,
        group_id: str = None,
        name: str = None,
    ):
        # The serial number of the permission that is granted to the role.
        self.code = code
        # The description of the permission to be granted to the role.
        self.description = description
        # The ID of the permission group to which the permission that is granted to the role belongs.
        self.group_id = group_id
        # The name of the permission to be granted to the role.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.description is not None:
            result['Description'] = self.description
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListRoleResponseBodyRoleListRoleItemActionList(TeaModel):
    def __init__(
        self,
        action: List[ListRoleResponseBodyRoleListRoleItemActionListAction] = None,
    ):
        self.action = action

    def validate(self):
        if self.action:
            for k in self.action:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Action'] = []
        if self.action is not None:
            for k in self.action:
                result['Action'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.action = []
        if m.get('Action') is not None:
            for k in m.get('Action'):
                temp_model = ListRoleResponseBodyRoleListRoleItemActionListAction()
                self.action.append(temp_model.from_map(k))
        return self


class ListRoleResponseBodyRoleListRoleItemRole(TeaModel):
    def __init__(
        self,
        admin_user_id: str = None,
        create_time: int = None,
        id: int = None,
        is_default: bool = None,
        name: str = None,
        update_time: int = None,
    ):
        # The ID of the Alibaba Cloud account.
        self.admin_user_id = admin_user_id
        # The timestamp when the role was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The ID of the role.
        self.id = id
        # Indicates whether the role is a default role.
        self.is_default = is_default
        # The name of the role.
        self.name = name
        # The timestamp when the role was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.admin_user_id is not None:
            result['AdminUserId'] = self.admin_user_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.id is not None:
            result['Id'] = self.id
        if self.is_default is not None:
            result['IsDefault'] = self.is_default
        if self.name is not None:
            result['Name'] = self.name
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdminUserId') is not None:
            self.admin_user_id = m.get('AdminUserId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsDefault') is not None:
            self.is_default = m.get('IsDefault')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class ListRoleResponseBodyRoleListRoleItem(TeaModel):
    def __init__(
        self,
        action_list: ListRoleResponseBodyRoleListRoleItemActionList = None,
        role: ListRoleResponseBodyRoleListRoleItemRole = None,
    ):
        # The set of permissions to be granted to the role.
        self.action_list = action_list
        # The roles.
        self.role = role

    def validate(self):
        if self.action_list:
            self.action_list.validate()
        if self.role:
            self.role.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_list is not None:
            result['ActionList'] = self.action_list.to_map()
        if self.role is not None:
            result['Role'] = self.role.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionList') is not None:
            temp_model = ListRoleResponseBodyRoleListRoleItemActionList()
            self.action_list = temp_model.from_map(m['ActionList'])
        if m.get('Role') is not None:
            temp_model = ListRoleResponseBodyRoleListRoleItemRole()
            self.role = temp_model.from_map(m['Role'])
        return self


class ListRoleResponseBodyRoleList(TeaModel):
    def __init__(
        self,
        role_item: List[ListRoleResponseBodyRoleListRoleItem] = None,
    ):
        self.role_item = role_item

    def validate(self):
        if self.role_item:
            for k in self.role_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RoleItem'] = []
        if self.role_item is not None:
            for k in self.role_item:
                result['RoleItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.role_item = []
        if m.get('RoleItem') is not None:
            for k in m.get('RoleItem'):
                temp_model = ListRoleResponseBodyRoleListRoleItem()
                self.role_item.append(temp_model.from_map(k))
        return self


class ListRoleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        role_list: ListRoleResponseBodyRoleList = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The roles.
        self.role_list = role_list

    def validate(self):
        if self.role_list:
            self.role_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.role_list is not None:
            result['RoleList'] = self.role_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RoleList') is not None:
            temp_model = ListRoleResponseBodyRoleList()
            self.role_list = temp_model.from_map(m['RoleList'])
        return self


class ListRoleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRoleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRoleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListScaleOutEcuRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        cluster_id: str = None,
        cpu: int = None,
        group_id: str = None,
        instance_num: int = None,
        logical_region_id: str = None,
        mem: int = None,
    ):
        # The ID of the application. Specify this parameter if you want to query the available ECUs in the cluster where the application is deployed.
        # 
        # >  Specify at least one of the ClusterId and AppId parameters as the query parameter.
        self.app_id = app_id
        # The ID of the cluster. Specify this parameter if you want to query the available ECUs in the cluster.
        # 
        # > Specify at least one of the ClusterId and AppId parameters as the query parameter.
        self.cluster_id = cluster_id
        # The number of CPU cores based on which you want to query the available ECUs in the cluster.
        self.cpu = cpu
        # The ID of the instance group. Specify this parameter if you want to query the available ECUs in the cluster where the instance group resides.
        self.group_id = group_id
        # The number of ECUs that you want to query. If this parameter is not specified, all the ECUs that meet the query conditions are returned.
        self.instance_num = instance_num
        # The ID of the namespace.
        # 
        # *   The ID of a custom namespace is in the `region ID:namespace identifier` format. Example: cn-beijing:test.
        # *   The ID of the default namespace is in the `region ID` format. Example: cn-beijing.
        self.logical_region_id = logical_region_id
        # The size of available memory based on which you want to query the available ECUs in the cluster. Unit: MB.
        self.mem = mem

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_num is not None:
            result['InstanceNum'] = self.instance_num
        if self.logical_region_id is not None:
            result['LogicalRegionId'] = self.logical_region_id
        if self.mem is not None:
            result['Mem'] = self.mem
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceNum') is not None:
            self.instance_num = m.get('InstanceNum')
        if m.get('LogicalRegionId') is not None:
            self.logical_region_id = m.get('LogicalRegionId')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        return self


class ListScaleOutEcuResponseBodyEcuInfoListEcuInfo(TeaModel):
    def __init__(
        self,
        available_cpu: int = None,
        available_mem: int = None,
        create_time: int = None,
        docker_env: bool = None,
        ecu_id: str = None,
        heartbeat_time: int = None,
        instance_id: str = None,
        ip_addr: str = None,
        name: str = None,
        online: bool = None,
        region_id: str = None,
        update_time: int = None,
        user_id: str = None,
        vpc_id: str = None,
        zone_id: str = None,
    ):
        # The number of available CPU cores for the ECU.
        self.available_cpu = available_cpu
        # The size of available memory for the ECU. Unit: MB.
        self.available_mem = available_mem
        # The time when the ECU was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # Indicates whether Docker is installed. Valid values:
        # 
        # *   true: Docker is installed.
        # *   false: Docker is not installed.
        self.docker_env = docker_env
        # The unique ID of the ECU. To query the ID, you can run the `dmidecode` command on the ECS instance that corresponds to the ECU.
        self.ecu_id = ecu_id
        # The time when the last heartbeat detection was performed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.heartbeat_time = heartbeat_time
        # The ID of the ECU.
        self.instance_id = instance_id
        # The private IP address of the ECU.
        self.ip_addr = ip_addr
        # The name of the ECU.
        self.name = name
        # Indicates whether the ECU is online. If the ECU is online, its corresponding ECS instance is managed in EDAS. Valid values:
        # 
        # *   true: The ECU is online.
        # *   false: The ECU is offline.
        self.online = online
        # The ID of the region where the ECU is located.
        self.region_id = region_id
        # The time when the ECU was last updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time
        # The ID of the Alibaba Cloud account to which the ECU belongs.
        self.user_id = user_id
        # The ID of the virtual private cloud (VPC) where the ECU is located.
        self.vpc_id = vpc_id
        # The ID of the zone where the ECU resides.
        self.zone_id = zone_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_cpu is not None:
            result['AvailableCpu'] = self.available_cpu
        if self.available_mem is not None:
            result['AvailableMem'] = self.available_mem
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.docker_env is not None:
            result['DockerEnv'] = self.docker_env
        if self.ecu_id is not None:
            result['EcuId'] = self.ecu_id
        if self.heartbeat_time is not None:
            result['HeartbeatTime'] = self.heartbeat_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ip_addr is not None:
            result['IpAddr'] = self.ip_addr
        if self.name is not None:
            result['Name'] = self.name
        if self.online is not None:
            result['Online'] = self.online
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvailableCpu') is not None:
            self.available_cpu = m.get('AvailableCpu')
        if m.get('AvailableMem') is not None:
            self.available_mem = m.get('AvailableMem')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DockerEnv') is not None:
            self.docker_env = m.get('DockerEnv')
        if m.get('EcuId') is not None:
            self.ecu_id = m.get('EcuId')
        if m.get('HeartbeatTime') is not None:
            self.heartbeat_time = m.get('HeartbeatTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IpAddr') is not None:
            self.ip_addr = m.get('IpAddr')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Online') is not None:
            self.online = m.get('Online')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class ListScaleOutEcuResponseBodyEcuInfoList(TeaModel):
    def __init__(
        self,
        ecu_info: List[ListScaleOutEcuResponseBodyEcuInfoListEcuInfo] = None,
    ):
        self.ecu_info = ecu_info

    def validate(self):
        if self.ecu_info:
            for k in self.ecu_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EcuInfo'] = []
        if self.ecu_info is not None:
            for k in self.ecu_info:
                result['EcuInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ecu_info = []
        if m.get('EcuInfo') is not None:
            for k in m.get('EcuInfo'):
                temp_model = ListScaleOutEcuResponseBodyEcuInfoListEcuInfo()
                self.ecu_info.append(temp_model.from_map(k))
        return self


class ListScaleOutEcuResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        ecu_info_list: ListScaleOutEcuResponseBodyEcuInfoList = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The ECUs.
        self.ecu_info_list = ecu_info_list
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.ecu_info_list:
            self.ecu_info_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.ecu_info_list is not None:
            result['EcuInfoList'] = self.ecu_info_list.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EcuInfoList') is not None:
            temp_model = ListScaleOutEcuResponseBodyEcuInfoList()
            self.ecu_info_list = temp_model.from_map(m['EcuInfoList'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListScaleOutEcuResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListScaleOutEcuResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListScaleOutEcuResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        group_id: str = None,
        group_name: str = None,
    ):
        # The time when the service group was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The ID of the service group.
        self.group_id = group_id
        # The name of the service group.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class ListServiceGroupsResponseBodyServiceGroupsList(TeaModel):
    def __init__(
        self,
        list_service_groups: List[ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups] = None,
    ):
        self.list_service_groups = list_service_groups

    def validate(self):
        if self.list_service_groups:
            for k in self.list_service_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ListServiceGroups'] = []
        if self.list_service_groups is not None:
            for k in self.list_service_groups:
                result['ListServiceGroups'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list_service_groups = []
        if m.get('ListServiceGroups') is not None:
            for k in m.get('ListServiceGroups'):
                temp_model = ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups()
                self.list_service_groups.append(temp_model.from_map(k))
        return self


class ListServiceGroupsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        service_groups_list: ListServiceGroupsResponseBodyServiceGroupsList = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The information about service groups.
        self.service_groups_list = service_groups_list

    def validate(self):
        if self.service_groups_list:
            self.service_groups_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.service_groups_list is not None:
            result['ServiceGroupsList'] = self.service_groups_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ServiceGroupsList') is not None:
            temp_model = ListServiceGroupsResponseBodyServiceGroupsList()
            self.service_groups_list = temp_model.from_map(m['ServiceGroupsList'])
        return self


class ListServiceGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListServiceGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListServiceGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSlbRequest(TeaModel):
    def __init__(
        self,
        address_type: str = None,
        slb_type: str = None,
        vpc_id: str = None,
    ):
        # The type of the IP addresses. Valid values:
        # 
        # *   Internet: Users can connect to the SLB instance over the Internet.
        # *   Intranet: Users can connect to the SLB instance over the internal network.
        self.address_type = address_type
        # The type of the SLB instance. Valid values:
        # 
        # *   clb: Classic Load Balancer (CLB)
        # *   alb: Application Load Balancer (ALB)
        self.slb_type = slb_type
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_type is not None:
            result['AddressType'] = self.address_type
        if self.slb_type is not None:
            result['SlbType'] = self.slb_type
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressType') is not None:
            self.address_type = m.get('AddressType')
        if m.get('SlbType') is not None:
            self.slb_type = m.get('SlbType')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class ListSlbResponseBodySlbListSlbEntity(TeaModel):
    def __init__(
        self,
        address: str = None,
        address_type: str = None,
        expired: bool = None,
        group_id: int = None,
        network_type: str = None,
        region_id: str = None,
        reusable: bool = None,
        slb_id: str = None,
        slb_name: str = None,
        slb_status: str = None,
        tags: str = None,
        user_id: str = None,
        vpc_id: str = None,
        vswitch_id: str = None,
    ):
        # The IP address of the SLB instance.
        self.address = address
        # The type of the IP addresses. Valid values:
        # 
        # *   internet: Users can connect to the SLB instance over the Internet.
        # *   intranet: Users can connect to the SLB instance over the internal network.
        self.address_type = address_type
        # Indicates whether the SLB instance has expired. Valid values:
        # 
        # *   true: The SLB instance has expired.
        # *   false: The SLB instance has not expired.
        self.expired = expired
        # The ID of the resource group in Enterprise Distributed Application Service (EDAS).
        self.group_id = group_id
        # The type of the network.
        self.network_type = network_type
        # The ID of the region.
        self.region_id = region_id
        # Indicates whether Kubernetes applications can be reused. Valid values:
        # 
        # *   true: Kubernetes applications can be reused.
        # *   false: Kubernetes applications cannot be reused.
        self.reusable = reusable
        # The ID of the SLB instance.
        self.slb_id = slb_id
        # The name of the SLB instance.
        self.slb_name = slb_name
        # The status of the SLB instance.
        self.slb_status = slb_status
        # The tag of the SLB instance.
        self.tags = tags
        # The ID of the user.
        self.user_id = user_id
        # The ID of the VPC.
        self.vpc_id = vpc_id
        # The ID of the vSwitch in the VPC.
        self.vswitch_id = vswitch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.address_type is not None:
            result['AddressType'] = self.address_type
        if self.expired is not None:
            result['Expired'] = self.expired
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.reusable is not None:
            result['Reusable'] = self.reusable
        if self.slb_id is not None:
            result['SlbId'] = self.slb_id
        if self.slb_name is not None:
            result['SlbName'] = self.slb_name
        if self.slb_status is not None:
            result['SlbStatus'] = self.slb_status
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vswitch_id is not None:
            result['VswitchId'] = self.vswitch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AddressType') is not None:
            self.address_type = m.get('AddressType')
        if m.get('Expired') is not None:
            self.expired = m.get('Expired')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Reusable') is not None:
            self.reusable = m.get('Reusable')
        if m.get('SlbId') is not None:
            self.slb_id = m.get('SlbId')
        if m.get('SlbName') is not None:
            self.slb_name = m.get('SlbName')
        if m.get('SlbStatus') is not None:
            self.slb_status = m.get('SlbStatus')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VswitchId') is not None:
            self.vswitch_id = m.get('VswitchId')
        return self


class ListSlbResponseBodySlbList(TeaModel):
    def __init__(
        self,
        slb_entity: List[ListSlbResponseBodySlbListSlbEntity] = None,
    ):
        self.slb_entity = slb_entity

    def validate(self):
        if self.slb_entity:
            for k in self.slb_entity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SlbEntity'] = []
        if self.slb_entity is not None:
            for k in self.slb_entity:
                result['SlbEntity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.slb_entity = []
        if m.get('SlbEntity') is not None:
            for k in m.get('SlbEntity'):
                temp_model = ListSlbResponseBodySlbListSlbEntity()
                self.slb_entity.append(temp_model.from_map(k))
        return self


class ListSlbResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        slb_list: ListSlbResponseBodySlbList = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The list of SLB instances.
        self.slb_list = slb_list

    def validate(self):
        if self.slb_list:
            self.slb_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.slb_list is not None:
            result['SlbList'] = self.slb_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SlbList') is not None:
            temp_model = ListSlbResponseBodySlbList()
            self.slb_list = temp_model.from_map(m['SlbList'])
        return self


class ListSlbResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSlbResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSlbResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSubAccountResponseBodySubAccountListSubAccount(TeaModel):
    def __init__(
        self,
        admin_edas_id: str = None,
        admin_user_id: str = None,
        admin_user_kp: str = None,
        email: str = None,
        phone: str = None,
        sub_edas_id: str = None,
        sub_user_id: str = None,
        sub_user_kp: str = None,
    ):
        # The ID of the Alibaba Cloud account. This ID is generated by EDAS.
        self.admin_edas_id = admin_edas_id
        # The ID of the Alibaba Cloud account.
        self.admin_user_id = admin_user_id
        # This parameter is the same as the AdminEdasId parameter. This parameter is deprecated.
        self.admin_user_kp = admin_user_kp
        # The email address of the RAM user.
        self.email = email
        # The contact information of the RAM user.
        self.phone = phone
        # The ID of the RAM user. This ID is generated by Enterprise Distributed Application Service (EDAS).
        self.sub_edas_id = sub_edas_id
        # The ID of the RAM user.
        self.sub_user_id = sub_user_id
        # This parameter is the same as the SubEdasId parameter. This parameter is deprecated.
        self.sub_user_kp = sub_user_kp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.admin_edas_id is not None:
            result['AdminEdasId'] = self.admin_edas_id
        if self.admin_user_id is not None:
            result['AdminUserId'] = self.admin_user_id
        if self.admin_user_kp is not None:
            result['AdminUserKp'] = self.admin_user_kp
        if self.email is not None:
            result['Email'] = self.email
        if self.phone is not None:
            result['Phone'] = self.phone
        if self.sub_edas_id is not None:
            result['SubEdasId'] = self.sub_edas_id
        if self.sub_user_id is not None:
            result['SubUserId'] = self.sub_user_id
        if self.sub_user_kp is not None:
            result['SubUserKp'] = self.sub_user_kp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdminEdasId') is not None:
            self.admin_edas_id = m.get('AdminEdasId')
        if m.get('AdminUserId') is not None:
            self.admin_user_id = m.get('AdminUserId')
        if m.get('AdminUserKp') is not None:
            self.admin_user_kp = m.get('AdminUserKp')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Phone') is not None:
            self.phone = m.get('Phone')
        if m.get('SubEdasId') is not None:
            self.sub_edas_id = m.get('SubEdasId')
        if m.get('SubUserId') is not None:
            self.sub_user_id = m.get('SubUserId')
        if m.get('SubUserKp') is not None:
            self.sub_user_kp = m.get('SubUserKp')
        return self


class ListSubAccountResponseBodySubAccountList(TeaModel):
    def __init__(
        self,
        sub_account: List[ListSubAccountResponseBodySubAccountListSubAccount] = None,
    ):
        self.sub_account = sub_account

    def validate(self):
        if self.sub_account:
            for k in self.sub_account:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubAccount'] = []
        if self.sub_account is not None:
            for k in self.sub_account:
                result['SubAccount'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.sub_account = []
        if m.get('SubAccount') is not None:
            for k in m.get('SubAccount'):
                temp_model = ListSubAccountResponseBodySubAccountListSubAccount()
                self.sub_account.append(temp_model.from_map(k))
        return self


class ListSubAccountResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        sub_account_list: ListSubAccountResponseBodySubAccountList = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The RAM users.
        self.sub_account_list = sub_account_list

    def validate(self):
        if self.sub_account_list:
            self.sub_account_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sub_account_list is not None:
            result['SubAccountList'] = self.sub_account_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SubAccountList') is not None:
            temp_model = ListSubAccountResponseBodySubAccountList()
            self.sub_account_list = temp_model.from_map(m['SubAccountList'])
        return self


class ListSubAccountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSubAccountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSubAccountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSwimmingLaneRequest(TeaModel):
    def __init__(
        self,
        group_id: int = None,
    ):
        # The ID of the lane group.
        # 
        # This parameter is required.
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        extra: str = None,
        lane_id: int = None,
        rules: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        # Additional information.
        self.extra = extra
        # The ID of the lane.
        self.lane_id = lane_id
        # The association rule.
        self.rules = rules

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.extra is not None:
            result['Extra'] = self.extra
        if self.lane_id is not None:
            result['LaneId'] = self.lane_id
        if self.rules is not None:
            result['Rules'] = self.rules
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Extra') is not None:
            self.extra = m.get('Extra')
        if m.get('LaneId') is not None:
            self.lane_id = m.get('LaneId')
        if m.get('Rules') is not None:
            self.rules = m.get('Rules')
        return self


class ListSwimmingLaneResponseBodyData(TeaModel):
    def __init__(
        self,
        enable_rules: bool = None,
        entry_rule: str = None,
        group_id: int = None,
        id: int = None,
        name: str = None,
        namespace_id: str = None,
        scenario_sign: str = None,
        swimming_lane_app_relation_ship_list: List[ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList] = None,
        tag: str = None,
    ):
        # Indicates whether the throttling rule is enabled.
        self.enable_rules = enable_rules
        # The conditions.
        self.entry_rule = entry_rule
        # The ID of the lane group.
        self.group_id = group_id
        # The ID of the lane.
        self.id = id
        # The name of the lane.
        self.name = name
        # The ID of the microservices namespace.
        self.namespace_id = namespace_id
        # The expected tag.
        self.scenario_sign = scenario_sign
        # The applications that are related to the lane.
        self.swimming_lane_app_relation_ship_list = swimming_lane_app_relation_ship_list
        # The tag.
        self.tag = tag

    def validate(self):
        if self.swimming_lane_app_relation_ship_list:
            for k in self.swimming_lane_app_relation_ship_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_rules is not None:
            result['EnableRules'] = self.enable_rules
        if self.entry_rule is not None:
            result['EntryRule'] = self.entry_rule
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.scenario_sign is not None:
            result['ScenarioSign'] = self.scenario_sign
        result['SwimmingLaneAppRelationShipList'] = []
        if self.swimming_lane_app_relation_ship_list is not None:
            for k in self.swimming_lane_app_relation_ship_list:
                result['SwimmingLaneAppRelationShipList'].append(k.to_map() if k else None)
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableRules') is not None:
            self.enable_rules = m.get('EnableRules')
        if m.get('EntryRule') is not None:
            self.entry_rule = m.get('EntryRule')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('ScenarioSign') is not None:
            self.scenario_sign = m.get('ScenarioSign')
        self.swimming_lane_app_relation_ship_list = []
        if m.get('SwimmingLaneAppRelationShipList') is not None:
            for k in m.get('SwimmingLaneAppRelationShipList'):
                temp_model = ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList()
                self.swimming_lane_app_relation_ship_list.append(temp_model.from_map(k))
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class ListSwimmingLaneResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[ListSwimmingLaneResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The data that is returned.
        self.data = data
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListSwimmingLaneResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListSwimmingLaneResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSwimmingLaneResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSwimmingLaneResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSwimmingLaneGroupRequest(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        logical_region_id: str = None,
    ):
        # The ID of the lane group.
        self.group_id = group_id
        # The ID of the namespace.
        # 
        # The ID of a custom namespace is in the region ID:namespace identifier format. Example: cn-beijing:test.\\
        # The ID of the default namespace is in the region ID format. Example: cn-beijing.
        # 
        # This parameter is required.
        self.logical_region_id = logical_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.logical_region_id is not None:
            result['LogicalRegionId'] = self.logical_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('LogicalRegionId') is not None:
            self.logical_region_id = m.get('LogicalRegionId')
        return self


class ListSwimmingLaneGroupResponseBodyDataApplicationList(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        return self


class ListSwimmingLaneGroupResponseBodyDataEntryApplication(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        source: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        # The data source. Set the value to EDAS.
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.source is not None:
            result['Source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        return self


class ListSwimmingLaneGroupResponseBodyData(TeaModel):
    def __init__(
        self,
        application_list: List[ListSwimmingLaneGroupResponseBodyDataApplicationList] = None,
        entry_application: ListSwimmingLaneGroupResponseBodyDataEntryApplication = None,
        id: int = None,
        name: str = None,
        namespace_id: str = None,
    ):
        # The applications that are related to the lane group.
        self.application_list = application_list
        # The information about the Enterprise Distributed Application Service (EDAS) ingress gateway.
        self.entry_application = entry_application
        # The ID of the lane group.
        self.id = id
        # The name of the lane group.
        self.name = name
        # The ID of the microservices namespace.
        self.namespace_id = namespace_id

    def validate(self):
        if self.application_list:
            for k in self.application_list:
                if k:
                    k.validate()
        if self.entry_application:
            self.entry_application.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ApplicationList'] = []
        if self.application_list is not None:
            for k in self.application_list:
                result['ApplicationList'].append(k.to_map() if k else None)
        if self.entry_application is not None:
            result['EntryApplication'] = self.entry_application.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.application_list = []
        if m.get('ApplicationList') is not None:
            for k in m.get('ApplicationList'):
                temp_model = ListSwimmingLaneGroupResponseBodyDataApplicationList()
                self.application_list.append(temp_model.from_map(k))
        if m.get('EntryApplication') is not None:
            temp_model = ListSwimmingLaneGroupResponseBodyDataEntryApplication()
            self.entry_application = temp_model.from_map(m['EntryApplication'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class ListSwimmingLaneGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[ListSwimmingLaneGroupResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The data of the lane group.
        self.data = data
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListSwimmingLaneGroupResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListSwimmingLaneGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSwimmingLaneGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSwimmingLaneGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTagResourcesRequest(TeaModel):
    def __init__(
        self,
        resource_ids: Dict[str, Any] = None,
        resource_region_id: str = None,
        resource_type: str = None,
        tags: Dict[str, Any] = None,
    ):
        # The IDs of the resources. You can specify up to 20 IDs. Set this parameter to a JSON array.
        self.resource_ids = resource_ids
        # The region in which the resource resides.
        # 
        # This parameter is required.
        self.resource_region_id = resource_region_id
        # The type of the resource. Valid values:
        # 
        # *   **application**: Enterprise Distributed Application Service (EDAS) application
        # *   **cluster**: EDAS cluster
        # 
        # This parameter is required.
        self.resource_type = resource_type
        # The key-value pairs that specify the tags.
        # 
        # *   You can add up to 20 tags to a resource.
        # *   The key cannot start with **aliyun** or **acs:** and cannot contain **http://** or **https://**.
        # *   The tag key or tag value can be up to 128 characters in length, and can contain letters, digits, hyphens (-), commas (,), asterisks (\\*), forward slashes (/), question marks (?), and colons (:).
        # *   Set this parameter to a JSON array.
        self.tags = tags

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_ids is not None:
            result['ResourceIds'] = self.resource_ids
        if self.resource_region_id is not None:
            result['ResourceRegionId'] = self.resource_region_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceIds') is not None:
            self.resource_ids = m.get('ResourceIds')
        if m.get('ResourceRegionId') is not None:
            self.resource_region_id = m.get('ResourceRegionId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class ListTagResourcesResponseBodyTagResourcesTagResource(TeaModel):
    def __init__(
        self,
        resource_id: str = None,
        resource_type: str = None,
        tag_key: str = None,
        tag_value: str = None,
    ):
        # The ID of the resource.
        self.resource_id = resource_id
        # The type of the resource.
        self.resource_type = resource_type
        # The tag key of the resource.
        self.tag_key = tag_key
        # The tag value of the resource.
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class ListTagResourcesResponseBodyTagResources(TeaModel):
    def __init__(
        self,
        tag_resource: List[ListTagResourcesResponseBodyTagResourcesTagResource] = None,
    ):
        self.tag_resource = tag_resource

    def validate(self):
        if self.tag_resource:
            for k in self.tag_resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TagResource'] = []
        if self.tag_resource is not None:
            for k in self.tag_resource:
                result['TagResource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tag_resource = []
        if m.get('TagResource') is not None:
            for k in m.get('TagResource'):
                temp_model = ListTagResourcesResponseBodyTagResourcesTagResource()
                self.tag_resource.append(temp_model.from_map(k))
        return self


class ListTagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        tag_resources: ListTagResourcesResponseBodyTagResources = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The information about resource tags.
        self.tag_resources = tag_resources

    def validate(self):
        if self.tag_resources:
            self.tag_resources.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.tag_resources is not None:
            result['TagResources'] = self.tag_resources.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TagResources') is not None:
            temp_model = ListTagResourcesResponseBodyTagResources()
            self.tag_resources = temp_model.from_map(m['TagResources'])
        return self


class ListTagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUserDefineRegionRequest(TeaModel):
    def __init__(
        self,
        debug_enable: bool = None,
    ):
        # Specifies whether remote debugging is allowed.
        self.debug_enable = debug_enable

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.debug_enable is not None:
            result['DebugEnable'] = self.debug_enable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DebugEnable') is not None:
            self.debug_enable = m.get('DebugEnable')
        return self


class ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity(TeaModel):
    def __init__(
        self,
        belong_region: str = None,
        debug_enable: bool = None,
        description: str = None,
        id: int = None,
        mse_instance_id: str = None,
        region_id: str = None,
        region_name: str = None,
        registry_type: str = None,
        user_id: str = None,
    ):
        # The ID of the region to which the namespace belongs.
        self.belong_region = belong_region
        # Indicates whether remote debugging is allowed.
        self.debug_enable = debug_enable
        # The description of the namespace.
        self.description = description
        # The unique identifier of the namespace.
        self.id = id
        # The type of the registry. Valid values:
        # 
        # *   default: shared service registry of Enterprise Distributed Application Service (EDAS)
        # *   exclusive_mse: Microservices Engine (MSE) Nacos registry
        self.mse_instance_id = mse_instance_id
        # The ID of the namespace.
        # 
        # > The ID cannot be changed after the namespace is created. The ID is in the `Physical region ID:Logical region identifier` format .
        self.region_id = region_id
        # The name of the namespace.
        self.region_name = region_name
        # The ID of the MSE instance.
        self.registry_type = registry_type
        # The ID of the Alibaba Cloud account to which the namespace belongs.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.belong_region is not None:
            result['BelongRegion'] = self.belong_region
        if self.debug_enable is not None:
            result['DebugEnable'] = self.debug_enable
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.mse_instance_id is not None:
            result['MseInstanceId'] = self.mse_instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.region_name is not None:
            result['RegionName'] = self.region_name
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BelongRegion') is not None:
            self.belong_region = m.get('BelongRegion')
        if m.get('DebugEnable') is not None:
            self.debug_enable = m.get('DebugEnable')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MseInstanceId') is not None:
            self.mse_instance_id = m.get('MseInstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegionName') is not None:
            self.region_name = m.get('RegionName')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListUserDefineRegionResponseBodyUserDefineRegionList(TeaModel):
    def __init__(
        self,
        user_define_region_entity: List[ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity] = None,
    ):
        self.user_define_region_entity = user_define_region_entity

    def validate(self):
        if self.user_define_region_entity:
            for k in self.user_define_region_entity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['UserDefineRegionEntity'] = []
        if self.user_define_region_entity is not None:
            for k in self.user_define_region_entity:
                result['UserDefineRegionEntity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.user_define_region_entity = []
        if m.get('UserDefineRegionEntity') is not None:
            for k in m.get('UserDefineRegionEntity'):
                temp_model = ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity()
                self.user_define_region_entity.append(temp_model.from_map(k))
        return self


class ListUserDefineRegionResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        user_define_region_list: ListUserDefineRegionResponseBodyUserDefineRegionList = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The namespaces.
        self.user_define_region_list = user_define_region_list

    def validate(self):
        if self.user_define_region_list:
            self.user_define_region_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.user_define_region_list is not None:
            result['UserDefineRegionList'] = self.user_define_region_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UserDefineRegionList') is not None:
            temp_model = ListUserDefineRegionResponseBodyUserDefineRegionList()
            self.user_define_region_list = temp_model.from_map(m['UserDefineRegionList'])
        return self


class ListUserDefineRegionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUserDefineRegionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUserDefineRegionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListVpcResponseBodyVpcListVpcEntity(TeaModel):
    def __init__(
        self,
        ecs_num: int = None,
        expired: bool = None,
        region_id: str = None,
        user_id: str = None,
        vpc_id: str = None,
        vpc_name: str = None,
    ):
        # This operation uses only common request headers. For more information, see [Common parameters for API calls](https://help.aliyun.com/document_detail/123488.html).
        self.ecs_num = ecs_num
        # The region ID of the VPC.
        self.expired = expired
        # No request parameters.
        self.region_id = region_id
        # GET /pop/v5/vpc_list HTTP/1.1
        # Common request headers
        self.user_id = user_id
        # The ID of the Alibaba Cloud account to which the VPC belongs.
        self.vpc_id = vpc_id
        # The number of ECS instances associated with the VPC.
        self.vpc_name = vpc_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ecs_num is not None:
            result['EcsNum'] = self.ecs_num
        if self.expired is not None:
            result['Expired'] = self.expired
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vpc_name is not None:
            result['VpcName'] = self.vpc_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EcsNum') is not None:
            self.ecs_num = m.get('EcsNum')
        if m.get('Expired') is not None:
            self.expired = m.get('Expired')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VpcName') is not None:
            self.vpc_name = m.get('VpcName')
        return self


class ListVpcResponseBodyVpcList(TeaModel):
    def __init__(
        self,
        vpc_entity: List[ListVpcResponseBodyVpcListVpcEntity] = None,
    ):
        self.vpc_entity = vpc_entity

    def validate(self):
        if self.vpc_entity:
            for k in self.vpc_entity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VpcEntity'] = []
        if self.vpc_entity is not None:
            for k in self.vpc_entity:
                result['VpcEntity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.vpc_entity = []
        if m.get('VpcEntity') is not None:
            for k in m.get('VpcEntity'):
                temp_model = ListVpcResponseBodyVpcListVpcEntity()
                self.vpc_entity.append(temp_model.from_map(k))
        return self


class ListVpcResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        vpc_list: ListVpcResponseBodyVpcList = None,
    ):
        # The ID of the request.
        self.code = code
        # The information about VPCs.
        self.message = message
        # The name of the VPC.
        self.request_id = request_id
        # Indicates whether the VPC is available. Valid values:
        # - true: The VPC is available.
        # - false: The VPC is unavailable.
        self.vpc_list = vpc_list

    def validate(self):
        if self.vpc_list:
            self.vpc_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.vpc_list is not None:
            result['VpcList'] = self.vpc_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VpcList') is not None:
            temp_model = ListVpcResponseBodyVpcList()
            self.vpc_list = temp_model.from_map(m['VpcList'])
        return self


class ListVpcResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListVpcResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListVpcResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MigrateEcuRequest(TeaModel):
    def __init__(
        self,
        instance_ids: str = None,
        logical_region_id: str = None,
    ):
        # The ID of the ECS instance. Separate multiple IDs with commas (,).
        # 
        # This parameter is required.
        self.instance_ids = instance_ids
        # The ID of the custom namespace.
        # 
        # *   The ID of a custom namespace is in the `region ID:custom namespace ID` format. Example: cn-beijing:tdy218.
        # *   The ID of the default namespace is in the `region ID` format. Example: cn-beijing.
        self.logical_region_id = logical_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.logical_region_id is not None:
            result['LogicalRegionId'] = self.logical_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('LogicalRegionId') is not None:
            self.logical_region_id = m.get('LogicalRegionId')
        return self


class MigrateEcuResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # Indicates whether the request is successful. Valid values:
        # 
        # *   true: The request is successful.
        # *   false: The request fails.
        self.data = data
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class MigrateEcuResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MigrateEcuResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MigrateEcuResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyScalingRuleRequest(TeaModel):
    def __init__(
        self,
        accept_eula: bool = None,
        app_id: str = None,
        group_id: str = None,
        in_condition: str = None,
        in_cpu: int = None,
        in_duration: int = None,
        in_enable: bool = None,
        in_instance_num: int = None,
        in_load: int = None,
        in_rt: int = None,
        in_step: int = None,
        key_pair_name: str = None,
        multi_az_policy: str = None,
        out_cpu: int = None,
        out_condition: str = None,
        out_duration: int = None,
        out_enable: bool = None,
        out_instance_num: int = None,
        out_load: int = None,
        out_rt: int = None,
        out_step: int = None,
        password: str = None,
        resource_from: str = None,
        scaling_policy: str = None,
        template_id: str = None,
        template_instance_id: str = None,
        template_instance_name: str = None,
        template_version: int = None,
        v_switch_ids: str = None,
        vpc_id: str = None,
    ):
        # Set the value to true if scale-outs are allowed.
        self.accept_eula = accept_eula
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the instance group to which the application is deployed.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The relationship among the conditions that trigger a scale-in.
        # 
        # *   OR: one of the conditions
        # *   AND: all conditions
        self.in_condition = in_condition
        # The CPU utilization that triggers a scale-in.
        self.in_cpu = in_cpu
        # The duration in which the metric threshold is exceeded. Unit: minutes.
        self.in_duration = in_duration
        # Specifies whether to allow scale-ins.
        # 
        # *   true: allows scale-ins.
        # *   false: does not allow scale-ins.
        self.in_enable = in_enable
        # The minimum number of instances that must be retained in each group when a scale-in is performed.
        self.in_instance_num = in_instance_num
        # The system load that triggers a scale-in.
        self.in_load = in_load
        # The minimum service latency that triggers a scale-in. The lower limit is 0. Unit: milliseconds.
        self.in_rt = in_rt
        # The number of instances that are removed during each scale-in.
        self.in_step = in_step
        # The key pair that is used to log on to the instance. This parameter takes effect only if you choose to create instances based on the specifications of an existing instance during a scale-out.
        self.key_pair_name = key_pair_name
        # The multi-zone scaling policy. Valid values:
        # 
        # *   PRIORITY: The vSwitch that is first selected has the highest priority.
        # *   BALANCE: This policy evenly distributes instances across zones in which the vSwitches reside.
        self.multi_az_policy = multi_az_policy
        # The CPU utilization that triggers a scale-out.
        self.out_cpu = out_cpu
        # The relationship among the conditions that trigger a scale-out.
        # 
        # *   OR: one of the conditions
        # *   AND: all conditions
        self.out_condition = out_condition
        # The duration in which the metric threshold is exceeded. Unit: minutes.
        self.out_duration = out_duration
        # Specifies whether to allow scale-outs.
        self.out_enable = out_enable
        # The maximum number of instances in each group when a scale-out is performed.
        self.out_instance_num = out_instance_num
        # The system load that triggers a scale-out.
        self.out_load = out_load
        # The minimum service latency that triggers a scale-out. The lower limit is 0. Unit: milliseconds.
        self.out_rt = out_rt
        # The number of instances that are added during each scale-out.
        self.out_step = out_step
        # The password that is used to log on to the instance. This parameter takes effect only if you choose to create instances based on the specifications of an existing instance during a scale-out.
        self.password = password
        # The source of the instance to be added during a scale-out. Valid values:
        # 
        # *   NEW: elastic resources
        # *   AVAILABLE: existing resources If you prefer existing resources to elastic resources, set this parameter to AVAILABLE_FIRST.
        # 
        # If you set this parameter to NEW or AVAILABLE_FIRST, you must specify the auto-scaling parameters. If you set this parameter to NEW, instances are created based on a launch template or the specifications of an existing instance.
        self.resource_from = resource_from
        # The instance handling mode during a scale-in. Valid values:
        # 
        # *   release: When a scale-in is performed, instances that are no longer used are released.
        # *   recycle: When a scale-in is performed, instances that are no longer used are stopped and reclaimed.
        self.scaling_policy = scaling_policy
        # The ID of the launch template that is used to create instances during a scale-out. This parameter takes effect only if you set the OutEnable parameter to true. This parameter takes precedence over the TemplateInstanceId parameter.
        self.template_id = template_id
        # The ID of the instance whose specifications are used to create instances during a scale-out. This parameter is valid only when you set the OutEnable parameter to true.
        self.template_instance_id = template_instance_id
        # The name of the instance whose specifications are used to create instances during a scale-out. This parameter takes effect only if you specify the TemplateInstanceId parameter.
        self.template_instance_name = template_instance_name
        # The version of the launch template that is used to create instances during a scale-out. This parameter takes effect only if you set the OutEnable parameter to true. To use the default template version, set this parameter to `-1`. Otherwise, set this parameter to the version that you want to use.
        self.template_version = template_version
        # The IDs of the vSwitches that are associated with the VPC. Separate multiple IDs with commas (,).
        self.v_switch_ids = v_switch_ids
        # The ID of the virtual private cloud (VPC) that is associated with the instances created based on a launch template or the specifications of an existing instance.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_eula is not None:
            result['AcceptEULA'] = self.accept_eula
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.in_condition is not None:
            result['InCondition'] = self.in_condition
        if self.in_cpu is not None:
            result['InCpu'] = self.in_cpu
        if self.in_duration is not None:
            result['InDuration'] = self.in_duration
        if self.in_enable is not None:
            result['InEnable'] = self.in_enable
        if self.in_instance_num is not None:
            result['InInstanceNum'] = self.in_instance_num
        if self.in_load is not None:
            result['InLoad'] = self.in_load
        if self.in_rt is not None:
            result['InRT'] = self.in_rt
        if self.in_step is not None:
            result['InStep'] = self.in_step
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.multi_az_policy is not None:
            result['MultiAzPolicy'] = self.multi_az_policy
        if self.out_cpu is not None:
            result['OutCPU'] = self.out_cpu
        if self.out_condition is not None:
            result['OutCondition'] = self.out_condition
        if self.out_duration is not None:
            result['OutDuration'] = self.out_duration
        if self.out_enable is not None:
            result['OutEnable'] = self.out_enable
        if self.out_instance_num is not None:
            result['OutInstanceNum'] = self.out_instance_num
        if self.out_load is not None:
            result['OutLoad'] = self.out_load
        if self.out_rt is not None:
            result['OutRT'] = self.out_rt
        if self.out_step is not None:
            result['OutStep'] = self.out_step
        if self.password is not None:
            result['Password'] = self.password
        if self.resource_from is not None:
            result['ResourceFrom'] = self.resource_from
        if self.scaling_policy is not None:
            result['ScalingPolicy'] = self.scaling_policy
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_instance_id is not None:
            result['TemplateInstanceId'] = self.template_instance_id
        if self.template_instance_name is not None:
            result['TemplateInstanceName'] = self.template_instance_name
        if self.template_version is not None:
            result['TemplateVersion'] = self.template_version
        if self.v_switch_ids is not None:
            result['VSwitchIds'] = self.v_switch_ids
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptEULA') is not None:
            self.accept_eula = m.get('AcceptEULA')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InCondition') is not None:
            self.in_condition = m.get('InCondition')
        if m.get('InCpu') is not None:
            self.in_cpu = m.get('InCpu')
        if m.get('InDuration') is not None:
            self.in_duration = m.get('InDuration')
        if m.get('InEnable') is not None:
            self.in_enable = m.get('InEnable')
        if m.get('InInstanceNum') is not None:
            self.in_instance_num = m.get('InInstanceNum')
        if m.get('InLoad') is not None:
            self.in_load = m.get('InLoad')
        if m.get('InRT') is not None:
            self.in_rt = m.get('InRT')
        if m.get('InStep') is not None:
            self.in_step = m.get('InStep')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('MultiAzPolicy') is not None:
            self.multi_az_policy = m.get('MultiAzPolicy')
        if m.get('OutCPU') is not None:
            self.out_cpu = m.get('OutCPU')
        if m.get('OutCondition') is not None:
            self.out_condition = m.get('OutCondition')
        if m.get('OutDuration') is not None:
            self.out_duration = m.get('OutDuration')
        if m.get('OutEnable') is not None:
            self.out_enable = m.get('OutEnable')
        if m.get('OutInstanceNum') is not None:
            self.out_instance_num = m.get('OutInstanceNum')
        if m.get('OutLoad') is not None:
            self.out_load = m.get('OutLoad')
        if m.get('OutRT') is not None:
            self.out_rt = m.get('OutRT')
        if m.get('OutStep') is not None:
            self.out_step = m.get('OutStep')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('ResourceFrom') is not None:
            self.resource_from = m.get('ResourceFrom')
        if m.get('ScalingPolicy') is not None:
            self.scaling_policy = m.get('ScalingPolicy')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateInstanceId') is not None:
            self.template_instance_id = m.get('TemplateInstanceId')
        if m.get('TemplateInstanceName') is not None:
            self.template_instance_name = m.get('TemplateInstanceName')
        if m.get('TemplateVersion') is not None:
            self.template_version = m.get('TemplateVersion')
        if m.get('VSwitchIds') is not None:
            self.v_switch_ids = m.get('VSwitchIds')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class ModifyScalingRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyScalingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyScalingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyScalingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryApplicationStatusRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class QueryApplicationStatusResponseBodyAppInfoApplication(TeaModel):
    def __init__(
        self,
        application_id: str = None,
        build_package_id: int = None,
        cluster_id: str = None,
        cpu: int = None,
        create_time: int = None,
        dockerize: bool = None,
        email: str = None,
        health_check_url: str = None,
        instance_count: int = None,
        launch_time: int = None,
        memory: int = None,
        name: str = None,
        owner: str = None,
        phone: str = None,
        port: int = None,
        region_id: str = None,
        running_instance_count: int = None,
        user_id: str = None,
    ):
        # The ID of the application.
        self.application_id = application_id
        # The build package number of Enterprise Distributed Application Service (EDAS) Container.
        self.build_package_id = build_package_id
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The number of CPU cores used by the application.
        self.cpu = cpu
        # The time when the application was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # Indicates whether the application is a Docker application.
        self.dockerize = dockerize
        # The email address of the user who created the application.
        self.email = email
        # The health check URL.
        self.health_check_url = health_check_url
        # The number of application instances.
        self.instance_count = instance_count
        # The time when the application was launched. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.launch_time = launch_time
        # The memory size.
        self.memory = memory
        # The name of the application.
        self.name = name
        # The ID of the user who created the application.
        self.owner = owner
        # The mobile number of the user who created the application.
        self.phone = phone
        # The port used by the application.
        self.port = port
        # The ID of the namespace.
        self.region_id = region_id
        # The number of application instances that are running.
        self.running_instance_count = running_instance_count
        # The ID of the Alibaba Cloud account.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_id is not None:
            result['ApplicationId'] = self.application_id
        if self.build_package_id is not None:
            result['BuildPackageId'] = self.build_package_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.dockerize is not None:
            result['Dockerize'] = self.dockerize
        if self.email is not None:
            result['Email'] = self.email
        if self.health_check_url is not None:
            result['HealthCheckUrl'] = self.health_check_url
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.launch_time is not None:
            result['LaunchTime'] = self.launch_time
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.phone is not None:
            result['Phone'] = self.phone
        if self.port is not None:
            result['Port'] = self.port
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.running_instance_count is not None:
            result['RunningInstanceCount'] = self.running_instance_count
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationId') is not None:
            self.application_id = m.get('ApplicationId')
        if m.get('BuildPackageId') is not None:
            self.build_package_id = m.get('BuildPackageId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Dockerize') is not None:
            self.dockerize = m.get('Dockerize')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('HealthCheckUrl') is not None:
            self.health_check_url = m.get('HealthCheckUrl')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('LaunchTime') is not None:
            self.launch_time = m.get('LaunchTime')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Phone') is not None:
            self.phone = m.get('Phone')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RunningInstanceCount') is not None:
            self.running_instance_count = m.get('RunningInstanceCount')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        deploy_record_id: str = None,
        ecc_id: str = None,
        ecu_id: str = None,
        package_md_5: str = None,
        package_version_id: str = None,
    ):
        # The time when the deployment record was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The ID of the deployment record.
        self.deploy_record_id = deploy_record_id
        # The unique ID of the ECC.
        self.ecc_id = ecc_id
        # The unique ID of the ECU.
        self.ecu_id = ecu_id
        # The MD5 hash value of the deployment package.
        self.package_md_5 = package_md_5
        # The version of the deployment package that was used to deploy an application in the instance group.
        self.package_version_id = package_version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deploy_record_id is not None:
            result['DeployRecordId'] = self.deploy_record_id
        if self.ecc_id is not None:
            result['EccId'] = self.ecc_id
        if self.ecu_id is not None:
            result['EcuId'] = self.ecu_id
        if self.package_md_5 is not None:
            result['PackageMd5'] = self.package_md_5
        if self.package_version_id is not None:
            result['PackageVersionId'] = self.package_version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeployRecordId') is not None:
            self.deploy_record_id = m.get('DeployRecordId')
        if m.get('EccId') is not None:
            self.ecc_id = m.get('EccId')
        if m.get('EcuId') is not None:
            self.ecu_id = m.get('EcuId')
        if m.get('PackageMd5') is not None:
            self.package_md_5 = m.get('PackageMd5')
        if m.get('PackageVersionId') is not None:
            self.package_version_id = m.get('PackageVersionId')
        return self


class QueryApplicationStatusResponseBodyAppInfoDeployRecordList(TeaModel):
    def __init__(
        self,
        deploy_record: List[QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord] = None,
    ):
        self.deploy_record = deploy_record

    def validate(self):
        if self.deploy_record:
            for k in self.deploy_record:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeployRecord'] = []
        if self.deploy_record is not None:
            for k in self.deploy_record:
                result['DeployRecord'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.deploy_record = []
        if m.get('DeployRecord') is not None:
            for k in m.get('DeployRecord'):
                temp_model = QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord()
                self.deploy_record.append(temp_model.from_map(k))
        return self


class QueryApplicationStatusResponseBodyAppInfoEccListEcc(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_state: int = None,
        container_status: str = None,
        create_time: int = None,
        ecc_id: str = None,
        ecu_id: str = None,
        group_id: str = None,
        ip: str = None,
        task_state: int = None,
        update_time: int = None,
        vpc_id: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The status of the application instance. Valid values:
        # 
        # *   0: AGENT_OFF: indicates that the agent is offline.
        # *   1: STOPPED: indicates that the application is stopped.
        # *   3: RUNNING_BUT_URL_FAILED: indicates that the health check failed.
        # *   7: RUNNING: indicates that the application is running.
        self.app_state = app_state
        # The status of the container.
        self.container_status = container_status
        # The time when the ECC was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The unique ID of the ECC.
        self.ecc_id = ecc_id
        # The unique ID of the ECU.
        self.ecu_id = ecu_id
        # The ID of the instance group.
        self.group_id = group_id
        # The private IP address of the ECU.
        self.ip = ip
        # The state of the latest task initiated on the application instance. Valid values:
        # 
        # *   0: UNKNOWN: indicates that the state of the latest task is unknown.
        # *   1: PROCESSING: indicates that the latest task is being processed.
        # *   2: SUCCESS: indicates that the latest task is executed.
        # *   3: FAILED: indicates that the latest task failed.
        self.task_state = task_state
        # The time when the ECC was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time
        # The ID of the VPC.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_state is not None:
            result['AppState'] = self.app_state
        if self.container_status is not None:
            result['ContainerStatus'] = self.container_status
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.ecc_id is not None:
            result['EccId'] = self.ecc_id
        if self.ecu_id is not None:
            result['EcuId'] = self.ecu_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.task_state is not None:
            result['TaskState'] = self.task_state
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppState') is not None:
            self.app_state = m.get('AppState')
        if m.get('ContainerStatus') is not None:
            self.container_status = m.get('ContainerStatus')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('EccId') is not None:
            self.ecc_id = m.get('EccId')
        if m.get('EcuId') is not None:
            self.ecu_id = m.get('EcuId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('TaskState') is not None:
            self.task_state = m.get('TaskState')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class QueryApplicationStatusResponseBodyAppInfoEccList(TeaModel):
    def __init__(
        self,
        ecc: List[QueryApplicationStatusResponseBodyAppInfoEccListEcc] = None,
    ):
        self.ecc = ecc

    def validate(self):
        if self.ecc:
            for k in self.ecc:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ecc'] = []
        if self.ecc is not None:
            for k in self.ecc:
                result['Ecc'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ecc = []
        if m.get('Ecc') is not None:
            for k in m.get('Ecc'):
                temp_model = QueryApplicationStatusResponseBodyAppInfoEccListEcc()
                self.ecc.append(temp_model.from_map(k))
        return self


class QueryApplicationStatusResponseBodyAppInfoEcuListEcu(TeaModel):
    def __init__(
        self,
        available_cpu: int = None,
        available_mem: int = None,
        create_time: int = None,
        docker_env: bool = None,
        ecu_id: str = None,
        group_id: str = None,
        heartbeat_time: int = None,
        instance_id: str = None,
        ip_addr: str = None,
        name: str = None,
        online: bool = None,
        region_id: str = None,
        update_time: int = None,
        user_id: str = None,
        vpc_id: str = None,
        zone_id: str = None,
    ):
        # The number of available CPU cores.
        self.available_cpu = available_cpu
        # The size of the available memory.
        self.available_mem = available_mem
        # The time when the ECU was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # Indicates whether Docker is installed.
        self.docker_env = docker_env
        # The unique ID of the ECU. You can run the `dmidecode` command on the ECS instance to query the ECU ID.
        self.ecu_id = ecu_id
        # The ID of the group.
        self.group_id = group_id
        # The time when the last heartbeat detection was performed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.heartbeat_time = heartbeat_time
        # The ID of the instance.
        self.instance_id = instance_id
        # The private IP address of the ECU.
        self.ip_addr = ip_addr
        # The name of the ECU.
        self.name = name
        # Indicates whether the ECU is online.
        self.online = online
        # The ID of the region.
        self.region_id = region_id
        # The time when the ECU was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time
        # The ID of the user associated with the ECU.
        self.user_id = user_id
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id
        # The ID of the zone.
        self.zone_id = zone_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_cpu is not None:
            result['AvailableCpu'] = self.available_cpu
        if self.available_mem is not None:
            result['AvailableMem'] = self.available_mem
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.docker_env is not None:
            result['DockerEnv'] = self.docker_env
        if self.ecu_id is not None:
            result['EcuId'] = self.ecu_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.heartbeat_time is not None:
            result['HeartbeatTime'] = self.heartbeat_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ip_addr is not None:
            result['IpAddr'] = self.ip_addr
        if self.name is not None:
            result['Name'] = self.name
        if self.online is not None:
            result['Online'] = self.online
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvailableCpu') is not None:
            self.available_cpu = m.get('AvailableCpu')
        if m.get('AvailableMem') is not None:
            self.available_mem = m.get('AvailableMem')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DockerEnv') is not None:
            self.docker_env = m.get('DockerEnv')
        if m.get('EcuId') is not None:
            self.ecu_id = m.get('EcuId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('HeartbeatTime') is not None:
            self.heartbeat_time = m.get('HeartbeatTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IpAddr') is not None:
            self.ip_addr = m.get('IpAddr')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Online') is not None:
            self.online = m.get('Online')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class QueryApplicationStatusResponseBodyAppInfoEcuList(TeaModel):
    def __init__(
        self,
        ecu: List[QueryApplicationStatusResponseBodyAppInfoEcuListEcu] = None,
    ):
        self.ecu = ecu

    def validate(self):
        if self.ecu:
            for k in self.ecu:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ecu'] = []
        if self.ecu is not None:
            for k in self.ecu:
                result['Ecu'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ecu = []
        if m.get('Ecu') is not None:
            for k in m.get('Ecu'):
                temp_model = QueryApplicationStatusResponseBodyAppInfoEcuListEcu()
                self.ecu.append(temp_model.from_map(k))
        return self


class QueryApplicationStatusResponseBodyAppInfoGroupListGroup(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_version_id: str = None,
        cluster_id: str = None,
        create_time: int = None,
        group_id: str = None,
        group_name: str = None,
        group_type: int = None,
        package_version_id: str = None,
        update_time: int = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The ID of the change process for application deployment in the instance group.
        self.app_version_id = app_version_id
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The time when the instance group was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The ID of the instance group.
        self.group_id = group_id
        # The name of the instance group.
        self.group_name = group_name
        # The type of the instance group. Valid values:
        # 
        # *   0: default group
        # *   1: self-managed group
        # *   2: canary release group
        self.group_type = group_type
        # The version of the deployment package that was used to deploy an application in the instance group.
        self.package_version_id = package_version_id
        # The time when the instance group was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_version_id is not None:
            result['AppVersionId'] = self.app_version_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.package_version_id is not None:
            result['PackageVersionId'] = self.package_version_id
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppVersionId') is not None:
            self.app_version_id = m.get('AppVersionId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('PackageVersionId') is not None:
            self.package_version_id = m.get('PackageVersionId')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class QueryApplicationStatusResponseBodyAppInfoGroupList(TeaModel):
    def __init__(
        self,
        group: List[QueryApplicationStatusResponseBodyAppInfoGroupListGroup] = None,
    ):
        self.group = group

    def validate(self):
        if self.group:
            for k in self.group:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Group'] = []
        if self.group is not None:
            for k in self.group:
                result['Group'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.group = []
        if m.get('Group') is not None:
            for k in m.get('Group'):
                temp_model = QueryApplicationStatusResponseBodyAppInfoGroupListGroup()
                self.group.append(temp_model.from_map(k))
        return self


class QueryApplicationStatusResponseBodyAppInfo(TeaModel):
    def __init__(
        self,
        application: QueryApplicationStatusResponseBodyAppInfoApplication = None,
        deploy_record_list: QueryApplicationStatusResponseBodyAppInfoDeployRecordList = None,
        ecc_list: QueryApplicationStatusResponseBodyAppInfoEccList = None,
        ecu_list: QueryApplicationStatusResponseBodyAppInfoEcuList = None,
        group_list: QueryApplicationStatusResponseBodyAppInfoGroupList = None,
    ):
        # The basic information about the application.
        self.application = application
        # The information about deployment records.
        self.deploy_record_list = deploy_record_list
        # The information about elastic compute containers (ECCs).
        self.ecc_list = ecc_list
        # The information about elastic compute units (ECUs).
        self.ecu_list = ecu_list
        # The information about the instance groups.
        self.group_list = group_list

    def validate(self):
        if self.application:
            self.application.validate()
        if self.deploy_record_list:
            self.deploy_record_list.validate()
        if self.ecc_list:
            self.ecc_list.validate()
        if self.ecu_list:
            self.ecu_list.validate()
        if self.group_list:
            self.group_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application is not None:
            result['Application'] = self.application.to_map()
        if self.deploy_record_list is not None:
            result['DeployRecordList'] = self.deploy_record_list.to_map()
        if self.ecc_list is not None:
            result['EccList'] = self.ecc_list.to_map()
        if self.ecu_list is not None:
            result['EcuList'] = self.ecu_list.to_map()
        if self.group_list is not None:
            result['GroupList'] = self.group_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Application') is not None:
            temp_model = QueryApplicationStatusResponseBodyAppInfoApplication()
            self.application = temp_model.from_map(m['Application'])
        if m.get('DeployRecordList') is not None:
            temp_model = QueryApplicationStatusResponseBodyAppInfoDeployRecordList()
            self.deploy_record_list = temp_model.from_map(m['DeployRecordList'])
        if m.get('EccList') is not None:
            temp_model = QueryApplicationStatusResponseBodyAppInfoEccList()
            self.ecc_list = temp_model.from_map(m['EccList'])
        if m.get('EcuList') is not None:
            temp_model = QueryApplicationStatusResponseBodyAppInfoEcuList()
            self.ecu_list = temp_model.from_map(m['EcuList'])
        if m.get('GroupList') is not None:
            temp_model = QueryApplicationStatusResponseBodyAppInfoGroupList()
            self.group_list = temp_model.from_map(m['GroupList'])
        return self


class QueryApplicationStatusResponseBody(TeaModel):
    def __init__(
        self,
        app_info: QueryApplicationStatusResponseBodyAppInfo = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The information about the application.
        self.app_info = app_info
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.app_info:
            self.app_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_info is not None:
            result['AppInfo'] = self.app_info.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppInfo') is not None:
            temp_model = QueryApplicationStatusResponseBodyAppInfo()
            self.app_info = temp_model.from_map(m['AppInfo'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryApplicationStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryApplicationStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryApplicationStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryEccInfoRequest(TeaModel):
    def __init__(
        self,
        ecc_id: str = None,
    ):
        # The ID of the ECC.
        # 
        # This parameter is required.
        self.ecc_id = ecc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ecc_id is not None:
            result['EccId'] = self.ecc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EccId') is not None:
            self.ecc_id = m.get('EccId')
        return self


class QueryEccInfoResponseBodyEccInfo(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        ecc_id: str = None,
        ecu_id: str = None,
        group_id: str = None,
        group_name: str = None,
        package_md_5: str = None,
        package_version: str = None,
        vpc_id: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # ECC ID
        self.ecc_id = ecc_id
        # ECU ID
        self.ecu_id = ecu_id
        # The ID of the ECC group.
        self.group_id = group_id
        # The name of the ECC group.
        self.group_name = group_name
        # The MD5 hash value of the deployment package version.
        self.package_md_5 = package_md_5
        # The version of the deployment package.
        self.package_version = package_version
        # VPC ID
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.ecc_id is not None:
            result['EccId'] = self.ecc_id
        if self.ecu_id is not None:
            result['EcuId'] = self.ecu_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.package_md_5 is not None:
            result['PackageMd5'] = self.package_md_5
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EccId') is not None:
            self.ecc_id = m.get('EccId')
        if m.get('EcuId') is not None:
            self.ecu_id = m.get('EcuId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('PackageMd5') is not None:
            self.package_md_5 = m.get('PackageMd5')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class QueryEccInfoResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        ecc_info: QueryEccInfoResponseBodyEccInfo = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The information about the ECC.
        self.ecc_info = ecc_info
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.ecc_info:
            self.ecc_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.ecc_info is not None:
            result['EccInfo'] = self.ecc_info.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EccInfo') is not None:
            temp_model = QueryEccInfoResponseBodyEccInfo()
            self.ecc_info = temp_model.from_map(m['EccInfo'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryEccInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryEccInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryEccInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMigrateEcuListRequest(TeaModel):
    def __init__(
        self,
        logical_region_id: str = None,
    ):
        # The ID of the namespace.
        # 
        # *   The ID of a custom namespace is in the `region ID:namespace identifier` format. Example: `cn-beijing:test`.
        # *   The ID of the default namespace is in the `region ID` format. Example: `cn-beijing`.
        self.logical_region_id = logical_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logical_region_id is not None:
            result['LogicalRegionId'] = self.logical_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LogicalRegionId') is not None:
            self.logical_region_id = m.get('LogicalRegionId')
        return self


class QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity(TeaModel):
    def __init__(
        self,
        available_cpu: int = None,
        available_mem: int = None,
        cpu: int = None,
        create_time: int = None,
        docker_env: bool = None,
        ecu_id: str = None,
        heartbeat_time: int = None,
        instance_id: str = None,
        ip_addr: str = None,
        mem: int = None,
        name: str = None,
        online: bool = None,
        region_id: str = None,
        update_time: int = None,
        user_id: str = None,
        vpc_id: str = None,
        zone_id: str = None,
    ):
        # The number of available CPUs. Unit: cores.
        self.available_cpu = available_cpu
        # The size of available memory. Unit: MB.
        self.available_mem = available_mem
        # The CPU quota set by the system. Unit: cores. The value 0 indicates that no quota is set by the system.
        self.cpu = cpu
        # The time when the ECU was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # Indicates whether Docker is installed. Valid values:
        # 
        # *   true: Docker is installed.
        # *   false: Docker is not installed.
        self.docker_env = docker_env
        # The unique ID of the ECU. To query the ID, you can run the `dmidecode` command on the ECS instance that corresponds to the ECU.
        self.ecu_id = ecu_id
        # The time when the last heartbeat detection was performed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.heartbeat_time = heartbeat_time
        # The ID of the ECU.
        self.instance_id = instance_id
        # The private IP address of the ECU.
        self.ip_addr = ip_addr
        # The total size of memory.
        self.mem = mem
        # The name of the ECU.
        self.name = name
        # Indicates whether the ECU is online. Valid values:
        # 
        # *   true: The ECU is online.
        # *   false: The ECU is offline.
        self.online = online
        # The ID of the region where the ECU resides.
        self.region_id = region_id
        # The time when the ECU was updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time
        # The ID of the Alibaba Cloud account to which the ECU belongs.
        self.user_id = user_id
        # VPC ID
        self.vpc_id = vpc_id
        # The ID of the zone where the ECU resides.
        self.zone_id = zone_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_cpu is not None:
            result['AvailableCpu'] = self.available_cpu
        if self.available_mem is not None:
            result['AvailableMem'] = self.available_mem
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.docker_env is not None:
            result['DockerEnv'] = self.docker_env
        if self.ecu_id is not None:
            result['EcuId'] = self.ecu_id
        if self.heartbeat_time is not None:
            result['HeartbeatTime'] = self.heartbeat_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ip_addr is not None:
            result['IpAddr'] = self.ip_addr
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.name is not None:
            result['Name'] = self.name
        if self.online is not None:
            result['Online'] = self.online
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvailableCpu') is not None:
            self.available_cpu = m.get('AvailableCpu')
        if m.get('AvailableMem') is not None:
            self.available_mem = m.get('AvailableMem')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DockerEnv') is not None:
            self.docker_env = m.get('DockerEnv')
        if m.get('EcuId') is not None:
            self.ecu_id = m.get('EcuId')
        if m.get('HeartbeatTime') is not None:
            self.heartbeat_time = m.get('HeartbeatTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IpAddr') is not None:
            self.ip_addr = m.get('IpAddr')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Online') is not None:
            self.online = m.get('Online')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class QueryMigrateEcuListResponseBodyEcuEntityList(TeaModel):
    def __init__(
        self,
        ecu_entity: List[QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity] = None,
    ):
        self.ecu_entity = ecu_entity

    def validate(self):
        if self.ecu_entity:
            for k in self.ecu_entity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EcuEntity'] = []
        if self.ecu_entity is not None:
            for k in self.ecu_entity:
                result['EcuEntity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ecu_entity = []
        if m.get('EcuEntity') is not None:
            for k in m.get('EcuEntity'):
                temp_model = QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity()
                self.ecu_entity.append(temp_model.from_map(k))
        return self


class QueryMigrateEcuListResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        ecu_entity_list: QueryMigrateEcuListResponseBodyEcuEntityList = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The information about ECUs that can be migrated.
        self.ecu_entity_list = ecu_entity_list
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.ecu_entity_list:
            self.ecu_entity_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.ecu_entity_list is not None:
            result['EcuEntityList'] = self.ecu_entity_list.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EcuEntityList') is not None:
            temp_model = QueryMigrateEcuListResponseBodyEcuEntityList()
            self.ecu_entity_list = temp_model.from_map(m['EcuEntityList'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryMigrateEcuListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMigrateEcuListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMigrateEcuListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMigrateRegionListRequest(TeaModel):
    def __init__(
        self,
        logical_region_id: str = None,
    ):
        # The ID of the namespace.
        self.logical_region_id = logical_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logical_region_id is not None:
            result['LogicalRegionId'] = self.logical_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LogicalRegionId') is not None:
            self.logical_region_id = m.get('LogicalRegionId')
        return self


class QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity(TeaModel):
    def __init__(
        self,
        region_name: str = None,
        region_no: str = None,
    ):
        # The name of the namespace.
        self.region_name = region_name
        # The ID of the namespace.
        self.region_no = region_no

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_name is not None:
            result['RegionName'] = self.region_name
        if self.region_no is not None:
            result['RegionNo'] = self.region_no
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionName') is not None:
            self.region_name = m.get('RegionName')
        if m.get('RegionNo') is not None:
            self.region_no = m.get('RegionNo')
        return self


class QueryMigrateRegionListResponseBodyRegionEntityList(TeaModel):
    def __init__(
        self,
        region_entity: List[QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity] = None,
    ):
        self.region_entity = region_entity

    def validate(self):
        if self.region_entity:
            for k in self.region_entity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RegionEntity'] = []
        if self.region_entity is not None:
            for k in self.region_entity:
                result['RegionEntity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.region_entity = []
        if m.get('RegionEntity') is not None:
            for k in m.get('RegionEntity'):
                temp_model = QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity()
                self.region_entity.append(temp_model.from_map(k))
        return self


class QueryMigrateRegionListResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        region_entity_list: QueryMigrateRegionListResponseBodyRegionEntityList = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The namespaces.
        self.region_entity_list = region_entity_list
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.region_entity_list:
            self.region_entity_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.region_entity_list is not None:
            result['RegionEntityList'] = self.region_entity_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RegionEntityList') is not None:
            temp_model = QueryMigrateRegionListResponseBodyRegionEntityList()
            self.region_entity_list = temp_model.from_map(m['RegionEntityList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryMigrateRegionListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMigrateRegionListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMigrateRegionListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryRegionConfigResponseBodyRegionConfigFileServerConfig(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        internal_url: str = None,
        public_url: str = None,
        vpc_url: str = None,
    ):
        # The Object Storage Service (OSS) bucket of the file server.
        self.bucket = bucket
        # The internal endpoint of the file server.
        self.internal_url = internal_url
        # The public endpoint of the file server.
        self.public_url = public_url
        # The virtual private cloud (VPC) endpoint of the file server.
        self.vpc_url = vpc_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.internal_url is not None:
            result['InternalUrl'] = self.internal_url
        if self.public_url is not None:
            result['PublicUrl'] = self.public_url
        if self.vpc_url is not None:
            result['VpcUrl'] = self.vpc_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('InternalUrl') is not None:
            self.internal_url = m.get('InternalUrl')
        if m.get('PublicUrl') is not None:
            self.public_url = m.get('PublicUrl')
        if m.get('VpcUrl') is not None:
            self.vpc_url = m.get('VpcUrl')
        return self


class QueryRegionConfigResponseBodyRegionConfig(TeaModel):
    def __init__(
        self,
        address_server_host: str = None,
        agent_install_script: str = None,
        file_server_config: QueryRegionConfigResponseBodyRegionConfigFileServerConfig = None,
        file_server_type: str = None,
        id: str = None,
        image_id: str = None,
        name: str = None,
        no: int = None,
        tag: str = None,
    ):
        # The domain name of Address Server.
        self.address_server_host = address_server_host
        # The installation path of the script for EDAS Agent.
        self.agent_install_script = agent_install_script
        # The information about the file server.
        self.file_server_config = file_server_config
        # The type of the file server.
        self.file_server_type = file_server_type
        # The configured ID of the region.
        self.id = id
        # The ID of the official image.
        self.image_id = image_id
        # The configured name of the region.
        self.name = name
        # The serial number of the region. This parameter is deprecated.
        self.no = no
        # The tag of the region. The value is fixed to `ALIYUN_SHARE`.
        self.tag = tag

    def validate(self):
        if self.file_server_config:
            self.file_server_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_server_host is not None:
            result['AddressServerHost'] = self.address_server_host
        if self.agent_install_script is not None:
            result['AgentInstallScript'] = self.agent_install_script
        if self.file_server_config is not None:
            result['FileServerConfig'] = self.file_server_config.to_map()
        if self.file_server_type is not None:
            result['FileServerType'] = self.file_server_type
        if self.id is not None:
            result['Id'] = self.id
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.name is not None:
            result['Name'] = self.name
        if self.no is not None:
            result['No'] = self.no
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressServerHost') is not None:
            self.address_server_host = m.get('AddressServerHost')
        if m.get('AgentInstallScript') is not None:
            self.agent_install_script = m.get('AgentInstallScript')
        if m.get('FileServerConfig') is not None:
            temp_model = QueryRegionConfigResponseBodyRegionConfigFileServerConfig()
            self.file_server_config = temp_model.from_map(m['FileServerConfig'])
        if m.get('FileServerType') is not None:
            self.file_server_type = m.get('FileServerType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('No') is not None:
            self.no = m.get('No')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class QueryRegionConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        region_config: QueryRegionConfigResponseBodyRegionConfig = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The information about region configurations.
        self.region_config = region_config
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.region_config:
            self.region_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.region_config is not None:
            result['RegionConfig'] = self.region_config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RegionConfig') is not None:
            temp_model = QueryRegionConfigResponseBodyRegionConfig()
            self.region_config = temp_model.from_map(m['RegionConfig'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryRegionConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryRegionConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryRegionConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySlsLogStoreListRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        current_page: int = None,
        page_size: int = None,
        type: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The number of the page to return. Pages start from Page 1.
        self.current_page = current_page
        # The number of entries to return on each page.
        self.page_size = page_size
        # The type of data that is collected by Log Service. Valid values:
        # 
        # *   file: the file type
        # *   stdout: the standard output type
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QuerySlsLogStoreListResponseBodyResult(TeaModel):
    def __init__(
        self,
        consumer_side: str = None,
        create_time: str = None,
        link: str = None,
        logstore: str = None,
        project: str = None,
        source: str = None,
    ):
        # The type of the logging service.
        self.consumer_side = consumer_side
        # The time when the logging service was created.
        self.create_time = create_time
        # The URL of the logging service.
        self.link = link
        # The name of the Logstore.
        self.logstore = logstore
        # The name of the project.
        self.project = project
        # The source of logs. Valid values:
        # 
        # *   Standard output: stdout.log
        # *   File log: the directory that stores logs
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.consumer_side is not None:
            result['ConsumerSide'] = self.consumer_side
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.link is not None:
            result['Link'] = self.link
        if self.logstore is not None:
            result['Logstore'] = self.logstore
        if self.project is not None:
            result['Project'] = self.project
        if self.source is not None:
            result['Source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConsumerSide') is not None:
            self.consumer_side = m.get('ConsumerSide')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Logstore') is not None:
            self.logstore = m.get('Logstore')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        return self


class QuerySlsLogStoreListResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        result: List[QuerySlsLogStoreListResponseBodyResult] = None,
        total_size: int = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The configurations of Log Service for the application.
        self.result = result
        # The number of log sources configured for the application.
        self.total_size = total_size

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Result'] = []
        if self.result is not None:
            for k in self.result:
                result['Result'].append(k.to_map() if k else None)
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result = []
        if m.get('Result') is not None:
            for k in m.get('Result'):
                temp_model = QuerySlsLogStoreListResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class QuerySlsLogStoreListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySlsLogStoreListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySlsLogStoreListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResetApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        ecc_info: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the elastic compute container (ECC) for which you want to reset the application. Separate multiple ECC IDs with commas (,). You can call the QueryApplicationStatus operation to query the ECC ID. For more information, see [QueryApplicationStatus](https://help.aliyun.com/document_detail/149394.html).
        # 
        # This parameter is required.
        self.ecc_info = ecc_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.ecc_info is not None:
            result['EccInfo'] = self.ecc_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EccInfo') is not None:
            self.ecc_info = m.get('EccInfo')
        return self


class ResetApplicationResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process for this operation. You can call the GetChangeOrderInfo operation to query the progress of this operation. For more information, see [GetChangeOrderInfo](https://help.aliyun.com/document_detail/62072.html).
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ResetApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResetApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResetApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RestartApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        ecc_info: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the elastic compute container (ECC) that corresponds to the ECS instance on which you want to restart the application. You can call the QueryApplicationStatus operation to query the ECC ID. For more information, see [QueryApplicationStatus](https://help.aliyun.com/document_detail/149394.html).
        # 
        # *   Separate multiple ECC IDs with commas (,).
        # *   If you leave this parameter empty, the application will be restarted on all the ECS instances deployed with the application.
        self.ecc_info = ecc_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.ecc_info is not None:
            result['EccInfo'] = self.ecc_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EccInfo') is not None:
            self.ecc_info = m.get('EccInfo')
        return self


class RestartApplicationResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process.
        # 
        # You can call the GetChangeOrderInfo operation to query the progress of this restart. For more information, see [GetChangeOrderInfo](https://help.aliyun.com/document_detail/62072.html).
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RestartApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RestartApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RestartApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RestartK8sApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        timeout: int = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The timeout period of the change process. Unit: seconds.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class RestartK8sApplicationResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process.
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RestartK8sApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RestartK8sApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RestartK8sApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RetryChangeOrderTaskRequest(TeaModel):
    def __init__(
        self,
        retry_status: bool = None,
        task_id: str = None,
    ):
        # The retry status.
        self.retry_status = retry_status
        # The ID of the process.
        # 
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.retry_status is not None:
            result['RetryStatus'] = self.retry_status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RetryStatus') is not None:
            self.retry_status = m.get('RetryStatus')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class RetryChangeOrderTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The retry information.
        self.data = data
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RetryChangeOrderTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RetryChangeOrderTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RetryChangeOrderTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RollbackApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        batch: int = None,
        batch_wait_time: int = None,
        group_id: str = None,
        history_version: str = None,
    ):
        # The application ID. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/423162.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The number of batches for the rollback. Default value: 1. Valid values: 1 to 5.
        self.batch = batch
        # The wait time between batches. Default value: 0. The default value indicates no wait time. Valid values: 0 to 5. Unit: minutes.
        self.batch_wait_time = batch_wait_time
        # The application group ID. You can call the ListDeployGroup operation to query the application group ID. For more information, see [ListDeployGroup](https://help.aliyun.com/document_detail/423184.html).
        # 
        # If you need to roll back the application in all application groups, set this parameter to `all`.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The historical version to which you want to roll back the application. Call the ListHistoryDeployVersion operation to query the historical versions of the application. Then, set this parameter based on the returned value of `PackageVersion`. For more information, see [ListHistoryDeployVersion](https://help.aliyun.com/document_detail/423163.html).
        # 
        # This parameter is required.
        self.history_version = history_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.batch is not None:
            result['Batch'] = self.batch
        if self.batch_wait_time is not None:
            result['BatchWaitTime'] = self.batch_wait_time
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.history_version is not None:
            result['HistoryVersion'] = self.history_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Batch') is not None:
            self.batch = m.get('Batch')
        if m.get('BatchWaitTime') is not None:
            self.batch_wait_time = m.get('BatchWaitTime')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('HistoryVersion') is not None:
            self.history_version = m.get('HistoryVersion')
        return self


class RollbackApplicationResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The change process ID. You can call the GetChangeOrderInfo operation to query the progress of this rollback. For more information, see [GetChangeOrderInfo](https://help.aliyun.com/document_detail/423155.html).
        self.change_order_id = change_order_id
        # The HTTP status code.
        self.code = code
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RollbackApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RollbackApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RollbackApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RollbackChangeOrderRequest(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change process.
        # 
        # This parameter is required.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class RollbackChangeOrderResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change process.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class RollbackChangeOrderResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: RollbackChangeOrderResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        trace_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The information about the change process.
        self.data = data
        # The error code that is returned.
        self.error_code = error_code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The ID of the trace.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = RollbackChangeOrderResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RollbackChangeOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RollbackChangeOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RollbackChangeOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ScaleInApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        ecc_info: str = None,
        force_status: bool = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the elastic compute container (ECC) that corresponds to the Elastic Compute Service (ECS) instance to be removed for the application. Separate multiple ECC IDs with commas (,). You can call the QueryApplicationStatus operation to query the ECC ID. For more information, see [QueryApplicationStatus](https://help.aliyun.com/document_detail/149394.html).
        # 
        # This parameter is required.
        self.ecc_info = ecc_info
        # Specifies whether to forcibly unpublish the application from the ECS instance. You need to set this parameter to true only if the ECS instance expires. In normal cases, you do not need to set this parameter to true.
        self.force_status = force_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.ecc_info is not None:
            result['EccInfo'] = self.ecc_info
        if self.force_status is not None:
            result['ForceStatus'] = self.force_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EccInfo') is not None:
            self.ecc_info = m.get('EccInfo')
        if m.get('ForceStatus') is not None:
            self.force_status = m.get('ForceStatus')
        return self


class ScaleInApplicationResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
    ):
        # The ID of the change process for this operation. You can call the GetChangeOrderInfo operation to query the progress of this scale-in. For more information, see [GetChangeOrderInfo](https://help.aliyun.com/document_detail/62072.html). No ID is generated if the ForceStatus parameter is set to true. You can check whether the request is successful based on the value of the Code parameter.
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class ScaleInApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ScaleInApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ScaleInApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ScaleK8sApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        replicas: int = None,
        timeout: int = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The expected number of application instances after the scale-out or scale-in. The minimum number is 0.
        # 
        # This parameter is required.
        self.replicas = replicas
        # The timeout period of the change process. Unit: seconds.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class ScaleK8sApplicationResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process. You can call the GetChangeOrderInfo operation to query the progress of this scaling operation. For more information, see [GetChangeOrderInfo](https://help.aliyun.com/document_detail/62072.html).
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ScaleK8sApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ScaleK8sApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ScaleK8sApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ScaleOutApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        deploy_group: str = None,
        ecu_info: str = None,
    ):
        # The ID of the application that you want to scale out. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the instance group where the application you want to scale out is deployed. You can call the QueryApplicationStatus operation to query the group ID. For more information, see [QueryApplicationStatus](https://help.aliyun.com/document_detail/149394.html).
        # 
        # This parameter is required.
        self.deploy_group = deploy_group
        # The ID of the elastic compute unit (ECU) that corresponds to the Elastic Compute Service (ECS) instance to be added to the instance group for scale-out. You can call the ListScaleOutEcu operation to query the ECU ID. For more information, see [ListScaleOutEcu](https://help.aliyun.com/document_detail/149371.html). Separate multiple ECU IDs with commas (,).
        # 
        # This parameter is required.
        self.ecu_info = ecu_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.deploy_group is not None:
            result['DeployGroup'] = self.deploy_group
        if self.ecu_info is not None:
            result['EcuInfo'] = self.ecu_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DeployGroup') is not None:
            self.deploy_group = m.get('DeployGroup')
        if m.get('EcuInfo') is not None:
            self.ecu_info = m.get('EcuInfo')
        return self


class ScaleOutApplicationResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process. You can call the GetChangeOrderInfo operation to query the progress of this scale-out. For more information, see [GetChangeOrderInfo](https://help.aliyun.com/document_detail/62072.html).
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ScaleOutApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ScaleOutApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ScaleOutApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ScaleoutApplicationWithNewInstancesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        auto_renew: bool = None,
        auto_renew_period: int = None,
        cluster_id: str = None,
        group_id: str = None,
        instance_charge_period: int = None,
        instance_charge_period_unit: str = None,
        instance_charge_type: str = None,
        scaling_num: int = None,
        scaling_policy: str = None,
        template_id: str = None,
        template_instance_id: str = None,
        template_version: str = None,
    ):
        # The ID of the application that you want to scale out. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        self.app_id = app_id
        # Specifies whether to enable auto-renewal. This parameter takes effect only when the InstanceChargeType parameter is set to PrePaid. Valid values:
        # 
        # *   true: enables auto-renewal.
        # *   false: does not enable auto-renewal. This is the default value.
        self.auto_renew = auto_renew
        # The auto-renewal period. Valid values:
        # 
        # *   If the InstanceChargePeriodUnit parameter is set to Week, the valid values of the AutoRenewPeriod parameter are 1, 2, and 3.
        # *   If the InstanceChargePeriodUnit parameter is set to Month, the valid values of the AutoRenewPeriod parameter are 1, 2, 3, 6, 12, 24, 36, 48, and 60.
        # 
        # Default value: 1.
        self.auto_renew_period = auto_renew_period
        # The ID of the cluster to which you want to add ECS instances. If the application and application instance group for the scale-out are specified, this parameter is ignored.
        self.cluster_id = cluster_id
        # The ID of the instance group that you want to scale out. You can call the ListDeployGroup operation to query the group ID. For more information, see [ListDeployGroup](https://help.aliyun.com/document_detail/62077.html).
        self.group_id = group_id
        # The duration of the subscription. The unit of the subscription duration is specified by the InstanceChargePeriodUnit parameter. This parameter takes effect only when the InstanceChargeType parameter is set to PrePaid.
        # 
        # *   If the InstanceChargePeriodUnit parameter is set to Week, the valid values of the InstanceChargePeriod parameter are 1, 2, 3, and 4.
        # *   If the InstanceChargePeriodUnit parameter is set to Month, the valid values of the InstanceChargePeriod parameter are 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36, 48, and 60.
        self.instance_charge_period = instance_charge_period
        # The unit of the subscription period. Valid values:
        # 
        # *   Week: billed on a weekly basis.
        # *   Month: billed on a monthly basis. This is the default value.
        self.instance_charge_period_unit = instance_charge_period_unit
        # The billing method of the instance. Valid values:
        # 
        # *   PrePaid: subscription.
        # *   PostPaid: pay-as-you-go. This is the default value.
        self.instance_charge_type = instance_charge_type
        # The number of instances to be added for the scale-out.
        # 
        # This parameter is required.
        self.scaling_num = scaling_num
        # The instance reclaim mode of the scaling group. Valid values:
        # 
        # *   recycle: economical mode
        # *   release: release mode
        # 
        # For more information about how to remove instances from a specified scaling group, see [RemoveInstances](https://help.aliyun.com/document_detail/25955.html).
        self.scaling_policy = scaling_policy
        # The ID of the ECS instance launch template. You can call the DescribeLaunchTemplates operation to query the launch template ID. For more information, see [DescribeLaunchTemplates](https://help.aliyun.com/document_detail/73759.html).
        self.template_id = template_id
        # The ID of the existing ECS instance used for the scale-out. If this parameter is specified, the specifications and configurations of the specified ECS instance are used as a template to purchase new instances.
        self.template_instance_id = template_instance_id
        # The version of the ECS instance launch template. You can call the DescribeLaunchTemplateVersions operation to query the launch template version. For more information, see [DescribeLaunchTemplateVersions](https://help.aliyun.com/document_detail/73761.html).
        # 
        # > If you set this parameter to `-1`, the default launch template version is used.
        self.template_version = template_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.auto_renew_period is not None:
            result['AutoRenewPeriod'] = self.auto_renew_period
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_charge_period is not None:
            result['InstanceChargePeriod'] = self.instance_charge_period
        if self.instance_charge_period_unit is not None:
            result['InstanceChargePeriodUnit'] = self.instance_charge_period_unit
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.scaling_num is not None:
            result['ScalingNum'] = self.scaling_num
        if self.scaling_policy is not None:
            result['ScalingPolicy'] = self.scaling_policy
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_instance_id is not None:
            result['TemplateInstanceId'] = self.template_instance_id
        if self.template_version is not None:
            result['TemplateVersion'] = self.template_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('AutoRenewPeriod') is not None:
            self.auto_renew_period = m.get('AutoRenewPeriod')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceChargePeriod') is not None:
            self.instance_charge_period = m.get('InstanceChargePeriod')
        if m.get('InstanceChargePeriodUnit') is not None:
            self.instance_charge_period_unit = m.get('InstanceChargePeriodUnit')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('ScalingNum') is not None:
            self.scaling_num = m.get('ScalingNum')
        if m.get('ScalingPolicy') is not None:
            self.scaling_policy = m.get('ScalingPolicy')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateInstanceId') is not None:
            self.template_instance_id = m.get('TemplateInstanceId')
        if m.get('TemplateVersion') is not None:
            self.template_version = m.get('TemplateVersion')
        return self


class ScaleoutApplicationWithNewInstancesResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        instance_ids: List[str] = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process for the scale-out.
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The IDs of ECS instances.
        self.instance_ids = instance_ids
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ScaleoutApplicationWithNewInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ScaleoutApplicationWithNewInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ScaleoutApplicationWithNewInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        ecc_info: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the elastic compute container (ECC) that corresponds to the Elastic Compute Service (ECS) instance on which you want to start the application. Separate multiple ECC IDs with commas (,). You can call the QueryApplicationStatus operation to query the ECC ID. For more information, see [QueryApplicationStatus](https://help.aliyun.com/document_detail/149394.html).
        self.ecc_info = ecc_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.ecc_info is not None:
            result['EccInfo'] = self.ecc_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EccInfo') is not None:
            self.ecc_info = m.get('EccInfo')
        return self


class StartApplicationResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process for this operation. You can call the GetChangeOrderInfo operation to query the progress of this startup. For more information, see [GetChangeOrderInfo](https://help.aliyun.com/document_detail/62072.html).
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartK8sAppPrecheckRequest(TeaModel):
    def __init__(
        self,
        annotations: str = None,
        app_id: str = None,
        app_name: str = None,
        cluster_id: str = None,
        component_ids: str = None,
        config_mount_descs: str = None,
        empty_dirs: str = None,
        env_froms: str = None,
        envs: str = None,
        image_url: str = None,
        java_start_up_config: str = None,
        labels: str = None,
        limit_ephemeral_storage: int = None,
        limit_mem: int = None,
        limitm_cpu: int = None,
        local_volume: str = None,
        namespace: str = None,
        package_url: str = None,
        pvc_mount_descs: str = None,
        region_id: str = None,
        replicas: int = None,
        requests_ephemeral_storage: int = None,
        requests_mem: int = None,
        requestsm_cpu: int = None,
    ):
        # The annotation of an application pod.
        self.annotations = annotations
        # The ID of the application.
        self.app_id = app_id
        # The name of the application. The name must start with a letter, and can contain digits, letters, and hyphens (-). It can be up to 36 characters in length.
        self.app_name = app_name
        # The ID of the cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The ID of the application component. You can call the ListComponents operation to query application components. This parameter must be specified when the application runs in Apache Tomcat or in a standard Java application runtime environment. The Apache Tomcat application runtime environment is applicable to Dubbo applications that are deployed by using WAR packages. A standard Java application runtime environment is applicable to Spring Boot or Spring Cloud applications that are deployed by using JAR packages.
        # 
        # Valid values for regular application component IDs:
        # 
        # *   4: Apache Tomcat 7.0.91
        # *   5: OpenJDK 1.8.x
        # *   6: OpenJDK 1.7.x
        # *   7: Apache Tomcat 8.5.42
        # 
        # This parameter is available only for Java SDK 2.57.3 or later, or Python SDK 2.57.3 or later. Assume that you use an SDK that is not provided by Enterprise Distributed Application Service (EDAS), such as aliyun-python-sdk-core, aliyun-java-sdk-core, and Alibaba Cloud CLI. In this case, you can directly specify this parameter.
        self.component_ids = component_ids
        # The configuration for mounting a Kubernetes ConfigMap or Secret to a directory in an elastic container instance. The following parameters are included in the configuration:
        # 
        # *   name: the name of the Kubernetes ConfigMap or Secret.
        # *   type: the type of the API object that you want to mount. You can mount a Kubernetes ConfigMap or Secret.
        # *   mountPath: the mount path. The mount path must be an absolute path that starts with a forward slash (/).
        self.config_mount_descs = config_mount_descs
        # The configuration for mounting a Kubernetes emptyDir volume to a directory in an elastic container instance. The following parameters are included in the configuration:
        # 
        # *   mountPath: The mount path in the container. This parameter is required.
        # *   readOnly: (Optional) The mount mode. The value true indicates the read-only mode. The value false indicates the read and write mode. Default value: false.
        # *   subPathExpr: (Optional) The regular expression that is used to match the subdirectory.
        self.empty_dirs = empty_dirs
        # The Kubernetes environment variables that are configured in EnvFrom mode. A ConfigMap or Secret is mounted to a directory. Each key corresponds to a file in the directory, and the content of the file is the value of the key.
        # 
        # The following parameters are included in the configuration of the EnvFroms parameter:
        # 
        # *   configMapRef: the ConfigMap that is referenced. The following parameter is included:
        # 
        #     name: the name of the ConfigMap.
        # 
        # *   secretRef: the Secret that is referenced. The following parameter is included:
        # 
        #     name: the name of the Secret.
        self.env_froms = env_froms
        # The environment variables that are used to deploy the application. The value must be a JSON array. Valid values: regular environment variables, Kubernetes ConfigMap environment variables, and Kubernetes Secret environment variables. Specify regular environment variables in the following format:
        # 
        # `{"name":"x", "value": "y"}`
        # 
        # Specify Kubernetes ConfigMap environment variables in the following format to reference values from ConfigMaps:
        # 
        # `{ "name": "x2", "valueFrom": { "configMapKeyRef": { "name": "my-config", "key": "y2" } } }`
        # 
        # Specify Kubernetes Secret environment variables in the following format to reference values from Secrets:
        # 
        # `{ "name": "x3", "valueFrom": { "secretKeyRef": { "name": "my-secret", "key": "y3" } } }`
        # 
        # > If you want to cancel this configuration, set this parameter to an empty JSON array, which is in the format of "[]".
        self.envs = envs
        # The URL of the image.
        self.image_url = image_url
        # The configuration of Java startup parameters for a Java application. These startup parameters involve the memory, application, garbage collection (GC) policy, tools, service registration and discovery, and custom configurations. Proper parameter settings help reduce the GC overheads, shorten the server response time, and improve the throughput. Set this parameter to a JSON string. In the example, original indicates the configuration value, and startup indicates a startup parameter. The system automatically concatenates all startup values as the settings of Java startup parameters for the application. To delete this configuration, leave the parameter value empty by entering `""` or `"{}"`. The following parameters are included in the configuration:
        # 
        # *   InitialHeapSize: the initial size of the heap memory.
        # *   MaxHeapSize: the maximum size of the heap memory.
        # *   CustomParams: the custom parameters, such as JVM -D parameters.
        # *   Other parameters: You can view the JSON structure submitted by the frontend.
        self.java_start_up_config = java_start_up_config
        # The label of an application pod.
        self.labels = labels
        # The maximum size of space required by ephemeral storage. Unit: GB. The value 0 indicates that no limit is set on the ephemeral storage space.
        self.limit_ephemeral_storage = limit_ephemeral_storage
        # The maximum size of memory allowed for each application instance when the application is running. Unit: MB. The value of LimitMem must be greater than or equal to that of RequestsMem.
        self.limit_mem = limit_mem
        # The maximum number of CPU cores allowed for each application instance when the application is running. Unit: millicores. The value 0 indicates that no limit is set on CPU cores.
        self.limitm_cpu = limitm_cpu
        # The configurations that are used when the host files are mounted to the container on which the application is running. Example: `[{"type":"","nodePath":"/localfiles","mountPath":"/app/files"},{"type":"Directory","nodePath":"/mnt","mountPath":"/app/storage"}\\]`. Description:
        # 
        # *   `nodePath`: the host path.
        # *   `mountPath`: the path in the container.
        # *   `type`: the mounting type.
        self.local_volume = local_volume
        # The namespace of the Kubernetes cluster. This parameter specifies the Kubernetes namespace in which your application is deployed. By default, the default namespace is used.
        # 
        # This parameter is required.
        self.namespace = namespace
        # The URL of the deployment package.
        self.package_url = package_url
        # The configuration for mounting a Kubernetes PersistentVolumeClaim (PVC) to a directory in an elastic container instance. The following parameters are included in the configuration:
        # 
        # *   pvcName: the name of the PVC. Make sure that the volume exists and is in the Bound state.
        # 
        # *   mountPaths: the directory to which you want to mount the PVC. You can configure multiple directories. You can set the following two parameters for each mount directory:
        # 
        #     *   mountPath: the mount path. The mount path must be an absolute path that starts with a forward slash (/).
        #     *   readOnly: the mount mode. The value true indicates the read-only mode. The value false indicates the read and write mode. Default value: false.
        self.pvc_mount_descs = pvc_mount_descs
        # The ID of the region.
        self.region_id = region_id
        # The number of application instances.
        self.replicas = replicas
        # The minimum size of space required by ephemeral storage. Unit: GB. The value 0 indicates that no limit is set on the ephemeral storage space.
        self.requests_ephemeral_storage = requests_ephemeral_storage
        # The maximum size of memory allowed for each application instance when the application is created. Unit: MB. The value 0 indicates that no limit is set on the memory size. The value of RequestsMem cannot be greater than that of LimitMem.
        self.requests_mem = requests_mem
        # The maximum number of CPU cores allowed for each application instance when the application is created. Unit: millicores.
        self.requestsm_cpu = requestsm_cpu

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotations is not None:
            result['Annotations'] = self.annotations
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.component_ids is not None:
            result['ComponentIds'] = self.component_ids
        if self.config_mount_descs is not None:
            result['ConfigMountDescs'] = self.config_mount_descs
        if self.empty_dirs is not None:
            result['EmptyDirs'] = self.empty_dirs
        if self.env_froms is not None:
            result['EnvFroms'] = self.env_froms
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.java_start_up_config is not None:
            result['JavaStartUpConfig'] = self.java_start_up_config
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.limit_ephemeral_storage is not None:
            result['LimitEphemeralStorage'] = self.limit_ephemeral_storage
        if self.limit_mem is not None:
            result['LimitMem'] = self.limit_mem
        if self.limitm_cpu is not None:
            result['LimitmCpu'] = self.limitm_cpu
        if self.local_volume is not None:
            result['LocalVolume'] = self.local_volume
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.pvc_mount_descs is not None:
            result['PvcMountDescs'] = self.pvc_mount_descs
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.requests_ephemeral_storage is not None:
            result['RequestsEphemeralStorage'] = self.requests_ephemeral_storage
        if self.requests_mem is not None:
            result['RequestsMem'] = self.requests_mem
        if self.requestsm_cpu is not None:
            result['RequestsmCpu'] = self.requestsm_cpu
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Annotations') is not None:
            self.annotations = m.get('Annotations')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ComponentIds') is not None:
            self.component_ids = m.get('ComponentIds')
        if m.get('ConfigMountDescs') is not None:
            self.config_mount_descs = m.get('ConfigMountDescs')
        if m.get('EmptyDirs') is not None:
            self.empty_dirs = m.get('EmptyDirs')
        if m.get('EnvFroms') is not None:
            self.env_froms = m.get('EnvFroms')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('JavaStartUpConfig') is not None:
            self.java_start_up_config = m.get('JavaStartUpConfig')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('LimitEphemeralStorage') is not None:
            self.limit_ephemeral_storage = m.get('LimitEphemeralStorage')
        if m.get('LimitMem') is not None:
            self.limit_mem = m.get('LimitMem')
        if m.get('LimitmCpu') is not None:
            self.limitm_cpu = m.get('LimitmCpu')
        if m.get('LocalVolume') is not None:
            self.local_volume = m.get('LocalVolume')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PvcMountDescs') is not None:
            self.pvc_mount_descs = m.get('PvcMountDescs')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('RequestsEphemeralStorage') is not None:
            self.requests_ephemeral_storage = m.get('RequestsEphemeralStorage')
        if m.get('RequestsMem') is not None:
            self.requests_mem = m.get('RequestsMem')
        if m.get('RequestsmCpu') is not None:
            self.requestsm_cpu = m.get('RequestsmCpu')
        return self


class StartK8sAppPrecheckResponseBodyData(TeaModel):
    def __init__(
        self,
        jobs: List[str] = None,
    ):
        # The jobs and the details about the jobs.
        self.jobs = jobs

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.jobs is not None:
            result['Jobs'] = self.jobs
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Jobs') is not None:
            self.jobs = m.get('Jobs')
        return self


class StartK8sAppPrecheckResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: StartK8sAppPrecheckResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code.
        self.code = code
        # The returned data.
        self.data = data
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = StartK8sAppPrecheckResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartK8sAppPrecheckResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartK8sAppPrecheckResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartK8sAppPrecheckResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartK8sApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        replicas: int = None,
        timeout: int = None,
    ):
        # The ID of the application. You can query the application ID by calling the ListApplication operation. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The number of instances on which you want to start the application.
        self.replicas = replicas
        # The timeout period of the change process. Valid values: 1 to 1800. Default value: 600. Unit: seconds.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class StartK8sApplicationResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process.
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartK8sApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartK8sApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartK8sApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        ecc_info: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the elastic compute container (ECC) that corresponds to the Elastic Compute Service (ECS) instance on which you want to stop the application. You can call the QueryApplicationStatus operation to query the ECC ID. For more information, see [QueryApplicationStatus](https://help.aliyun.com/document_detail/149394.html).
        # 
        # *   If you want to stop the application on multiple ECS instances, separate the ECC IDs with commas (,).
        # *   If you leave this parameter empty, the application will be stopped on all ECS instances.
        self.ecc_info = ecc_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.ecc_info is not None:
            result['EccInfo'] = self.ecc_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EccInfo') is not None:
            self.ecc_info = m.get('EccInfo')
        return self


class StopApplicationResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process. You can call the GetChangeOrderInfo operation to query the details about the change process. For more information, see [GetChangeOrderInfo](https://help.aliyun.com/document_detail/62072.html).
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopK8sApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        timeout: int = None,
    ):
        # The ID of the application. You can query the application ID by calling the ListApplication operation. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The timeout period of the change process. Unit: seconds.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class StopK8sApplicationResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process.
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopK8sApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopK8sApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopK8sApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SwitchAdvancedMonitoringRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        enable_advanced_monitoring: bool = None,
    ):
        # The ID of the application for which you want to query or configure the advanced application monitoring feature.
        # 
        # This parameter is required.
        self.app_id = app_id
        # Specifies whether to enable the advanced application monitoring feature. Valid values:
        # 
        # *   true: enables the advanced application monitoring feature.
        # *   false: disables the advanced application monitoring feature.
        # 
        # If you call this operation to query the status of the advanced application monitoring feature, you do not need to specify this parameter.
        self.enable_advanced_monitoring = enable_advanced_monitoring

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.enable_advanced_monitoring is not None:
            result['EnableAdvancedMonitoring'] = self.enable_advanced_monitoring
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EnableAdvancedMonitoring') is not None:
            self.enable_advanced_monitoring = m.get('EnableAdvancedMonitoring')
        return self


class SwitchAdvancedMonitoringResponseBody(TeaModel):
    def __init__(
        self,
        advanced_monitoring_enabled: bool = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # Indicates whether the advanced application monitoring feature is enabled. Valid values:
        # 
        # *   true: The advanced application monitoring feature is enabled.
        # *   false: The advanced application monitoring feature is disabled.
        self.advanced_monitoring_enabled = advanced_monitoring_enabled
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advanced_monitoring_enabled is not None:
            result['AdvancedMonitoringEnabled'] = self.advanced_monitoring_enabled
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdvancedMonitoringEnabled') is not None:
            self.advanced_monitoring_enabled = m.get('AdvancedMonitoringEnabled')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SwitchAdvancedMonitoringResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SwitchAdvancedMonitoringResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SwitchAdvancedMonitoringResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SynchronizeResourceRequest(TeaModel):
    def __init__(
        self,
        resource_ids: str = None,
        type: str = None,
    ):
        # The ID of the resource. This parameter is required only when you set the Type parameter to `ecs`. If you specify multiple IDs, separate them with commas (,). You can synchronize up to 50 resources at a time.
        self.resource_ids = resource_ids
        # The type of the resource to be synchronized. Valid values: `ecs, slb, vpc, and all`. These values are case-sensitive.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_ids is not None:
            result['ResourceIds'] = self.resource_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceIds') is not None:
            self.resource_ids = m.get('ResourceIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SynchronizeResourceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The data returned for the request.
        self.data = data
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the resources are synchronized. Valid values:
        # 
        # *   **true**: The resources are synchronized.
        # *   **false**: The resources fail to be synchronized.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SynchronizeResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SynchronizeResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SynchronizeResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TagResourcesRequest(TeaModel):
    def __init__(
        self,
        resource_ids: str = None,
        resource_region_id: str = None,
        resource_type: str = None,
        tags: str = None,
    ):
        # The IDs of the resources. You can specify up to 20 IDs in the format of a JSON array.
        # 
        # This parameter is required.
        self.resource_ids = resource_ids
        # The region in which the resource resides.
        # 
        # This parameter is required.
        self.resource_region_id = resource_region_id
        # The type of the resource. Valid values:
        # 
        # *   **application**: Enterprise Distributed Application Service (EDAS) application
        # *   **cluster**: EDAS cluster
        # 
        # This parameter is required.
        self.resource_type = resource_type
        # The key-value pairs. When you set this parameter, take note of the following limits:
        # 
        # *   You can add up to 20 tags to a resource.
        # *   The tag key cannot start with **aliyun** or **acs:**. It cannot contain **http://** or **https://**.
        # *   The tag key or tag value can be up to 128 characters in length, and can contain letters, digits, hyphens (-), commas (,), asterisks (\\*), forward slashes (/), question marks (?), and colons (:).
        # *   Set this parameter to a JSON array.
        # 
        # This parameter is required.
        self.tags = tags

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_ids is not None:
            result['ResourceIds'] = self.resource_ids
        if self.resource_region_id is not None:
            result['ResourceRegionId'] = self.resource_region_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceIds') is not None:
            self.resource_ids = m.get('ResourceIds')
        if m.get('ResourceRegionId') is not None:
            self.resource_region_id = m.get('ResourceRegionId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class TagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class TagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TransformClusterMemberRequest(TeaModel):
    def __init__(
        self,
        instance_ids: str = None,
        password: str = None,
        target_cluster_id: str = None,
    ):
        # The ID of the instance that you want to import or migrate. Separate multiple IDs with commas (,).
        # 
        # *   An instance may not belong to a cluster, but an instance can belong to only one cluster at most.
        # *   The ECS instances and the destination cluster must be in the same virtual private cloud (VPC).
        # 
        # This parameter is required.
        self.instance_ids = instance_ids
        # The logon password of the ECS instance that you want to import or migrate to the cluster.
        # 
        # This parameter is required.
        self.password = password
        # The ID of the destination cluster.
        # 
        # This parameter is required.
        self.target_cluster_id = target_cluster_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.password is not None:
            result['Password'] = self.password
        if self.target_cluster_id is not None:
            result['TargetClusterId'] = self.target_cluster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('TargetClusterId') is not None:
            self.target_cluster_id = m.get('TargetClusterId')
        return self


class TransformClusterMemberResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # `Transform submit success!` is returned if the request is successful.
        self.data = data
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class TransformClusterMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TransformClusterMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TransformClusterMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnbindK8sSlbRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        cluster_id: str = None,
        slb_name: str = None,
        type: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the cluster. You can call the GetK8sCluster operation to query the cluster ID. For more information, see [GetK8sCluster](https://help.aliyun.com/document_detail/181437.html).
        self.cluster_id = cluster_id
        # The name of the SLB instance.
        self.slb_name = slb_name
        # The type of the SLB instance. Valid values:
        # 
        # *   **internet**: Internet-facing SLB instance
        # *   **intranet**: internal-facing SLB instance
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.slb_name is not None:
            result['SlbName'] = self.slb_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('SlbName') is not None:
            self.slb_name = m.get('SlbName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UnbindK8sSlbResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process.
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnbindK8sSlbResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnbindK8sSlbResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnbindK8sSlbResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnbindSlbRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        delete_listener: str = None,
        slb_id: str = None,
        type: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # Specifies whether to remove the configured listeners. Valid values:
        # 
        # *   true: removes the configured listeners.
        # *   false: does not remove the configured listeners.
        self.delete_listener = delete_listener
        # The ID of the SLB instance.
        # 
        # This parameter is required.
        self.slb_id = slb_id
        # The network type of the SLB instance. Valid values:
        # 
        # *   **internet**: Internet-facing SLB instance
        # *   **intranet**: internal-facing SLB instance
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.delete_listener is not None:
            result['DeleteListener'] = self.delete_listener
        if self.slb_id is not None:
            result['SlbId'] = self.slb_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DeleteListener') is not None:
            self.delete_listener = m.get('DeleteListener')
        if m.get('SlbId') is not None:
            self.slb_id = m.get('SlbId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UnbindSlbResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # This parameter is left empty. It has no meaning.
        self.data = data
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnbindSlbResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnbindSlbResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnbindSlbResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UntagResourcesRequest(TeaModel):
    def __init__(
        self,
        delete_all: bool = None,
        resource_ids: str = None,
        resource_region_id: str = None,
        resource_type: str = None,
        tag_keys: str = None,
    ):
        # Specifies whether to remove all existing tags from the specified resources. Default value: false. Valid values:
        # 
        # *   **true**: removes all existing tags from the specified resources.
        # *   **false**: does not remove all existing tags from the specified resources.
        # 
        # > All existing tags of a resource are removed only if the **tagKeys** parameter is left empty and the **DeleteAll** parameter is set to true.
        self.delete_all = delete_all
        # The IDs of the resources from which you want to remove tags. You can specify up to 20 IDs.
        # 
        # This parameter is required.
        self.resource_ids = resource_ids
        # The region in which the resource resides.
        # 
        # This parameter is required.
        self.resource_region_id = resource_region_id
        # The type of the resource. Valid values:
        # 
        # *   **application**: Enterprise Distributed Application Service (EDAS) application
        # *   **cluster**: EDAS cluster
        # 
        # This parameter is required.
        self.resource_type = resource_type
        # The tags that you want to remove. You can specify up to 20 tags. Set this parameter to a JSON array.
        self.tag_keys = tag_keys

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delete_all is not None:
            result['DeleteAll'] = self.delete_all
        if self.resource_ids is not None:
            result['ResourceIds'] = self.resource_ids
        if self.resource_region_id is not None:
            result['ResourceRegionId'] = self.resource_region_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag_keys is not None:
            result['TagKeys'] = self.tag_keys
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeleteAll') is not None:
            self.delete_all = m.get('DeleteAll')
        if m.get('ResourceIds') is not None:
            self.resource_ids = m.get('ResourceIds')
        if m.get('ResourceRegionId') is not None:
            self.resource_region_id = m.get('ResourceRegionId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TagKeys') is not None:
            self.tag_keys = m.get('TagKeys')
        return self


class UntagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UntagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UntagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UntagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAccountInfoRequest(TeaModel):
    def __init__(
        self,
        email: str = None,
        name: str = None,
        telephone: str = None,
    ):
        # The email address of the account.
        self.email = email
        # The name of the account.
        self.name = name
        # The contact information of the account.
        self.telephone = telephone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.email is not None:
            result['Email'] = self.email
        if self.name is not None:
            result['Name'] = self.name
        if self.telephone is not None:
            result['Telephone'] = self.telephone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Telephone') is not None:
            self.telephone = m.get('Telephone')
        return self


class UpdateAccountInfoResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateAccountInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAccountInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAccountInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateApplicationBaseInfoRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        desc: str = None,
        owner: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The name of the application. The name must start with a letter, and can contain letters, digits, underscores (_), and hyphens (-). The name can be up to 36 characters in length.
        self.app_name = app_name
        # The description of the application. The description can be up to 256 characters in length.
        self.desc = desc
        # The owner of the application. The value can be up to 127 characters in length.
        self.owner = owner

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.owner is not None:
            result['Owner'] = self.owner
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        return self


class UpdateApplicationBaseInfoResponseBodyApplcation(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        application_type: str = None,
        build_package_id: int = None,
        cluster_id: str = None,
        cluster_type: int = None,
        cpu: int = None,
        create_time: int = None,
        description: str = None,
        dockerize: bool = None,
        ext_slb_id: str = None,
        ext_slb_ip: str = None,
        ext_slb_name: str = None,
        health_check_url: str = None,
        instance_count: int = None,
        memory: int = None,
        name: str = None,
        owner: str = None,
        port: int = None,
        region_id: str = None,
        running_instance_count: int = None,
        slb_id: str = None,
        slb_ip: str = None,
        slb_name: str = None,
        slb_port: int = None,
        user_id: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The deployment type of the application. Valid values:
        # 
        # *   War: The application is deployed by using a WAR package.
        # *   FatJar: The application is deployed by using a JAR package.
        # *   Image: The application is deployed by using an image.
        # *   If this parameter is empty, the application is not deployed.
        self.application_type = application_type
        # The build package number of Enterprise Distributed Application Service (EDAS) Container.
        self.build_package_id = build_package_id
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The type of the cluster. Valid values:
        # 
        # *   0: normal Docker cluster
        # *   1: Swarm cluster
        # *   2: ECS cluster
        # *   3: self-managed Kubernetes cluster in EDAS
        # *   4: cluster in which Pandora automatically registers applications
        # *   5: Container Service for Kubernetes (ACK) clusters
        self.cluster_type = cluster_type
        # The number of CPU cores.
        self.cpu = cpu
        # The time when the application was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The description of the application.
        self.description = description
        # Indicates whether the application is a Docker application.
        self.dockerize = dockerize
        # The ID of the Internet-facing SLB instance.
        self.ext_slb_id = ext_slb_id
        # The IP address of the Internet-facing Server Load Balancer (SLB) instance.
        self.ext_slb_ip = ext_slb_ip
        # The name of the Internet-facing SLB instance.
        self.ext_slb_name = ext_slb_name
        # The health check URL.
        self.health_check_url = health_check_url
        # The number of application instances.
        self.instance_count = instance_count
        # The size of memory configured for an application instance. Unit: MB.
        self.memory = memory
        # The name of the application.
        self.name = name
        # The owner of the application.
        self.owner = owner
        # The port used by the application.
        self.port = port
        # The ID of the region.
        self.region_id = region_id
        # The number of running application instances.
        self.running_instance_count = running_instance_count
        # The ID of the internal-facing SLB instance.
        self.slb_id = slb_id
        # The IP address of the internal-facing SLB instance.
        self.slb_ip = slb_ip
        # The name of the internal-facing SLB instance.
        self.slb_name = slb_name
        # The port used by the internal-facing SLB instance.
        self.slb_port = slb_port
        # The ID of the Alibaba Cloud account.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.application_type is not None:
            result['ApplicationType'] = self.application_type
        if self.build_package_id is not None:
            result['BuildPackageId'] = self.build_package_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.dockerize is not None:
            result['Dockerize'] = self.dockerize
        if self.ext_slb_id is not None:
            result['ExtSlbId'] = self.ext_slb_id
        if self.ext_slb_ip is not None:
            result['ExtSlbIp'] = self.ext_slb_ip
        if self.ext_slb_name is not None:
            result['ExtSlbName'] = self.ext_slb_name
        if self.health_check_url is not None:
            result['HealthCheckUrl'] = self.health_check_url
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.port is not None:
            result['Port'] = self.port
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.running_instance_count is not None:
            result['RunningInstanceCount'] = self.running_instance_count
        if self.slb_id is not None:
            result['SlbId'] = self.slb_id
        if self.slb_ip is not None:
            result['SlbIp'] = self.slb_ip
        if self.slb_name is not None:
            result['SlbName'] = self.slb_name
        if self.slb_port is not None:
            result['SlbPort'] = self.slb_port
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ApplicationType') is not None:
            self.application_type = m.get('ApplicationType')
        if m.get('BuildPackageId') is not None:
            self.build_package_id = m.get('BuildPackageId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Dockerize') is not None:
            self.dockerize = m.get('Dockerize')
        if m.get('ExtSlbId') is not None:
            self.ext_slb_id = m.get('ExtSlbId')
        if m.get('ExtSlbIp') is not None:
            self.ext_slb_ip = m.get('ExtSlbIp')
        if m.get('ExtSlbName') is not None:
            self.ext_slb_name = m.get('ExtSlbName')
        if m.get('HealthCheckUrl') is not None:
            self.health_check_url = m.get('HealthCheckUrl')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RunningInstanceCount') is not None:
            self.running_instance_count = m.get('RunningInstanceCount')
        if m.get('SlbId') is not None:
            self.slb_id = m.get('SlbId')
        if m.get('SlbIp') is not None:
            self.slb_ip = m.get('SlbIp')
        if m.get('SlbName') is not None:
            self.slb_name = m.get('SlbName')
        if m.get('SlbPort') is not None:
            self.slb_port = m.get('SlbPort')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class UpdateApplicationBaseInfoResponseBody(TeaModel):
    def __init__(
        self,
        applcation: UpdateApplicationBaseInfoResponseBodyApplcation = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The applications that you want to modify.
        self.applcation = applcation
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.applcation:
            self.applcation.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.applcation is not None:
            result['Applcation'] = self.applcation.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Applcation') is not None:
            temp_model = UpdateApplicationBaseInfoResponseBodyApplcation()
            self.applcation = temp_model.from_map(m['Applcation'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateApplicationBaseInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateApplicationBaseInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateApplicationBaseInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateApplicationScalingRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        scaling_behaviour: str = None,
        scaling_rule_enable: bool = None,
        scaling_rule_metric: str = None,
        scaling_rule_name: str = None,
        scaling_rule_timer: str = None,
        scaling_rule_trigger: str = None,
        scaling_rule_type: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        self.app_id = app_id
        # The behavior of the auto scaling. See the example for the data structure.
        self.scaling_behaviour = scaling_behaviour
        # Specifies whether to enable the auto scaling policy. Valid values:
        # 
        # *   **true**: enables the auto scaling policy.
        # *   **false**: disables the auto scaling policy.
        self.scaling_rule_enable = scaling_rule_enable
        # This parameter is deprecated.
        self.scaling_rule_metric = scaling_rule_metric
        # The name of the auto scaling policy.
        self.scaling_rule_name = scaling_rule_name
        # This parameter is deprecated.
        self.scaling_rule_timer = scaling_rule_timer
        # The trigger policy for the auto scaling policy. Set this parameter in the JSON format by using the ScalingRuleTriggerDTO class. For more information, see Additional description of request parameters.
        self.scaling_rule_trigger = scaling_rule_trigger
        # The type of the auto scaling policy.
        # 
        # *   Set the value to trigger.
        self.scaling_rule_type = scaling_rule_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.scaling_behaviour is not None:
            result['ScalingBehaviour'] = self.scaling_behaviour
        if self.scaling_rule_enable is not None:
            result['ScalingRuleEnable'] = self.scaling_rule_enable
        if self.scaling_rule_metric is not None:
            result['ScalingRuleMetric'] = self.scaling_rule_metric
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        if self.scaling_rule_timer is not None:
            result['ScalingRuleTimer'] = self.scaling_rule_timer
        if self.scaling_rule_trigger is not None:
            result['ScalingRuleTrigger'] = self.scaling_rule_trigger
        if self.scaling_rule_type is not None:
            result['ScalingRuleType'] = self.scaling_rule_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ScalingBehaviour') is not None:
            self.scaling_behaviour = m.get('ScalingBehaviour')
        if m.get('ScalingRuleEnable') is not None:
            self.scaling_rule_enable = m.get('ScalingRuleEnable')
        if m.get('ScalingRuleMetric') is not None:
            self.scaling_rule_metric = m.get('ScalingRuleMetric')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        if m.get('ScalingRuleTimer') is not None:
            self.scaling_rule_timer = m.get('ScalingRuleTimer')
        if m.get('ScalingRuleTrigger') is not None:
            self.scaling_rule_trigger = m.get('ScalingRuleTrigger')
        if m.get('ScalingRuleType') is not None:
            self.scaling_rule_type = m.get('ScalingRuleType')
        return self


class UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies(TeaModel):
    def __init__(
        self,
        period_seconds: int = None,
        type: str = None,
        value: str = None,
    ):
        # The cycle of the policy check. Valid values: 0 to 1800. Unit: seconds.
        self.period_seconds = period_seconds
        # The type of the policy. Valid values: Pods and Percent.
        self.type = type
        # The policy value of auto scaling. Set the value to an integer greater than zero. If the policy type is Pods, the value of this parameter indicates the number of pods. If the policy type is Percent, the value of this parameter indicates a percentage, which can exceed 100%.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.period_seconds is not None:
            result['PeriodSeconds'] = self.period_seconds
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PeriodSeconds') is not None:
            self.period_seconds = m.get('PeriodSeconds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown(TeaModel):
    def __init__(
        self,
        policies: List[UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies] = None,
        select_policy: str = None,
        stabilization_window_seconds: int = None,
    ):
        # The configuration of the policy.
        self.policies = policies
        # The step size policy for the scale-in. Valid values: Max, Min, and Disable.
        self.select_policy = select_policy
        # The cooldown time of the scale-in. Valid values: 0 to 3600. Unit: seconds. Default value: 300.
        self.stabilization_window_seconds = stabilization_window_seconds

    def validate(self):
        if self.policies:
            for k in self.policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Policies'] = []
        if self.policies is not None:
            for k in self.policies:
                result['Policies'].append(k.to_map() if k else None)
        if self.select_policy is not None:
            result['SelectPolicy'] = self.select_policy
        if self.stabilization_window_seconds is not None:
            result['StabilizationWindowSeconds'] = self.stabilization_window_seconds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.policies = []
        if m.get('Policies') is not None:
            for k in m.get('Policies'):
                temp_model = UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies()
                self.policies.append(temp_model.from_map(k))
        if m.get('SelectPolicy') is not None:
            self.select_policy = m.get('SelectPolicy')
        if m.get('StabilizationWindowSeconds') is not None:
            self.stabilization_window_seconds = m.get('StabilizationWindowSeconds')
        return self


class UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies(TeaModel):
    def __init__(
        self,
        period_seconds: int = None,
        type: str = None,
        value: str = None,
    ):
        # The cycle of the policy check. Valid values: 0 to 1800. Unit: seconds.
        self.period_seconds = period_seconds
        # The type of the policy. Valid values: Pods and Percent.
        self.type = type
        # The policy value of auto scaling. Set the value to an integer greater than zero. If the policy type is Pods, the value of this parameter indicates the number of pods. If the policy type is Percent, the value of this parameter indicates a percentage, which can exceed 100%.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.period_seconds is not None:
            result['PeriodSeconds'] = self.period_seconds
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PeriodSeconds') is not None:
            self.period_seconds = m.get('PeriodSeconds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp(TeaModel):
    def __init__(
        self,
        policies: List[UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies] = None,
        select_policy: str = None,
        stabilization_window_seconds: int = None,
    ):
        # The configuration of the policy.
        self.policies = policies
        # The step size policy for the scale-out. Valid values: Max, Min, and Disable.
        self.select_policy = select_policy
        # The cooldown time of the scale-out. Valid values: 0 to 3600. Unit: seconds. Default value: 0.
        self.stabilization_window_seconds = stabilization_window_seconds

    def validate(self):
        if self.policies:
            for k in self.policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Policies'] = []
        if self.policies is not None:
            for k in self.policies:
                result['Policies'].append(k.to_map() if k else None)
        if self.select_policy is not None:
            result['SelectPolicy'] = self.select_policy
        if self.stabilization_window_seconds is not None:
            result['StabilizationWindowSeconds'] = self.stabilization_window_seconds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.policies = []
        if m.get('Policies') is not None:
            for k in m.get('Policies'):
                temp_model = UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies()
                self.policies.append(temp_model.from_map(k))
        if m.get('SelectPolicy') is not None:
            self.select_policy = m.get('SelectPolicy')
        if m.get('StabilizationWindowSeconds') is not None:
            self.stabilization_window_seconds = m.get('StabilizationWindowSeconds')
        return self


class UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour(TeaModel):
    def __init__(
        self,
        scale_down: UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown = None,
        scale_up: UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp = None,
    ):
        self.scale_down = scale_down
        self.scale_up = scale_up

    def validate(self):
        if self.scale_down:
            self.scale_down.validate()
        if self.scale_up:
            self.scale_up.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.scale_down is not None:
            result['ScaleDown'] = self.scale_down.to_map()
        if self.scale_up is not None:
            result['ScaleUp'] = self.scale_up.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ScaleDown') is not None:
            temp_model = UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown()
            self.scale_down = temp_model.from_map(m['ScaleDown'])
        if m.get('ScaleUp') is not None:
            temp_model = UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp()
            self.scale_up = temp_model.from_map(m['ScaleUp'])
        return self


class UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics(TeaModel):
    def __init__(
        self,
        metric_target_average_utilization: int = None,
        metric_type: str = None,
    ):
        # This parameter is deprecated.
        self.metric_target_average_utilization = metric_target_average_utilization
        # This parameter is deprecated.
        self.metric_type = metric_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_target_average_utilization is not None:
            result['MetricTargetAverageUtilization'] = self.metric_target_average_utilization
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetricTargetAverageUtilization') is not None:
            self.metric_target_average_utilization = m.get('MetricTargetAverageUtilization')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        return self


class UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric(TeaModel):
    def __init__(
        self,
        max_replicas: int = None,
        metrics: List[UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics] = None,
        min_replicas: int = None,
    ):
        # This parameter is deprecated.
        self.max_replicas = max_replicas
        # This parameter is deprecated.
        self.metrics = metrics
        # This parameter is deprecated.
        self.min_replicas = min_replicas

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics()
                self.metrics.append(temp_model.from_map(k))
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        return self


class UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers(TeaModel):
    def __init__(
        self,
        meta_data: str = None,
        name: str = None,
        type: str = None,
    ):
        # The metadata of the trigger.
        self.meta_data = meta_data
        # The name of the trigger.
        self.name = name
        # The type of the trigger. Valid values: cron and app_metric.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.meta_data is not None:
            result['MetaData'] = self.meta_data
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetaData') is not None:
            self.meta_data = m.get('MetaData')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger(TeaModel):
    def __init__(
        self,
        max_replicas: int = None,
        min_replicas: int = None,
        triggers: List[UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers] = None,
    ):
        # The maximum number of replicas. The maximum value is 1000.
        self.max_replicas = max_replicas
        # The minimum number of replicas. The minimum value is 0.
        self.min_replicas = min_replicas
        # The configurations of the trigger.
        self.triggers = triggers

    def validate(self):
        if self.triggers:
            for k in self.triggers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        result['Triggers'] = []
        if self.triggers is not None:
            for k in self.triggers:
                result['Triggers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        self.triggers = []
        if m.get('Triggers') is not None:
            for k in m.get('Triggers'):
                temp_model = UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers()
                self.triggers.append(temp_model.from_map(k))
        return self


class UpdateApplicationScalingRuleResponseBodyAppScalingRule(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        behaviour: UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour = None,
        create_time: int = None,
        last_disable_time: int = None,
        max_replicas: int = None,
        metric: UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric = None,
        min_replicas: int = None,
        scale_rule_enabled: bool = None,
        scale_rule_name: str = None,
        scale_rule_type: str = None,
        trigger: UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger = None,
        update_time: int = None,
    ):
        # The ID of the application to which the auto scaling policy belongs.
        self.app_id = app_id
        self.behaviour = behaviour
        # The time when the auto scaling policy was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The time when the auto scaling policy was last disabled. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.last_disable_time = last_disable_time
        # This parameter is deprecated.
        self.max_replicas = max_replicas
        # This parameter is deprecated.
        self.metric = metric
        # This parameter is deprecated.
        self.min_replicas = min_replicas
        # Indicates whether the auto scaling policy is enabled. Valid values:
        # 
        # *   **true**: The auto scaling policy is enabled.
        # *   **false**: The auto scaling policy is disabled.
        self.scale_rule_enabled = scale_rule_enabled
        # The name of the auto scaling policy.
        self.scale_rule_name = scale_rule_name
        # The type of the auto scaling policy. The value is fixed to trigger.
        self.scale_rule_type = scale_rule_type
        # The configurations of the trigger.
        self.trigger = trigger
        # The time when the auto scaling policy was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time

    def validate(self):
        if self.behaviour:
            self.behaviour.validate()
        if self.metric:
            self.metric.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.behaviour is not None:
            result['Behaviour'] = self.behaviour.to_map()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_disable_time is not None:
            result['LastDisableTime'] = self.last_disable_time
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.metric is not None:
            result['Metric'] = self.metric.to_map()
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        if self.scale_rule_enabled is not None:
            result['ScaleRuleEnabled'] = self.scale_rule_enabled
        if self.scale_rule_name is not None:
            result['ScaleRuleName'] = self.scale_rule_name
        if self.scale_rule_type is not None:
            result['ScaleRuleType'] = self.scale_rule_type
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Behaviour') is not None:
            temp_model = UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour()
            self.behaviour = temp_model.from_map(m['Behaviour'])
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastDisableTime') is not None:
            self.last_disable_time = m.get('LastDisableTime')
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('Metric') is not None:
            temp_model = UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric()
            self.metric = temp_model.from_map(m['Metric'])
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        if m.get('ScaleRuleEnabled') is not None:
            self.scale_rule_enabled = m.get('ScaleRuleEnabled')
        if m.get('ScaleRuleName') is not None:
            self.scale_rule_name = m.get('ScaleRuleName')
        if m.get('ScaleRuleType') is not None:
            self.scale_rule_type = m.get('ScaleRuleType')
        if m.get('Trigger') is not None:
            temp_model = UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class UpdateApplicationScalingRuleResponseBody(TeaModel):
    def __init__(
        self,
        app_scaling_rule: UpdateApplicationScalingRuleResponseBodyAppScalingRule = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The information about the auto scaling policy.
        self.app_scaling_rule = app_scaling_rule
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.app_scaling_rule:
            self.app_scaling_rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_scaling_rule is not None:
            result['AppScalingRule'] = self.app_scaling_rule.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppScalingRule') is not None:
            temp_model = UpdateApplicationScalingRuleResponseBodyAppScalingRule()
            self.app_scaling_rule = temp_model.from_map(m['AppScalingRule'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateApplicationScalingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateApplicationScalingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateApplicationScalingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateConfigTemplateRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        description: str = None,
        format: str = None,
        id: int = None,
        name: str = None,
    ):
        # The content of the configuration template. The value must be in the format that is specified by the Format parameter.
        self.content = content
        # The description of the configuration template. The description can be up to 255 characters in length.
        self.description = description
        # The data format of the configuration template. Valid values:
        # 
        # *   JSON: JSON format
        # *   XML: XML format
        # *   YAML: YAML format
        # *   Properties: .properties format
        # *   KeyValue: key-value pairs
        # *   Custom: custom format
        self.format = format
        # The ID of the configuration template.
        self.id = id
        # The name of the configuration template. The name can be up to 64 characters in length.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.description is not None:
            result['Description'] = self.description
        if self.format is not None:
            result['Format'] = self.format
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class UpdateConfigTemplateResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateConfigTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateConfigTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateConfigTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateContainerRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        build_pack_id: int = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The build package number of EDAS Container. You can obtain the build package number in the Build package number column in the EDAS Container release notes table. For more information, see [Release notes for EDAS Container](https://help.aliyun.com/document_detail/92614.html).
        # 
        # This parameter is required.
        self.build_pack_id = build_pack_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.build_pack_id is not None:
            result['BuildPackId'] = self.build_pack_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BuildPackId') is not None:
            self.build_pack_id = m.get('BuildPackId')
        return self


class UpdateContainerResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process.
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateContainerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateContainerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateContainerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateContainerConfigurationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        context_path: str = None,
        group_id: str = None,
        http_port: int = None,
        max_threads: int = None,
        uriencoding: str = None,
        use_body_encoding: bool = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The context path of the Tomcat container. The context path can be an empty string, a null WAR package name, a root directory, or other custom non-empty strings. It can contain letters, digits, hyphens (-), and underscores (_). Take note of the following items:
        # 
        # *   If this parameter is not specified when you configure the application instance group, the configuration of the application is applied.
        # *   If this parameter is not specified when you configure the Tomcat container for an application, the root directory `/` is used.
        self.context_path = context_path
        # The ID of the application instance group.
        # 
        # *   If an ID is specified, this operation configures the Tomcat container for the specified application instance group.
        # *   If you set this parameter to "", this operation configures the Tomcat container for the application.
        self.group_id = group_id
        # The application port number for the Tomcat container. Take note of the following items:
        # 
        # *   If this parameter is not specified when you configure the application instance group, the configuration of the application is applied.
        # *   If this parameter is not specified when you configure the application, the default port 8080 is applied.
        self.http_port = http_port
        # The maximum number of threads. Take note of the following items:
        # 
        # *   If this parameter is not specified when you configure the application instance group, the configuration of the application is applied.
        # *   If this parameter is not specified when you configure the application, the default value 250 is applied.
        self.max_threads = max_threads
        # The uniform resource identifier (URI) encoding scheme. Valid values: ISO-8859-1, GBK, GB2312, and UTF-8. Take note of the following items:
        # 
        # *   If this parameter is not specified when you configure the application instance group, the configuration of the application is applied.
        # *   If this parameter is not specified when you configure the application, the default URI encoding scheme in the Tomcat container is applied.
        self.uriencoding = uriencoding
        # Specifies whether to use the encoding scheme specified in the request body for URI query parameters. Take note of the following items:
        # 
        # *   If this parameter is not specified when you configure the application instance group, the configuration of the application is applied.
        # *   If this parameter is not specified when you configure the application, the default value false is applied.
        self.use_body_encoding = use_body_encoding

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.context_path is not None:
            result['ContextPath'] = self.context_path
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.http_port is not None:
            result['HttpPort'] = self.http_port
        if self.max_threads is not None:
            result['MaxThreads'] = self.max_threads
        if self.uriencoding is not None:
            result['URIEncoding'] = self.uriencoding
        if self.use_body_encoding is not None:
            result['UseBodyEncoding'] = self.use_body_encoding
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ContextPath') is not None:
            self.context_path = m.get('ContextPath')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('HttpPort') is not None:
            self.http_port = m.get('HttpPort')
        if m.get('MaxThreads') is not None:
            self.max_threads = m.get('MaxThreads')
        if m.get('URIEncoding') is not None:
            self.uriencoding = m.get('URIEncoding')
        if m.get('UseBodyEncoding') is not None:
            self.use_body_encoding = m.get('UseBodyEncoding')
        return self


class UpdateContainerConfigurationResponseBodyContainerConfiguration(TeaModel):
    def __init__(
        self,
        context_path: str = None,
        http_port: int = None,
        max_threads: int = None,
        uriencoding: str = None,
        use_body_encoding: bool = None,
    ):
        # The context path of the Tomcat container.
        self.context_path = context_path
        # The application port number for the Tomcat container.
        self.http_port = http_port
        # The maximum number of threads.
        self.max_threads = max_threads
        # The URI encoding scheme. Valid values: ISO-8859-1, GBK, GB2312, and UTF-8.
        self.uriencoding = uriencoding
        # Indicates whether useBodyEncodingForURI is enabled.
        self.use_body_encoding = use_body_encoding

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.context_path is not None:
            result['ContextPath'] = self.context_path
        if self.http_port is not None:
            result['HttpPort'] = self.http_port
        if self.max_threads is not None:
            result['MaxThreads'] = self.max_threads
        if self.uriencoding is not None:
            result['URIEncoding'] = self.uriencoding
        if self.use_body_encoding is not None:
            result['UseBodyEncoding'] = self.use_body_encoding
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContextPath') is not None:
            self.context_path = m.get('ContextPath')
        if m.get('HttpPort') is not None:
            self.http_port = m.get('HttpPort')
        if m.get('MaxThreads') is not None:
            self.max_threads = m.get('MaxThreads')
        if m.get('URIEncoding') is not None:
            self.uriencoding = m.get('URIEncoding')
        if m.get('UseBodyEncoding') is not None:
            self.use_body_encoding = m.get('UseBodyEncoding')
        return self


class UpdateContainerConfigurationResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        container_configuration: UpdateContainerConfigurationResponseBodyContainerConfiguration = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The configuration of the Tomcat container.
        self.container_configuration = container_configuration
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.container_configuration:
            self.container_configuration.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.container_configuration is not None:
            result['ContainerConfiguration'] = self.container_configuration.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ContainerConfiguration') is not None:
            temp_model = UpdateContainerConfigurationResponseBodyContainerConfiguration()
            self.container_configuration = temp_model.from_map(m['ContainerConfiguration'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateContainerConfigurationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateContainerConfigurationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateContainerConfigurationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateHealthCheckUrlRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        hc_url: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The health check URL of the application. The URL must start with `http://`, and can be up to 255 characters in length. Example: `http://127.0.0.1:8080/_ehc.html`. If this parameter is not specified, the health check URL of the application is not changed.
        self.hc_url = hc_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.hc_url is not None:
            result['hcURL'] = self.hc_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('hcURL') is not None:
            self.hc_url = m.get('hcURL')
        return self


class UpdateHealthCheckUrlResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        health_check_url: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The health check URL.
        self.health_check_url = health_check_url
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.health_check_url is not None:
            result['HealthCheckURL'] = self.health_check_url
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HealthCheckURL') is not None:
            self.health_check_url = m.get('HealthCheckURL')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateHealthCheckUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateHealthCheckUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateHealthCheckUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateHookConfigurationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group_id: str = None,
        hooks: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the application instance group.
        self.group_id = group_id
        # The script to mount. Set the value in the JSON format. Example: `[{"ignoreFail":false,"name":"postprepareInstanceEnvironmentOnScaleOut","script":"ls"},{"ignoreFail":true,"name":"postdeleteInstanceDataOnScaleIn","script":""},{"ignoreFail":true,"name":"prestartInstance","script":""},{"ignoreFail":true,"name":"poststartInstance","script":""},{"ignoreFail":true,"name":"prestopInstance","script":""},{"ignoreFail":true,"name":"poststopInstance","script":""}]`
        # 
        # This parameter is required.
        self.hooks = hooks

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.hooks is not None:
            result['Hooks'] = self.hooks
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Hooks') is not None:
            self.hooks = m.get('Hooks')
        return self


class UpdateHookConfigurationResponseBodyHooksConfiguration(TeaModel):
    def __init__(
        self,
        ignore_fail: bool = None,
        name: str = None,
        script: str = None,
    ):
        # Indicates whether a mount failure is ignored. Valid values:
        # 
        # *   **true**: A mount failure is ignored.
        # *   **false**: A mount failure is not ignored.
        self.ignore_fail = ignore_fail
        # The name of the mounted script.
        self.name = name
        # The content of the mounted script.
        self.script = script

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignore_fail is not None:
            result['IgnoreFail'] = self.ignore_fail
        if self.name is not None:
            result['Name'] = self.name
        if self.script is not None:
            result['Script'] = self.script
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IgnoreFail') is not None:
            self.ignore_fail = m.get('IgnoreFail')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Script') is not None:
            self.script = m.get('Script')
        return self


class UpdateHookConfigurationResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        hooks_configuration: List[UpdateHookConfigurationResponseBodyHooksConfiguration] = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The information about the mounted script.
        self.hooks_configuration = hooks_configuration
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.hooks_configuration:
            for k in self.hooks_configuration:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['HooksConfiguration'] = []
        if self.hooks_configuration is not None:
            for k in self.hooks_configuration:
                result['HooksConfiguration'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.hooks_configuration = []
        if m.get('HooksConfiguration') is not None:
            for k in m.get('HooksConfiguration'):
                temp_model = UpdateHookConfigurationResponseBodyHooksConfiguration()
                self.hooks_configuration.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateHookConfigurationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateHookConfigurationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateHookConfigurationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateJvmConfigurationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group_id: str = None,
        max_heap_size: int = None,
        max_perm_size: int = None,
        min_heap_size: int = None,
        options: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the instance group where the application is deployed. You can call the ListDeployGroup operation to query the group ID. For more information, see [ListDeployGroup](https://help.aliyun.com/document_detail/62077.html).
        # 
        # > 
        # 
        # *   To configure the JVM parameters for an instance group, set this parameter to a specific ID.
        # 
        # *   To configure the JVM parameters for an application, leave this parameter empty.
        self.group_id = group_id
        # The maximum size of the heap memory. Unit: MB.
        # 
        # > 
        # 
        # *   If this parameter is not specified in the group configuration, the value specified in the application configuration is used.
        # 
        # *   If this parameter is not specified in the application configuration, the default value is used.
        self.max_heap_size = max_heap_size
        # The size of the permanent generation heap memory. Unit: MB.
        # 
        # > 
        # 
        # *   If this parameter is not specified in the group configuration, the value specified in the application configuration is used.
        # 
        # *   If this parameter is not specified in the application configuration, the default value is used.
        self.max_perm_size = max_perm_size
        # The initial size of the heap memory. Unit: MB.
        # 
        # > 
        # 
        # *   If this parameter is not specified in the group configuration, the value specified in the application configuration is used.
        # 
        # *   If this parameter is not specified in the application configuration, the default value is used.
        self.min_heap_size = min_heap_size
        # The custom JVM parameters.
        # 
        # > 
        # 
        # *   If this parameter is not specified in the group configuration, the value specified in the application configuration is used.
        # 
        # *   If this parameter is not specified in the application configuration, the default value is used.
        self.options = options

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.max_heap_size is not None:
            result['MaxHeapSize'] = self.max_heap_size
        if self.max_perm_size is not None:
            result['MaxPermSize'] = self.max_perm_size
        if self.min_heap_size is not None:
            result['MinHeapSize'] = self.min_heap_size
        if self.options is not None:
            result['Options'] = self.options
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('MaxHeapSize') is not None:
            self.max_heap_size = m.get('MaxHeapSize')
        if m.get('MaxPermSize') is not None:
            self.max_perm_size = m.get('MaxPermSize')
        if m.get('MinHeapSize') is not None:
            self.min_heap_size = m.get('MinHeapSize')
        if m.get('Options') is not None:
            self.options = m.get('Options')
        return self


class UpdateJvmConfigurationResponseBodyJvmConfiguration(TeaModel):
    def __init__(
        self,
        max_heap_size: int = None,
        max_perm_size: int = None,
        min_heap_size: int = None,
        options: str = None,
    ):
        # The maximum size of the heap memory. Unit: MB.
        self.max_heap_size = max_heap_size
        # The size of the permanent generation heap memory. Unit: MB.
        self.max_perm_size = max_perm_size
        # The initial size of the heap memory. Unit: MB.
        self.min_heap_size = min_heap_size
        # The optional parameters.
        self.options = options

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_heap_size is not None:
            result['MaxHeapSize'] = self.max_heap_size
        if self.max_perm_size is not None:
            result['MaxPermSize'] = self.max_perm_size
        if self.min_heap_size is not None:
            result['MinHeapSize'] = self.min_heap_size
        if self.options is not None:
            result['Options'] = self.options
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxHeapSize') is not None:
            self.max_heap_size = m.get('MaxHeapSize')
        if m.get('MaxPermSize') is not None:
            self.max_perm_size = m.get('MaxPermSize')
        if m.get('MinHeapSize') is not None:
            self.min_heap_size = m.get('MinHeapSize')
        if m.get('Options') is not None:
            self.options = m.get('Options')
        return self


class UpdateJvmConfigurationResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        jvm_configuration: UpdateJvmConfigurationResponseBodyJvmConfiguration = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The settings of the JVM parameters.
        self.jvm_configuration = jvm_configuration
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.jvm_configuration:
            self.jvm_configuration.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.jvm_configuration is not None:
            result['JvmConfiguration'] = self.jvm_configuration.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('JvmConfiguration') is not None:
            temp_model = UpdateJvmConfigurationResponseBodyJvmConfiguration()
            self.jvm_configuration = temp_model.from_map(m['JvmConfiguration'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateJvmConfigurationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateJvmConfigurationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateJvmConfigurationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateK8sApplicationBaseInfoRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        description: str = None,
        email: str = None,
        owner: str = None,
        phone_number: str = None,
    ):
        # The ID of the application that you want to modify.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The description of the application. The description can be up to 256 characters in length.
        self.description = description
        # The email address of the application owner.
        self.email = email
        # The owner of the application. The value can be up to 128 characters in length.
        self.owner = owner
        # The phone number of the application owner.
        self.phone_number = phone_number

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.description is not None:
            result['Description'] = self.description
        if self.email is not None:
            result['Email'] = self.email
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.phone_number is not None:
            result['PhoneNumber'] = self.phone_number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PhoneNumber') is not None:
            self.phone_number = m.get('PhoneNumber')
        return self


class UpdateK8sApplicationBaseInfoResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        result: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The result of the modification.
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class UpdateK8sApplicationBaseInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateK8sApplicationBaseInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateK8sApplicationBaseInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateK8sApplicationConfigRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        cluster_id: str = None,
        cpu_limit: str = None,
        cpu_request: str = None,
        ephemeral_storage_limit: str = None,
        ephemeral_storage_request: str = None,
        mcpu_limit: str = None,
        mcpu_request: str = None,
        memory_limit: str = None,
        memory_request: str = None,
        timeout: int = None,
    ):
        # The ID of the application. You can query the application ID by calling the ListApplication operation. For more information, see [ListApplication](https://help.aliyun.com/document_detail/423162.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the cluster. You can query the cluster ID by calling the ListCluster operation. For more information, see [ListCluster](https://help.aliyun.com/document_detail/411844.html).
        self.cluster_id = cluster_id
        # The maximum number of CPU cores allowed for each application instance when the application is running. The value 0 indicates that no limit is set on CPU cores.
        self.cpu_limit = cpu_limit
        # The number of CPU cores requested for each application instance when the application is running. Unit: cores. We recommend that you set this parameter. The value 0 indicates that no limit is set on CPU cores.
        # 
        # > You must set this parameter together with the CpuLimit parameter. Make sure that the value of this parameter does not exceed that of the CpuLimit parameter.
        self.cpu_request = cpu_request
        # The maximum size of space required by ephemeral storage. Unit: GB. The value 0 indicates that no limit is set on the ephemeral storage space.
        self.ephemeral_storage_limit = ephemeral_storage_limit
        # The minimum size of space required by ephemeral storage. Unit: GB. The value 0 indicates that no limit is set on the ephemeral storage space.
        # 
        # > You must set this parameter together with the EphemeralStorageLimit parameter. Make sure that the value of this parameter does not exceed that of the EphemeralStorageLimit parameter.
        self.ephemeral_storage_request = ephemeral_storage_request
        # The maximum number of CPU cores allowed. The value 0 indicates that no limit is set on CPU cores.
        self.mcpu_limit = mcpu_limit
        # The minimum number of CPU cores required. Unit: cores. The value 0 indicates that no limit is set on CPU cores.
        # 
        # > You must set this parameter together with the CpuLimit parameter. Make sure that the value of this parameter does not exceed that of the CpuLimit parameter.
        self.mcpu_request = mcpu_request
        # The maximum size of memory allowed for each application instance when the application is running. Unit: MB. The value 0 indicates that no limit is set on the memory size.
        self.memory_limit = memory_limit
        # The size of memory requested for each application instance when the application is running. Unit: MB. We recommend that you set this parameter. If you do not want to apply for a memory quota, set this parameter to 0.
        # 
        # > You must set this parameter together with the MemoryLimit parameter. Make sure that the value of this parameter does not exceed that of the MemoryLimit parameter.
        self.memory_request = memory_request
        # The timeout period of the change process. Valid values: 1 to 1800. Default value: 600. Unit: seconds.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cpu_limit is not None:
            result['CpuLimit'] = self.cpu_limit
        if self.cpu_request is not None:
            result['CpuRequest'] = self.cpu_request
        if self.ephemeral_storage_limit is not None:
            result['EphemeralStorageLimit'] = self.ephemeral_storage_limit
        if self.ephemeral_storage_request is not None:
            result['EphemeralStorageRequest'] = self.ephemeral_storage_request
        if self.mcpu_limit is not None:
            result['McpuLimit'] = self.mcpu_limit
        if self.mcpu_request is not None:
            result['McpuRequest'] = self.mcpu_request
        if self.memory_limit is not None:
            result['MemoryLimit'] = self.memory_limit
        if self.memory_request is not None:
            result['MemoryRequest'] = self.memory_request
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CpuLimit') is not None:
            self.cpu_limit = m.get('CpuLimit')
        if m.get('CpuRequest') is not None:
            self.cpu_request = m.get('CpuRequest')
        if m.get('EphemeralStorageLimit') is not None:
            self.ephemeral_storage_limit = m.get('EphemeralStorageLimit')
        if m.get('EphemeralStorageRequest') is not None:
            self.ephemeral_storage_request = m.get('EphemeralStorageRequest')
        if m.get('McpuLimit') is not None:
            self.mcpu_limit = m.get('McpuLimit')
        if m.get('McpuRequest') is not None:
            self.mcpu_request = m.get('McpuRequest')
        if m.get('MemoryLimit') is not None:
            self.memory_limit = m.get('MemoryLimit')
        if m.get('MemoryRequest') is not None:
            self.memory_request = m.get('MemoryRequest')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class UpdateK8sApplicationConfigResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process.
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateK8sApplicationConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateK8sApplicationConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateK8sApplicationConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateK8sConfigMapRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        data: Dict[str, Any] = None,
        name: str = None,
        namespace: str = None,
    ):
        # The ID of the Kubernetes cluster.
        self.cluster_id = cluster_id
        # The data of the ConfigMap. Set this parameter to a JSON string.
        self.data = data
        # The name of the ConfigMap. The name must start with a letter, and can contain digits, letters, and hyphens (-). It can be up to 63 characters in length.
        self.name = name
        # The namespace of the Kubernetes cluster.
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.data is not None:
            result['Data'] = self.data
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        return self


class UpdateK8sConfigMapResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateK8sConfigMapResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateK8sConfigMapResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateK8sConfigMapResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateK8sIngressRuleRequest(TeaModel):
    def __init__(
        self,
        annotations: str = None,
        cluster_id: str = None,
        ingress_conf: Dict[str, Any] = None,
        labels: str = None,
        name: str = None,
        namespace: str = None,
    ):
        # The annotations.
        self.annotations = annotations
        # The ID of the Kubernetes cluster.
        self.cluster_id = cluster_id
        # The routing rules of the Ingress. Set this parameter to a JSON string in the following format:
        # 
        #     {
        #       "rules": [
        #         {
        #           "host": "abc.com",
        #           "secretName": "tls-secret",
        #           "paths": [
        #             {
        #               "path": "/path",
        #               "backend": {
        #                 "servicePort": 80,
        #                 "serviceName": "xxx"
        #               }
        #             }
        #           ]
        #         }
        #       ]
        #     }
        # 
        # Parameter description:
        # 
        # *   rules: the list of routing rules.
        # *   host: the domain name to be accessed.
        # *   secretName: the name of the Secret that stores the information about the Transport Layer Security (TLS) certificate. The certificate is required if you need to use the HTTPS protocol.
        # *   paths: the list of paths to be accessed.
        # *   path: the path to be accessed.
        # *   backend: the configuration of the backend service. You can specify a service that is created in the Enterprise Distributed Application Service (EDAS) console.
        # *   serviceName: the name of the backend service.
        # *   servicePort: the port of the backend service.
        self.ingress_conf = ingress_conf
        # The labels.
        self.labels = labels
        # The name of the Ingress. The name can contain lowercase letters, digits, and hyphens (-). It must start with a lowercase letter but cannot end with a hyphen (-). The name can be up to 63 characters in length.
        self.name = name
        # The namespace of the Kubernetes cluster.
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotations is not None:
            result['Annotations'] = self.annotations
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.ingress_conf is not None:
            result['IngressConf'] = self.ingress_conf
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Annotations') is not None:
            self.annotations = m.get('Annotations')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('IngressConf') is not None:
            self.ingress_conf = m.get('IngressConf')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        return self


class UpdateK8sIngressRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class UpdateK8sIngressRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateK8sIngressRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateK8sIngressRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateK8sResourceRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        namespace: str = None,
        resource_content: str = None,
    ):
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The ID of the namespace to which the Kubernetes resource belongs.
        self.namespace = namespace
        # The description of the resource in the YAML format.
        self.resource_content = resource_content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.resource_content is not None:
            result['ResourceContent'] = self.resource_content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('ResourceContent') is not None:
            self.resource_content = m.get('ResourceContent')
        return self


class UpdateK8sResourceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateK8sResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateK8sResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateK8sResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateK8sSecretRequest(TeaModel):
    def __init__(
        self,
        base_64encoded: bool = None,
        cert_id: str = None,
        cert_region_id: str = None,
        cluster_id: str = None,
        data: str = None,
        name: str = None,
        namespace: str = None,
        type: str = None,
    ):
        # Specifies whether the data has been encoded in Base64.
        self.base_64encoded = base_64encoded
        # The ID of the certificate.
        self.cert_id = cert_id
        # The region ID of the certificate.
        self.cert_region_id = cert_region_id
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The data of the Secret. The value must be a JSON array that contains the following information:
        # 
        # *   Key: Secret key
        # *   Value: Secret value
        self.data = data
        # The name of the Secret. The name must start with a letter, and can contain digits, letters, and hyphens (-). It can be up to 63 characters in length.
        self.name = name
        # The namespace of the Kubernetes cluster.
        self.namespace = namespace
        # The type of the Secret. Valid values:
        # 
        # *   Opaque: user-defined data type
        # *   kubernetes.io/tls: Transport Layer Security (TLS) certificate type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_64encoded is not None:
            result['Base64Encoded'] = self.base_64encoded
        if self.cert_id is not None:
            result['CertId'] = self.cert_id
        if self.cert_region_id is not None:
            result['CertRegionId'] = self.cert_region_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.data is not None:
            result['Data'] = self.data
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Base64Encoded') is not None:
            self.base_64encoded = m.get('Base64Encoded')
        if m.get('CertId') is not None:
            self.cert_id = m.get('CertId')
        if m.get('CertRegionId') is not None:
            self.cert_region_id = m.get('CertRegionId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateK8sSecretResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateK8sSecretResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateK8sSecretResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateK8sSecretResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateK8sServiceRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        external_traffic_policy: str = None,
        name: str = None,
        service_ports: str = None,
        type: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The policy used for external traffic management. Valid values:
        # 
        # *   Local: local mode
        # *   Cluster: cluster mode
        # 
        # Default value: Local.
        self.external_traffic_policy = external_traffic_policy
        # The name of the service in a Kubernetes cluster.
        # 
        # *   The name can contain lowercase letters, digits, and hyphens (-).
        # *   It must start with a letter and end with a letter or digit.
        # *   The name can be 2 to 32 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The mappings between service ports. Set this parameter to a JSON array. The following parameters are included in the configurations:
        # 
        # *   **protocol**: the protocol used by the service. Valid values: TCP and UDP. This parameter is required.
        # *   **port**: the frontend service port. Valid values: 1 to 65535. This parameter is required.
        # *   **targetPort**: the backend container port. Valid values: 1 to 65535. This parameter is required.
        # 
        # Example: `[{"protocol": "TCP", "port": 80, "targetPort": 8080},{"protocol": "TCP", "port": 81, "targetPort": 8081}]`
        self.service_ports = service_ports
        # The type of the service in a Kubernetes cluster. Set the value to ClusterIP.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.external_traffic_policy is not None:
            result['ExternalTrafficPolicy'] = self.external_traffic_policy
        if self.name is not None:
            result['Name'] = self.name
        if self.service_ports is not None:
            result['ServicePorts'] = self.service_ports
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ExternalTrafficPolicy') is not None:
            self.external_traffic_policy = m.get('ExternalTrafficPolicy')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ServicePorts') is not None:
            self.service_ports = m.get('ServicePorts')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateK8sServiceResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process.
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateK8sServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateK8sServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateK8sServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateK8sSlbRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        cluster_id: str = None,
        disable_force_override: bool = None,
        port: str = None,
        scheduler: str = None,
        service_port_infos: str = None,
        slb_name: str = None,
        slb_protocol: str = None,
        specification: str = None,
        target_port: str = None,
        type: str = None,
    ):
        # The ID of the application. You can query the application ID by calling the ListApplication operation. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the cluster. You can query the cluster ID by calling the GetK8sCluster operation. For more information, see [GetK8sCluster](https://help.aliyun.com/document_detail/181437.html).
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # Specifies whether to disable listener configuration overriding.
        # 
        # *   true: disables listener configuration overriding.
        # *   false: enables listener configuration overriding.
        self.disable_force_override = disable_force_override
        # The frontend port. Valid values: 1 to 65535.
        self.port = port
        # The scheduling algorithm for the SLB instance. If you do not specify this parameter, the default value rr is used. SLB supports the following scheduling algorithms: round-robin and weighted round-robin. Valid values:
        # 
        # *   wrr: weighted round-robin scheduling. Backend servers that have higher weights receive more requests than those that have lower weights.
        # *   rr: round-robin scheduling. Requests are sequentially distributed to backend servers.
        self.scheduler = scheduler
        # The information about the ports. This parameter is required if you want to configure multi-port mappings or use a protocol other than TCP. You must set this parameter to a JSON array. Example: [{"targetPort":8080,"port":82,"loadBalancerProtocol":"TCP"},{"port":81,"certId":"1362469756373809_16c185d6fa2_1914500329_-xxxxxxx","targetPort":8181,"lo adBalancerProtocol":"HTTPS"}]
        # 
        # *   port: required. The frontend port. Valid values: 1 to 65535. Each port must be unique.
        # *   targetPort: required. The backend port. Valid values: 1 to 65535.
        # *   loadBalancerProtocol: required. Valid values: TCP and HTTPS. If the HTTP protocol is used, set this parameter to TCP.
        # *   certId: the ID of the certificate. This parameter is required if the HTTPS protocol is used. You can purchase an SLB instance in the SLB console.
        # *   Note: The ServicePortInfos parameter is specified to support multi-port mappings. If you want this parameter to take effect, make sure that you specify the AppId, ClusterId, Type, and SlbId parameters.
        self.service_port_infos = service_port_infos
        # The name of the SLB instance.
        self.slb_name = slb_name
        # The protocol used by the SLB instance. Set the value to TCP.
        self.slb_protocol = slb_protocol
        # The specifications of the SLB instance.
        # 
        # *   slb.s1.small
        # *   slb.s2.small
        # *   slb.s2.medium
        # *   slb.s3.small
        # *   slb.s3.medium
        # *   slb.s3.large
        # 
        # If you do not specify this parameter, the default value slb.s1.small is used.
        self.specification = specification
        # The backend port, which is also the service port of the application. Valid values: 1 to 65535.
        self.target_port = target_port
        # The type of the SLB instance. Valid values:
        # 
        # *   Internet: an Internet-facing SLB instance
        # *   Intranet: an internal-facing SLB instance
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.disable_force_override is not None:
            result['DisableForceOverride'] = self.disable_force_override
        if self.port is not None:
            result['Port'] = self.port
        if self.scheduler is not None:
            result['Scheduler'] = self.scheduler
        if self.service_port_infos is not None:
            result['ServicePortInfos'] = self.service_port_infos
        if self.slb_name is not None:
            result['SlbName'] = self.slb_name
        if self.slb_protocol is not None:
            result['SlbProtocol'] = self.slb_protocol
        if self.specification is not None:
            result['Specification'] = self.specification
        if self.target_port is not None:
            result['TargetPort'] = self.target_port
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DisableForceOverride') is not None:
            self.disable_force_override = m.get('DisableForceOverride')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Scheduler') is not None:
            self.scheduler = m.get('Scheduler')
        if m.get('ServicePortInfos') is not None:
            self.service_port_infos = m.get('ServicePortInfos')
        if m.get('SlbName') is not None:
            self.slb_name = m.get('SlbName')
        if m.get('SlbProtocol') is not None:
            self.slb_protocol = m.get('SlbProtocol')
        if m.get('Specification') is not None:
            self.specification = m.get('Specification')
        if m.get('TargetPort') is not None:
            self.target_port = m.get('TargetPort')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateK8sSlbResponseBody(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The ID of the change process.
        self.change_order_id = change_order_id
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateK8sSlbResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateK8sSlbResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateK8sSlbResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLocalitySettingRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        enabled: bool = None,
        namespace_id: str = None,
        region: str = None,
        threshold: float = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.enabled = enabled
        # This parameter is required.
        self.namespace_id = namespace_id
        # This parameter is required.
        self.region = region
        self.threshold = threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.region is not None:
            result['Region'] = self.region
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class UpdateLocalitySettingResponseBodyData(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        threshold: float = None,
    ):
        self.enabled = enabled
        self.threshold = threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class UpdateLocalitySettingResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: UpdateLocalitySettingResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateLocalitySettingResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateLocalitySettingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLocalitySettingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLocalitySettingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateRoleRequest(TeaModel):
    def __init__(
        self,
        action_data: str = None,
        role_id: int = None,
    ):
        # The set of permissions to be granted to the role. The value is in the format of `Permission group ID 1:Permission serial number 1;...;Permission group ID n:Permission serial number n`. Example: `1:1;1:2;2:1;2:2`. For more information about permission groups and permission serial numbers, see [ListAuthority](https://help.aliyun.com/document_detail/149409.html).
        # 
        # This parameter is required.
        self.action_data = action_data
        # The ID of the role. You can call the ListRole operation to query the role IDs. For more information, see [ListRole](https://help.aliyun.com/document_detail/149410.html).
        # 
        # This parameter is required.
        self.role_id = role_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_data is not None:
            result['ActionData'] = self.action_data
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionData') is not None:
            self.action_data = m.get('ActionData')
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        return self


class UpdateRoleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateRoleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateRoleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateRoleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSlsLogStoreRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        configs: str = None,
    ):
        # The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](https://help.aliyun.com/document_detail/149390.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The configurations of the Logstore.
        # 
        # *   The following parameters are included in the configurations:****\
        # 
        #     *   **type**: the collection type. Set this parameter to file to specify the file type. Set this parameter to stdout to specify the standard output type.
        # 
        #     *   **logstore**: the name of the Logstore. Make sure that the name of the Logstore is unique in the cluster. The name must comply with the following rules:
        # 
        #         *   The name can contain only lowercase letters, digits, hyphens (-), and underscores (_).
        #         *   The name must start and end with a lowercase letter or a digit.
        #         *   The name must be 3 to 63 characters in length.
        # 
        #         **\
        # 
        #         **Note**If you leave this parameter empty, the system automatically generates a name.
        # 
        #     *   **LogDir**: If the standard output type is used, the collection path is stdout.log. If the file type is used, the collection path is the path of the collected file. Wildcards (\\*) are supported. The collection path must match the following regular expression: `^/(.+)/(.*)^/$`.
        # 
        # This parameter is required.
        self.configs = configs

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.configs is not None:
            result['Configs'] = self.configs
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Configs') is not None:
            self.configs = m.get('Configs')
        return self


class UpdateSlsLogStoreResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The message that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateSlsLogStoreResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSlsLogStoreResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSlsLogStoreResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSwimmingLaneRequest(TeaModel):
    def __init__(
        self,
        app_infos: str = None,
        enable_rules: bool = None,
        entry_rules: str = None,
        lane_id: int = None,
        name: str = None,
    ):
        # The list of applications that are related to the lane.
        self.app_infos = app_infos
        # Specifies whether to enable the throttling rule.
        # 
        # This parameter is required.
        self.enable_rules = enable_rules
        # The configuration of the throttling rule.
        self.entry_rules = entry_rules
        # The ID of the lane.
        # 
        # This parameter is required.
        self.lane_id = lane_id
        # The name of the lane.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_infos is not None:
            result['AppInfos'] = self.app_infos
        if self.enable_rules is not None:
            result['EnableRules'] = self.enable_rules
        if self.entry_rules is not None:
            result['EntryRules'] = self.entry_rules
        if self.lane_id is not None:
            result['LaneId'] = self.lane_id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppInfos') is not None:
            self.app_infos = m.get('AppInfos')
        if m.get('EnableRules') is not None:
            self.enable_rules = m.get('EnableRules')
        if m.get('EntryRules') is not None:
            self.entry_rules = m.get('EntryRules')
        if m.get('LaneId') is not None:
            self.lane_id = m.get('LaneId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        lane_id: int = None,
        rules: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        # The ID of the lane.
        self.lane_id = lane_id
        # The association rule.
        self.rules = rules

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.lane_id is not None:
            result['LaneId'] = self.lane_id
        if self.rules is not None:
            result['Rules'] = self.rules
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('LaneId') is not None:
            self.lane_id = m.get('LaneId')
        if m.get('Rules') is not None:
            self.rules = m.get('Rules')
        return self


class UpdateSwimmingLaneResponseBodyData(TeaModel):
    def __init__(
        self,
        entry_rule: str = None,
        group_id: int = None,
        id: int = None,
        name: str = None,
        namespace_id: str = None,
        swimming_lane_app_relation_ship_list: List[UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList] = None,
        tag: str = None,
    ):
        # The rule of the lane.
        self.entry_rule = entry_rule
        # The ID of the lane group.
        self.group_id = group_id
        # The ID of the lane.
        self.id = id
        # The name of the lane.
        self.name = name
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The list of associations between the lane and the related application.
        self.swimming_lane_app_relation_ship_list = swimming_lane_app_relation_ship_list
        # The tag of the lane.
        self.tag = tag

    def validate(self):
        if self.swimming_lane_app_relation_ship_list:
            for k in self.swimming_lane_app_relation_ship_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entry_rule is not None:
            result['EntryRule'] = self.entry_rule
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        result['SwimmingLaneAppRelationShipList'] = []
        if self.swimming_lane_app_relation_ship_list is not None:
            for k in self.swimming_lane_app_relation_ship_list:
                result['SwimmingLaneAppRelationShipList'].append(k.to_map() if k else None)
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EntryRule') is not None:
            self.entry_rule = m.get('EntryRule')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        self.swimming_lane_app_relation_ship_list = []
        if m.get('SwimmingLaneAppRelationShipList') is not None:
            for k in m.get('SwimmingLaneAppRelationShipList'):
                temp_model = UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList()
                self.swimming_lane_app_relation_ship_list.append(temp_model.from_map(k))
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class UpdateSwimmingLaneResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: UpdateSwimmingLaneResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The data that is returned.
        self.data = data
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateSwimmingLaneResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateSwimmingLaneResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSwimmingLaneResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSwimmingLaneResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSwimmingLaneGroupRequest(TeaModel):
    def __init__(
        self,
        app_ids: str = None,
        entry_app: str = None,
        group_id: int = None,
        name: str = None,
    ):
        # The list of application IDs related to the lane group.
        self.app_ids = app_ids
        # The ingress application. The application is in the EDAS:{application ID} format.
        self.entry_app = entry_app
        # The ID of the lane group.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The name of the lane group.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_ids is not None:
            result['AppIds'] = self.app_ids
        if self.entry_app is not None:
            result['EntryApp'] = self.entry_app
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppIds') is not None:
            self.app_ids = m.get('AppIds')
        if m.get('EntryApp') is not None:
            self.entry_app = m.get('EntryApp')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class UpdateSwimmingLaneGroupResponseBodyDataApplicationList(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        return self


class UpdateSwimmingLaneGroupResponseBodyDataEntryApplication(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        return self


class UpdateSwimmingLaneGroupResponseBodyData(TeaModel):
    def __init__(
        self,
        application_list: List[UpdateSwimmingLaneGroupResponseBodyDataApplicationList] = None,
        entry_application: UpdateSwimmingLaneGroupResponseBodyDataEntryApplication = None,
        id: int = None,
        name: str = None,
        namespace_id: str = None,
    ):
        # The list of applications related to the lane group.
        self.application_list = application_list
        # The EDAS ingress gateway information.
        self.entry_application = entry_application
        # The ID of the lane group.
        self.id = id
        # The name of the lane group.
        self.name = name
        # The ID of the namespace.
        self.namespace_id = namespace_id

    def validate(self):
        if self.application_list:
            for k in self.application_list:
                if k:
                    k.validate()
        if self.entry_application:
            self.entry_application.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ApplicationList'] = []
        if self.application_list is not None:
            for k in self.application_list:
                result['ApplicationList'].append(k.to_map() if k else None)
        if self.entry_application is not None:
            result['EntryApplication'] = self.entry_application.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.application_list = []
        if m.get('ApplicationList') is not None:
            for k in m.get('ApplicationList'):
                temp_model = UpdateSwimmingLaneGroupResponseBodyDataApplicationList()
                self.application_list.append(temp_model.from_map(k))
        if m.get('EntryApplication') is not None:
            temp_model = UpdateSwimmingLaneGroupResponseBodyDataEntryApplication()
            self.entry_application = temp_model.from_map(m['EntryApplication'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class UpdateSwimmingLaneGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: UpdateSwimmingLaneGroupResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The data that is returned.
        self.data = data
        # The additional information that is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateSwimmingLaneGroupResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateSwimmingLaneGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSwimmingLaneGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSwimmingLaneGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


