# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from typing import Dict
from Tea.core import TeaCore

from alibabacloud_tea_openapi.client import Client as OpenApiClient
from alibabacloud_tea_openapi import models as open_api_models
from alibabacloud_tea_util.client import Client as UtilClient
from alibabacloud_endpoint_util.client import Client as EndpointUtilClient
from alibabacloud_ecs20140526 import models as ecs_20140526_models
from alibabacloud_tea_util import models as util_models
from alibabacloud_openapi_util.client import Client as OpenApiUtilClient


class Client(OpenApiClient):
    """
    *\
    """
    def __init__(
        self, 
        config: open_api_models.Config,
    ):
        super().__init__(config)
        self._endpoint_rule = 'regional'
        self._endpoint_map = {
            'cn-hangzhou': 'ecs-cn-hangzhou.aliyuncs.com',
            'cn-shanghai-finance-1': 'ecs-cn-hangzhou.aliyuncs.com',
            'cn-shenzhen-finance-1': 'ecs-cn-hangzhou.aliyuncs.com',
            'cn-north-2-gov-1': 'ecs.aliyuncs.com',
            'ap-northeast-2-pop': 'ecs.aliyuncs.com',
            'cn-beijing-finance-pop': 'ecs.aliyuncs.com',
            'cn-beijing-gov-1': 'ecs.aliyuncs.com',
            'cn-beijing-nu16-b01': 'ecs-cn-hangzhou.aliyuncs.com',
            'cn-edge-1': 'ecs.cn-qingdao-nebula.aliyuncs.com',
            'cn-fujian': 'ecs-cn-hangzhou.aliyuncs.com',
            'cn-haidian-cm12-c01': 'ecs-cn-hangzhou.aliyuncs.com',
            'cn-hangzhou-bj-b01': 'ecs-cn-hangzhou.aliyuncs.com',
            'cn-hangzhou-finance': 'ecs.aliyuncs.com',
            'cn-hangzhou-internal-prod-1': 'ecs-cn-hangzhou.aliyuncs.com',
            'cn-hangzhou-internal-test-1': 'ecs-cn-hangzhou.aliyuncs.com',
            'cn-hangzhou-internal-test-2': 'ecs-cn-hangzhou.aliyuncs.com',
            'cn-hangzhou-internal-test-3': 'ecs-cn-hangzhou.aliyuncs.com',
            'cn-hangzhou-test-306': 'ecs-cn-hangzhou.aliyuncs.com',
            'cn-hongkong-finance-pop': 'ecs.aliyuncs.com',
            'cn-huhehaote-nebula-1': 'ecs.cn-qingdao-nebula.aliyuncs.com',
            'cn-shanghai-et15-b01': 'ecs-cn-hangzhou.aliyuncs.com',
            'cn-shanghai-et2-b01': 'ecs-cn-hangzhou.aliyuncs.com',
            'cn-shanghai-inner': 'ecs.aliyuncs.com',
            'cn-shanghai-internal-test-1': 'ecs-cn-hangzhou.aliyuncs.com',
            'cn-shenzhen-inner': 'ecs.aliyuncs.com',
            'cn-shenzhen-st4-d01': 'ecs-cn-hangzhou.aliyuncs.com',
            'cn-shenzhen-su18-b01': 'ecs-cn-hangzhou.aliyuncs.com',
            'cn-wuhan': 'ecs.aliyuncs.com',
            'cn-yushanfang': 'ecs.aliyuncs.com',
            'cn-zhangbei': 'ecs.aliyuncs.com',
            'cn-zhangbei-na61-b01': 'ecs-cn-hangzhou.aliyuncs.com',
            'cn-zhangjiakou-na62-a01': 'ecs.cn-zhangjiakou.aliyuncs.com',
            'cn-zhengzhou-nebula-1': 'ecs.cn-qingdao-nebula.aliyuncs.com',
            'eu-west-1-oxs': 'ecs.cn-shenzhen-cloudstone.aliyuncs.com',
            'rus-west-1-pop': 'ecs.aliyuncs.com'
        }
        self.check_config(config)
        self._endpoint = self.get_endpoint('ecs', self._region_id, self._endpoint_rule, self._network, self._suffix, self._endpoint_map, self._endpoint)

    def get_endpoint(
        self,
        product_id: str,
        region_id: str,
        endpoint_rule: str,
        network: str,
        suffix: str,
        endpoint_map: Dict[str, str],
        endpoint: str,
    ) -> str:
        if not UtilClient.empty(endpoint):
            return endpoint
        if not UtilClient.is_unset(endpoint_map) and not UtilClient.empty(endpoint_map.get(region_id)):
            return endpoint_map.get(region_id)
        return EndpointUtilClient.get_endpoint_rules(product_id, region_id, endpoint_rule, network, suffix)

    def accept_inquired_system_event_with_options(
        self,
        request: ecs_20140526_models.AcceptInquiredSystemEventRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AcceptInquiredSystemEventResponse:
        """
        @summary Accepts the default operation for a system event in the Inquiring state and authorizes the system to perform the operation.
        
        @param request: AcceptInquiredSystemEventRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AcceptInquiredSystemEventResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.choice):
            query['Choice'] = request.choice
        if not UtilClient.is_unset(request.event_id):
            query['EventId'] = request.event_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AcceptInquiredSystemEvent',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AcceptInquiredSystemEventResponse(),
            self.call_api(params, req, runtime)
        )

    async def accept_inquired_system_event_with_options_async(
        self,
        request: ecs_20140526_models.AcceptInquiredSystemEventRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AcceptInquiredSystemEventResponse:
        """
        @summary Accepts the default operation for a system event in the Inquiring state and authorizes the system to perform the operation.
        
        @param request: AcceptInquiredSystemEventRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AcceptInquiredSystemEventResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.choice):
            query['Choice'] = request.choice
        if not UtilClient.is_unset(request.event_id):
            query['EventId'] = request.event_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AcceptInquiredSystemEvent',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AcceptInquiredSystemEventResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def accept_inquired_system_event(
        self,
        request: ecs_20140526_models.AcceptInquiredSystemEventRequest,
    ) -> ecs_20140526_models.AcceptInquiredSystemEventResponse:
        """
        @summary Accepts the default operation for a system event in the Inquiring state and authorizes the system to perform the operation.
        
        @param request: AcceptInquiredSystemEventRequest
        @return: AcceptInquiredSystemEventResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.accept_inquired_system_event_with_options(request, runtime)

    async def accept_inquired_system_event_async(
        self,
        request: ecs_20140526_models.AcceptInquiredSystemEventRequest,
    ) -> ecs_20140526_models.AcceptInquiredSystemEventResponse:
        """
        @summary Accepts the default operation for a system event in the Inquiring state and authorizes the system to perform the operation.
        
        @param request: AcceptInquiredSystemEventRequest
        @return: AcceptInquiredSystemEventResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.accept_inquired_system_event_with_options_async(request, runtime)

    def activate_router_interface_with_options(
        self,
        request: ecs_20140526_models.ActivateRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ActivateRouterInterfaceResponse:
        """
        @deprecated OpenAPI ActivateRouterInterface is deprecated, please use Vpc::2016-04-28::ActivateRouterInterface instead.
        
        @summary ActivateRouterInterface
        
        @param request: ActivateRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ActivateRouterInterfaceResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ActivateRouterInterface',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ActivateRouterInterfaceResponse(),
            self.call_api(params, req, runtime)
        )

    async def activate_router_interface_with_options_async(
        self,
        request: ecs_20140526_models.ActivateRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ActivateRouterInterfaceResponse:
        """
        @deprecated OpenAPI ActivateRouterInterface is deprecated, please use Vpc::2016-04-28::ActivateRouterInterface instead.
        
        @summary ActivateRouterInterface
        
        @param request: ActivateRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ActivateRouterInterfaceResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ActivateRouterInterface',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ActivateRouterInterfaceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def activate_router_interface(
        self,
        request: ecs_20140526_models.ActivateRouterInterfaceRequest,
    ) -> ecs_20140526_models.ActivateRouterInterfaceResponse:
        """
        @deprecated OpenAPI ActivateRouterInterface is deprecated, please use Vpc::2016-04-28::ActivateRouterInterface instead.
        
        @summary ActivateRouterInterface
        
        @param request: ActivateRouterInterfaceRequest
        @return: ActivateRouterInterfaceResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.activate_router_interface_with_options(request, runtime)

    async def activate_router_interface_async(
        self,
        request: ecs_20140526_models.ActivateRouterInterfaceRequest,
    ) -> ecs_20140526_models.ActivateRouterInterfaceResponse:
        """
        @deprecated OpenAPI ActivateRouterInterface is deprecated, please use Vpc::2016-04-28::ActivateRouterInterface instead.
        
        @summary ActivateRouterInterface
        
        @param request: ActivateRouterInterfaceRequest
        @return: ActivateRouterInterfaceResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.activate_router_interface_with_options_async(request, runtime)

    def add_bandwidth_package_ips_with_options(
        self,
        request: ecs_20140526_models.AddBandwidthPackageIpsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AddBandwidthPackageIpsResponse:
        """
        @deprecated OpenAPI AddBandwidthPackageIps is deprecated, please use Vpc::2016-04-28::AddBandwidthPackageIps instead.
        
        @summary AddBandwidthPackageIps
        
        @param request: AddBandwidthPackageIpsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddBandwidthPackageIpsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ip_count):
            query['IpCount'] = request.ip_count
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddBandwidthPackageIps',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AddBandwidthPackageIpsResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_bandwidth_package_ips_with_options_async(
        self,
        request: ecs_20140526_models.AddBandwidthPackageIpsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AddBandwidthPackageIpsResponse:
        """
        @deprecated OpenAPI AddBandwidthPackageIps is deprecated, please use Vpc::2016-04-28::AddBandwidthPackageIps instead.
        
        @summary AddBandwidthPackageIps
        
        @param request: AddBandwidthPackageIpsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddBandwidthPackageIpsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ip_count):
            query['IpCount'] = request.ip_count
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddBandwidthPackageIps',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AddBandwidthPackageIpsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_bandwidth_package_ips(
        self,
        request: ecs_20140526_models.AddBandwidthPackageIpsRequest,
    ) -> ecs_20140526_models.AddBandwidthPackageIpsResponse:
        """
        @deprecated OpenAPI AddBandwidthPackageIps is deprecated, please use Vpc::2016-04-28::AddBandwidthPackageIps instead.
        
        @summary AddBandwidthPackageIps
        
        @param request: AddBandwidthPackageIpsRequest
        @return: AddBandwidthPackageIpsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.add_bandwidth_package_ips_with_options(request, runtime)

    async def add_bandwidth_package_ips_async(
        self,
        request: ecs_20140526_models.AddBandwidthPackageIpsRequest,
    ) -> ecs_20140526_models.AddBandwidthPackageIpsResponse:
        """
        @deprecated OpenAPI AddBandwidthPackageIps is deprecated, please use Vpc::2016-04-28::AddBandwidthPackageIps instead.
        
        @summary AddBandwidthPackageIps
        
        @param request: AddBandwidthPackageIpsRequest
        @return: AddBandwidthPackageIpsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_bandwidth_package_ips_with_options_async(request, runtime)

    def add_tags_with_options(
        self,
        request: ecs_20140526_models.AddTagsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AddTagsResponse:
        """
        @deprecated OpenAPI AddTags is deprecated, please use Ecs::2014-05-26::TagResources instead.
        
        @summary Adds tags to Elastic Compute Service (ECS) resources, or overwrites tags of ECS resources. You can add tags to ECS resources such as instances, disks, snapshots, images, and security groups for easy management.
        
        @description When you call this operation, take note of the following items:
        Up to 20 tags can be added to each ECS resource.
        `Tag.N.Key` must match `Tag.N.Value` based on the value of N.
        If you add a tag that has the same key (`Tag.N.Key`) as an existing tag on the specified resource, the new tag value (`Tag.N.Value`) overwrites the original tag value.
        
        @param request: AddTagsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddTagsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddTags',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AddTagsResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_tags_with_options_async(
        self,
        request: ecs_20140526_models.AddTagsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AddTagsResponse:
        """
        @deprecated OpenAPI AddTags is deprecated, please use Ecs::2014-05-26::TagResources instead.
        
        @summary Adds tags to Elastic Compute Service (ECS) resources, or overwrites tags of ECS resources. You can add tags to ECS resources such as instances, disks, snapshots, images, and security groups for easy management.
        
        @description When you call this operation, take note of the following items:
        Up to 20 tags can be added to each ECS resource.
        `Tag.N.Key` must match `Tag.N.Value` based on the value of N.
        If you add a tag that has the same key (`Tag.N.Key`) as an existing tag on the specified resource, the new tag value (`Tag.N.Value`) overwrites the original tag value.
        
        @param request: AddTagsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddTagsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddTags',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AddTagsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_tags(
        self,
        request: ecs_20140526_models.AddTagsRequest,
    ) -> ecs_20140526_models.AddTagsResponse:
        """
        @deprecated OpenAPI AddTags is deprecated, please use Ecs::2014-05-26::TagResources instead.
        
        @summary Adds tags to Elastic Compute Service (ECS) resources, or overwrites tags of ECS resources. You can add tags to ECS resources such as instances, disks, snapshots, images, and security groups for easy management.
        
        @description When you call this operation, take note of the following items:
        Up to 20 tags can be added to each ECS resource.
        `Tag.N.Key` must match `Tag.N.Value` based on the value of N.
        If you add a tag that has the same key (`Tag.N.Key`) as an existing tag on the specified resource, the new tag value (`Tag.N.Value`) overwrites the original tag value.
        
        @param request: AddTagsRequest
        @return: AddTagsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.add_tags_with_options(request, runtime)

    async def add_tags_async(
        self,
        request: ecs_20140526_models.AddTagsRequest,
    ) -> ecs_20140526_models.AddTagsResponse:
        """
        @deprecated OpenAPI AddTags is deprecated, please use Ecs::2014-05-26::TagResources instead.
        
        @summary Adds tags to Elastic Compute Service (ECS) resources, or overwrites tags of ECS resources. You can add tags to ECS resources such as instances, disks, snapshots, images, and security groups for easy management.
        
        @description When you call this operation, take note of the following items:
        Up to 20 tags can be added to each ECS resource.
        `Tag.N.Key` must match `Tag.N.Value` based on the value of N.
        If you add a tag that has the same key (`Tag.N.Key`) as an existing tag on the specified resource, the new tag value (`Tag.N.Value`) overwrites the original tag value.
        
        @param request: AddTagsRequest
        @return: AddTagsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_tags_with_options_async(request, runtime)

    def allocate_dedicated_hosts_with_options(
        self,
        request: ecs_20140526_models.AllocateDedicatedHostsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AllocateDedicatedHostsResponse:
        """
        @summary Creates pay-as-you-go or subscription dedicated hosts. A dedicated host is a physical server dedicated to a single tenant. You can create Elastic Compute Service (ECS) instances on a dedicated host and view the attributes of a dedicated host.
        
        @description Before you create a dedicated host, you can call the [DescribeAvailableResource](https://help.aliyun.com/document_detail/66186.html) operation to query the resources available in a specific region or zone.
        We recommend that you understand the billing methods of resources before you create a dedicated host. You are charged for resources used by the created dedicated host. For more information, see [Billing overview](https://help.aliyun.com/document_detail/68978.html).
        You can create up to 100 pay-as-you-go or subscription dedicated hosts at a time.
        After a dedicated host is created, you can use the returned dedicated host ID as the value of a request parameter to call the [DescribeDedicatedHosts](https://help.aliyun.com/document_detail/134242.html) operation to query the state of the dedicated host.
        After you submit a request to create a dedicated host, an error is returned if a specific parameter is invalid or if the requested resources are insufficient. For more information about error causes, see the "Error codes" section of this topic.
        After a dedicated host is created, you can call the [ModifyInstanceDeployment](https://help.aliyun.com/document_detail/134248.html) operation to migrate ECS instances from a shared host to the dedicated host. You can also migrate ECS instances from another dedicated host to the created dedicated host.
        
        @param request: AllocateDedicatedHostsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AllocateDedicatedHostsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.action_on_maintenance):
            query['ActionOnMaintenance'] = request.action_on_maintenance
        if not UtilClient.is_unset(request.auto_placement):
            query['AutoPlacement'] = request.auto_placement
        if not UtilClient.is_unset(request.auto_release_time):
            query['AutoReleaseTime'] = request.auto_release_time
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_period):
            query['AutoRenewPeriod'] = request.auto_renew_period
        if not UtilClient.is_unset(request.charge_type):
            query['ChargeType'] = request.charge_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.cpu_over_commit_ratio):
            query['CpuOverCommitRatio'] = request.cpu_over_commit_ratio
        if not UtilClient.is_unset(request.dedicated_host_cluster_id):
            query['DedicatedHostClusterId'] = request.dedicated_host_cluster_id
        if not UtilClient.is_unset(request.dedicated_host_name):
            query['DedicatedHostName'] = request.dedicated_host_name
        if not UtilClient.is_unset(request.dedicated_host_type):
            query['DedicatedHostType'] = request.dedicated_host_type
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.min_quantity):
            query['MinQuantity'] = request.min_quantity
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.quantity):
            query['Quantity'] = request.quantity
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.network_attributes):
            query['NetworkAttributes'] = request.network_attributes
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AllocateDedicatedHosts',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AllocateDedicatedHostsResponse(),
            self.call_api(params, req, runtime)
        )

    async def allocate_dedicated_hosts_with_options_async(
        self,
        request: ecs_20140526_models.AllocateDedicatedHostsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AllocateDedicatedHostsResponse:
        """
        @summary Creates pay-as-you-go or subscription dedicated hosts. A dedicated host is a physical server dedicated to a single tenant. You can create Elastic Compute Service (ECS) instances on a dedicated host and view the attributes of a dedicated host.
        
        @description Before you create a dedicated host, you can call the [DescribeAvailableResource](https://help.aliyun.com/document_detail/66186.html) operation to query the resources available in a specific region or zone.
        We recommend that you understand the billing methods of resources before you create a dedicated host. You are charged for resources used by the created dedicated host. For more information, see [Billing overview](https://help.aliyun.com/document_detail/68978.html).
        You can create up to 100 pay-as-you-go or subscription dedicated hosts at a time.
        After a dedicated host is created, you can use the returned dedicated host ID as the value of a request parameter to call the [DescribeDedicatedHosts](https://help.aliyun.com/document_detail/134242.html) operation to query the state of the dedicated host.
        After you submit a request to create a dedicated host, an error is returned if a specific parameter is invalid or if the requested resources are insufficient. For more information about error causes, see the "Error codes" section of this topic.
        After a dedicated host is created, you can call the [ModifyInstanceDeployment](https://help.aliyun.com/document_detail/134248.html) operation to migrate ECS instances from a shared host to the dedicated host. You can also migrate ECS instances from another dedicated host to the created dedicated host.
        
        @param request: AllocateDedicatedHostsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AllocateDedicatedHostsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.action_on_maintenance):
            query['ActionOnMaintenance'] = request.action_on_maintenance
        if not UtilClient.is_unset(request.auto_placement):
            query['AutoPlacement'] = request.auto_placement
        if not UtilClient.is_unset(request.auto_release_time):
            query['AutoReleaseTime'] = request.auto_release_time
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_period):
            query['AutoRenewPeriod'] = request.auto_renew_period
        if not UtilClient.is_unset(request.charge_type):
            query['ChargeType'] = request.charge_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.cpu_over_commit_ratio):
            query['CpuOverCommitRatio'] = request.cpu_over_commit_ratio
        if not UtilClient.is_unset(request.dedicated_host_cluster_id):
            query['DedicatedHostClusterId'] = request.dedicated_host_cluster_id
        if not UtilClient.is_unset(request.dedicated_host_name):
            query['DedicatedHostName'] = request.dedicated_host_name
        if not UtilClient.is_unset(request.dedicated_host_type):
            query['DedicatedHostType'] = request.dedicated_host_type
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.min_quantity):
            query['MinQuantity'] = request.min_quantity
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.quantity):
            query['Quantity'] = request.quantity
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.network_attributes):
            query['NetworkAttributes'] = request.network_attributes
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AllocateDedicatedHosts',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AllocateDedicatedHostsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def allocate_dedicated_hosts(
        self,
        request: ecs_20140526_models.AllocateDedicatedHostsRequest,
    ) -> ecs_20140526_models.AllocateDedicatedHostsResponse:
        """
        @summary Creates pay-as-you-go or subscription dedicated hosts. A dedicated host is a physical server dedicated to a single tenant. You can create Elastic Compute Service (ECS) instances on a dedicated host and view the attributes of a dedicated host.
        
        @description Before you create a dedicated host, you can call the [DescribeAvailableResource](https://help.aliyun.com/document_detail/66186.html) operation to query the resources available in a specific region or zone.
        We recommend that you understand the billing methods of resources before you create a dedicated host. You are charged for resources used by the created dedicated host. For more information, see [Billing overview](https://help.aliyun.com/document_detail/68978.html).
        You can create up to 100 pay-as-you-go or subscription dedicated hosts at a time.
        After a dedicated host is created, you can use the returned dedicated host ID as the value of a request parameter to call the [DescribeDedicatedHosts](https://help.aliyun.com/document_detail/134242.html) operation to query the state of the dedicated host.
        After you submit a request to create a dedicated host, an error is returned if a specific parameter is invalid or if the requested resources are insufficient. For more information about error causes, see the "Error codes" section of this topic.
        After a dedicated host is created, you can call the [ModifyInstanceDeployment](https://help.aliyun.com/document_detail/134248.html) operation to migrate ECS instances from a shared host to the dedicated host. You can also migrate ECS instances from another dedicated host to the created dedicated host.
        
        @param request: AllocateDedicatedHostsRequest
        @return: AllocateDedicatedHostsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.allocate_dedicated_hosts_with_options(request, runtime)

    async def allocate_dedicated_hosts_async(
        self,
        request: ecs_20140526_models.AllocateDedicatedHostsRequest,
    ) -> ecs_20140526_models.AllocateDedicatedHostsResponse:
        """
        @summary Creates pay-as-you-go or subscription dedicated hosts. A dedicated host is a physical server dedicated to a single tenant. You can create Elastic Compute Service (ECS) instances on a dedicated host and view the attributes of a dedicated host.
        
        @description Before you create a dedicated host, you can call the [DescribeAvailableResource](https://help.aliyun.com/document_detail/66186.html) operation to query the resources available in a specific region or zone.
        We recommend that you understand the billing methods of resources before you create a dedicated host. You are charged for resources used by the created dedicated host. For more information, see [Billing overview](https://help.aliyun.com/document_detail/68978.html).
        You can create up to 100 pay-as-you-go or subscription dedicated hosts at a time.
        After a dedicated host is created, you can use the returned dedicated host ID as the value of a request parameter to call the [DescribeDedicatedHosts](https://help.aliyun.com/document_detail/134242.html) operation to query the state of the dedicated host.
        After you submit a request to create a dedicated host, an error is returned if a specific parameter is invalid or if the requested resources are insufficient. For more information about error causes, see the "Error codes" section of this topic.
        After a dedicated host is created, you can call the [ModifyInstanceDeployment](https://help.aliyun.com/document_detail/134248.html) operation to migrate ECS instances from a shared host to the dedicated host. You can also migrate ECS instances from another dedicated host to the created dedicated host.
        
        @param request: AllocateDedicatedHostsRequest
        @return: AllocateDedicatedHostsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.allocate_dedicated_hosts_with_options_async(request, runtime)

    def allocate_eip_address_with_options(
        self,
        request: ecs_20140526_models.AllocateEipAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AllocateEipAddressResponse:
        """
        @deprecated OpenAPI AllocateEipAddress is deprecated, please use Vpc::2016-04-28::AllocateEipAddress instead.
        
        @summary AllocateEipAddress
        
        @description > This operation has been upgraded. We recommend that you do not use it. For information about the new version of this operation, see [AllocateEipAddress](https://help.aliyun.com/document_detail/120192.html).
        
        @param request: AllocateEipAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AllocateEipAddressResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.activity_id):
            query['ActivityId'] = request.activity_id
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.isp):
            query['ISP'] = request.isp
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AllocateEipAddress',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AllocateEipAddressResponse(),
            self.call_api(params, req, runtime)
        )

    async def allocate_eip_address_with_options_async(
        self,
        request: ecs_20140526_models.AllocateEipAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AllocateEipAddressResponse:
        """
        @deprecated OpenAPI AllocateEipAddress is deprecated, please use Vpc::2016-04-28::AllocateEipAddress instead.
        
        @summary AllocateEipAddress
        
        @description > This operation has been upgraded. We recommend that you do not use it. For information about the new version of this operation, see [AllocateEipAddress](https://help.aliyun.com/document_detail/120192.html).
        
        @param request: AllocateEipAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AllocateEipAddressResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.activity_id):
            query['ActivityId'] = request.activity_id
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.isp):
            query['ISP'] = request.isp
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AllocateEipAddress',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AllocateEipAddressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def allocate_eip_address(
        self,
        request: ecs_20140526_models.AllocateEipAddressRequest,
    ) -> ecs_20140526_models.AllocateEipAddressResponse:
        """
        @deprecated OpenAPI AllocateEipAddress is deprecated, please use Vpc::2016-04-28::AllocateEipAddress instead.
        
        @summary AllocateEipAddress
        
        @description > This operation has been upgraded. We recommend that you do not use it. For information about the new version of this operation, see [AllocateEipAddress](https://help.aliyun.com/document_detail/120192.html).
        
        @param request: AllocateEipAddressRequest
        @return: AllocateEipAddressResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.allocate_eip_address_with_options(request, runtime)

    async def allocate_eip_address_async(
        self,
        request: ecs_20140526_models.AllocateEipAddressRequest,
    ) -> ecs_20140526_models.AllocateEipAddressResponse:
        """
        @deprecated OpenAPI AllocateEipAddress is deprecated, please use Vpc::2016-04-28::AllocateEipAddress instead.
        
        @summary AllocateEipAddress
        
        @description > This operation has been upgraded. We recommend that you do not use it. For information about the new version of this operation, see [AllocateEipAddress](https://help.aliyun.com/document_detail/120192.html).
        
        @param request: AllocateEipAddressRequest
        @return: AllocateEipAddressResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.allocate_eip_address_with_options_async(request, runtime)

    def allocate_public_ip_address_with_options(
        self,
        request: ecs_20140526_models.AllocatePublicIpAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AllocatePublicIpAddressResponse:
        """
        @summary Assigns a static public IP address (also called system-assigned public IP address or auto-assigned public IP address) to an Elastic Compute Service (ECS) instance.
        
        @description ### [](#)Precautions
        The ECS instance to which you want to assign a static public IP address must be in the **Running** (`Running`) or **Stopped** (`Stopped`) state.
        If `OperationLocks` in the response of the DescribeInstances operation contains `"LockReason" : "security"` for an ECS instance, the instance is [locked for security reasons](https://help.aliyun.com/document_detail/25695.html) and cannot be assigned a static public IP address.
        When you call the AllocatePublicIpAddress operation for an ECS instance, make sure that the public bandwidth of the instance is greater than 0 Mbit/s. You can call the [ModifyInstanceNetworkSpec](https://help.aliyun.com/document_detail/2679879.html) operation to change the public bandwidth.
        ### [](#)Considerations
        Only users in the whitelist can specify `IpAddress` in the AllocatePublicIpAddress operation. If the public bandwidth of your ECS instance is greater than 0 Mbit/s, you can specify the ID of the instance (`InstanceId`) to randomly assign a static public IP address to the instance. If the public bandwidth of your ECS instance is 0 Mbit/s, you must call the [ModifyInstanceNetworkSpec](https://help.aliyun.com/document_detail/2679879.html) operation to increase the public bandwidth of the instance before you call the AllocatePublicIpAddress operation.
        You can assign only one static public IP address to an ECS instance. If the instance already has a static public IP address, the static public IP address is returned for the `IpAddress` response parameter.
        After you assign a static public IP address to an ECS instance, you must restart the instance ([RebootInstance](https://help.aliyun.com/document_detail/25502.html)) or start the instance ([StartInstance](https://help.aliyun.com/document_detail/25500.html)) for the public IP address to take effect.
        If an ECS instance resides in a virtual private cloud (VPC), you can assign a static public IP address to the instance or associate an elastic IP address (EIP) with the instance. For more information, see [AssociateEipAddress](https://help.aliyun.com/document_detail/2518064.html).
        
        @param request: AllocatePublicIpAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AllocatePublicIpAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.ip_address):
            query['IpAddress'] = request.ip_address
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vlan_id):
            query['VlanId'] = request.vlan_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AllocatePublicIpAddress',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AllocatePublicIpAddressResponse(),
            self.call_api(params, req, runtime)
        )

    async def allocate_public_ip_address_with_options_async(
        self,
        request: ecs_20140526_models.AllocatePublicIpAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AllocatePublicIpAddressResponse:
        """
        @summary Assigns a static public IP address (also called system-assigned public IP address or auto-assigned public IP address) to an Elastic Compute Service (ECS) instance.
        
        @description ### [](#)Precautions
        The ECS instance to which you want to assign a static public IP address must be in the **Running** (`Running`) or **Stopped** (`Stopped`) state.
        If `OperationLocks` in the response of the DescribeInstances operation contains `"LockReason" : "security"` for an ECS instance, the instance is [locked for security reasons](https://help.aliyun.com/document_detail/25695.html) and cannot be assigned a static public IP address.
        When you call the AllocatePublicIpAddress operation for an ECS instance, make sure that the public bandwidth of the instance is greater than 0 Mbit/s. You can call the [ModifyInstanceNetworkSpec](https://help.aliyun.com/document_detail/2679879.html) operation to change the public bandwidth.
        ### [](#)Considerations
        Only users in the whitelist can specify `IpAddress` in the AllocatePublicIpAddress operation. If the public bandwidth of your ECS instance is greater than 0 Mbit/s, you can specify the ID of the instance (`InstanceId`) to randomly assign a static public IP address to the instance. If the public bandwidth of your ECS instance is 0 Mbit/s, you must call the [ModifyInstanceNetworkSpec](https://help.aliyun.com/document_detail/2679879.html) operation to increase the public bandwidth of the instance before you call the AllocatePublicIpAddress operation.
        You can assign only one static public IP address to an ECS instance. If the instance already has a static public IP address, the static public IP address is returned for the `IpAddress` response parameter.
        After you assign a static public IP address to an ECS instance, you must restart the instance ([RebootInstance](https://help.aliyun.com/document_detail/25502.html)) or start the instance ([StartInstance](https://help.aliyun.com/document_detail/25500.html)) for the public IP address to take effect.
        If an ECS instance resides in a virtual private cloud (VPC), you can assign a static public IP address to the instance or associate an elastic IP address (EIP) with the instance. For more information, see [AssociateEipAddress](https://help.aliyun.com/document_detail/2518064.html).
        
        @param request: AllocatePublicIpAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AllocatePublicIpAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.ip_address):
            query['IpAddress'] = request.ip_address
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vlan_id):
            query['VlanId'] = request.vlan_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AllocatePublicIpAddress',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AllocatePublicIpAddressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def allocate_public_ip_address(
        self,
        request: ecs_20140526_models.AllocatePublicIpAddressRequest,
    ) -> ecs_20140526_models.AllocatePublicIpAddressResponse:
        """
        @summary Assigns a static public IP address (also called system-assigned public IP address or auto-assigned public IP address) to an Elastic Compute Service (ECS) instance.
        
        @description ### [](#)Precautions
        The ECS instance to which you want to assign a static public IP address must be in the **Running** (`Running`) or **Stopped** (`Stopped`) state.
        If `OperationLocks` in the response of the DescribeInstances operation contains `"LockReason" : "security"` for an ECS instance, the instance is [locked for security reasons](https://help.aliyun.com/document_detail/25695.html) and cannot be assigned a static public IP address.
        When you call the AllocatePublicIpAddress operation for an ECS instance, make sure that the public bandwidth of the instance is greater than 0 Mbit/s. You can call the [ModifyInstanceNetworkSpec](https://help.aliyun.com/document_detail/2679879.html) operation to change the public bandwidth.
        ### [](#)Considerations
        Only users in the whitelist can specify `IpAddress` in the AllocatePublicIpAddress operation. If the public bandwidth of your ECS instance is greater than 0 Mbit/s, you can specify the ID of the instance (`InstanceId`) to randomly assign a static public IP address to the instance. If the public bandwidth of your ECS instance is 0 Mbit/s, you must call the [ModifyInstanceNetworkSpec](https://help.aliyun.com/document_detail/2679879.html) operation to increase the public bandwidth of the instance before you call the AllocatePublicIpAddress operation.
        You can assign only one static public IP address to an ECS instance. If the instance already has a static public IP address, the static public IP address is returned for the `IpAddress` response parameter.
        After you assign a static public IP address to an ECS instance, you must restart the instance ([RebootInstance](https://help.aliyun.com/document_detail/25502.html)) or start the instance ([StartInstance](https://help.aliyun.com/document_detail/25500.html)) for the public IP address to take effect.
        If an ECS instance resides in a virtual private cloud (VPC), you can assign a static public IP address to the instance or associate an elastic IP address (EIP) with the instance. For more information, see [AssociateEipAddress](https://help.aliyun.com/document_detail/2518064.html).
        
        @param request: AllocatePublicIpAddressRequest
        @return: AllocatePublicIpAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.allocate_public_ip_address_with_options(request, runtime)

    async def allocate_public_ip_address_async(
        self,
        request: ecs_20140526_models.AllocatePublicIpAddressRequest,
    ) -> ecs_20140526_models.AllocatePublicIpAddressResponse:
        """
        @summary Assigns a static public IP address (also called system-assigned public IP address or auto-assigned public IP address) to an Elastic Compute Service (ECS) instance.
        
        @description ### [](#)Precautions
        The ECS instance to which you want to assign a static public IP address must be in the **Running** (`Running`) or **Stopped** (`Stopped`) state.
        If `OperationLocks` in the response of the DescribeInstances operation contains `"LockReason" : "security"` for an ECS instance, the instance is [locked for security reasons](https://help.aliyun.com/document_detail/25695.html) and cannot be assigned a static public IP address.
        When you call the AllocatePublicIpAddress operation for an ECS instance, make sure that the public bandwidth of the instance is greater than 0 Mbit/s. You can call the [ModifyInstanceNetworkSpec](https://help.aliyun.com/document_detail/2679879.html) operation to change the public bandwidth.
        ### [](#)Considerations
        Only users in the whitelist can specify `IpAddress` in the AllocatePublicIpAddress operation. If the public bandwidth of your ECS instance is greater than 0 Mbit/s, you can specify the ID of the instance (`InstanceId`) to randomly assign a static public IP address to the instance. If the public bandwidth of your ECS instance is 0 Mbit/s, you must call the [ModifyInstanceNetworkSpec](https://help.aliyun.com/document_detail/2679879.html) operation to increase the public bandwidth of the instance before you call the AllocatePublicIpAddress operation.
        You can assign only one static public IP address to an ECS instance. If the instance already has a static public IP address, the static public IP address is returned for the `IpAddress` response parameter.
        After you assign a static public IP address to an ECS instance, you must restart the instance ([RebootInstance](https://help.aliyun.com/document_detail/25502.html)) or start the instance ([StartInstance](https://help.aliyun.com/document_detail/25500.html)) for the public IP address to take effect.
        If an ECS instance resides in a virtual private cloud (VPC), you can assign a static public IP address to the instance or associate an elastic IP address (EIP) with the instance. For more information, see [AssociateEipAddress](https://help.aliyun.com/document_detail/2518064.html).
        
        @param request: AllocatePublicIpAddressRequest
        @return: AllocatePublicIpAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.allocate_public_ip_address_with_options_async(request, runtime)

    def apply_auto_snapshot_policy_with_options(
        self,
        request: ecs_20140526_models.ApplyAutoSnapshotPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ApplyAutoSnapshotPolicyResponse:
        """
        @summary Applies an automatic snapshot policy to one or more cloud disks. You can call this operation to replace the automatic snapshot policy of a cloud disk.
        
        @description    Each disk can have only one automatic snapshot policy.
        Each automatic snapshot policy can be applied to multiple disks.
        
        @param request: ApplyAutoSnapshotPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ApplyAutoSnapshotPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.auto_snapshot_policy_id):
            query['autoSnapshotPolicyId'] = request.auto_snapshot_policy_id
        if not UtilClient.is_unset(request.disk_ids):
            query['diskIds'] = request.disk_ids
        if not UtilClient.is_unset(request.region_id):
            query['regionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ApplyAutoSnapshotPolicy',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ApplyAutoSnapshotPolicyResponse(),
            self.call_api(params, req, runtime)
        )

    async def apply_auto_snapshot_policy_with_options_async(
        self,
        request: ecs_20140526_models.ApplyAutoSnapshotPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ApplyAutoSnapshotPolicyResponse:
        """
        @summary Applies an automatic snapshot policy to one or more cloud disks. You can call this operation to replace the automatic snapshot policy of a cloud disk.
        
        @description    Each disk can have only one automatic snapshot policy.
        Each automatic snapshot policy can be applied to multiple disks.
        
        @param request: ApplyAutoSnapshotPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ApplyAutoSnapshotPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.auto_snapshot_policy_id):
            query['autoSnapshotPolicyId'] = request.auto_snapshot_policy_id
        if not UtilClient.is_unset(request.disk_ids):
            query['diskIds'] = request.disk_ids
        if not UtilClient.is_unset(request.region_id):
            query['regionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ApplyAutoSnapshotPolicy',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ApplyAutoSnapshotPolicyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def apply_auto_snapshot_policy(
        self,
        request: ecs_20140526_models.ApplyAutoSnapshotPolicyRequest,
    ) -> ecs_20140526_models.ApplyAutoSnapshotPolicyResponse:
        """
        @summary Applies an automatic snapshot policy to one or more cloud disks. You can call this operation to replace the automatic snapshot policy of a cloud disk.
        
        @description    Each disk can have only one automatic snapshot policy.
        Each automatic snapshot policy can be applied to multiple disks.
        
        @param request: ApplyAutoSnapshotPolicyRequest
        @return: ApplyAutoSnapshotPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.apply_auto_snapshot_policy_with_options(request, runtime)

    async def apply_auto_snapshot_policy_async(
        self,
        request: ecs_20140526_models.ApplyAutoSnapshotPolicyRequest,
    ) -> ecs_20140526_models.ApplyAutoSnapshotPolicyResponse:
        """
        @summary Applies an automatic snapshot policy to one or more cloud disks. You can call this operation to replace the automatic snapshot policy of a cloud disk.
        
        @description    Each disk can have only one automatic snapshot policy.
        Each automatic snapshot policy can be applied to multiple disks.
        
        @param request: ApplyAutoSnapshotPolicyRequest
        @return: ApplyAutoSnapshotPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.apply_auto_snapshot_policy_with_options_async(request, runtime)

    def assign_ipv_6addresses_with_options(
        self,
        request: ecs_20140526_models.AssignIpv6AddressesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AssignIpv6AddressesResponse:
        """
        @summary Assigns one or more IPv6 addresses to an elastic network interface (ENI).
        
        @description ## [](#)Usage notes
        You can specify IPv6 addresses in the CIDR block of the vSwitch to which the ENI is connected. You can also specify the number of IPv6 addresses that the system assigns to the ENI. Take note of the following items:
        IPv6 must be enabled on the vSwitch to which the ENI is connected. For more information, see [Enable IPv6 for a vSwitch](https://help.aliyun.com/document_detail/98923.html).
        The ENI must be in the Available (Available) or InUse (InUse) state.
        If you want to assign IPv6 addresses to a primary ENI, make sure that the Elastic Compute Service (ECS) instance to which the ENI is attached is in the Running (Running) or Stopped (Stopped) state.
        The maximum number of IPv6 addresses that can be assigned to an ENI varies based on the instance type of the instance to which the ENI is attached.
        If the ENI is in the Available (Available) state, up to 10 IPv6 addresses can be assigned to the ENI.
        If the ENI is attached to an ECS instance, the maximum number of IPv6 addresses that can be assigned to the ENI varies based on the instance type. For more information, see [Overview of instance families](https://help.aliyun.com/document_detail/25378.html).
        After the operation is called, you can obtain the IPv6 addresses that are assigned to the ENI from the response.
        
        @param request: AssignIpv6AddressesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssignIpv6AddressesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipv_6address):
            query['Ipv6Address'] = request.ipv_6address
        if not UtilClient.is_unset(request.ipv_6address_count):
            query['Ipv6AddressCount'] = request.ipv_6address_count
        if not UtilClient.is_unset(request.ipv_6prefix):
            query['Ipv6Prefix'] = request.ipv_6prefix
        if not UtilClient.is_unset(request.ipv_6prefix_count):
            query['Ipv6PrefixCount'] = request.ipv_6prefix_count
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssignIpv6Addresses',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AssignIpv6AddressesResponse(),
            self.call_api(params, req, runtime)
        )

    async def assign_ipv_6addresses_with_options_async(
        self,
        request: ecs_20140526_models.AssignIpv6AddressesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AssignIpv6AddressesResponse:
        """
        @summary Assigns one or more IPv6 addresses to an elastic network interface (ENI).
        
        @description ## [](#)Usage notes
        You can specify IPv6 addresses in the CIDR block of the vSwitch to which the ENI is connected. You can also specify the number of IPv6 addresses that the system assigns to the ENI. Take note of the following items:
        IPv6 must be enabled on the vSwitch to which the ENI is connected. For more information, see [Enable IPv6 for a vSwitch](https://help.aliyun.com/document_detail/98923.html).
        The ENI must be in the Available (Available) or InUse (InUse) state.
        If you want to assign IPv6 addresses to a primary ENI, make sure that the Elastic Compute Service (ECS) instance to which the ENI is attached is in the Running (Running) or Stopped (Stopped) state.
        The maximum number of IPv6 addresses that can be assigned to an ENI varies based on the instance type of the instance to which the ENI is attached.
        If the ENI is in the Available (Available) state, up to 10 IPv6 addresses can be assigned to the ENI.
        If the ENI is attached to an ECS instance, the maximum number of IPv6 addresses that can be assigned to the ENI varies based on the instance type. For more information, see [Overview of instance families](https://help.aliyun.com/document_detail/25378.html).
        After the operation is called, you can obtain the IPv6 addresses that are assigned to the ENI from the response.
        
        @param request: AssignIpv6AddressesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssignIpv6AddressesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipv_6address):
            query['Ipv6Address'] = request.ipv_6address
        if not UtilClient.is_unset(request.ipv_6address_count):
            query['Ipv6AddressCount'] = request.ipv_6address_count
        if not UtilClient.is_unset(request.ipv_6prefix):
            query['Ipv6Prefix'] = request.ipv_6prefix
        if not UtilClient.is_unset(request.ipv_6prefix_count):
            query['Ipv6PrefixCount'] = request.ipv_6prefix_count
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssignIpv6Addresses',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AssignIpv6AddressesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def assign_ipv_6addresses(
        self,
        request: ecs_20140526_models.AssignIpv6AddressesRequest,
    ) -> ecs_20140526_models.AssignIpv6AddressesResponse:
        """
        @summary Assigns one or more IPv6 addresses to an elastic network interface (ENI).
        
        @description ## [](#)Usage notes
        You can specify IPv6 addresses in the CIDR block of the vSwitch to which the ENI is connected. You can also specify the number of IPv6 addresses that the system assigns to the ENI. Take note of the following items:
        IPv6 must be enabled on the vSwitch to which the ENI is connected. For more information, see [Enable IPv6 for a vSwitch](https://help.aliyun.com/document_detail/98923.html).
        The ENI must be in the Available (Available) or InUse (InUse) state.
        If you want to assign IPv6 addresses to a primary ENI, make sure that the Elastic Compute Service (ECS) instance to which the ENI is attached is in the Running (Running) or Stopped (Stopped) state.
        The maximum number of IPv6 addresses that can be assigned to an ENI varies based on the instance type of the instance to which the ENI is attached.
        If the ENI is in the Available (Available) state, up to 10 IPv6 addresses can be assigned to the ENI.
        If the ENI is attached to an ECS instance, the maximum number of IPv6 addresses that can be assigned to the ENI varies based on the instance type. For more information, see [Overview of instance families](https://help.aliyun.com/document_detail/25378.html).
        After the operation is called, you can obtain the IPv6 addresses that are assigned to the ENI from the response.
        
        @param request: AssignIpv6AddressesRequest
        @return: AssignIpv6AddressesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.assign_ipv_6addresses_with_options(request, runtime)

    async def assign_ipv_6addresses_async(
        self,
        request: ecs_20140526_models.AssignIpv6AddressesRequest,
    ) -> ecs_20140526_models.AssignIpv6AddressesResponse:
        """
        @summary Assigns one or more IPv6 addresses to an elastic network interface (ENI).
        
        @description ## [](#)Usage notes
        You can specify IPv6 addresses in the CIDR block of the vSwitch to which the ENI is connected. You can also specify the number of IPv6 addresses that the system assigns to the ENI. Take note of the following items:
        IPv6 must be enabled on the vSwitch to which the ENI is connected. For more information, see [Enable IPv6 for a vSwitch](https://help.aliyun.com/document_detail/98923.html).
        The ENI must be in the Available (Available) or InUse (InUse) state.
        If you want to assign IPv6 addresses to a primary ENI, make sure that the Elastic Compute Service (ECS) instance to which the ENI is attached is in the Running (Running) or Stopped (Stopped) state.
        The maximum number of IPv6 addresses that can be assigned to an ENI varies based on the instance type of the instance to which the ENI is attached.
        If the ENI is in the Available (Available) state, up to 10 IPv6 addresses can be assigned to the ENI.
        If the ENI is attached to an ECS instance, the maximum number of IPv6 addresses that can be assigned to the ENI varies based on the instance type. For more information, see [Overview of instance families](https://help.aliyun.com/document_detail/25378.html).
        After the operation is called, you can obtain the IPv6 addresses that are assigned to the ENI from the response.
        
        @param request: AssignIpv6AddressesRequest
        @return: AssignIpv6AddressesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.assign_ipv_6addresses_with_options_async(request, runtime)

    def assign_private_ip_addresses_with_options(
        self,
        request: ecs_20140526_models.AssignPrivateIpAddressesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AssignPrivateIpAddressesResponse:
        """
        @summary Assigns secondary private IP addresses to an elastic network interface (ENI). You can specify available private IP addresses within the CIDR block of the vSwitch that is connected to the ENI. Alternatively, you can specify the number of private IP addresses that are automatically assigned from the CIDR block of the vSwitch to the ENI.
        
        @description ## [](#)Usage notes
        The ENI to which you want to assign IP prefixes must be in the Available (Available) or InUse (InUse) state.
        When you assign private IP addresses to a primary ENI, the Elastic Compute Service (ECS) instance to which the ENI is attached must be in the Running (Running) or Stopped (Stopped) state.
        When an ENI is in the Available state, you can assign up to 49 secondary private IP addresses to the ENI. When an ENI is attached to an instance, the number of secondary private IP addresses that can be assigned to the ENI varies based on the instance type. For more information, see [Overview of instance families](https://help.aliyun.com/document_detail/25378.html).
        After the operation is called, you can obtain the assigned secondary private IP addresses from the response.
        
        @param request: AssignPrivateIpAddressesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssignPrivateIpAddressesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipv_4prefix):
            query['Ipv4Prefix'] = request.ipv_4prefix
        if not UtilClient.is_unset(request.ipv_4prefix_count):
            query['Ipv4PrefixCount'] = request.ipv_4prefix_count
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.secondary_private_ip_address_count):
            query['SecondaryPrivateIpAddressCount'] = request.secondary_private_ip_address_count
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssignPrivateIpAddresses',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AssignPrivateIpAddressesResponse(),
            self.call_api(params, req, runtime)
        )

    async def assign_private_ip_addresses_with_options_async(
        self,
        request: ecs_20140526_models.AssignPrivateIpAddressesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AssignPrivateIpAddressesResponse:
        """
        @summary Assigns secondary private IP addresses to an elastic network interface (ENI). You can specify available private IP addresses within the CIDR block of the vSwitch that is connected to the ENI. Alternatively, you can specify the number of private IP addresses that are automatically assigned from the CIDR block of the vSwitch to the ENI.
        
        @description ## [](#)Usage notes
        The ENI to which you want to assign IP prefixes must be in the Available (Available) or InUse (InUse) state.
        When you assign private IP addresses to a primary ENI, the Elastic Compute Service (ECS) instance to which the ENI is attached must be in the Running (Running) or Stopped (Stopped) state.
        When an ENI is in the Available state, you can assign up to 49 secondary private IP addresses to the ENI. When an ENI is attached to an instance, the number of secondary private IP addresses that can be assigned to the ENI varies based on the instance type. For more information, see [Overview of instance families](https://help.aliyun.com/document_detail/25378.html).
        After the operation is called, you can obtain the assigned secondary private IP addresses from the response.
        
        @param request: AssignPrivateIpAddressesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssignPrivateIpAddressesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipv_4prefix):
            query['Ipv4Prefix'] = request.ipv_4prefix
        if not UtilClient.is_unset(request.ipv_4prefix_count):
            query['Ipv4PrefixCount'] = request.ipv_4prefix_count
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.secondary_private_ip_address_count):
            query['SecondaryPrivateIpAddressCount'] = request.secondary_private_ip_address_count
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssignPrivateIpAddresses',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AssignPrivateIpAddressesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def assign_private_ip_addresses(
        self,
        request: ecs_20140526_models.AssignPrivateIpAddressesRequest,
    ) -> ecs_20140526_models.AssignPrivateIpAddressesResponse:
        """
        @summary Assigns secondary private IP addresses to an elastic network interface (ENI). You can specify available private IP addresses within the CIDR block of the vSwitch that is connected to the ENI. Alternatively, you can specify the number of private IP addresses that are automatically assigned from the CIDR block of the vSwitch to the ENI.
        
        @description ## [](#)Usage notes
        The ENI to which you want to assign IP prefixes must be in the Available (Available) or InUse (InUse) state.
        When you assign private IP addresses to a primary ENI, the Elastic Compute Service (ECS) instance to which the ENI is attached must be in the Running (Running) or Stopped (Stopped) state.
        When an ENI is in the Available state, you can assign up to 49 secondary private IP addresses to the ENI. When an ENI is attached to an instance, the number of secondary private IP addresses that can be assigned to the ENI varies based on the instance type. For more information, see [Overview of instance families](https://help.aliyun.com/document_detail/25378.html).
        After the operation is called, you can obtain the assigned secondary private IP addresses from the response.
        
        @param request: AssignPrivateIpAddressesRequest
        @return: AssignPrivateIpAddressesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.assign_private_ip_addresses_with_options(request, runtime)

    async def assign_private_ip_addresses_async(
        self,
        request: ecs_20140526_models.AssignPrivateIpAddressesRequest,
    ) -> ecs_20140526_models.AssignPrivateIpAddressesResponse:
        """
        @summary Assigns secondary private IP addresses to an elastic network interface (ENI). You can specify available private IP addresses within the CIDR block of the vSwitch that is connected to the ENI. Alternatively, you can specify the number of private IP addresses that are automatically assigned from the CIDR block of the vSwitch to the ENI.
        
        @description ## [](#)Usage notes
        The ENI to which you want to assign IP prefixes must be in the Available (Available) or InUse (InUse) state.
        When you assign private IP addresses to a primary ENI, the Elastic Compute Service (ECS) instance to which the ENI is attached must be in the Running (Running) or Stopped (Stopped) state.
        When an ENI is in the Available state, you can assign up to 49 secondary private IP addresses to the ENI. When an ENI is attached to an instance, the number of secondary private IP addresses that can be assigned to the ENI varies based on the instance type. For more information, see [Overview of instance families](https://help.aliyun.com/document_detail/25378.html).
        After the operation is called, you can obtain the assigned secondary private IP addresses from the response.
        
        @param request: AssignPrivateIpAddressesRequest
        @return: AssignPrivateIpAddressesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.assign_private_ip_addresses_with_options_async(request, runtime)

    def associate_eip_address_with_options(
        self,
        request: ecs_20140526_models.AssociateEipAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AssociateEipAddressResponse:
        """
        @deprecated OpenAPI AssociateEipAddress is deprecated, please use Vpc::2016-04-28::AssociateEipAddress instead.
        
        @summary AssociateEipAddress
        
        @param request: AssociateEipAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateEipAddressResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateEipAddress',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AssociateEipAddressResponse(),
            self.call_api(params, req, runtime)
        )

    async def associate_eip_address_with_options_async(
        self,
        request: ecs_20140526_models.AssociateEipAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AssociateEipAddressResponse:
        """
        @deprecated OpenAPI AssociateEipAddress is deprecated, please use Vpc::2016-04-28::AssociateEipAddress instead.
        
        @summary AssociateEipAddress
        
        @param request: AssociateEipAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateEipAddressResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateEipAddress',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AssociateEipAddressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def associate_eip_address(
        self,
        request: ecs_20140526_models.AssociateEipAddressRequest,
    ) -> ecs_20140526_models.AssociateEipAddressResponse:
        """
        @deprecated OpenAPI AssociateEipAddress is deprecated, please use Vpc::2016-04-28::AssociateEipAddress instead.
        
        @summary AssociateEipAddress
        
        @param request: AssociateEipAddressRequest
        @return: AssociateEipAddressResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.associate_eip_address_with_options(request, runtime)

    async def associate_eip_address_async(
        self,
        request: ecs_20140526_models.AssociateEipAddressRequest,
    ) -> ecs_20140526_models.AssociateEipAddressResponse:
        """
        @deprecated OpenAPI AssociateEipAddress is deprecated, please use Vpc::2016-04-28::AssociateEipAddress instead.
        
        @summary AssociateEipAddress
        
        @param request: AssociateEipAddressRequest
        @return: AssociateEipAddressResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.associate_eip_address_with_options_async(request, runtime)

    def associate_ha_vip_with_options(
        self,
        request: ecs_20140526_models.AssociateHaVipRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AssociateHaVipResponse:
        """
        @deprecated OpenAPI AssociateHaVip is deprecated, please use Vpc::2016-04-28::AssociateHaVip instead.
        
        @summary AssociateHaVip
        
        @param request: AssociateHaVipRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateHaVipResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ha_vip_id):
            query['HaVipId'] = request.ha_vip_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateHaVip',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AssociateHaVipResponse(),
            self.call_api(params, req, runtime)
        )

    async def associate_ha_vip_with_options_async(
        self,
        request: ecs_20140526_models.AssociateHaVipRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AssociateHaVipResponse:
        """
        @deprecated OpenAPI AssociateHaVip is deprecated, please use Vpc::2016-04-28::AssociateHaVip instead.
        
        @summary AssociateHaVip
        
        @param request: AssociateHaVipRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateHaVipResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ha_vip_id):
            query['HaVipId'] = request.ha_vip_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateHaVip',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AssociateHaVipResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def associate_ha_vip(
        self,
        request: ecs_20140526_models.AssociateHaVipRequest,
    ) -> ecs_20140526_models.AssociateHaVipResponse:
        """
        @deprecated OpenAPI AssociateHaVip is deprecated, please use Vpc::2016-04-28::AssociateHaVip instead.
        
        @summary AssociateHaVip
        
        @param request: AssociateHaVipRequest
        @return: AssociateHaVipResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.associate_ha_vip_with_options(request, runtime)

    async def associate_ha_vip_async(
        self,
        request: ecs_20140526_models.AssociateHaVipRequest,
    ) -> ecs_20140526_models.AssociateHaVipResponse:
        """
        @deprecated OpenAPI AssociateHaVip is deprecated, please use Vpc::2016-04-28::AssociateHaVip instead.
        
        @summary AssociateHaVip
        
        @param request: AssociateHaVipRequest
        @return: AssociateHaVipResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.associate_ha_vip_with_options_async(request, runtime)

    def attach_classic_link_vpc_with_options(
        self,
        request: ecs_20140526_models.AttachClassicLinkVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AttachClassicLinkVpcResponse:
        """
        @summary Links an instance that is deployed in the classic network to a virtual private cloud (VPC) by establishing a ClassicLink connection between the instance and the VPC. This way, the instance can communicate with cloud resources in the VPC over the internal network.
        
        @description When you call this operation, take note of the following items:
        The instance that you want to connect to a VPC must be in the **Running** or **Stopped** state.
        The ClassicLink feature must be enabled for the destination VPC. For more information, see [Create a ClassicLink connection](https://help.aliyun.com/document_detail/65413.html).
        The instance and the VPC must reside in the same region.
        
        @param request: AttachClassicLinkVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AttachClassicLinkVpcResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AttachClassicLinkVpc',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AttachClassicLinkVpcResponse(),
            self.call_api(params, req, runtime)
        )

    async def attach_classic_link_vpc_with_options_async(
        self,
        request: ecs_20140526_models.AttachClassicLinkVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AttachClassicLinkVpcResponse:
        """
        @summary Links an instance that is deployed in the classic network to a virtual private cloud (VPC) by establishing a ClassicLink connection between the instance and the VPC. This way, the instance can communicate with cloud resources in the VPC over the internal network.
        
        @description When you call this operation, take note of the following items:
        The instance that you want to connect to a VPC must be in the **Running** or **Stopped** state.
        The ClassicLink feature must be enabled for the destination VPC. For more information, see [Create a ClassicLink connection](https://help.aliyun.com/document_detail/65413.html).
        The instance and the VPC must reside in the same region.
        
        @param request: AttachClassicLinkVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AttachClassicLinkVpcResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AttachClassicLinkVpc',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AttachClassicLinkVpcResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def attach_classic_link_vpc(
        self,
        request: ecs_20140526_models.AttachClassicLinkVpcRequest,
    ) -> ecs_20140526_models.AttachClassicLinkVpcResponse:
        """
        @summary Links an instance that is deployed in the classic network to a virtual private cloud (VPC) by establishing a ClassicLink connection between the instance and the VPC. This way, the instance can communicate with cloud resources in the VPC over the internal network.
        
        @description When you call this operation, take note of the following items:
        The instance that you want to connect to a VPC must be in the **Running** or **Stopped** state.
        The ClassicLink feature must be enabled for the destination VPC. For more information, see [Create a ClassicLink connection](https://help.aliyun.com/document_detail/65413.html).
        The instance and the VPC must reside in the same region.
        
        @param request: AttachClassicLinkVpcRequest
        @return: AttachClassicLinkVpcResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.attach_classic_link_vpc_with_options(request, runtime)

    async def attach_classic_link_vpc_async(
        self,
        request: ecs_20140526_models.AttachClassicLinkVpcRequest,
    ) -> ecs_20140526_models.AttachClassicLinkVpcResponse:
        """
        @summary Links an instance that is deployed in the classic network to a virtual private cloud (VPC) by establishing a ClassicLink connection between the instance and the VPC. This way, the instance can communicate with cloud resources in the VPC over the internal network.
        
        @description When you call this operation, take note of the following items:
        The instance that you want to connect to a VPC must be in the **Running** or **Stopped** state.
        The ClassicLink feature must be enabled for the destination VPC. For more information, see [Create a ClassicLink connection](https://help.aliyun.com/document_detail/65413.html).
        The instance and the VPC must reside in the same region.
        
        @param request: AttachClassicLinkVpcRequest
        @return: AttachClassicLinkVpcResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.attach_classic_link_vpc_with_options_async(request, runtime)

    def attach_disk_with_options(
        self,
        request: ecs_20140526_models.AttachDiskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AttachDiskResponse:
        """
        @summary Attaches a pay-as-you-go data disk or a system disk to an Elastic Compute Service (ECS) instance.
        
        @description Take note of the following items:
        The ECS instance and the disk must reside in the same zone.
        The disk must be in the **Unattached** (`Available`) state.
        When you attach the disk as a data disk to an ECS instance, take note of the following items:
        The ECS instance must be in the **Running** (`Running`) or **Stopped** (`Stopped`) state.
        If the disk was separately purchased, the billing method of the disk must be pay-as-you-go.
        If the disk is a system disk that was detached from an ECS instance, no limits apply to the billing method of the disk.
        If the disk is an elastic ephemeral disk that was detached from an ECS instance, the disk can be attached only to the instance.
        When you attach the disk as the system disk to an ECS instance, take note of the following items:
        The ECS instance must be the original instance from which the system disk was detached.
        The ECS instance must be in the **Stopped** (`Stopped`) state.
        You must configure logon credentials for the ECS instance.
        The disk cannot be an elastic ephemeral disk.
        For more information about how to attach a system disk, see [Detach or attach a system disk](https://help.aliyun.com/document_detail/146752.html).
        If the response contains `{"OperationLocks": {"LockReason" : "security"}}` when you query information about an ECS instance, the instance is locked for security reasons. No operations are allowed on the instance.
        
        @param request: AttachDiskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AttachDiskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bootable):
            query['Bootable'] = request.bootable
        if not UtilClient.is_unset(request.delete_with_instance):
            query['DeleteWithInstance'] = request.delete_with_instance
        if not UtilClient.is_unset(request.device):
            query['Device'] = request.device
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.password):
            query['Password'] = request.password
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AttachDisk',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AttachDiskResponse(),
            self.call_api(params, req, runtime)
        )

    async def attach_disk_with_options_async(
        self,
        request: ecs_20140526_models.AttachDiskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AttachDiskResponse:
        """
        @summary Attaches a pay-as-you-go data disk or a system disk to an Elastic Compute Service (ECS) instance.
        
        @description Take note of the following items:
        The ECS instance and the disk must reside in the same zone.
        The disk must be in the **Unattached** (`Available`) state.
        When you attach the disk as a data disk to an ECS instance, take note of the following items:
        The ECS instance must be in the **Running** (`Running`) or **Stopped** (`Stopped`) state.
        If the disk was separately purchased, the billing method of the disk must be pay-as-you-go.
        If the disk is a system disk that was detached from an ECS instance, no limits apply to the billing method of the disk.
        If the disk is an elastic ephemeral disk that was detached from an ECS instance, the disk can be attached only to the instance.
        When you attach the disk as the system disk to an ECS instance, take note of the following items:
        The ECS instance must be the original instance from which the system disk was detached.
        The ECS instance must be in the **Stopped** (`Stopped`) state.
        You must configure logon credentials for the ECS instance.
        The disk cannot be an elastic ephemeral disk.
        For more information about how to attach a system disk, see [Detach or attach a system disk](https://help.aliyun.com/document_detail/146752.html).
        If the response contains `{"OperationLocks": {"LockReason" : "security"}}` when you query information about an ECS instance, the instance is locked for security reasons. No operations are allowed on the instance.
        
        @param request: AttachDiskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AttachDiskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bootable):
            query['Bootable'] = request.bootable
        if not UtilClient.is_unset(request.delete_with_instance):
            query['DeleteWithInstance'] = request.delete_with_instance
        if not UtilClient.is_unset(request.device):
            query['Device'] = request.device
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.password):
            query['Password'] = request.password
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AttachDisk',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AttachDiskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def attach_disk(
        self,
        request: ecs_20140526_models.AttachDiskRequest,
    ) -> ecs_20140526_models.AttachDiskResponse:
        """
        @summary Attaches a pay-as-you-go data disk or a system disk to an Elastic Compute Service (ECS) instance.
        
        @description Take note of the following items:
        The ECS instance and the disk must reside in the same zone.
        The disk must be in the **Unattached** (`Available`) state.
        When you attach the disk as a data disk to an ECS instance, take note of the following items:
        The ECS instance must be in the **Running** (`Running`) or **Stopped** (`Stopped`) state.
        If the disk was separately purchased, the billing method of the disk must be pay-as-you-go.
        If the disk is a system disk that was detached from an ECS instance, no limits apply to the billing method of the disk.
        If the disk is an elastic ephemeral disk that was detached from an ECS instance, the disk can be attached only to the instance.
        When you attach the disk as the system disk to an ECS instance, take note of the following items:
        The ECS instance must be the original instance from which the system disk was detached.
        The ECS instance must be in the **Stopped** (`Stopped`) state.
        You must configure logon credentials for the ECS instance.
        The disk cannot be an elastic ephemeral disk.
        For more information about how to attach a system disk, see [Detach or attach a system disk](https://help.aliyun.com/document_detail/146752.html).
        If the response contains `{"OperationLocks": {"LockReason" : "security"}}` when you query information about an ECS instance, the instance is locked for security reasons. No operations are allowed on the instance.
        
        @param request: AttachDiskRequest
        @return: AttachDiskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.attach_disk_with_options(request, runtime)

    async def attach_disk_async(
        self,
        request: ecs_20140526_models.AttachDiskRequest,
    ) -> ecs_20140526_models.AttachDiskResponse:
        """
        @summary Attaches a pay-as-you-go data disk or a system disk to an Elastic Compute Service (ECS) instance.
        
        @description Take note of the following items:
        The ECS instance and the disk must reside in the same zone.
        The disk must be in the **Unattached** (`Available`) state.
        When you attach the disk as a data disk to an ECS instance, take note of the following items:
        The ECS instance must be in the **Running** (`Running`) or **Stopped** (`Stopped`) state.
        If the disk was separately purchased, the billing method of the disk must be pay-as-you-go.
        If the disk is a system disk that was detached from an ECS instance, no limits apply to the billing method of the disk.
        If the disk is an elastic ephemeral disk that was detached from an ECS instance, the disk can be attached only to the instance.
        When you attach the disk as the system disk to an ECS instance, take note of the following items:
        The ECS instance must be the original instance from which the system disk was detached.
        The ECS instance must be in the **Stopped** (`Stopped`) state.
        You must configure logon credentials for the ECS instance.
        The disk cannot be an elastic ephemeral disk.
        For more information about how to attach a system disk, see [Detach or attach a system disk](https://help.aliyun.com/document_detail/146752.html).
        If the response contains `{"OperationLocks": {"LockReason" : "security"}}` when you query information about an ECS instance, the instance is locked for security reasons. No operations are allowed on the instance.
        
        @param request: AttachDiskRequest
        @return: AttachDiskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.attach_disk_with_options_async(request, runtime)

    def attach_instance_ram_role_with_options(
        self,
        request: ecs_20140526_models.AttachInstanceRamRoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AttachInstanceRamRoleResponse:
        """
        @summary Attaches an instance Resource Access Management (RAM) role to Elastic Compute Service (ECS) instances.
        
        @description You can call the [DescribeInstanceRamRole](https://help.aliyun.com/document_detail/2679686.html) operation to query the [instance RAM roles](https://help.aliyun.com/document_detail/61175.html) that are attached to ECS instances.
        >  If an ECS instance already has an instance RAM role, an error is returned when you attach another instance RAM role to the instance.
        
        @param request: AttachInstanceRamRoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AttachInstanceRamRoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.policy):
            query['Policy'] = request.policy
        if not UtilClient.is_unset(request.ram_role_name):
            query['RamRoleName'] = request.ram_role_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AttachInstanceRamRole',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AttachInstanceRamRoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def attach_instance_ram_role_with_options_async(
        self,
        request: ecs_20140526_models.AttachInstanceRamRoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AttachInstanceRamRoleResponse:
        """
        @summary Attaches an instance Resource Access Management (RAM) role to Elastic Compute Service (ECS) instances.
        
        @description You can call the [DescribeInstanceRamRole](https://help.aliyun.com/document_detail/2679686.html) operation to query the [instance RAM roles](https://help.aliyun.com/document_detail/61175.html) that are attached to ECS instances.
        >  If an ECS instance already has an instance RAM role, an error is returned when you attach another instance RAM role to the instance.
        
        @param request: AttachInstanceRamRoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AttachInstanceRamRoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.policy):
            query['Policy'] = request.policy
        if not UtilClient.is_unset(request.ram_role_name):
            query['RamRoleName'] = request.ram_role_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AttachInstanceRamRole',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AttachInstanceRamRoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def attach_instance_ram_role(
        self,
        request: ecs_20140526_models.AttachInstanceRamRoleRequest,
    ) -> ecs_20140526_models.AttachInstanceRamRoleResponse:
        """
        @summary Attaches an instance Resource Access Management (RAM) role to Elastic Compute Service (ECS) instances.
        
        @description You can call the [DescribeInstanceRamRole](https://help.aliyun.com/document_detail/2679686.html) operation to query the [instance RAM roles](https://help.aliyun.com/document_detail/61175.html) that are attached to ECS instances.
        >  If an ECS instance already has an instance RAM role, an error is returned when you attach another instance RAM role to the instance.
        
        @param request: AttachInstanceRamRoleRequest
        @return: AttachInstanceRamRoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.attach_instance_ram_role_with_options(request, runtime)

    async def attach_instance_ram_role_async(
        self,
        request: ecs_20140526_models.AttachInstanceRamRoleRequest,
    ) -> ecs_20140526_models.AttachInstanceRamRoleResponse:
        """
        @summary Attaches an instance Resource Access Management (RAM) role to Elastic Compute Service (ECS) instances.
        
        @description You can call the [DescribeInstanceRamRole](https://help.aliyun.com/document_detail/2679686.html) operation to query the [instance RAM roles](https://help.aliyun.com/document_detail/61175.html) that are attached to ECS instances.
        >  If an ECS instance already has an instance RAM role, an error is returned when you attach another instance RAM role to the instance.
        
        @param request: AttachInstanceRamRoleRequest
        @return: AttachInstanceRamRoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.attach_instance_ram_role_with_options_async(request, runtime)

    def attach_key_pair_with_options(
        self,
        request: ecs_20140526_models.AttachKeyPairRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AttachKeyPairResponse:
        """
        @summary Binds an SSH key pair to one or more Linux instances.
        
        @description Take note of the following items:
        SSH key pairs are not supported on Windows instances.
        If an SSH key pair is bound to an instance, authentication by using the username and password is disabled for the instance.
        If you bind an SSH key pair to an instance in the **running** state, you must call the [RebootInstance](https://help.aliyun.com/document_detail/25502.html) operation to restart the instance for the key pair to take effect.
        If you bind an SSH key pair to an instance in the **stopped** state, you must call the [StartInstance](https://help.aliyun.com/document_detail/25500.html) operation to start the instance for the key pair to take effect.
        If an instance is already bound to an SSH key pair, the new SSH key pair will replace the original one.
        
        @param request: AttachKeyPairRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AttachKeyPairResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AttachKeyPair',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AttachKeyPairResponse(),
            self.call_api(params, req, runtime)
        )

    async def attach_key_pair_with_options_async(
        self,
        request: ecs_20140526_models.AttachKeyPairRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AttachKeyPairResponse:
        """
        @summary Binds an SSH key pair to one or more Linux instances.
        
        @description Take note of the following items:
        SSH key pairs are not supported on Windows instances.
        If an SSH key pair is bound to an instance, authentication by using the username and password is disabled for the instance.
        If you bind an SSH key pair to an instance in the **running** state, you must call the [RebootInstance](https://help.aliyun.com/document_detail/25502.html) operation to restart the instance for the key pair to take effect.
        If you bind an SSH key pair to an instance in the **stopped** state, you must call the [StartInstance](https://help.aliyun.com/document_detail/25500.html) operation to start the instance for the key pair to take effect.
        If an instance is already bound to an SSH key pair, the new SSH key pair will replace the original one.
        
        @param request: AttachKeyPairRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AttachKeyPairResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AttachKeyPair',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AttachKeyPairResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def attach_key_pair(
        self,
        request: ecs_20140526_models.AttachKeyPairRequest,
    ) -> ecs_20140526_models.AttachKeyPairResponse:
        """
        @summary Binds an SSH key pair to one or more Linux instances.
        
        @description Take note of the following items:
        SSH key pairs are not supported on Windows instances.
        If an SSH key pair is bound to an instance, authentication by using the username and password is disabled for the instance.
        If you bind an SSH key pair to an instance in the **running** state, you must call the [RebootInstance](https://help.aliyun.com/document_detail/25502.html) operation to restart the instance for the key pair to take effect.
        If you bind an SSH key pair to an instance in the **stopped** state, you must call the [StartInstance](https://help.aliyun.com/document_detail/25500.html) operation to start the instance for the key pair to take effect.
        If an instance is already bound to an SSH key pair, the new SSH key pair will replace the original one.
        
        @param request: AttachKeyPairRequest
        @return: AttachKeyPairResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.attach_key_pair_with_options(request, runtime)

    async def attach_key_pair_async(
        self,
        request: ecs_20140526_models.AttachKeyPairRequest,
    ) -> ecs_20140526_models.AttachKeyPairResponse:
        """
        @summary Binds an SSH key pair to one or more Linux instances.
        
        @description Take note of the following items:
        SSH key pairs are not supported on Windows instances.
        If an SSH key pair is bound to an instance, authentication by using the username and password is disabled for the instance.
        If you bind an SSH key pair to an instance in the **running** state, you must call the [RebootInstance](https://help.aliyun.com/document_detail/25502.html) operation to restart the instance for the key pair to take effect.
        If you bind an SSH key pair to an instance in the **stopped** state, you must call the [StartInstance](https://help.aliyun.com/document_detail/25500.html) operation to start the instance for the key pair to take effect.
        If an instance is already bound to an SSH key pair, the new SSH key pair will replace the original one.
        
        @param request: AttachKeyPairRequest
        @return: AttachKeyPairResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.attach_key_pair_with_options_async(request, runtime)

    def attach_network_interface_with_options(
        self,
        request: ecs_20140526_models.AttachNetworkInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AttachNetworkInterfaceResponse:
        """
        @summary Attaches an elastic network interface (ENI) to an Elastic Compute Service (ECS) instance that resides in a virtual private cloud (VPC). When you call this operation, you can specify parameters, such as NetworkInterfaceId, InstanceId, and NetworkCardIndex, in the request.
        
        @description Take note of the following items:
        The ENI must be in the **Available** state. You can attach an ENI to only one instance that resides in the same zone and VPC as the ENI.
        The instance must be in the Running or Stopped state. When you attach ENIs to instances of specific instance types, make sure that the instances are in the Stopped state. For more information, see the "Instance types of the ECS instances that must be in the Stopped (Stopped) state" section in the [Bind an ENI](https://help.aliyun.com/document_detail/58503.html) topic.
        >If the last start time of the instance (including the start time of the instance if it is a new instance, the last restart time of the instance, and the last reactivation time of the instance) is before April 1st, 2018 and the instance is in the Running state, you must call the RebootInstance operation to restart the instance. If you do not call the RebootInstance operation to restart the instance, you cannot attach the ENI to the instance.
        You can attach multiple ENIs to one instance. For more information, see [ENI overview](https://help.aliyun.com/document_detail/58496.html).
        The vSwitch to which the ENI is connected must be in the same zone and VPC as the vSwitch to which the instance is connected.
        This operation is an asynchronous operation. After you call this operation to attach an ENI, you can view the status or events of the ENI to check whether the ENI is attached. The following figure shows the transitions between the statuses of the ENI.
        ![](https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/file-manage-files/en-US/20230223/vqky/AttachNetworkInterface.png)
        - If the ENI is in the Attaching state, the ENI attachment request is sent and the ENI is being attached to the specified instance.
        - If the ENI is in the InUse state, the ENI is attached to the specified instance.
        - If the ENI is in the Available state, the ENI failed to be attached.
        *For examples on how to call this operation, see** [Attach an ENI](https://help.aliyun.com/document_detail/471550.html).
        
        @param request: AttachNetworkInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AttachNetworkInterfaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.network_card_index):
            query['NetworkCardIndex'] = request.network_card_index
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.trunk_network_instance_id):
            query['TrunkNetworkInstanceId'] = request.trunk_network_instance_id
        if not UtilClient.is_unset(request.wait_for_network_configuration_ready):
            query['WaitForNetworkConfigurationReady'] = request.wait_for_network_configuration_ready
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AttachNetworkInterface',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AttachNetworkInterfaceResponse(),
            self.call_api(params, req, runtime)
        )

    async def attach_network_interface_with_options_async(
        self,
        request: ecs_20140526_models.AttachNetworkInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AttachNetworkInterfaceResponse:
        """
        @summary Attaches an elastic network interface (ENI) to an Elastic Compute Service (ECS) instance that resides in a virtual private cloud (VPC). When you call this operation, you can specify parameters, such as NetworkInterfaceId, InstanceId, and NetworkCardIndex, in the request.
        
        @description Take note of the following items:
        The ENI must be in the **Available** state. You can attach an ENI to only one instance that resides in the same zone and VPC as the ENI.
        The instance must be in the Running or Stopped state. When you attach ENIs to instances of specific instance types, make sure that the instances are in the Stopped state. For more information, see the "Instance types of the ECS instances that must be in the Stopped (Stopped) state" section in the [Bind an ENI](https://help.aliyun.com/document_detail/58503.html) topic.
        >If the last start time of the instance (including the start time of the instance if it is a new instance, the last restart time of the instance, and the last reactivation time of the instance) is before April 1st, 2018 and the instance is in the Running state, you must call the RebootInstance operation to restart the instance. If you do not call the RebootInstance operation to restart the instance, you cannot attach the ENI to the instance.
        You can attach multiple ENIs to one instance. For more information, see [ENI overview](https://help.aliyun.com/document_detail/58496.html).
        The vSwitch to which the ENI is connected must be in the same zone and VPC as the vSwitch to which the instance is connected.
        This operation is an asynchronous operation. After you call this operation to attach an ENI, you can view the status or events of the ENI to check whether the ENI is attached. The following figure shows the transitions between the statuses of the ENI.
        ![](https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/file-manage-files/en-US/20230223/vqky/AttachNetworkInterface.png)
        - If the ENI is in the Attaching state, the ENI attachment request is sent and the ENI is being attached to the specified instance.
        - If the ENI is in the InUse state, the ENI is attached to the specified instance.
        - If the ENI is in the Available state, the ENI failed to be attached.
        *For examples on how to call this operation, see** [Attach an ENI](https://help.aliyun.com/document_detail/471550.html).
        
        @param request: AttachNetworkInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AttachNetworkInterfaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.network_card_index):
            query['NetworkCardIndex'] = request.network_card_index
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.trunk_network_instance_id):
            query['TrunkNetworkInstanceId'] = request.trunk_network_instance_id
        if not UtilClient.is_unset(request.wait_for_network_configuration_ready):
            query['WaitForNetworkConfigurationReady'] = request.wait_for_network_configuration_ready
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AttachNetworkInterface',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AttachNetworkInterfaceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def attach_network_interface(
        self,
        request: ecs_20140526_models.AttachNetworkInterfaceRequest,
    ) -> ecs_20140526_models.AttachNetworkInterfaceResponse:
        """
        @summary Attaches an elastic network interface (ENI) to an Elastic Compute Service (ECS) instance that resides in a virtual private cloud (VPC). When you call this operation, you can specify parameters, such as NetworkInterfaceId, InstanceId, and NetworkCardIndex, in the request.
        
        @description Take note of the following items:
        The ENI must be in the **Available** state. You can attach an ENI to only one instance that resides in the same zone and VPC as the ENI.
        The instance must be in the Running or Stopped state. When you attach ENIs to instances of specific instance types, make sure that the instances are in the Stopped state. For more information, see the "Instance types of the ECS instances that must be in the Stopped (Stopped) state" section in the [Bind an ENI](https://help.aliyun.com/document_detail/58503.html) topic.
        >If the last start time of the instance (including the start time of the instance if it is a new instance, the last restart time of the instance, and the last reactivation time of the instance) is before April 1st, 2018 and the instance is in the Running state, you must call the RebootInstance operation to restart the instance. If you do not call the RebootInstance operation to restart the instance, you cannot attach the ENI to the instance.
        You can attach multiple ENIs to one instance. For more information, see [ENI overview](https://help.aliyun.com/document_detail/58496.html).
        The vSwitch to which the ENI is connected must be in the same zone and VPC as the vSwitch to which the instance is connected.
        This operation is an asynchronous operation. After you call this operation to attach an ENI, you can view the status or events of the ENI to check whether the ENI is attached. The following figure shows the transitions between the statuses of the ENI.
        ![](https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/file-manage-files/en-US/20230223/vqky/AttachNetworkInterface.png)
        - If the ENI is in the Attaching state, the ENI attachment request is sent and the ENI is being attached to the specified instance.
        - If the ENI is in the InUse state, the ENI is attached to the specified instance.
        - If the ENI is in the Available state, the ENI failed to be attached.
        *For examples on how to call this operation, see** [Attach an ENI](https://help.aliyun.com/document_detail/471550.html).
        
        @param request: AttachNetworkInterfaceRequest
        @return: AttachNetworkInterfaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.attach_network_interface_with_options(request, runtime)

    async def attach_network_interface_async(
        self,
        request: ecs_20140526_models.AttachNetworkInterfaceRequest,
    ) -> ecs_20140526_models.AttachNetworkInterfaceResponse:
        """
        @summary Attaches an elastic network interface (ENI) to an Elastic Compute Service (ECS) instance that resides in a virtual private cloud (VPC). When you call this operation, you can specify parameters, such as NetworkInterfaceId, InstanceId, and NetworkCardIndex, in the request.
        
        @description Take note of the following items:
        The ENI must be in the **Available** state. You can attach an ENI to only one instance that resides in the same zone and VPC as the ENI.
        The instance must be in the Running or Stopped state. When you attach ENIs to instances of specific instance types, make sure that the instances are in the Stopped state. For more information, see the "Instance types of the ECS instances that must be in the Stopped (Stopped) state" section in the [Bind an ENI](https://help.aliyun.com/document_detail/58503.html) topic.
        >If the last start time of the instance (including the start time of the instance if it is a new instance, the last restart time of the instance, and the last reactivation time of the instance) is before April 1st, 2018 and the instance is in the Running state, you must call the RebootInstance operation to restart the instance. If you do not call the RebootInstance operation to restart the instance, you cannot attach the ENI to the instance.
        You can attach multiple ENIs to one instance. For more information, see [ENI overview](https://help.aliyun.com/document_detail/58496.html).
        The vSwitch to which the ENI is connected must be in the same zone and VPC as the vSwitch to which the instance is connected.
        This operation is an asynchronous operation. After you call this operation to attach an ENI, you can view the status or events of the ENI to check whether the ENI is attached. The following figure shows the transitions between the statuses of the ENI.
        ![](https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/file-manage-files/en-US/20230223/vqky/AttachNetworkInterface.png)
        - If the ENI is in the Attaching state, the ENI attachment request is sent and the ENI is being attached to the specified instance.
        - If the ENI is in the InUse state, the ENI is attached to the specified instance.
        - If the ENI is in the Available state, the ENI failed to be attached.
        *For examples on how to call this operation, see** [Attach an ENI](https://help.aliyun.com/document_detail/471550.html).
        
        @param request: AttachNetworkInterfaceRequest
        @return: AttachNetworkInterfaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.attach_network_interface_with_options_async(request, runtime)

    def authorize_security_group_with_options(
        self,
        request: ecs_20140526_models.AuthorizeSecurityGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AuthorizeSecurityGroupResponse:
        """
        @summary Creates inbound security group rules in a security group. You can use the created rules to allow or deny inbound traffic from other objects to Elastic Compute Service (ECS) instances in the security group for fine-grained network access control.
        
        @description ### [](#)Precautions
        **Quantity limit**: The maximum number of inbound and outbound rules in all security groups associated with an elastic network interface (ENI) cannot exceed 1,000. For more information, see the [Security groups](~~25412#SecurityGroupQuota1~~) section of the "Limits and quotas on ECS" topic.
        **Rule priorities**: For inbound security group rules, the valid values of Priority range from 1 to 100. A smaller value indicates a higher priority. When multiple security group rules have the same priority, drop rules take precedence.
        ### [](#)Considerations
        If the security group rule that you call the AuthorizeSecurityGroup operation to create exists in the security group, the call is successful but no security group rule is created.
        ### [](#)Parameters that define a security group rule
        Define an inbound security group rule by configuring the following parameters together:
        Source: You can specify one parameter from SourceCidrIp (IPv4 address), Ipv6SourceCidrIp (IPv6 address), SourcetPrefixListId (prefix list ID), and SourceGroupId (source security group ID).
        PortRange: specifies the range of destination port numbers.
        IpProtocol: specifies the protocol.
        Policy: specifies the action.
        >  Advanced security groups do not support security group rules that reference security groups as authorization objects. Each basic security group can contain up to 20 security group rules that reference security groups as authorization objects.
        ### [](#)Sample requests
        Sample requests to create inbound security group rules that control access from different sources in a security group in the China (Hangzhou) region:
        Sample request to create an inbound security group rule that controls access from a specific CIDR block:
        "RegionId":"cn-hangzhou", // Specify the region.
        "SecurityGroupId":"sg-bp67acfmxazb4p***", // Specify the security group.
        "Permissions":[
        {
        "SourceCidrIp":"10.0.0.0/8", // Specify the source IPv4 CIDR block.
        "PortRange":"22/22", // Specify the port range.
        "IpProtocol":"TCP", // Specify the protocol.
        "Policy":"Accept" // Specify the action.
        }
        ]
        Sample request to create an inbound security group rule that controls access from a security group and an inbound security group rule that controls access from a prefix list:
        "RegionId":"cn-hangzhou",
        "SecurityGroupId":"sg-bp67acfmxazb4p***",
        "Permissions":[
        {
        "SourceGroupId":"sg-bp17vs63txqxbd***", // Specify the source security group.
        "PortRange":"22/22",
        "IpProtocol":"TCP",
        "Policy":"Drop"
        },{
        "SourcePrefixListId":"pl-x1j1k5ykzqlixdcy***", // Specify the source prefix list.
        "PortRange":"22/22",
        "IpProtocol":"TCP",
        "Policy":"Drop"
        }
        ]
        
        @param request: AuthorizeSecurityGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AuthorizeSecurityGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dest_cidr_ip):
            query['DestCidrIp'] = request.dest_cidr_ip
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.ipv_6dest_cidr_ip):
            query['Ipv6DestCidrIp'] = request.ipv_6dest_cidr_ip
        if not UtilClient.is_unset(request.ipv_6source_cidr_ip):
            query['Ipv6SourceCidrIp'] = request.ipv_6source_cidr_ip
        if not UtilClient.is_unset(request.nic_type):
            query['NicType'] = request.nic_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.permissions):
            query['Permissions'] = request.permissions
        if not UtilClient.is_unset(request.policy):
            query['Policy'] = request.policy
        if not UtilClient.is_unset(request.port_range):
            query['PortRange'] = request.port_range
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.source_cidr_ip):
            query['SourceCidrIp'] = request.source_cidr_ip
        if not UtilClient.is_unset(request.source_group_id):
            query['SourceGroupId'] = request.source_group_id
        if not UtilClient.is_unset(request.source_group_owner_account):
            query['SourceGroupOwnerAccount'] = request.source_group_owner_account
        if not UtilClient.is_unset(request.source_group_owner_id):
            query['SourceGroupOwnerId'] = request.source_group_owner_id
        if not UtilClient.is_unset(request.source_port_range):
            query['SourcePortRange'] = request.source_port_range
        if not UtilClient.is_unset(request.source_prefix_list_id):
            query['SourcePrefixListId'] = request.source_prefix_list_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AuthorizeSecurityGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AuthorizeSecurityGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def authorize_security_group_with_options_async(
        self,
        request: ecs_20140526_models.AuthorizeSecurityGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AuthorizeSecurityGroupResponse:
        """
        @summary Creates inbound security group rules in a security group. You can use the created rules to allow or deny inbound traffic from other objects to Elastic Compute Service (ECS) instances in the security group for fine-grained network access control.
        
        @description ### [](#)Precautions
        **Quantity limit**: The maximum number of inbound and outbound rules in all security groups associated with an elastic network interface (ENI) cannot exceed 1,000. For more information, see the [Security groups](~~25412#SecurityGroupQuota1~~) section of the "Limits and quotas on ECS" topic.
        **Rule priorities**: For inbound security group rules, the valid values of Priority range from 1 to 100. A smaller value indicates a higher priority. When multiple security group rules have the same priority, drop rules take precedence.
        ### [](#)Considerations
        If the security group rule that you call the AuthorizeSecurityGroup operation to create exists in the security group, the call is successful but no security group rule is created.
        ### [](#)Parameters that define a security group rule
        Define an inbound security group rule by configuring the following parameters together:
        Source: You can specify one parameter from SourceCidrIp (IPv4 address), Ipv6SourceCidrIp (IPv6 address), SourcetPrefixListId (prefix list ID), and SourceGroupId (source security group ID).
        PortRange: specifies the range of destination port numbers.
        IpProtocol: specifies the protocol.
        Policy: specifies the action.
        >  Advanced security groups do not support security group rules that reference security groups as authorization objects. Each basic security group can contain up to 20 security group rules that reference security groups as authorization objects.
        ### [](#)Sample requests
        Sample requests to create inbound security group rules that control access from different sources in a security group in the China (Hangzhou) region:
        Sample request to create an inbound security group rule that controls access from a specific CIDR block:
        "RegionId":"cn-hangzhou", // Specify the region.
        "SecurityGroupId":"sg-bp67acfmxazb4p***", // Specify the security group.
        "Permissions":[
        {
        "SourceCidrIp":"10.0.0.0/8", // Specify the source IPv4 CIDR block.
        "PortRange":"22/22", // Specify the port range.
        "IpProtocol":"TCP", // Specify the protocol.
        "Policy":"Accept" // Specify the action.
        }
        ]
        Sample request to create an inbound security group rule that controls access from a security group and an inbound security group rule that controls access from a prefix list:
        "RegionId":"cn-hangzhou",
        "SecurityGroupId":"sg-bp67acfmxazb4p***",
        "Permissions":[
        {
        "SourceGroupId":"sg-bp17vs63txqxbd***", // Specify the source security group.
        "PortRange":"22/22",
        "IpProtocol":"TCP",
        "Policy":"Drop"
        },{
        "SourcePrefixListId":"pl-x1j1k5ykzqlixdcy***", // Specify the source prefix list.
        "PortRange":"22/22",
        "IpProtocol":"TCP",
        "Policy":"Drop"
        }
        ]
        
        @param request: AuthorizeSecurityGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AuthorizeSecurityGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dest_cidr_ip):
            query['DestCidrIp'] = request.dest_cidr_ip
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.ipv_6dest_cidr_ip):
            query['Ipv6DestCidrIp'] = request.ipv_6dest_cidr_ip
        if not UtilClient.is_unset(request.ipv_6source_cidr_ip):
            query['Ipv6SourceCidrIp'] = request.ipv_6source_cidr_ip
        if not UtilClient.is_unset(request.nic_type):
            query['NicType'] = request.nic_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.permissions):
            query['Permissions'] = request.permissions
        if not UtilClient.is_unset(request.policy):
            query['Policy'] = request.policy
        if not UtilClient.is_unset(request.port_range):
            query['PortRange'] = request.port_range
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.source_cidr_ip):
            query['SourceCidrIp'] = request.source_cidr_ip
        if not UtilClient.is_unset(request.source_group_id):
            query['SourceGroupId'] = request.source_group_id
        if not UtilClient.is_unset(request.source_group_owner_account):
            query['SourceGroupOwnerAccount'] = request.source_group_owner_account
        if not UtilClient.is_unset(request.source_group_owner_id):
            query['SourceGroupOwnerId'] = request.source_group_owner_id
        if not UtilClient.is_unset(request.source_port_range):
            query['SourcePortRange'] = request.source_port_range
        if not UtilClient.is_unset(request.source_prefix_list_id):
            query['SourcePrefixListId'] = request.source_prefix_list_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AuthorizeSecurityGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AuthorizeSecurityGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def authorize_security_group(
        self,
        request: ecs_20140526_models.AuthorizeSecurityGroupRequest,
    ) -> ecs_20140526_models.AuthorizeSecurityGroupResponse:
        """
        @summary Creates inbound security group rules in a security group. You can use the created rules to allow or deny inbound traffic from other objects to Elastic Compute Service (ECS) instances in the security group for fine-grained network access control.
        
        @description ### [](#)Precautions
        **Quantity limit**: The maximum number of inbound and outbound rules in all security groups associated with an elastic network interface (ENI) cannot exceed 1,000. For more information, see the [Security groups](~~25412#SecurityGroupQuota1~~) section of the "Limits and quotas on ECS" topic.
        **Rule priorities**: For inbound security group rules, the valid values of Priority range from 1 to 100. A smaller value indicates a higher priority. When multiple security group rules have the same priority, drop rules take precedence.
        ### [](#)Considerations
        If the security group rule that you call the AuthorizeSecurityGroup operation to create exists in the security group, the call is successful but no security group rule is created.
        ### [](#)Parameters that define a security group rule
        Define an inbound security group rule by configuring the following parameters together:
        Source: You can specify one parameter from SourceCidrIp (IPv4 address), Ipv6SourceCidrIp (IPv6 address), SourcetPrefixListId (prefix list ID), and SourceGroupId (source security group ID).
        PortRange: specifies the range of destination port numbers.
        IpProtocol: specifies the protocol.
        Policy: specifies the action.
        >  Advanced security groups do not support security group rules that reference security groups as authorization objects. Each basic security group can contain up to 20 security group rules that reference security groups as authorization objects.
        ### [](#)Sample requests
        Sample requests to create inbound security group rules that control access from different sources in a security group in the China (Hangzhou) region:
        Sample request to create an inbound security group rule that controls access from a specific CIDR block:
        "RegionId":"cn-hangzhou", // Specify the region.
        "SecurityGroupId":"sg-bp67acfmxazb4p***", // Specify the security group.
        "Permissions":[
        {
        "SourceCidrIp":"10.0.0.0/8", // Specify the source IPv4 CIDR block.
        "PortRange":"22/22", // Specify the port range.
        "IpProtocol":"TCP", // Specify the protocol.
        "Policy":"Accept" // Specify the action.
        }
        ]
        Sample request to create an inbound security group rule that controls access from a security group and an inbound security group rule that controls access from a prefix list:
        "RegionId":"cn-hangzhou",
        "SecurityGroupId":"sg-bp67acfmxazb4p***",
        "Permissions":[
        {
        "SourceGroupId":"sg-bp17vs63txqxbd***", // Specify the source security group.
        "PortRange":"22/22",
        "IpProtocol":"TCP",
        "Policy":"Drop"
        },{
        "SourcePrefixListId":"pl-x1j1k5ykzqlixdcy***", // Specify the source prefix list.
        "PortRange":"22/22",
        "IpProtocol":"TCP",
        "Policy":"Drop"
        }
        ]
        
        @param request: AuthorizeSecurityGroupRequest
        @return: AuthorizeSecurityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.authorize_security_group_with_options(request, runtime)

    async def authorize_security_group_async(
        self,
        request: ecs_20140526_models.AuthorizeSecurityGroupRequest,
    ) -> ecs_20140526_models.AuthorizeSecurityGroupResponse:
        """
        @summary Creates inbound security group rules in a security group. You can use the created rules to allow or deny inbound traffic from other objects to Elastic Compute Service (ECS) instances in the security group for fine-grained network access control.
        
        @description ### [](#)Precautions
        **Quantity limit**: The maximum number of inbound and outbound rules in all security groups associated with an elastic network interface (ENI) cannot exceed 1,000. For more information, see the [Security groups](~~25412#SecurityGroupQuota1~~) section of the "Limits and quotas on ECS" topic.
        **Rule priorities**: For inbound security group rules, the valid values of Priority range from 1 to 100. A smaller value indicates a higher priority. When multiple security group rules have the same priority, drop rules take precedence.
        ### [](#)Considerations
        If the security group rule that you call the AuthorizeSecurityGroup operation to create exists in the security group, the call is successful but no security group rule is created.
        ### [](#)Parameters that define a security group rule
        Define an inbound security group rule by configuring the following parameters together:
        Source: You can specify one parameter from SourceCidrIp (IPv4 address), Ipv6SourceCidrIp (IPv6 address), SourcetPrefixListId (prefix list ID), and SourceGroupId (source security group ID).
        PortRange: specifies the range of destination port numbers.
        IpProtocol: specifies the protocol.
        Policy: specifies the action.
        >  Advanced security groups do not support security group rules that reference security groups as authorization objects. Each basic security group can contain up to 20 security group rules that reference security groups as authorization objects.
        ### [](#)Sample requests
        Sample requests to create inbound security group rules that control access from different sources in a security group in the China (Hangzhou) region:
        Sample request to create an inbound security group rule that controls access from a specific CIDR block:
        "RegionId":"cn-hangzhou", // Specify the region.
        "SecurityGroupId":"sg-bp67acfmxazb4p***", // Specify the security group.
        "Permissions":[
        {
        "SourceCidrIp":"10.0.0.0/8", // Specify the source IPv4 CIDR block.
        "PortRange":"22/22", // Specify the port range.
        "IpProtocol":"TCP", // Specify the protocol.
        "Policy":"Accept" // Specify the action.
        }
        ]
        Sample request to create an inbound security group rule that controls access from a security group and an inbound security group rule that controls access from a prefix list:
        "RegionId":"cn-hangzhou",
        "SecurityGroupId":"sg-bp67acfmxazb4p***",
        "Permissions":[
        {
        "SourceGroupId":"sg-bp17vs63txqxbd***", // Specify the source security group.
        "PortRange":"22/22",
        "IpProtocol":"TCP",
        "Policy":"Drop"
        },{
        "SourcePrefixListId":"pl-x1j1k5ykzqlixdcy***", // Specify the source prefix list.
        "PortRange":"22/22",
        "IpProtocol":"TCP",
        "Policy":"Drop"
        }
        ]
        
        @param request: AuthorizeSecurityGroupRequest
        @return: AuthorizeSecurityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.authorize_security_group_with_options_async(request, runtime)

    def authorize_security_group_egress_with_options(
        self,
        request: ecs_20140526_models.AuthorizeSecurityGroupEgressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AuthorizeSecurityGroupEgressResponse:
        """
        @summary Creates outbound rules in a security group. You can use the created rules to allow or deny outbound traffic from Elastic Compute Service (ECS) instances in the security group to other objects for fine-grained network access control.
        
        @description ### [](#)Precautions
        **Quantity limit**: The maximum number of inbound and outbound rules in all security groups associated with an elastic network interface (ENI) cannot exceed 1,000. For more information, see the [Security group limits](~~25412#SecurityGroupQuota1~~) section of the "Limits" topic.
        **Rule priorities**: For outbound security group rules, the valid values of Priority range from 1 to 100. A smaller value indicates a higher priority. When multiple security group rules have the same priority, drop rules take precedence.
        ### [](#)Considerations
        If the security group rule that you call the AuthorizeSecurityGroupEgress operation to create exists in the security group, the call is successful but no security group rule is created.
        ### [](#)Parameters that define a security group rule
        Define an outbound security group rule by configuring the following parameters together:
        One of the following parameters: DestCidrIp, Ipv6DestCidrIp, DestPrefixListId, and DestGroupId. DestCidrIp specifies the destination IPv4 CIDR block. Ipv6DestCidrIp specifies the destination IPv6 CIDR block. DestPrefixListId specifies the ID of the destination prefix list. DestGroupId specifies the destination security group.
        PortRange: specifies the range of destination port numbers.
        IpProtocol: specifies the protocol.
        Policy: specifies the action.
        >  Advanced security groups do not support security group rules that reference security groups as authorization objects. Each basic security group can contain up to 20 security group rules that reference security groups as authorization objects.
        ### [](#)Sample requests
        Sample requests to create outbound security group rules that control access to different destinations in a security group in the China (Hangzhou) region:
        Sample request to create an outbound security group rule that controls access to a specified CIDR block:
        "RegionId":"cn-hangzhou", // The region ID.
        "SecurityGroupId":"sg-bp17vs63txqxbds9**", // The ID of the source security group.
        "Permissions":[
        {
        "DestCidrIp":"10.0.0.0/8", // The destination IPv4 CIDR block.
        "PortRange":"-1/-1", // The range of destination port numbers.
        "IpProtocol":"ICMP", //T he protocol.       "Policy":"Accept" // Specify the action.
        }
        ]
        Sample request to create an outbound security group rule that controls access to a security group and an outbound security group rule that controls access to a prefix list:
        "RegionId":"cn-hangzhou",
        "SecurityGroupId":"sg-bp17vs63txqxbds9**",
        "Permissions":[
        {
        "DestGroupId":"sg-bp67acfmxazb4pi**", // The ID of the destination security group.
        "PortRange":"22/22",
        "IpProtocol":"TCP",
        "Policy":"Drop"
        },{
        "DestPrefixListId":"pl-x1j1k5ykzqlixdcy***", // The destination prefix list.
        "PortRange":"22/22",
        "IpProtocol":"TCP",
        "Policy":"Drop"
        }
        ]
        
        @param request: AuthorizeSecurityGroupEgressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AuthorizeSecurityGroupEgressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dest_cidr_ip):
            query['DestCidrIp'] = request.dest_cidr_ip
        if not UtilClient.is_unset(request.dest_group_id):
            query['DestGroupId'] = request.dest_group_id
        if not UtilClient.is_unset(request.dest_group_owner_account):
            query['DestGroupOwnerAccount'] = request.dest_group_owner_account
        if not UtilClient.is_unset(request.dest_group_owner_id):
            query['DestGroupOwnerId'] = request.dest_group_owner_id
        if not UtilClient.is_unset(request.dest_prefix_list_id):
            query['DestPrefixListId'] = request.dest_prefix_list_id
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.ipv_6dest_cidr_ip):
            query['Ipv6DestCidrIp'] = request.ipv_6dest_cidr_ip
        if not UtilClient.is_unset(request.ipv_6source_cidr_ip):
            query['Ipv6SourceCidrIp'] = request.ipv_6source_cidr_ip
        if not UtilClient.is_unset(request.nic_type):
            query['NicType'] = request.nic_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.permissions):
            query['Permissions'] = request.permissions
        if not UtilClient.is_unset(request.policy):
            query['Policy'] = request.policy
        if not UtilClient.is_unset(request.port_range):
            query['PortRange'] = request.port_range
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.source_cidr_ip):
            query['SourceCidrIp'] = request.source_cidr_ip
        if not UtilClient.is_unset(request.source_port_range):
            query['SourcePortRange'] = request.source_port_range
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AuthorizeSecurityGroupEgress',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AuthorizeSecurityGroupEgressResponse(),
            self.call_api(params, req, runtime)
        )

    async def authorize_security_group_egress_with_options_async(
        self,
        request: ecs_20140526_models.AuthorizeSecurityGroupEgressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.AuthorizeSecurityGroupEgressResponse:
        """
        @summary Creates outbound rules in a security group. You can use the created rules to allow or deny outbound traffic from Elastic Compute Service (ECS) instances in the security group to other objects for fine-grained network access control.
        
        @description ### [](#)Precautions
        **Quantity limit**: The maximum number of inbound and outbound rules in all security groups associated with an elastic network interface (ENI) cannot exceed 1,000. For more information, see the [Security group limits](~~25412#SecurityGroupQuota1~~) section of the "Limits" topic.
        **Rule priorities**: For outbound security group rules, the valid values of Priority range from 1 to 100. A smaller value indicates a higher priority. When multiple security group rules have the same priority, drop rules take precedence.
        ### [](#)Considerations
        If the security group rule that you call the AuthorizeSecurityGroupEgress operation to create exists in the security group, the call is successful but no security group rule is created.
        ### [](#)Parameters that define a security group rule
        Define an outbound security group rule by configuring the following parameters together:
        One of the following parameters: DestCidrIp, Ipv6DestCidrIp, DestPrefixListId, and DestGroupId. DestCidrIp specifies the destination IPv4 CIDR block. Ipv6DestCidrIp specifies the destination IPv6 CIDR block. DestPrefixListId specifies the ID of the destination prefix list. DestGroupId specifies the destination security group.
        PortRange: specifies the range of destination port numbers.
        IpProtocol: specifies the protocol.
        Policy: specifies the action.
        >  Advanced security groups do not support security group rules that reference security groups as authorization objects. Each basic security group can contain up to 20 security group rules that reference security groups as authorization objects.
        ### [](#)Sample requests
        Sample requests to create outbound security group rules that control access to different destinations in a security group in the China (Hangzhou) region:
        Sample request to create an outbound security group rule that controls access to a specified CIDR block:
        "RegionId":"cn-hangzhou", // The region ID.
        "SecurityGroupId":"sg-bp17vs63txqxbds9**", // The ID of the source security group.
        "Permissions":[
        {
        "DestCidrIp":"10.0.0.0/8", // The destination IPv4 CIDR block.
        "PortRange":"-1/-1", // The range of destination port numbers.
        "IpProtocol":"ICMP", //T he protocol.       "Policy":"Accept" // Specify the action.
        }
        ]
        Sample request to create an outbound security group rule that controls access to a security group and an outbound security group rule that controls access to a prefix list:
        "RegionId":"cn-hangzhou",
        "SecurityGroupId":"sg-bp17vs63txqxbds9**",
        "Permissions":[
        {
        "DestGroupId":"sg-bp67acfmxazb4pi**", // The ID of the destination security group.
        "PortRange":"22/22",
        "IpProtocol":"TCP",
        "Policy":"Drop"
        },{
        "DestPrefixListId":"pl-x1j1k5ykzqlixdcy***", // The destination prefix list.
        "PortRange":"22/22",
        "IpProtocol":"TCP",
        "Policy":"Drop"
        }
        ]
        
        @param request: AuthorizeSecurityGroupEgressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AuthorizeSecurityGroupEgressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dest_cidr_ip):
            query['DestCidrIp'] = request.dest_cidr_ip
        if not UtilClient.is_unset(request.dest_group_id):
            query['DestGroupId'] = request.dest_group_id
        if not UtilClient.is_unset(request.dest_group_owner_account):
            query['DestGroupOwnerAccount'] = request.dest_group_owner_account
        if not UtilClient.is_unset(request.dest_group_owner_id):
            query['DestGroupOwnerId'] = request.dest_group_owner_id
        if not UtilClient.is_unset(request.dest_prefix_list_id):
            query['DestPrefixListId'] = request.dest_prefix_list_id
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.ipv_6dest_cidr_ip):
            query['Ipv6DestCidrIp'] = request.ipv_6dest_cidr_ip
        if not UtilClient.is_unset(request.ipv_6source_cidr_ip):
            query['Ipv6SourceCidrIp'] = request.ipv_6source_cidr_ip
        if not UtilClient.is_unset(request.nic_type):
            query['NicType'] = request.nic_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.permissions):
            query['Permissions'] = request.permissions
        if not UtilClient.is_unset(request.policy):
            query['Policy'] = request.policy
        if not UtilClient.is_unset(request.port_range):
            query['PortRange'] = request.port_range
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.source_cidr_ip):
            query['SourceCidrIp'] = request.source_cidr_ip
        if not UtilClient.is_unset(request.source_port_range):
            query['SourcePortRange'] = request.source_port_range
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AuthorizeSecurityGroupEgress',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.AuthorizeSecurityGroupEgressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def authorize_security_group_egress(
        self,
        request: ecs_20140526_models.AuthorizeSecurityGroupEgressRequest,
    ) -> ecs_20140526_models.AuthorizeSecurityGroupEgressResponse:
        """
        @summary Creates outbound rules in a security group. You can use the created rules to allow or deny outbound traffic from Elastic Compute Service (ECS) instances in the security group to other objects for fine-grained network access control.
        
        @description ### [](#)Precautions
        **Quantity limit**: The maximum number of inbound and outbound rules in all security groups associated with an elastic network interface (ENI) cannot exceed 1,000. For more information, see the [Security group limits](~~25412#SecurityGroupQuota1~~) section of the "Limits" topic.
        **Rule priorities**: For outbound security group rules, the valid values of Priority range from 1 to 100. A smaller value indicates a higher priority. When multiple security group rules have the same priority, drop rules take precedence.
        ### [](#)Considerations
        If the security group rule that you call the AuthorizeSecurityGroupEgress operation to create exists in the security group, the call is successful but no security group rule is created.
        ### [](#)Parameters that define a security group rule
        Define an outbound security group rule by configuring the following parameters together:
        One of the following parameters: DestCidrIp, Ipv6DestCidrIp, DestPrefixListId, and DestGroupId. DestCidrIp specifies the destination IPv4 CIDR block. Ipv6DestCidrIp specifies the destination IPv6 CIDR block. DestPrefixListId specifies the ID of the destination prefix list. DestGroupId specifies the destination security group.
        PortRange: specifies the range of destination port numbers.
        IpProtocol: specifies the protocol.
        Policy: specifies the action.
        >  Advanced security groups do not support security group rules that reference security groups as authorization objects. Each basic security group can contain up to 20 security group rules that reference security groups as authorization objects.
        ### [](#)Sample requests
        Sample requests to create outbound security group rules that control access to different destinations in a security group in the China (Hangzhou) region:
        Sample request to create an outbound security group rule that controls access to a specified CIDR block:
        "RegionId":"cn-hangzhou", // The region ID.
        "SecurityGroupId":"sg-bp17vs63txqxbds9**", // The ID of the source security group.
        "Permissions":[
        {
        "DestCidrIp":"10.0.0.0/8", // The destination IPv4 CIDR block.
        "PortRange":"-1/-1", // The range of destination port numbers.
        "IpProtocol":"ICMP", //T he protocol.       "Policy":"Accept" // Specify the action.
        }
        ]
        Sample request to create an outbound security group rule that controls access to a security group and an outbound security group rule that controls access to a prefix list:
        "RegionId":"cn-hangzhou",
        "SecurityGroupId":"sg-bp17vs63txqxbds9**",
        "Permissions":[
        {
        "DestGroupId":"sg-bp67acfmxazb4pi**", // The ID of the destination security group.
        "PortRange":"22/22",
        "IpProtocol":"TCP",
        "Policy":"Drop"
        },{
        "DestPrefixListId":"pl-x1j1k5ykzqlixdcy***", // The destination prefix list.
        "PortRange":"22/22",
        "IpProtocol":"TCP",
        "Policy":"Drop"
        }
        ]
        
        @param request: AuthorizeSecurityGroupEgressRequest
        @return: AuthorizeSecurityGroupEgressResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.authorize_security_group_egress_with_options(request, runtime)

    async def authorize_security_group_egress_async(
        self,
        request: ecs_20140526_models.AuthorizeSecurityGroupEgressRequest,
    ) -> ecs_20140526_models.AuthorizeSecurityGroupEgressResponse:
        """
        @summary Creates outbound rules in a security group. You can use the created rules to allow or deny outbound traffic from Elastic Compute Service (ECS) instances in the security group to other objects for fine-grained network access control.
        
        @description ### [](#)Precautions
        **Quantity limit**: The maximum number of inbound and outbound rules in all security groups associated with an elastic network interface (ENI) cannot exceed 1,000. For more information, see the [Security group limits](~~25412#SecurityGroupQuota1~~) section of the "Limits" topic.
        **Rule priorities**: For outbound security group rules, the valid values of Priority range from 1 to 100. A smaller value indicates a higher priority. When multiple security group rules have the same priority, drop rules take precedence.
        ### [](#)Considerations
        If the security group rule that you call the AuthorizeSecurityGroupEgress operation to create exists in the security group, the call is successful but no security group rule is created.
        ### [](#)Parameters that define a security group rule
        Define an outbound security group rule by configuring the following parameters together:
        One of the following parameters: DestCidrIp, Ipv6DestCidrIp, DestPrefixListId, and DestGroupId. DestCidrIp specifies the destination IPv4 CIDR block. Ipv6DestCidrIp specifies the destination IPv6 CIDR block. DestPrefixListId specifies the ID of the destination prefix list. DestGroupId specifies the destination security group.
        PortRange: specifies the range of destination port numbers.
        IpProtocol: specifies the protocol.
        Policy: specifies the action.
        >  Advanced security groups do not support security group rules that reference security groups as authorization objects. Each basic security group can contain up to 20 security group rules that reference security groups as authorization objects.
        ### [](#)Sample requests
        Sample requests to create outbound security group rules that control access to different destinations in a security group in the China (Hangzhou) region:
        Sample request to create an outbound security group rule that controls access to a specified CIDR block:
        "RegionId":"cn-hangzhou", // The region ID.
        "SecurityGroupId":"sg-bp17vs63txqxbds9**", // The ID of the source security group.
        "Permissions":[
        {
        "DestCidrIp":"10.0.0.0/8", // The destination IPv4 CIDR block.
        "PortRange":"-1/-1", // The range of destination port numbers.
        "IpProtocol":"ICMP", //T he protocol.       "Policy":"Accept" // Specify the action.
        }
        ]
        Sample request to create an outbound security group rule that controls access to a security group and an outbound security group rule that controls access to a prefix list:
        "RegionId":"cn-hangzhou",
        "SecurityGroupId":"sg-bp17vs63txqxbds9**",
        "Permissions":[
        {
        "DestGroupId":"sg-bp67acfmxazb4pi**", // The ID of the destination security group.
        "PortRange":"22/22",
        "IpProtocol":"TCP",
        "Policy":"Drop"
        },{
        "DestPrefixListId":"pl-x1j1k5ykzqlixdcy***", // The destination prefix list.
        "PortRange":"22/22",
        "IpProtocol":"TCP",
        "Policy":"Drop"
        }
        ]
        
        @param request: AuthorizeSecurityGroupEgressRequest
        @return: AuthorizeSecurityGroupEgressResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.authorize_security_group_egress_with_options_async(request, runtime)

    def cancel_auto_snapshot_policy_with_options(
        self,
        request: ecs_20140526_models.CancelAutoSnapshotPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CancelAutoSnapshotPolicyResponse:
        """
        @summary Disables automatic snapshot policies for one or more disks.
        
        @param request: CancelAutoSnapshotPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelAutoSnapshotPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.auto_snapshot_policy_id):
            query['autoSnapshotPolicyId'] = request.auto_snapshot_policy_id
        if not UtilClient.is_unset(request.disk_ids):
            query['diskIds'] = request.disk_ids
        if not UtilClient.is_unset(request.region_id):
            query['regionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelAutoSnapshotPolicy',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CancelAutoSnapshotPolicyResponse(),
            self.call_api(params, req, runtime)
        )

    async def cancel_auto_snapshot_policy_with_options_async(
        self,
        request: ecs_20140526_models.CancelAutoSnapshotPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CancelAutoSnapshotPolicyResponse:
        """
        @summary Disables automatic snapshot policies for one or more disks.
        
        @param request: CancelAutoSnapshotPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelAutoSnapshotPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.auto_snapshot_policy_id):
            query['autoSnapshotPolicyId'] = request.auto_snapshot_policy_id
        if not UtilClient.is_unset(request.disk_ids):
            query['diskIds'] = request.disk_ids
        if not UtilClient.is_unset(request.region_id):
            query['regionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelAutoSnapshotPolicy',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CancelAutoSnapshotPolicyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def cancel_auto_snapshot_policy(
        self,
        request: ecs_20140526_models.CancelAutoSnapshotPolicyRequest,
    ) -> ecs_20140526_models.CancelAutoSnapshotPolicyResponse:
        """
        @summary Disables automatic snapshot policies for one or more disks.
        
        @param request: CancelAutoSnapshotPolicyRequest
        @return: CancelAutoSnapshotPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.cancel_auto_snapshot_policy_with_options(request, runtime)

    async def cancel_auto_snapshot_policy_async(
        self,
        request: ecs_20140526_models.CancelAutoSnapshotPolicyRequest,
    ) -> ecs_20140526_models.CancelAutoSnapshotPolicyResponse:
        """
        @summary Disables automatic snapshot policies for one or more disks.
        
        @param request: CancelAutoSnapshotPolicyRequest
        @return: CancelAutoSnapshotPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.cancel_auto_snapshot_policy_with_options_async(request, runtime)

    def cancel_copy_image_with_options(
        self,
        request: ecs_20140526_models.CancelCopyImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CancelCopyImageResponse:
        """
        @summary Cancels an ongoing image copy task.
        
        @description When you call this operation, take note of the following items:
        After you cancel an image copy task, the image copy created in the destination region is deleted, and the copied image remains unchanged.
        If the image copy task is complete, the CancelCopyImage operation fails, and an error is returned.
        
        @param request: CancelCopyImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelCopyImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelCopyImage',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CancelCopyImageResponse(),
            self.call_api(params, req, runtime)
        )

    async def cancel_copy_image_with_options_async(
        self,
        request: ecs_20140526_models.CancelCopyImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CancelCopyImageResponse:
        """
        @summary Cancels an ongoing image copy task.
        
        @description When you call this operation, take note of the following items:
        After you cancel an image copy task, the image copy created in the destination region is deleted, and the copied image remains unchanged.
        If the image copy task is complete, the CancelCopyImage operation fails, and an error is returned.
        
        @param request: CancelCopyImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelCopyImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelCopyImage',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CancelCopyImageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def cancel_copy_image(
        self,
        request: ecs_20140526_models.CancelCopyImageRequest,
    ) -> ecs_20140526_models.CancelCopyImageResponse:
        """
        @summary Cancels an ongoing image copy task.
        
        @description When you call this operation, take note of the following items:
        After you cancel an image copy task, the image copy created in the destination region is deleted, and the copied image remains unchanged.
        If the image copy task is complete, the CancelCopyImage operation fails, and an error is returned.
        
        @param request: CancelCopyImageRequest
        @return: CancelCopyImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.cancel_copy_image_with_options(request, runtime)

    async def cancel_copy_image_async(
        self,
        request: ecs_20140526_models.CancelCopyImageRequest,
    ) -> ecs_20140526_models.CancelCopyImageResponse:
        """
        @summary Cancels an ongoing image copy task.
        
        @description When you call this operation, take note of the following items:
        After you cancel an image copy task, the image copy created in the destination region is deleted, and the copied image remains unchanged.
        If the image copy task is complete, the CancelCopyImage operation fails, and an error is returned.
        
        @param request: CancelCopyImageRequest
        @return: CancelCopyImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.cancel_copy_image_with_options_async(request, runtime)

    def cancel_image_pipeline_execution_with_options(
        self,
        request: ecs_20140526_models.CancelImagePipelineExecutionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CancelImagePipelineExecutionResponse:
        """
        @summary Cancels an image building task.
        
        @description Before you call the CancelImagePipelineExecution operation, make sure that the image building task to be canceled is in the BUILDING, PREPARING, or REPAIRING state.
        
        @param request: CancelImagePipelineExecutionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelImagePipelineExecutionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.execution_id):
            query['ExecutionId'] = request.execution_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.template_tag):
            query['TemplateTag'] = request.template_tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelImagePipelineExecution',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CancelImagePipelineExecutionResponse(),
            self.call_api(params, req, runtime)
        )

    async def cancel_image_pipeline_execution_with_options_async(
        self,
        request: ecs_20140526_models.CancelImagePipelineExecutionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CancelImagePipelineExecutionResponse:
        """
        @summary Cancels an image building task.
        
        @description Before you call the CancelImagePipelineExecution operation, make sure that the image building task to be canceled is in the BUILDING, PREPARING, or REPAIRING state.
        
        @param request: CancelImagePipelineExecutionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelImagePipelineExecutionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.execution_id):
            query['ExecutionId'] = request.execution_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.template_tag):
            query['TemplateTag'] = request.template_tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelImagePipelineExecution',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CancelImagePipelineExecutionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def cancel_image_pipeline_execution(
        self,
        request: ecs_20140526_models.CancelImagePipelineExecutionRequest,
    ) -> ecs_20140526_models.CancelImagePipelineExecutionResponse:
        """
        @summary Cancels an image building task.
        
        @description Before you call the CancelImagePipelineExecution operation, make sure that the image building task to be canceled is in the BUILDING, PREPARING, or REPAIRING state.
        
        @param request: CancelImagePipelineExecutionRequest
        @return: CancelImagePipelineExecutionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.cancel_image_pipeline_execution_with_options(request, runtime)

    async def cancel_image_pipeline_execution_async(
        self,
        request: ecs_20140526_models.CancelImagePipelineExecutionRequest,
    ) -> ecs_20140526_models.CancelImagePipelineExecutionResponse:
        """
        @summary Cancels an image building task.
        
        @description Before you call the CancelImagePipelineExecution operation, make sure that the image building task to be canceled is in the BUILDING, PREPARING, or REPAIRING state.
        
        @param request: CancelImagePipelineExecutionRequest
        @return: CancelImagePipelineExecutionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.cancel_image_pipeline_execution_with_options_async(request, runtime)

    def cancel_physical_connection_with_options(
        self,
        request: ecs_20140526_models.CancelPhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CancelPhysicalConnectionResponse:
        """
        @deprecated OpenAPI CancelPhysicalConnection is deprecated, please use Vpc::2016-04-28::CancelPhysicalConnection instead.
        
        @summary CancelPhysicalConnection
        
        @param request: CancelPhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelPhysicalConnectionResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelPhysicalConnection',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CancelPhysicalConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def cancel_physical_connection_with_options_async(
        self,
        request: ecs_20140526_models.CancelPhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CancelPhysicalConnectionResponse:
        """
        @deprecated OpenAPI CancelPhysicalConnection is deprecated, please use Vpc::2016-04-28::CancelPhysicalConnection instead.
        
        @summary CancelPhysicalConnection
        
        @param request: CancelPhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelPhysicalConnectionResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelPhysicalConnection',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CancelPhysicalConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def cancel_physical_connection(
        self,
        request: ecs_20140526_models.CancelPhysicalConnectionRequest,
    ) -> ecs_20140526_models.CancelPhysicalConnectionResponse:
        """
        @deprecated OpenAPI CancelPhysicalConnection is deprecated, please use Vpc::2016-04-28::CancelPhysicalConnection instead.
        
        @summary CancelPhysicalConnection
        
        @param request: CancelPhysicalConnectionRequest
        @return: CancelPhysicalConnectionResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.cancel_physical_connection_with_options(request, runtime)

    async def cancel_physical_connection_async(
        self,
        request: ecs_20140526_models.CancelPhysicalConnectionRequest,
    ) -> ecs_20140526_models.CancelPhysicalConnectionResponse:
        """
        @deprecated OpenAPI CancelPhysicalConnection is deprecated, please use Vpc::2016-04-28::CancelPhysicalConnection instead.
        
        @summary CancelPhysicalConnection
        
        @param request: CancelPhysicalConnectionRequest
        @return: CancelPhysicalConnectionResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.cancel_physical_connection_with_options_async(request, runtime)

    def cancel_simulated_system_events_with_options(
        self,
        request: ecs_20140526_models.CancelSimulatedSystemEventsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CancelSimulatedSystemEventsResponse:
        """
        @summary Cancels simulated system events that are in the Scheduled or Executing state. After you cancel a simulated system event, the simulated event enters the Canceled state.
        
        @param request: CancelSimulatedSystemEventsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelSimulatedSystemEventsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.event_id):
            query['EventId'] = request.event_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelSimulatedSystemEvents',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CancelSimulatedSystemEventsResponse(),
            self.call_api(params, req, runtime)
        )

    async def cancel_simulated_system_events_with_options_async(
        self,
        request: ecs_20140526_models.CancelSimulatedSystemEventsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CancelSimulatedSystemEventsResponse:
        """
        @summary Cancels simulated system events that are in the Scheduled or Executing state. After you cancel a simulated system event, the simulated event enters the Canceled state.
        
        @param request: CancelSimulatedSystemEventsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelSimulatedSystemEventsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.event_id):
            query['EventId'] = request.event_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelSimulatedSystemEvents',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CancelSimulatedSystemEventsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def cancel_simulated_system_events(
        self,
        request: ecs_20140526_models.CancelSimulatedSystemEventsRequest,
    ) -> ecs_20140526_models.CancelSimulatedSystemEventsResponse:
        """
        @summary Cancels simulated system events that are in the Scheduled or Executing state. After you cancel a simulated system event, the simulated event enters the Canceled state.
        
        @param request: CancelSimulatedSystemEventsRequest
        @return: CancelSimulatedSystemEventsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.cancel_simulated_system_events_with_options(request, runtime)

    async def cancel_simulated_system_events_async(
        self,
        request: ecs_20140526_models.CancelSimulatedSystemEventsRequest,
    ) -> ecs_20140526_models.CancelSimulatedSystemEventsResponse:
        """
        @summary Cancels simulated system events that are in the Scheduled or Executing state. After you cancel a simulated system event, the simulated event enters the Canceled state.
        
        @param request: CancelSimulatedSystemEventsRequest
        @return: CancelSimulatedSystemEventsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.cancel_simulated_system_events_with_options_async(request, runtime)

    def cancel_task_with_options(
        self,
        request: ecs_20140526_models.CancelTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CancelTaskResponse:
        """
        @summary Cancels a running task. You can cancel the running tasks generated by the ImportImage or ExportImage operation.
        
        @param request: CancelTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelTask',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CancelTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def cancel_task_with_options_async(
        self,
        request: ecs_20140526_models.CancelTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CancelTaskResponse:
        """
        @summary Cancels a running task. You can cancel the running tasks generated by the ImportImage or ExportImage operation.
        
        @param request: CancelTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelTask',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CancelTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def cancel_task(
        self,
        request: ecs_20140526_models.CancelTaskRequest,
    ) -> ecs_20140526_models.CancelTaskResponse:
        """
        @summary Cancels a running task. You can cancel the running tasks generated by the ImportImage or ExportImage operation.
        
        @param request: CancelTaskRequest
        @return: CancelTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.cancel_task_with_options(request, runtime)

    async def cancel_task_async(
        self,
        request: ecs_20140526_models.CancelTaskRequest,
    ) -> ecs_20140526_models.CancelTaskResponse:
        """
        @summary Cancels a running task. You can cancel the running tasks generated by the ImportImage or ExportImage operation.
        
        @param request: CancelTaskRequest
        @return: CancelTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.cancel_task_with_options_async(request, runtime)

    def connect_router_interface_with_options(
        self,
        request: ecs_20140526_models.ConnectRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ConnectRouterInterfaceResponse:
        """
        @deprecated OpenAPI ConnectRouterInterface is deprecated, please use Vpc::2016-04-28::ConnectRouterInterface instead.
        
        @summary ConnectRouterInterface
        
        @param request: ConnectRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ConnectRouterInterfaceResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ConnectRouterInterface',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ConnectRouterInterfaceResponse(),
            self.call_api(params, req, runtime)
        )

    async def connect_router_interface_with_options_async(
        self,
        request: ecs_20140526_models.ConnectRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ConnectRouterInterfaceResponse:
        """
        @deprecated OpenAPI ConnectRouterInterface is deprecated, please use Vpc::2016-04-28::ConnectRouterInterface instead.
        
        @summary ConnectRouterInterface
        
        @param request: ConnectRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ConnectRouterInterfaceResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ConnectRouterInterface',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ConnectRouterInterfaceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def connect_router_interface(
        self,
        request: ecs_20140526_models.ConnectRouterInterfaceRequest,
    ) -> ecs_20140526_models.ConnectRouterInterfaceResponse:
        """
        @deprecated OpenAPI ConnectRouterInterface is deprecated, please use Vpc::2016-04-28::ConnectRouterInterface instead.
        
        @summary ConnectRouterInterface
        
        @param request: ConnectRouterInterfaceRequest
        @return: ConnectRouterInterfaceResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.connect_router_interface_with_options(request, runtime)

    async def connect_router_interface_async(
        self,
        request: ecs_20140526_models.ConnectRouterInterfaceRequest,
    ) -> ecs_20140526_models.ConnectRouterInterfaceResponse:
        """
        @deprecated OpenAPI ConnectRouterInterface is deprecated, please use Vpc::2016-04-28::ConnectRouterInterface instead.
        
        @summary ConnectRouterInterface
        
        @param request: ConnectRouterInterfaceRequest
        @return: ConnectRouterInterfaceResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.connect_router_interface_with_options_async(request, runtime)

    def convert_nat_public_ip_to_eip_with_options(
        self,
        request: ecs_20140526_models.ConvertNatPublicIpToEipRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ConvertNatPublicIpToEipResponse:
        """
        @summary Converts the static public IP address of an Elastic Compute Service (ECS) instance that resides in a virtual private cloud (VPC) into an elastic IP address (EIP). Static public IP addresses are the public IP addresses that are automatically assigned to ECS instances.
        
        @description ## [](#)Usage notes
        After a public IP address is converted into an EIP, the EIP is billed separately. Make sure that you fully understand the billing methods of EIPs. For more information, see [Billing overview](https://help.aliyun.com/document_detail/122035.html).
        When you call this operation, make sure that the ECS instance meets the following requirements:
        The instance is in the **Stopped** (`Stopped`) or **Running** (`Running`) state.
        The instance has no EIPs associated.
        The instance has no configuration change tasks that have not taken effect.
        The public bandwidth of the instance is not 0 Mbit/s.
        If the instance is a subscription instance, the billing method for network usage of the instance must be `pay-by-traffic`. The public IP address of a subscription instance that uses the `pay-by-bandwidth` billing method for network usage cannot be converted into an EIP. This requirement does not apply to pay-as-you-go instances. For more information, see [Change the billing method for network usage](https://help.aliyun.com/document_detail/178883.html).
        If the instance is a subscription instance that resides in a VPC, the instance does not expire within 24 hours.
        
        @param request: ConvertNatPublicIpToEipRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ConvertNatPublicIpToEipResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ConvertNatPublicIpToEip',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ConvertNatPublicIpToEipResponse(),
            self.call_api(params, req, runtime)
        )

    async def convert_nat_public_ip_to_eip_with_options_async(
        self,
        request: ecs_20140526_models.ConvertNatPublicIpToEipRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ConvertNatPublicIpToEipResponse:
        """
        @summary Converts the static public IP address of an Elastic Compute Service (ECS) instance that resides in a virtual private cloud (VPC) into an elastic IP address (EIP). Static public IP addresses are the public IP addresses that are automatically assigned to ECS instances.
        
        @description ## [](#)Usage notes
        After a public IP address is converted into an EIP, the EIP is billed separately. Make sure that you fully understand the billing methods of EIPs. For more information, see [Billing overview](https://help.aliyun.com/document_detail/122035.html).
        When you call this operation, make sure that the ECS instance meets the following requirements:
        The instance is in the **Stopped** (`Stopped`) or **Running** (`Running`) state.
        The instance has no EIPs associated.
        The instance has no configuration change tasks that have not taken effect.
        The public bandwidth of the instance is not 0 Mbit/s.
        If the instance is a subscription instance, the billing method for network usage of the instance must be `pay-by-traffic`. The public IP address of a subscription instance that uses the `pay-by-bandwidth` billing method for network usage cannot be converted into an EIP. This requirement does not apply to pay-as-you-go instances. For more information, see [Change the billing method for network usage](https://help.aliyun.com/document_detail/178883.html).
        If the instance is a subscription instance that resides in a VPC, the instance does not expire within 24 hours.
        
        @param request: ConvertNatPublicIpToEipRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ConvertNatPublicIpToEipResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ConvertNatPublicIpToEip',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ConvertNatPublicIpToEipResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def convert_nat_public_ip_to_eip(
        self,
        request: ecs_20140526_models.ConvertNatPublicIpToEipRequest,
    ) -> ecs_20140526_models.ConvertNatPublicIpToEipResponse:
        """
        @summary Converts the static public IP address of an Elastic Compute Service (ECS) instance that resides in a virtual private cloud (VPC) into an elastic IP address (EIP). Static public IP addresses are the public IP addresses that are automatically assigned to ECS instances.
        
        @description ## [](#)Usage notes
        After a public IP address is converted into an EIP, the EIP is billed separately. Make sure that you fully understand the billing methods of EIPs. For more information, see [Billing overview](https://help.aliyun.com/document_detail/122035.html).
        When you call this operation, make sure that the ECS instance meets the following requirements:
        The instance is in the **Stopped** (`Stopped`) or **Running** (`Running`) state.
        The instance has no EIPs associated.
        The instance has no configuration change tasks that have not taken effect.
        The public bandwidth of the instance is not 0 Mbit/s.
        If the instance is a subscription instance, the billing method for network usage of the instance must be `pay-by-traffic`. The public IP address of a subscription instance that uses the `pay-by-bandwidth` billing method for network usage cannot be converted into an EIP. This requirement does not apply to pay-as-you-go instances. For more information, see [Change the billing method for network usage](https://help.aliyun.com/document_detail/178883.html).
        If the instance is a subscription instance that resides in a VPC, the instance does not expire within 24 hours.
        
        @param request: ConvertNatPublicIpToEipRequest
        @return: ConvertNatPublicIpToEipResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.convert_nat_public_ip_to_eip_with_options(request, runtime)

    async def convert_nat_public_ip_to_eip_async(
        self,
        request: ecs_20140526_models.ConvertNatPublicIpToEipRequest,
    ) -> ecs_20140526_models.ConvertNatPublicIpToEipResponse:
        """
        @summary Converts the static public IP address of an Elastic Compute Service (ECS) instance that resides in a virtual private cloud (VPC) into an elastic IP address (EIP). Static public IP addresses are the public IP addresses that are automatically assigned to ECS instances.
        
        @description ## [](#)Usage notes
        After a public IP address is converted into an EIP, the EIP is billed separately. Make sure that you fully understand the billing methods of EIPs. For more information, see [Billing overview](https://help.aliyun.com/document_detail/122035.html).
        When you call this operation, make sure that the ECS instance meets the following requirements:
        The instance is in the **Stopped** (`Stopped`) or **Running** (`Running`) state.
        The instance has no EIPs associated.
        The instance has no configuration change tasks that have not taken effect.
        The public bandwidth of the instance is not 0 Mbit/s.
        If the instance is a subscription instance, the billing method for network usage of the instance must be `pay-by-traffic`. The public IP address of a subscription instance that uses the `pay-by-bandwidth` billing method for network usage cannot be converted into an EIP. This requirement does not apply to pay-as-you-go instances. For more information, see [Change the billing method for network usage](https://help.aliyun.com/document_detail/178883.html).
        If the instance is a subscription instance that resides in a VPC, the instance does not expire within 24 hours.
        
        @param request: ConvertNatPublicIpToEipRequest
        @return: ConvertNatPublicIpToEipResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.convert_nat_public_ip_to_eip_with_options_async(request, runtime)

    def copy_image_with_options(
        self,
        request: ecs_20140526_models.CopyImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CopyImageResponse:
        """
        @summary Copies a custom image from one region to another region. You can copy custom images to deploy or copy Elastic Compute Service (ECS) instances across regions.
        
        @description ## [](#)Usage notes
        After you copy a custom image to the destination region, you can use the image copy (new image) to create ECS instances by calling the RunInstances operation or replace the system disks of instances by calling the ReplaceSystemDisk operation in the destination region.
        Take note of the following items:
        Only custom images that are in the `Available` state can be copied.
        Custom images that belong to your Alibaba Cloud account can be copied across regions. Images that are shared with you by others can be copied only within the regions where the images reside.
        When an image is being copied, the new image cannot be deleted by calling the [DeleteImage](https://help.aliyun.com/document_detail/25537.html) operation. However, you can cancel the ongoing image copy task by calling the [CancelCopyImage](https://help.aliyun.com/document_detail/25539.html) operation.
        A region supports only up to five concurrent image copy tasks. Excess image copy tasks are queued for execution.
        You can configure `ResourceGroupId` to specify the resource group to which to assign the new image. If you do not configure `ResourceGroupId`, the new image is assigned to the default resource group.
        
        @param request: CopyImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CopyImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.destination_description):
            query['DestinationDescription'] = request.destination_description
        if not UtilClient.is_unset(request.destination_image_name):
            query['DestinationImageName'] = request.destination_image_name
        if not UtilClient.is_unset(request.destination_region_id):
            query['DestinationRegionId'] = request.destination_region_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.encrypt_algorithm):
            query['EncryptAlgorithm'] = request.encrypt_algorithm
        if not UtilClient.is_unset(request.encrypted):
            query['Encrypted'] = request.encrypted
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.kmskey_id):
            query['KMSKeyId'] = request.kmskey_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CopyImage',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CopyImageResponse(),
            self.call_api(params, req, runtime)
        )

    async def copy_image_with_options_async(
        self,
        request: ecs_20140526_models.CopyImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CopyImageResponse:
        """
        @summary Copies a custom image from one region to another region. You can copy custom images to deploy or copy Elastic Compute Service (ECS) instances across regions.
        
        @description ## [](#)Usage notes
        After you copy a custom image to the destination region, you can use the image copy (new image) to create ECS instances by calling the RunInstances operation or replace the system disks of instances by calling the ReplaceSystemDisk operation in the destination region.
        Take note of the following items:
        Only custom images that are in the `Available` state can be copied.
        Custom images that belong to your Alibaba Cloud account can be copied across regions. Images that are shared with you by others can be copied only within the regions where the images reside.
        When an image is being copied, the new image cannot be deleted by calling the [DeleteImage](https://help.aliyun.com/document_detail/25537.html) operation. However, you can cancel the ongoing image copy task by calling the [CancelCopyImage](https://help.aliyun.com/document_detail/25539.html) operation.
        A region supports only up to five concurrent image copy tasks. Excess image copy tasks are queued for execution.
        You can configure `ResourceGroupId` to specify the resource group to which to assign the new image. If you do not configure `ResourceGroupId`, the new image is assigned to the default resource group.
        
        @param request: CopyImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CopyImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.destination_description):
            query['DestinationDescription'] = request.destination_description
        if not UtilClient.is_unset(request.destination_image_name):
            query['DestinationImageName'] = request.destination_image_name
        if not UtilClient.is_unset(request.destination_region_id):
            query['DestinationRegionId'] = request.destination_region_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.encrypt_algorithm):
            query['EncryptAlgorithm'] = request.encrypt_algorithm
        if not UtilClient.is_unset(request.encrypted):
            query['Encrypted'] = request.encrypted
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.kmskey_id):
            query['KMSKeyId'] = request.kmskey_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CopyImage',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CopyImageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def copy_image(
        self,
        request: ecs_20140526_models.CopyImageRequest,
    ) -> ecs_20140526_models.CopyImageResponse:
        """
        @summary Copies a custom image from one region to another region. You can copy custom images to deploy or copy Elastic Compute Service (ECS) instances across regions.
        
        @description ## [](#)Usage notes
        After you copy a custom image to the destination region, you can use the image copy (new image) to create ECS instances by calling the RunInstances operation or replace the system disks of instances by calling the ReplaceSystemDisk operation in the destination region.
        Take note of the following items:
        Only custom images that are in the `Available` state can be copied.
        Custom images that belong to your Alibaba Cloud account can be copied across regions. Images that are shared with you by others can be copied only within the regions where the images reside.
        When an image is being copied, the new image cannot be deleted by calling the [DeleteImage](https://help.aliyun.com/document_detail/25537.html) operation. However, you can cancel the ongoing image copy task by calling the [CancelCopyImage](https://help.aliyun.com/document_detail/25539.html) operation.
        A region supports only up to five concurrent image copy tasks. Excess image copy tasks are queued for execution.
        You can configure `ResourceGroupId` to specify the resource group to which to assign the new image. If you do not configure `ResourceGroupId`, the new image is assigned to the default resource group.
        
        @param request: CopyImageRequest
        @return: CopyImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.copy_image_with_options(request, runtime)

    async def copy_image_async(
        self,
        request: ecs_20140526_models.CopyImageRequest,
    ) -> ecs_20140526_models.CopyImageResponse:
        """
        @summary Copies a custom image from one region to another region. You can copy custom images to deploy or copy Elastic Compute Service (ECS) instances across regions.
        
        @description ## [](#)Usage notes
        After you copy a custom image to the destination region, you can use the image copy (new image) to create ECS instances by calling the RunInstances operation or replace the system disks of instances by calling the ReplaceSystemDisk operation in the destination region.
        Take note of the following items:
        Only custom images that are in the `Available` state can be copied.
        Custom images that belong to your Alibaba Cloud account can be copied across regions. Images that are shared with you by others can be copied only within the regions where the images reside.
        When an image is being copied, the new image cannot be deleted by calling the [DeleteImage](https://help.aliyun.com/document_detail/25537.html) operation. However, you can cancel the ongoing image copy task by calling the [CancelCopyImage](https://help.aliyun.com/document_detail/25539.html) operation.
        A region supports only up to five concurrent image copy tasks. Excess image copy tasks are queued for execution.
        You can configure `ResourceGroupId` to specify the resource group to which to assign the new image. If you do not configure `ResourceGroupId`, the new image is assigned to the default resource group.
        
        @param request: CopyImageRequest
        @return: CopyImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.copy_image_with_options_async(request, runtime)

    def copy_snapshot_with_options(
        self,
        request: ecs_20140526_models.CopySnapshotRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CopySnapshotResponse:
        """
        @summary Copies a standard or encrypted snapshot from one region to another.
        
        @description When you call this operation, take note of the following item:
        New snapshots (snapshot copies) cannot be used to roll back the disks for which source snapshots (copied snapshots) were created.
        Local snapshots cannot be copied.
        
        @param request: CopySnapshotRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CopySnapshotResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.arn):
            query['Arn'] = request.arn
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.destination_region_id):
            query['DestinationRegionId'] = request.destination_region_id
        if not UtilClient.is_unset(request.destination_snapshot_description):
            query['DestinationSnapshotDescription'] = request.destination_snapshot_description
        if not UtilClient.is_unset(request.destination_snapshot_name):
            query['DestinationSnapshotName'] = request.destination_snapshot_name
        if not UtilClient.is_unset(request.destination_storage_location_arn):
            query['DestinationStorageLocationArn'] = request.destination_storage_location_arn
        if not UtilClient.is_unset(request.encrypted):
            query['Encrypted'] = request.encrypted
        if not UtilClient.is_unset(request.kmskey_id):
            query['KMSKeyId'] = request.kmskey_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.retention_days):
            query['RetentionDays'] = request.retention_days
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CopySnapshot',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CopySnapshotResponse(),
            self.call_api(params, req, runtime)
        )

    async def copy_snapshot_with_options_async(
        self,
        request: ecs_20140526_models.CopySnapshotRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CopySnapshotResponse:
        """
        @summary Copies a standard or encrypted snapshot from one region to another.
        
        @description When you call this operation, take note of the following item:
        New snapshots (snapshot copies) cannot be used to roll back the disks for which source snapshots (copied snapshots) were created.
        Local snapshots cannot be copied.
        
        @param request: CopySnapshotRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CopySnapshotResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.arn):
            query['Arn'] = request.arn
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.destination_region_id):
            query['DestinationRegionId'] = request.destination_region_id
        if not UtilClient.is_unset(request.destination_snapshot_description):
            query['DestinationSnapshotDescription'] = request.destination_snapshot_description
        if not UtilClient.is_unset(request.destination_snapshot_name):
            query['DestinationSnapshotName'] = request.destination_snapshot_name
        if not UtilClient.is_unset(request.destination_storage_location_arn):
            query['DestinationStorageLocationArn'] = request.destination_storage_location_arn
        if not UtilClient.is_unset(request.encrypted):
            query['Encrypted'] = request.encrypted
        if not UtilClient.is_unset(request.kmskey_id):
            query['KMSKeyId'] = request.kmskey_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.retention_days):
            query['RetentionDays'] = request.retention_days
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CopySnapshot',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CopySnapshotResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def copy_snapshot(
        self,
        request: ecs_20140526_models.CopySnapshotRequest,
    ) -> ecs_20140526_models.CopySnapshotResponse:
        """
        @summary Copies a standard or encrypted snapshot from one region to another.
        
        @description When you call this operation, take note of the following item:
        New snapshots (snapshot copies) cannot be used to roll back the disks for which source snapshots (copied snapshots) were created.
        Local snapshots cannot be copied.
        
        @param request: CopySnapshotRequest
        @return: CopySnapshotResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.copy_snapshot_with_options(request, runtime)

    async def copy_snapshot_async(
        self,
        request: ecs_20140526_models.CopySnapshotRequest,
    ) -> ecs_20140526_models.CopySnapshotResponse:
        """
        @summary Copies a standard or encrypted snapshot from one region to another.
        
        @description When you call this operation, take note of the following item:
        New snapshots (snapshot copies) cannot be used to roll back the disks for which source snapshots (copied snapshots) were created.
        Local snapshots cannot be copied.
        
        @param request: CopySnapshotRequest
        @return: CopySnapshotResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.copy_snapshot_with_options_async(request, runtime)

    def create_activation_with_options(
        self,
        request: ecs_20140526_models.CreateActivationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateActivationResponse:
        """
        @summary Creates an activation code. The activation code is used to register servers that are not provided by Alibaba Cloud as Alibaba Cloud managed instances.
        
        @description ## [](#)Usage notes
        After you use an activation code to register a server that is not provided by Alibaba Cloud as an Alibaba Cloud managed instance, you can use various online services of Alibaba Cloud, such as Cloud Assistant, CloudOps Orchestration Service (OOS), and Apsara Devops, on the managed instance.
        If a server is not provided by Alibaba Cloud, you can register the server as an Alibaba Cloud managed instance only if the server has Internet connectivity and runs one of the following operating systems:
        Alibaba Cloud Linux 2, Alibaba Cloud Linux 3, or later
        CentOS 6, CentOS 7, CentOS 8, or later
        Debian 8, Debian 9, Debian 10, or later
        Ubuntu 12, Ubuntu 14, Ubuntu 16, Ubuntu 18, or later
        CoreOS
        OpenSUSE
        Red Hat 5, Red Hat 6, Red Hat 7, or later
        SUSE Linux Enterprise Server 11, SUSE Linux Enterprise Server 12, SUSE Linux Enterprise Server 15, or later
        Windows Server 2012, Windows Server 2016, Windows Server 2019, or later
        You can have up to 5,000 activation codes per Alibaba Cloud region. When the number of activation codes exceeds 1,000, the usage of the activation codes must be greater than 50% before you can create additional activation codes.
        >  To obtain the usage of activation codes, go to the *ECS Cloud Assistant** page in the Elastic Compute Service (ECS) console, click the **Manage Instances** tab, and then click **Register Instance**.
        
        @param request: CreateActivationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateActivationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.instance_count):
            query['InstanceCount'] = request.instance_count
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.ip_address_range):
            query['IpAddressRange'] = request.ip_address_range
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.time_to_live_in_hours):
            query['TimeToLiveInHours'] = request.time_to_live_in_hours
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateActivation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateActivationResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_activation_with_options_async(
        self,
        request: ecs_20140526_models.CreateActivationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateActivationResponse:
        """
        @summary Creates an activation code. The activation code is used to register servers that are not provided by Alibaba Cloud as Alibaba Cloud managed instances.
        
        @description ## [](#)Usage notes
        After you use an activation code to register a server that is not provided by Alibaba Cloud as an Alibaba Cloud managed instance, you can use various online services of Alibaba Cloud, such as Cloud Assistant, CloudOps Orchestration Service (OOS), and Apsara Devops, on the managed instance.
        If a server is not provided by Alibaba Cloud, you can register the server as an Alibaba Cloud managed instance only if the server has Internet connectivity and runs one of the following operating systems:
        Alibaba Cloud Linux 2, Alibaba Cloud Linux 3, or later
        CentOS 6, CentOS 7, CentOS 8, or later
        Debian 8, Debian 9, Debian 10, or later
        Ubuntu 12, Ubuntu 14, Ubuntu 16, Ubuntu 18, or later
        CoreOS
        OpenSUSE
        Red Hat 5, Red Hat 6, Red Hat 7, or later
        SUSE Linux Enterprise Server 11, SUSE Linux Enterprise Server 12, SUSE Linux Enterprise Server 15, or later
        Windows Server 2012, Windows Server 2016, Windows Server 2019, or later
        You can have up to 5,000 activation codes per Alibaba Cloud region. When the number of activation codes exceeds 1,000, the usage of the activation codes must be greater than 50% before you can create additional activation codes.
        >  To obtain the usage of activation codes, go to the *ECS Cloud Assistant** page in the Elastic Compute Service (ECS) console, click the **Manage Instances** tab, and then click **Register Instance**.
        
        @param request: CreateActivationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateActivationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.instance_count):
            query['InstanceCount'] = request.instance_count
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.ip_address_range):
            query['IpAddressRange'] = request.ip_address_range
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.time_to_live_in_hours):
            query['TimeToLiveInHours'] = request.time_to_live_in_hours
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateActivation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateActivationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_activation(
        self,
        request: ecs_20140526_models.CreateActivationRequest,
    ) -> ecs_20140526_models.CreateActivationResponse:
        """
        @summary Creates an activation code. The activation code is used to register servers that are not provided by Alibaba Cloud as Alibaba Cloud managed instances.
        
        @description ## [](#)Usage notes
        After you use an activation code to register a server that is not provided by Alibaba Cloud as an Alibaba Cloud managed instance, you can use various online services of Alibaba Cloud, such as Cloud Assistant, CloudOps Orchestration Service (OOS), and Apsara Devops, on the managed instance.
        If a server is not provided by Alibaba Cloud, you can register the server as an Alibaba Cloud managed instance only if the server has Internet connectivity and runs one of the following operating systems:
        Alibaba Cloud Linux 2, Alibaba Cloud Linux 3, or later
        CentOS 6, CentOS 7, CentOS 8, or later
        Debian 8, Debian 9, Debian 10, or later
        Ubuntu 12, Ubuntu 14, Ubuntu 16, Ubuntu 18, or later
        CoreOS
        OpenSUSE
        Red Hat 5, Red Hat 6, Red Hat 7, or later
        SUSE Linux Enterprise Server 11, SUSE Linux Enterprise Server 12, SUSE Linux Enterprise Server 15, or later
        Windows Server 2012, Windows Server 2016, Windows Server 2019, or later
        You can have up to 5,000 activation codes per Alibaba Cloud region. When the number of activation codes exceeds 1,000, the usage of the activation codes must be greater than 50% before you can create additional activation codes.
        >  To obtain the usage of activation codes, go to the *ECS Cloud Assistant** page in the Elastic Compute Service (ECS) console, click the **Manage Instances** tab, and then click **Register Instance**.
        
        @param request: CreateActivationRequest
        @return: CreateActivationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_activation_with_options(request, runtime)

    async def create_activation_async(
        self,
        request: ecs_20140526_models.CreateActivationRequest,
    ) -> ecs_20140526_models.CreateActivationResponse:
        """
        @summary Creates an activation code. The activation code is used to register servers that are not provided by Alibaba Cloud as Alibaba Cloud managed instances.
        
        @description ## [](#)Usage notes
        After you use an activation code to register a server that is not provided by Alibaba Cloud as an Alibaba Cloud managed instance, you can use various online services of Alibaba Cloud, such as Cloud Assistant, CloudOps Orchestration Service (OOS), and Apsara Devops, on the managed instance.
        If a server is not provided by Alibaba Cloud, you can register the server as an Alibaba Cloud managed instance only if the server has Internet connectivity and runs one of the following operating systems:
        Alibaba Cloud Linux 2, Alibaba Cloud Linux 3, or later
        CentOS 6, CentOS 7, CentOS 8, or later
        Debian 8, Debian 9, Debian 10, or later
        Ubuntu 12, Ubuntu 14, Ubuntu 16, Ubuntu 18, or later
        CoreOS
        OpenSUSE
        Red Hat 5, Red Hat 6, Red Hat 7, or later
        SUSE Linux Enterprise Server 11, SUSE Linux Enterprise Server 12, SUSE Linux Enterprise Server 15, or later
        Windows Server 2012, Windows Server 2016, Windows Server 2019, or later
        You can have up to 5,000 activation codes per Alibaba Cloud region. When the number of activation codes exceeds 1,000, the usage of the activation codes must be greater than 50% before you can create additional activation codes.
        >  To obtain the usage of activation codes, go to the *ECS Cloud Assistant** page in the Elastic Compute Service (ECS) console, click the **Manage Instances** tab, and then click **Register Instance**.
        
        @param request: CreateActivationRequest
        @return: CreateActivationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_activation_with_options_async(request, runtime)

    def create_auto_provisioning_group_with_options(
        self,
        tmp_req: ecs_20140526_models.CreateAutoProvisioningGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateAutoProvisioningGroupResponse:
        """
        @summary Creates an auto provisioning group.
        
        @description ## [](#)Usage notes
        Auto Provisioning is a service that allows quick deployment of an instance cluster that consists of spot instances and pay-as-you-go instances. Auto Provisioning supports push-button deployment of instance clusters across different billing methods, instance families, and zones. For more information, see [Use auto provisioning group-related API operations to create multiple ECS instances at the same time](https://help.aliyun.com/document_detail/200772.html).
        Auto Provisioning uses auto provisioning groups to schedule and maintain computing resources. You can use auto provisioning groups to obtain a steady supply of computing resources. This helps reduce the impact on compute capacity when spot instances are reclaimed.
        Auto Provisioning is provided free of charge. However, you are charged for instance resources that are created in auto provisioning groups. For more information, see [Overview of spot instances](https://help.aliyun.com/document_detail/52088.html) and [Pay-as-you-go](https://help.aliyun.com/document_detail/40653.html).
        When you specify both a launch template (`LaunchTemplateId`) and extended configurations (`LaunchConfiguration.*` parameters), LaunchTemplateId takes precedence.
        
        @param tmp_req: CreateAutoProvisioningGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAutoProvisioningGroupResponse
        """
        UtilClient.validate_model(tmp_req)
        request = ecs_20140526_models.CreateAutoProvisioningGroupShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.resource_pool_options):
            request.resource_pool_options_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.resource_pool_options, 'ResourcePoolOptions', 'json')
        query = {}
        if not UtilClient.is_unset(request.auto_provisioning_group_name):
            query['AutoProvisioningGroupName'] = request.auto_provisioning_group_name
        if not UtilClient.is_unset(request.auto_provisioning_group_type):
            query['AutoProvisioningGroupType'] = request.auto_provisioning_group_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.data_disk_config):
            query['DataDiskConfig'] = request.data_disk_config
        if not UtilClient.is_unset(request.default_target_capacity_type):
            query['DefaultTargetCapacityType'] = request.default_target_capacity_type
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.excess_capacity_termination_policy):
            query['ExcessCapacityTerminationPolicy'] = request.excess_capacity_termination_policy
        if not UtilClient.is_unset(request.hibernation_options_configured):
            query['HibernationOptionsConfigured'] = request.hibernation_options_configured
        if not UtilClient.is_unset(request.launch_template_config):
            query['LaunchTemplateConfig'] = request.launch_template_config
        if not UtilClient.is_unset(request.launch_template_id):
            query['LaunchTemplateId'] = request.launch_template_id
        if not UtilClient.is_unset(request.launch_template_version):
            query['LaunchTemplateVersion'] = request.launch_template_version
        if not UtilClient.is_unset(request.max_spot_price):
            query['MaxSpotPrice'] = request.max_spot_price
        if not UtilClient.is_unset(request.min_target_capacity):
            query['MinTargetCapacity'] = request.min_target_capacity
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pay_as_you_go_allocation_strategy):
            query['PayAsYouGoAllocationStrategy'] = request.pay_as_you_go_allocation_strategy
        if not UtilClient.is_unset(request.pay_as_you_go_target_capacity):
            query['PayAsYouGoTargetCapacity'] = request.pay_as_you_go_target_capacity
        if not UtilClient.is_unset(request.pre_paid_options):
            query['PrePaidOptions'] = request.pre_paid_options
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_pool_options_shrink):
            query['ResourcePoolOptions'] = request.resource_pool_options_shrink
        if not UtilClient.is_unset(request.spot_allocation_strategy):
            query['SpotAllocationStrategy'] = request.spot_allocation_strategy
        if not UtilClient.is_unset(request.spot_instance_interruption_behavior):
            query['SpotInstanceInterruptionBehavior'] = request.spot_instance_interruption_behavior
        if not UtilClient.is_unset(request.spot_instance_pools_to_use_count):
            query['SpotInstancePoolsToUseCount'] = request.spot_instance_pools_to_use_count
        if not UtilClient.is_unset(request.spot_target_capacity):
            query['SpotTargetCapacity'] = request.spot_target_capacity
        if not UtilClient.is_unset(request.system_disk_config):
            query['SystemDiskConfig'] = request.system_disk_config
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.terminate_instances):
            query['TerminateInstances'] = request.terminate_instances
        if not UtilClient.is_unset(request.terminate_instances_with_expiration):
            query['TerminateInstancesWithExpiration'] = request.terminate_instances_with_expiration
        if not UtilClient.is_unset(request.total_target_capacity):
            query['TotalTargetCapacity'] = request.total_target_capacity
        if not UtilClient.is_unset(request.valid_from):
            query['ValidFrom'] = request.valid_from
        if not UtilClient.is_unset(request.valid_until):
            query['ValidUntil'] = request.valid_until
        if not UtilClient.is_unset(request.launch_configuration):
            query['LaunchConfiguration'] = request.launch_configuration
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateAutoProvisioningGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateAutoProvisioningGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_auto_provisioning_group_with_options_async(
        self,
        tmp_req: ecs_20140526_models.CreateAutoProvisioningGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateAutoProvisioningGroupResponse:
        """
        @summary Creates an auto provisioning group.
        
        @description ## [](#)Usage notes
        Auto Provisioning is a service that allows quick deployment of an instance cluster that consists of spot instances and pay-as-you-go instances. Auto Provisioning supports push-button deployment of instance clusters across different billing methods, instance families, and zones. For more information, see [Use auto provisioning group-related API operations to create multiple ECS instances at the same time](https://help.aliyun.com/document_detail/200772.html).
        Auto Provisioning uses auto provisioning groups to schedule and maintain computing resources. You can use auto provisioning groups to obtain a steady supply of computing resources. This helps reduce the impact on compute capacity when spot instances are reclaimed.
        Auto Provisioning is provided free of charge. However, you are charged for instance resources that are created in auto provisioning groups. For more information, see [Overview of spot instances](https://help.aliyun.com/document_detail/52088.html) and [Pay-as-you-go](https://help.aliyun.com/document_detail/40653.html).
        When you specify both a launch template (`LaunchTemplateId`) and extended configurations (`LaunchConfiguration.*` parameters), LaunchTemplateId takes precedence.
        
        @param tmp_req: CreateAutoProvisioningGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAutoProvisioningGroupResponse
        """
        UtilClient.validate_model(tmp_req)
        request = ecs_20140526_models.CreateAutoProvisioningGroupShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.resource_pool_options):
            request.resource_pool_options_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.resource_pool_options, 'ResourcePoolOptions', 'json')
        query = {}
        if not UtilClient.is_unset(request.auto_provisioning_group_name):
            query['AutoProvisioningGroupName'] = request.auto_provisioning_group_name
        if not UtilClient.is_unset(request.auto_provisioning_group_type):
            query['AutoProvisioningGroupType'] = request.auto_provisioning_group_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.data_disk_config):
            query['DataDiskConfig'] = request.data_disk_config
        if not UtilClient.is_unset(request.default_target_capacity_type):
            query['DefaultTargetCapacityType'] = request.default_target_capacity_type
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.excess_capacity_termination_policy):
            query['ExcessCapacityTerminationPolicy'] = request.excess_capacity_termination_policy
        if not UtilClient.is_unset(request.hibernation_options_configured):
            query['HibernationOptionsConfigured'] = request.hibernation_options_configured
        if not UtilClient.is_unset(request.launch_template_config):
            query['LaunchTemplateConfig'] = request.launch_template_config
        if not UtilClient.is_unset(request.launch_template_id):
            query['LaunchTemplateId'] = request.launch_template_id
        if not UtilClient.is_unset(request.launch_template_version):
            query['LaunchTemplateVersion'] = request.launch_template_version
        if not UtilClient.is_unset(request.max_spot_price):
            query['MaxSpotPrice'] = request.max_spot_price
        if not UtilClient.is_unset(request.min_target_capacity):
            query['MinTargetCapacity'] = request.min_target_capacity
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pay_as_you_go_allocation_strategy):
            query['PayAsYouGoAllocationStrategy'] = request.pay_as_you_go_allocation_strategy
        if not UtilClient.is_unset(request.pay_as_you_go_target_capacity):
            query['PayAsYouGoTargetCapacity'] = request.pay_as_you_go_target_capacity
        if not UtilClient.is_unset(request.pre_paid_options):
            query['PrePaidOptions'] = request.pre_paid_options
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_pool_options_shrink):
            query['ResourcePoolOptions'] = request.resource_pool_options_shrink
        if not UtilClient.is_unset(request.spot_allocation_strategy):
            query['SpotAllocationStrategy'] = request.spot_allocation_strategy
        if not UtilClient.is_unset(request.spot_instance_interruption_behavior):
            query['SpotInstanceInterruptionBehavior'] = request.spot_instance_interruption_behavior
        if not UtilClient.is_unset(request.spot_instance_pools_to_use_count):
            query['SpotInstancePoolsToUseCount'] = request.spot_instance_pools_to_use_count
        if not UtilClient.is_unset(request.spot_target_capacity):
            query['SpotTargetCapacity'] = request.spot_target_capacity
        if not UtilClient.is_unset(request.system_disk_config):
            query['SystemDiskConfig'] = request.system_disk_config
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.terminate_instances):
            query['TerminateInstances'] = request.terminate_instances
        if not UtilClient.is_unset(request.terminate_instances_with_expiration):
            query['TerminateInstancesWithExpiration'] = request.terminate_instances_with_expiration
        if not UtilClient.is_unset(request.total_target_capacity):
            query['TotalTargetCapacity'] = request.total_target_capacity
        if not UtilClient.is_unset(request.valid_from):
            query['ValidFrom'] = request.valid_from
        if not UtilClient.is_unset(request.valid_until):
            query['ValidUntil'] = request.valid_until
        if not UtilClient.is_unset(request.launch_configuration):
            query['LaunchConfiguration'] = request.launch_configuration
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateAutoProvisioningGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateAutoProvisioningGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_auto_provisioning_group(
        self,
        request: ecs_20140526_models.CreateAutoProvisioningGroupRequest,
    ) -> ecs_20140526_models.CreateAutoProvisioningGroupResponse:
        """
        @summary Creates an auto provisioning group.
        
        @description ## [](#)Usage notes
        Auto Provisioning is a service that allows quick deployment of an instance cluster that consists of spot instances and pay-as-you-go instances. Auto Provisioning supports push-button deployment of instance clusters across different billing methods, instance families, and zones. For more information, see [Use auto provisioning group-related API operations to create multiple ECS instances at the same time](https://help.aliyun.com/document_detail/200772.html).
        Auto Provisioning uses auto provisioning groups to schedule and maintain computing resources. You can use auto provisioning groups to obtain a steady supply of computing resources. This helps reduce the impact on compute capacity when spot instances are reclaimed.
        Auto Provisioning is provided free of charge. However, you are charged for instance resources that are created in auto provisioning groups. For more information, see [Overview of spot instances](https://help.aliyun.com/document_detail/52088.html) and [Pay-as-you-go](https://help.aliyun.com/document_detail/40653.html).
        When you specify both a launch template (`LaunchTemplateId`) and extended configurations (`LaunchConfiguration.*` parameters), LaunchTemplateId takes precedence.
        
        @param request: CreateAutoProvisioningGroupRequest
        @return: CreateAutoProvisioningGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_auto_provisioning_group_with_options(request, runtime)

    async def create_auto_provisioning_group_async(
        self,
        request: ecs_20140526_models.CreateAutoProvisioningGroupRequest,
    ) -> ecs_20140526_models.CreateAutoProvisioningGroupResponse:
        """
        @summary Creates an auto provisioning group.
        
        @description ## [](#)Usage notes
        Auto Provisioning is a service that allows quick deployment of an instance cluster that consists of spot instances and pay-as-you-go instances. Auto Provisioning supports push-button deployment of instance clusters across different billing methods, instance families, and zones. For more information, see [Use auto provisioning group-related API operations to create multiple ECS instances at the same time](https://help.aliyun.com/document_detail/200772.html).
        Auto Provisioning uses auto provisioning groups to schedule and maintain computing resources. You can use auto provisioning groups to obtain a steady supply of computing resources. This helps reduce the impact on compute capacity when spot instances are reclaimed.
        Auto Provisioning is provided free of charge. However, you are charged for instance resources that are created in auto provisioning groups. For more information, see [Overview of spot instances](https://help.aliyun.com/document_detail/52088.html) and [Pay-as-you-go](https://help.aliyun.com/document_detail/40653.html).
        When you specify both a launch template (`LaunchTemplateId`) and extended configurations (`LaunchConfiguration.*` parameters), LaunchTemplateId takes precedence.
        
        @param request: CreateAutoProvisioningGroupRequest
        @return: CreateAutoProvisioningGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_auto_provisioning_group_with_options_async(request, runtime)

    def create_auto_snapshot_policy_with_options(
        self,
        request: ecs_20140526_models.CreateAutoSnapshotPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateAutoSnapshotPolicyResponse:
        """
        @summary Creates an automatic snapshot policy in a specific region. You can specify the schedule on which to create automatic snapshots, the retention period of the automatic snapshots, and whether to enable cross-region replication for the snapshots in the automatic snapshot policy. The automatic snapshot policy can be applied to create snapshots for system disks or data disks to back up disk data.
        
        @description Before you call this operation, learn about how to [create an automatic snapshot policy](https://help.aliyun.com/document_detail/127767.html).
        Take note of the following items:
        You can create up to 100 automatic snapshot policies per region for a single Alibaba Cloud account. If the maximum number of automatic snapshots for a disk is reached and a new snapshot creation task is created, the system deletes the oldest automatic snapshot of the disk.
        If the instance to which a disk is attached is being stopped or restarted, the system cannot create snapshots for the disk based on the associated automatic snapshot policy.
        If cross-region snapshot replication is enabled and no encryption parameters are configured, encrypted snapshots are copied to the destination region and snapshot copies are encrypted by using the service key of the destination region. For more information about the limits on cross-region snapshot replication, see [Copy a snapshot](https://help.aliyun.com/document_detail/159441.html).
        After the automatic snapshot policy is created, call the [ApplyAutoSnapshotPolicy](https://help.aliyun.com/document_detail/25531.html) operation to apply the policy to disks. If you want to modify the automatic snapshot policy, call the [ModifyAutoSnapshotPolicyEx](https://help.aliyun.com/document_detail/25529.html) operation.
        
        @param request: CreateAutoSnapshotPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAutoSnapshotPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.copied_snapshots_retention_days):
            query['CopiedSnapshotsRetentionDays'] = request.copied_snapshots_retention_days
        if not UtilClient.is_unset(request.copy_encryption_configuration):
            query['CopyEncryptionConfiguration'] = request.copy_encryption_configuration
        if not UtilClient.is_unset(request.enable_cross_region_copy):
            query['EnableCrossRegionCopy'] = request.enable_cross_region_copy
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_location_arn):
            query['StorageLocationArn'] = request.storage_location_arn
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.target_copy_regions):
            query['TargetCopyRegions'] = request.target_copy_regions
        if not UtilClient.is_unset(request.auto_snapshot_policy_name):
            query['autoSnapshotPolicyName'] = request.auto_snapshot_policy_name
        if not UtilClient.is_unset(request.region_id):
            query['regionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_weekdays):
            query['repeatWeekdays'] = request.repeat_weekdays
        if not UtilClient.is_unset(request.retention_days):
            query['retentionDays'] = request.retention_days
        if not UtilClient.is_unset(request.time_points):
            query['timePoints'] = request.time_points
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateAutoSnapshotPolicy',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateAutoSnapshotPolicyResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_auto_snapshot_policy_with_options_async(
        self,
        request: ecs_20140526_models.CreateAutoSnapshotPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateAutoSnapshotPolicyResponse:
        """
        @summary Creates an automatic snapshot policy in a specific region. You can specify the schedule on which to create automatic snapshots, the retention period of the automatic snapshots, and whether to enable cross-region replication for the snapshots in the automatic snapshot policy. The automatic snapshot policy can be applied to create snapshots for system disks or data disks to back up disk data.
        
        @description Before you call this operation, learn about how to [create an automatic snapshot policy](https://help.aliyun.com/document_detail/127767.html).
        Take note of the following items:
        You can create up to 100 automatic snapshot policies per region for a single Alibaba Cloud account. If the maximum number of automatic snapshots for a disk is reached and a new snapshot creation task is created, the system deletes the oldest automatic snapshot of the disk.
        If the instance to which a disk is attached is being stopped or restarted, the system cannot create snapshots for the disk based on the associated automatic snapshot policy.
        If cross-region snapshot replication is enabled and no encryption parameters are configured, encrypted snapshots are copied to the destination region and snapshot copies are encrypted by using the service key of the destination region. For more information about the limits on cross-region snapshot replication, see [Copy a snapshot](https://help.aliyun.com/document_detail/159441.html).
        After the automatic snapshot policy is created, call the [ApplyAutoSnapshotPolicy](https://help.aliyun.com/document_detail/25531.html) operation to apply the policy to disks. If you want to modify the automatic snapshot policy, call the [ModifyAutoSnapshotPolicyEx](https://help.aliyun.com/document_detail/25529.html) operation.
        
        @param request: CreateAutoSnapshotPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAutoSnapshotPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.copied_snapshots_retention_days):
            query['CopiedSnapshotsRetentionDays'] = request.copied_snapshots_retention_days
        if not UtilClient.is_unset(request.copy_encryption_configuration):
            query['CopyEncryptionConfiguration'] = request.copy_encryption_configuration
        if not UtilClient.is_unset(request.enable_cross_region_copy):
            query['EnableCrossRegionCopy'] = request.enable_cross_region_copy
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_location_arn):
            query['StorageLocationArn'] = request.storage_location_arn
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.target_copy_regions):
            query['TargetCopyRegions'] = request.target_copy_regions
        if not UtilClient.is_unset(request.auto_snapshot_policy_name):
            query['autoSnapshotPolicyName'] = request.auto_snapshot_policy_name
        if not UtilClient.is_unset(request.region_id):
            query['regionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_weekdays):
            query['repeatWeekdays'] = request.repeat_weekdays
        if not UtilClient.is_unset(request.retention_days):
            query['retentionDays'] = request.retention_days
        if not UtilClient.is_unset(request.time_points):
            query['timePoints'] = request.time_points
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateAutoSnapshotPolicy',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateAutoSnapshotPolicyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_auto_snapshot_policy(
        self,
        request: ecs_20140526_models.CreateAutoSnapshotPolicyRequest,
    ) -> ecs_20140526_models.CreateAutoSnapshotPolicyResponse:
        """
        @summary Creates an automatic snapshot policy in a specific region. You can specify the schedule on which to create automatic snapshots, the retention period of the automatic snapshots, and whether to enable cross-region replication for the snapshots in the automatic snapshot policy. The automatic snapshot policy can be applied to create snapshots for system disks or data disks to back up disk data.
        
        @description Before you call this operation, learn about how to [create an automatic snapshot policy](https://help.aliyun.com/document_detail/127767.html).
        Take note of the following items:
        You can create up to 100 automatic snapshot policies per region for a single Alibaba Cloud account. If the maximum number of automatic snapshots for a disk is reached and a new snapshot creation task is created, the system deletes the oldest automatic snapshot of the disk.
        If the instance to which a disk is attached is being stopped or restarted, the system cannot create snapshots for the disk based on the associated automatic snapshot policy.
        If cross-region snapshot replication is enabled and no encryption parameters are configured, encrypted snapshots are copied to the destination region and snapshot copies are encrypted by using the service key of the destination region. For more information about the limits on cross-region snapshot replication, see [Copy a snapshot](https://help.aliyun.com/document_detail/159441.html).
        After the automatic snapshot policy is created, call the [ApplyAutoSnapshotPolicy](https://help.aliyun.com/document_detail/25531.html) operation to apply the policy to disks. If you want to modify the automatic snapshot policy, call the [ModifyAutoSnapshotPolicyEx](https://help.aliyun.com/document_detail/25529.html) operation.
        
        @param request: CreateAutoSnapshotPolicyRequest
        @return: CreateAutoSnapshotPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_auto_snapshot_policy_with_options(request, runtime)

    async def create_auto_snapshot_policy_async(
        self,
        request: ecs_20140526_models.CreateAutoSnapshotPolicyRequest,
    ) -> ecs_20140526_models.CreateAutoSnapshotPolicyResponse:
        """
        @summary Creates an automatic snapshot policy in a specific region. You can specify the schedule on which to create automatic snapshots, the retention period of the automatic snapshots, and whether to enable cross-region replication for the snapshots in the automatic snapshot policy. The automatic snapshot policy can be applied to create snapshots for system disks or data disks to back up disk data.
        
        @description Before you call this operation, learn about how to [create an automatic snapshot policy](https://help.aliyun.com/document_detail/127767.html).
        Take note of the following items:
        You can create up to 100 automatic snapshot policies per region for a single Alibaba Cloud account. If the maximum number of automatic snapshots for a disk is reached and a new snapshot creation task is created, the system deletes the oldest automatic snapshot of the disk.
        If the instance to which a disk is attached is being stopped or restarted, the system cannot create snapshots for the disk based on the associated automatic snapshot policy.
        If cross-region snapshot replication is enabled and no encryption parameters are configured, encrypted snapshots are copied to the destination region and snapshot copies are encrypted by using the service key of the destination region. For more information about the limits on cross-region snapshot replication, see [Copy a snapshot](https://help.aliyun.com/document_detail/159441.html).
        After the automatic snapshot policy is created, call the [ApplyAutoSnapshotPolicy](https://help.aliyun.com/document_detail/25531.html) operation to apply the policy to disks. If you want to modify the automatic snapshot policy, call the [ModifyAutoSnapshotPolicyEx](https://help.aliyun.com/document_detail/25529.html) operation.
        
        @param request: CreateAutoSnapshotPolicyRequest
        @return: CreateAutoSnapshotPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_auto_snapshot_policy_with_options_async(request, runtime)

    def create_capacity_reservation_with_options(
        self,
        request: ecs_20140526_models.CreateCapacityReservationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateCapacityReservationResponse:
        """
        @summary Creates a capacity reservation.
        
        @description When you create a capacity reservation, you can specify attributes such as a zone and an instance type. The system uses a private pool to reserve resources that match the specified attributes. For more information, see [Overview of Immediate Capacity Reservation](https://help.aliyun.com/document_detail/193633.html).
        Currently, only immediate capacity reservations are supported. Immediate capacity reservations take effect immediately after you purchase them. After you purchase an immediate capacity reservation, you are charged for the specified instance type based on the pay-as-you-go billing method regardless of whether you use the capacity reservation to create pay-as-you-go instances. Billing stops when you manually release the capacity reservation or when the capacity reservation expires and is automatically released.
        You can call the [CreateInstance](https://help.aliyun.com/document_detail/25499.html) or [RunInstances](https://help.aliyun.com/document_detail/63440.html) operation to specify private pool attributes when you create instances. To modify the attributes of a private pool, you can call the [ModifyInstanceAttachmentAttributes](https://help.aliyun.com/document_detail/190006.html) operation. If an instance matches a private pool associated with a capacity reservation, you are charged based on the configurations of the instance such as the instance type, disks, and public bandwidth.
        Before you use a private pool associated with a capacity reservation to create pay-as-you-go instances, you are charged only for the specified instance type.
        You can apply savings plans or regional reserved instances to offset hourly billing of unused immediate capacity reservations, and hourly fees of the instances that match the immediate capacity reservations. However, you cannot use zonal reserved instances to offset the hourly fees. We recommend that you purchase reserved instances or savings plans before you purchase immediate capacity reservations. This way, you can access resources free of charge within the coverage of the reserved instances or savings plans.
        > You can call the CreateCapacityReservation operation to create only immediate capacity reservations. You can create immediate or scheduled capacity reservations in the Elastic Compute Service (ECS) console. For more information, see [Overview](~~193626#section-oil-qh5-xvx~~).
        
        @param request: CreateCapacityReservationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateCapacityReservationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.end_time_type):
            query['EndTimeType'] = request.end_time_type
        if not UtilClient.is_unset(request.instance_amount):
            query['InstanceAmount'] = request.instance_amount
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateCapacityReservation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateCapacityReservationResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_capacity_reservation_with_options_async(
        self,
        request: ecs_20140526_models.CreateCapacityReservationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateCapacityReservationResponse:
        """
        @summary Creates a capacity reservation.
        
        @description When you create a capacity reservation, you can specify attributes such as a zone and an instance type. The system uses a private pool to reserve resources that match the specified attributes. For more information, see [Overview of Immediate Capacity Reservation](https://help.aliyun.com/document_detail/193633.html).
        Currently, only immediate capacity reservations are supported. Immediate capacity reservations take effect immediately after you purchase them. After you purchase an immediate capacity reservation, you are charged for the specified instance type based on the pay-as-you-go billing method regardless of whether you use the capacity reservation to create pay-as-you-go instances. Billing stops when you manually release the capacity reservation or when the capacity reservation expires and is automatically released.
        You can call the [CreateInstance](https://help.aliyun.com/document_detail/25499.html) or [RunInstances](https://help.aliyun.com/document_detail/63440.html) operation to specify private pool attributes when you create instances. To modify the attributes of a private pool, you can call the [ModifyInstanceAttachmentAttributes](https://help.aliyun.com/document_detail/190006.html) operation. If an instance matches a private pool associated with a capacity reservation, you are charged based on the configurations of the instance such as the instance type, disks, and public bandwidth.
        Before you use a private pool associated with a capacity reservation to create pay-as-you-go instances, you are charged only for the specified instance type.
        You can apply savings plans or regional reserved instances to offset hourly billing of unused immediate capacity reservations, and hourly fees of the instances that match the immediate capacity reservations. However, you cannot use zonal reserved instances to offset the hourly fees. We recommend that you purchase reserved instances or savings plans before you purchase immediate capacity reservations. This way, you can access resources free of charge within the coverage of the reserved instances or savings plans.
        > You can call the CreateCapacityReservation operation to create only immediate capacity reservations. You can create immediate or scheduled capacity reservations in the Elastic Compute Service (ECS) console. For more information, see [Overview](~~193626#section-oil-qh5-xvx~~).
        
        @param request: CreateCapacityReservationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateCapacityReservationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.end_time_type):
            query['EndTimeType'] = request.end_time_type
        if not UtilClient.is_unset(request.instance_amount):
            query['InstanceAmount'] = request.instance_amount
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateCapacityReservation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateCapacityReservationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_capacity_reservation(
        self,
        request: ecs_20140526_models.CreateCapacityReservationRequest,
    ) -> ecs_20140526_models.CreateCapacityReservationResponse:
        """
        @summary Creates a capacity reservation.
        
        @description When you create a capacity reservation, you can specify attributes such as a zone and an instance type. The system uses a private pool to reserve resources that match the specified attributes. For more information, see [Overview of Immediate Capacity Reservation](https://help.aliyun.com/document_detail/193633.html).
        Currently, only immediate capacity reservations are supported. Immediate capacity reservations take effect immediately after you purchase them. After you purchase an immediate capacity reservation, you are charged for the specified instance type based on the pay-as-you-go billing method regardless of whether you use the capacity reservation to create pay-as-you-go instances. Billing stops when you manually release the capacity reservation or when the capacity reservation expires and is automatically released.
        You can call the [CreateInstance](https://help.aliyun.com/document_detail/25499.html) or [RunInstances](https://help.aliyun.com/document_detail/63440.html) operation to specify private pool attributes when you create instances. To modify the attributes of a private pool, you can call the [ModifyInstanceAttachmentAttributes](https://help.aliyun.com/document_detail/190006.html) operation. If an instance matches a private pool associated with a capacity reservation, you are charged based on the configurations of the instance such as the instance type, disks, and public bandwidth.
        Before you use a private pool associated with a capacity reservation to create pay-as-you-go instances, you are charged only for the specified instance type.
        You can apply savings plans or regional reserved instances to offset hourly billing of unused immediate capacity reservations, and hourly fees of the instances that match the immediate capacity reservations. However, you cannot use zonal reserved instances to offset the hourly fees. We recommend that you purchase reserved instances or savings plans before you purchase immediate capacity reservations. This way, you can access resources free of charge within the coverage of the reserved instances or savings plans.
        > You can call the CreateCapacityReservation operation to create only immediate capacity reservations. You can create immediate or scheduled capacity reservations in the Elastic Compute Service (ECS) console. For more information, see [Overview](~~193626#section-oil-qh5-xvx~~).
        
        @param request: CreateCapacityReservationRequest
        @return: CreateCapacityReservationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_capacity_reservation_with_options(request, runtime)

    async def create_capacity_reservation_async(
        self,
        request: ecs_20140526_models.CreateCapacityReservationRequest,
    ) -> ecs_20140526_models.CreateCapacityReservationResponse:
        """
        @summary Creates a capacity reservation.
        
        @description When you create a capacity reservation, you can specify attributes such as a zone and an instance type. The system uses a private pool to reserve resources that match the specified attributes. For more information, see [Overview of Immediate Capacity Reservation](https://help.aliyun.com/document_detail/193633.html).
        Currently, only immediate capacity reservations are supported. Immediate capacity reservations take effect immediately after you purchase them. After you purchase an immediate capacity reservation, you are charged for the specified instance type based on the pay-as-you-go billing method regardless of whether you use the capacity reservation to create pay-as-you-go instances. Billing stops when you manually release the capacity reservation or when the capacity reservation expires and is automatically released.
        You can call the [CreateInstance](https://help.aliyun.com/document_detail/25499.html) or [RunInstances](https://help.aliyun.com/document_detail/63440.html) operation to specify private pool attributes when you create instances. To modify the attributes of a private pool, you can call the [ModifyInstanceAttachmentAttributes](https://help.aliyun.com/document_detail/190006.html) operation. If an instance matches a private pool associated with a capacity reservation, you are charged based on the configurations of the instance such as the instance type, disks, and public bandwidth.
        Before you use a private pool associated with a capacity reservation to create pay-as-you-go instances, you are charged only for the specified instance type.
        You can apply savings plans or regional reserved instances to offset hourly billing of unused immediate capacity reservations, and hourly fees of the instances that match the immediate capacity reservations. However, you cannot use zonal reserved instances to offset the hourly fees. We recommend that you purchase reserved instances or savings plans before you purchase immediate capacity reservations. This way, you can access resources free of charge within the coverage of the reserved instances or savings plans.
        > You can call the CreateCapacityReservation operation to create only immediate capacity reservations. You can create immediate or scheduled capacity reservations in the Elastic Compute Service (ECS) console. For more information, see [Overview](~~193626#section-oil-qh5-xvx~~).
        
        @param request: CreateCapacityReservationRequest
        @return: CreateCapacityReservationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_capacity_reservation_with_options_async(request, runtime)

    def create_command_with_options(
        self,
        request: ecs_20140526_models.CreateCommandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateCommandResponse:
        """
        @summary Creates a Cloud Assistant command, which can be a Shell, PowerShell, or batch command.
        
        @description ## [](#)Usage notes
        You can create commands of the following types:
        Batch commands (RunBatScript), applicable to Windows instances
        PowerShell commands (RunPowerShellScript), applicable to Windows instances
        Shell commands (RunShellScript), applicable to Linux instances
        You can specify the Timeout parameter to set the maximum timeout period for executions of a command on Elastic Compute Service (ECS) instances. If an execution times out, [Cloud Assistant Agent](https://help.aliyun.com/document_detail/64921.html) forcefully terminates the command process by canceling the process ID (PID) of the command.
        For a one-time task, when the execution times out, the state of the command ([InvokeRecordStatus](https://help.aliyun.com/document_detail/64845.html)) becomes Failed.
        For a scheduled task, take note of the following items:
        The timeout period takes effect on each execution.
        When an execution times out, the state ([InvokeRecordStatus](https://help.aliyun.com/document_detail/64845.html)) of the command becomes Failed.
        The timeout of one execution does not affect the subsequent executions.
        You can retain up to 500 to 50,000 Cloud Assistant commands in each region. You can also apply for a quota increase. For information about how to query and increase quotas, see [Manage quotas](https://help.aliyun.com/document_detail/184116.html).
        You can use WorkingDir to specify the execution directory of a Cloud Assistant command. For Linux instances, the default execution directory of Cloud Assistant commands is the home directory of the root user, which is `/root`. For Windows instances, the default execution directory of Cloud Assistant commands is the directory where the Cloud Assistant Agent process resides, such as `C:\\Windows\\System32`.
        You can enable the custom parameter feature for a Cloud Assistant command by setting EnableParameter to true. When you set CommandContent, you can define custom parameters in the {{parameter}} format. Then, when the [InvokeCommand](https://help.aliyun.com/document_detail/64841.html) operation is called, the key-value pairs of custom parameters are passed in. For example, if a command is `echo {{name}}`, the Parameters parameter can be used to pass in the `<name, Jack>` key-value pair when the InvokeCommand operation is called. The name key of the custom parameter is automatically replaced by the paired Jack value to generate a new command. As a result, the `echo Jack` command is run.
        
        @param request: CreateCommandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateCommandResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.command_content):
            query['CommandContent'] = request.command_content
        if not UtilClient.is_unset(request.content_encoding):
            query['ContentEncoding'] = request.content_encoding
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enable_parameter):
            query['EnableParameter'] = request.enable_parameter
        if not UtilClient.is_unset(request.launcher):
            query['Launcher'] = request.launcher
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.timeout):
            query['Timeout'] = request.timeout
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.working_dir):
            query['WorkingDir'] = request.working_dir
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateCommand',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateCommandResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_command_with_options_async(
        self,
        request: ecs_20140526_models.CreateCommandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateCommandResponse:
        """
        @summary Creates a Cloud Assistant command, which can be a Shell, PowerShell, or batch command.
        
        @description ## [](#)Usage notes
        You can create commands of the following types:
        Batch commands (RunBatScript), applicable to Windows instances
        PowerShell commands (RunPowerShellScript), applicable to Windows instances
        Shell commands (RunShellScript), applicable to Linux instances
        You can specify the Timeout parameter to set the maximum timeout period for executions of a command on Elastic Compute Service (ECS) instances. If an execution times out, [Cloud Assistant Agent](https://help.aliyun.com/document_detail/64921.html) forcefully terminates the command process by canceling the process ID (PID) of the command.
        For a one-time task, when the execution times out, the state of the command ([InvokeRecordStatus](https://help.aliyun.com/document_detail/64845.html)) becomes Failed.
        For a scheduled task, take note of the following items:
        The timeout period takes effect on each execution.
        When an execution times out, the state ([InvokeRecordStatus](https://help.aliyun.com/document_detail/64845.html)) of the command becomes Failed.
        The timeout of one execution does not affect the subsequent executions.
        You can retain up to 500 to 50,000 Cloud Assistant commands in each region. You can also apply for a quota increase. For information about how to query and increase quotas, see [Manage quotas](https://help.aliyun.com/document_detail/184116.html).
        You can use WorkingDir to specify the execution directory of a Cloud Assistant command. For Linux instances, the default execution directory of Cloud Assistant commands is the home directory of the root user, which is `/root`. For Windows instances, the default execution directory of Cloud Assistant commands is the directory where the Cloud Assistant Agent process resides, such as `C:\\Windows\\System32`.
        You can enable the custom parameter feature for a Cloud Assistant command by setting EnableParameter to true. When you set CommandContent, you can define custom parameters in the {{parameter}} format. Then, when the [InvokeCommand](https://help.aliyun.com/document_detail/64841.html) operation is called, the key-value pairs of custom parameters are passed in. For example, if a command is `echo {{name}}`, the Parameters parameter can be used to pass in the `<name, Jack>` key-value pair when the InvokeCommand operation is called. The name key of the custom parameter is automatically replaced by the paired Jack value to generate a new command. As a result, the `echo Jack` command is run.
        
        @param request: CreateCommandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateCommandResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.command_content):
            query['CommandContent'] = request.command_content
        if not UtilClient.is_unset(request.content_encoding):
            query['ContentEncoding'] = request.content_encoding
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enable_parameter):
            query['EnableParameter'] = request.enable_parameter
        if not UtilClient.is_unset(request.launcher):
            query['Launcher'] = request.launcher
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.timeout):
            query['Timeout'] = request.timeout
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.working_dir):
            query['WorkingDir'] = request.working_dir
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateCommand',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateCommandResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_command(
        self,
        request: ecs_20140526_models.CreateCommandRequest,
    ) -> ecs_20140526_models.CreateCommandResponse:
        """
        @summary Creates a Cloud Assistant command, which can be a Shell, PowerShell, or batch command.
        
        @description ## [](#)Usage notes
        You can create commands of the following types:
        Batch commands (RunBatScript), applicable to Windows instances
        PowerShell commands (RunPowerShellScript), applicable to Windows instances
        Shell commands (RunShellScript), applicable to Linux instances
        You can specify the Timeout parameter to set the maximum timeout period for executions of a command on Elastic Compute Service (ECS) instances. If an execution times out, [Cloud Assistant Agent](https://help.aliyun.com/document_detail/64921.html) forcefully terminates the command process by canceling the process ID (PID) of the command.
        For a one-time task, when the execution times out, the state of the command ([InvokeRecordStatus](https://help.aliyun.com/document_detail/64845.html)) becomes Failed.
        For a scheduled task, take note of the following items:
        The timeout period takes effect on each execution.
        When an execution times out, the state ([InvokeRecordStatus](https://help.aliyun.com/document_detail/64845.html)) of the command becomes Failed.
        The timeout of one execution does not affect the subsequent executions.
        You can retain up to 500 to 50,000 Cloud Assistant commands in each region. You can also apply for a quota increase. For information about how to query and increase quotas, see [Manage quotas](https://help.aliyun.com/document_detail/184116.html).
        You can use WorkingDir to specify the execution directory of a Cloud Assistant command. For Linux instances, the default execution directory of Cloud Assistant commands is the home directory of the root user, which is `/root`. For Windows instances, the default execution directory of Cloud Assistant commands is the directory where the Cloud Assistant Agent process resides, such as `C:\\Windows\\System32`.
        You can enable the custom parameter feature for a Cloud Assistant command by setting EnableParameter to true. When you set CommandContent, you can define custom parameters in the {{parameter}} format. Then, when the [InvokeCommand](https://help.aliyun.com/document_detail/64841.html) operation is called, the key-value pairs of custom parameters are passed in. For example, if a command is `echo {{name}}`, the Parameters parameter can be used to pass in the `<name, Jack>` key-value pair when the InvokeCommand operation is called. The name key of the custom parameter is automatically replaced by the paired Jack value to generate a new command. As a result, the `echo Jack` command is run.
        
        @param request: CreateCommandRequest
        @return: CreateCommandResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_command_with_options(request, runtime)

    async def create_command_async(
        self,
        request: ecs_20140526_models.CreateCommandRequest,
    ) -> ecs_20140526_models.CreateCommandResponse:
        """
        @summary Creates a Cloud Assistant command, which can be a Shell, PowerShell, or batch command.
        
        @description ## [](#)Usage notes
        You can create commands of the following types:
        Batch commands (RunBatScript), applicable to Windows instances
        PowerShell commands (RunPowerShellScript), applicable to Windows instances
        Shell commands (RunShellScript), applicable to Linux instances
        You can specify the Timeout parameter to set the maximum timeout period for executions of a command on Elastic Compute Service (ECS) instances. If an execution times out, [Cloud Assistant Agent](https://help.aliyun.com/document_detail/64921.html) forcefully terminates the command process by canceling the process ID (PID) of the command.
        For a one-time task, when the execution times out, the state of the command ([InvokeRecordStatus](https://help.aliyun.com/document_detail/64845.html)) becomes Failed.
        For a scheduled task, take note of the following items:
        The timeout period takes effect on each execution.
        When an execution times out, the state ([InvokeRecordStatus](https://help.aliyun.com/document_detail/64845.html)) of the command becomes Failed.
        The timeout of one execution does not affect the subsequent executions.
        You can retain up to 500 to 50,000 Cloud Assistant commands in each region. You can also apply for a quota increase. For information about how to query and increase quotas, see [Manage quotas](https://help.aliyun.com/document_detail/184116.html).
        You can use WorkingDir to specify the execution directory of a Cloud Assistant command. For Linux instances, the default execution directory of Cloud Assistant commands is the home directory of the root user, which is `/root`. For Windows instances, the default execution directory of Cloud Assistant commands is the directory where the Cloud Assistant Agent process resides, such as `C:\\Windows\\System32`.
        You can enable the custom parameter feature for a Cloud Assistant command by setting EnableParameter to true. When you set CommandContent, you can define custom parameters in the {{parameter}} format. Then, when the [InvokeCommand](https://help.aliyun.com/document_detail/64841.html) operation is called, the key-value pairs of custom parameters are passed in. For example, if a command is `echo {{name}}`, the Parameters parameter can be used to pass in the `<name, Jack>` key-value pair when the InvokeCommand operation is called. The name key of the custom parameter is automatically replaced by the paired Jack value to generate a new command. As a result, the `echo Jack` command is run.
        
        @param request: CreateCommandRequest
        @return: CreateCommandResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_command_with_options_async(request, runtime)

    def create_dedicated_host_cluster_with_options(
        self,
        request: ecs_20140526_models.CreateDedicatedHostClusterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateDedicatedHostClusterResponse:
        """
        @summary Creates a dedicated host group.
        
        @param request: CreateDedicatedHostClusterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDedicatedHostClusterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dedicated_host_cluster_name):
            query['DedicatedHostClusterName'] = request.dedicated_host_cluster_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDedicatedHostCluster',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateDedicatedHostClusterResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_dedicated_host_cluster_with_options_async(
        self,
        request: ecs_20140526_models.CreateDedicatedHostClusterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateDedicatedHostClusterResponse:
        """
        @summary Creates a dedicated host group.
        
        @param request: CreateDedicatedHostClusterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDedicatedHostClusterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dedicated_host_cluster_name):
            query['DedicatedHostClusterName'] = request.dedicated_host_cluster_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDedicatedHostCluster',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateDedicatedHostClusterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_dedicated_host_cluster(
        self,
        request: ecs_20140526_models.CreateDedicatedHostClusterRequest,
    ) -> ecs_20140526_models.CreateDedicatedHostClusterResponse:
        """
        @summary Creates a dedicated host group.
        
        @param request: CreateDedicatedHostClusterRequest
        @return: CreateDedicatedHostClusterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_dedicated_host_cluster_with_options(request, runtime)

    async def create_dedicated_host_cluster_async(
        self,
        request: ecs_20140526_models.CreateDedicatedHostClusterRequest,
    ) -> ecs_20140526_models.CreateDedicatedHostClusterResponse:
        """
        @summary Creates a dedicated host group.
        
        @param request: CreateDedicatedHostClusterRequest
        @return: CreateDedicatedHostClusterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_dedicated_host_cluster_with_options_async(request, runtime)

    def create_deployment_set_with_options(
        self,
        request: ecs_20140526_models.CreateDeploymentSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateDeploymentSetResponse:
        """
        @summary Creates a deployment set in a region.
        
        @param request: CreateDeploymentSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDeploymentSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.deployment_set_name):
            query['DeploymentSetName'] = request.deployment_set_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.granularity):
            query['Granularity'] = request.granularity
        if not UtilClient.is_unset(request.group_count):
            query['GroupCount'] = request.group_count
        if not UtilClient.is_unset(request.on_unable_to_redeploy_failed_instance):
            query['OnUnableToRedeployFailedInstance'] = request.on_unable_to_redeploy_failed_instance
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.strategy):
            query['Strategy'] = request.strategy
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDeploymentSet',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateDeploymentSetResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_deployment_set_with_options_async(
        self,
        request: ecs_20140526_models.CreateDeploymentSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateDeploymentSetResponse:
        """
        @summary Creates a deployment set in a region.
        
        @param request: CreateDeploymentSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDeploymentSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.deployment_set_name):
            query['DeploymentSetName'] = request.deployment_set_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.granularity):
            query['Granularity'] = request.granularity
        if not UtilClient.is_unset(request.group_count):
            query['GroupCount'] = request.group_count
        if not UtilClient.is_unset(request.on_unable_to_redeploy_failed_instance):
            query['OnUnableToRedeployFailedInstance'] = request.on_unable_to_redeploy_failed_instance
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.strategy):
            query['Strategy'] = request.strategy
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDeploymentSet',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateDeploymentSetResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_deployment_set(
        self,
        request: ecs_20140526_models.CreateDeploymentSetRequest,
    ) -> ecs_20140526_models.CreateDeploymentSetResponse:
        """
        @summary Creates a deployment set in a region.
        
        @param request: CreateDeploymentSetRequest
        @return: CreateDeploymentSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_deployment_set_with_options(request, runtime)

    async def create_deployment_set_async(
        self,
        request: ecs_20140526_models.CreateDeploymentSetRequest,
    ) -> ecs_20140526_models.CreateDeploymentSetResponse:
        """
        @summary Creates a deployment set in a region.
        
        @param request: CreateDeploymentSetRequest
        @return: CreateDeploymentSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_deployment_set_with_options_async(request, runtime)

    def create_diagnostic_metric_set_with_options(
        self,
        request: ecs_20140526_models.CreateDiagnosticMetricSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateDiagnosticMetricSetResponse:
        """
        @summary Creates a diagnostic metric set. You can group diagnostic metrics into diagnostic metric sets.
        
        @param request: CreateDiagnosticMetricSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDiagnosticMetricSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.metric_ids):
            query['MetricIds'] = request.metric_ids
        if not UtilClient.is_unset(request.metric_set_name):
            query['MetricSetName'] = request.metric_set_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDiagnosticMetricSet',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateDiagnosticMetricSetResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_diagnostic_metric_set_with_options_async(
        self,
        request: ecs_20140526_models.CreateDiagnosticMetricSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateDiagnosticMetricSetResponse:
        """
        @summary Creates a diagnostic metric set. You can group diagnostic metrics into diagnostic metric sets.
        
        @param request: CreateDiagnosticMetricSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDiagnosticMetricSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.metric_ids):
            query['MetricIds'] = request.metric_ids
        if not UtilClient.is_unset(request.metric_set_name):
            query['MetricSetName'] = request.metric_set_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDiagnosticMetricSet',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateDiagnosticMetricSetResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_diagnostic_metric_set(
        self,
        request: ecs_20140526_models.CreateDiagnosticMetricSetRequest,
    ) -> ecs_20140526_models.CreateDiagnosticMetricSetResponse:
        """
        @summary Creates a diagnostic metric set. You can group diagnostic metrics into diagnostic metric sets.
        
        @param request: CreateDiagnosticMetricSetRequest
        @return: CreateDiagnosticMetricSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_diagnostic_metric_set_with_options(request, runtime)

    async def create_diagnostic_metric_set_async(
        self,
        request: ecs_20140526_models.CreateDiagnosticMetricSetRequest,
    ) -> ecs_20140526_models.CreateDiagnosticMetricSetResponse:
        """
        @summary Creates a diagnostic metric set. You can group diagnostic metrics into diagnostic metric sets.
        
        @param request: CreateDiagnosticMetricSetRequest
        @return: CreateDiagnosticMetricSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_diagnostic_metric_set_with_options_async(request, runtime)

    def create_diagnostic_report_with_options(
        self,
        request: ecs_20140526_models.CreateDiagnosticReportRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateDiagnosticReportResponse:
        """
        @summary Creates a diagnostic report for a resource. When you call this operation, you can configure the MetricSetId parameter to create a diagnostic report based on the specified diagnostic metric set. Then, you can call the DescribeDiagnosticReportAttributes operation based on the returned diagnostic report ID to view the details of the diagnostic report.
        
        @param request: CreateDiagnosticReportRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDiagnosticReportResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.metric_set_id):
            query['MetricSetId'] = request.metric_set_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDiagnosticReport',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateDiagnosticReportResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_diagnostic_report_with_options_async(
        self,
        request: ecs_20140526_models.CreateDiagnosticReportRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateDiagnosticReportResponse:
        """
        @summary Creates a diagnostic report for a resource. When you call this operation, you can configure the MetricSetId parameter to create a diagnostic report based on the specified diagnostic metric set. Then, you can call the DescribeDiagnosticReportAttributes operation based on the returned diagnostic report ID to view the details of the diagnostic report.
        
        @param request: CreateDiagnosticReportRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDiagnosticReportResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.metric_set_id):
            query['MetricSetId'] = request.metric_set_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDiagnosticReport',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateDiagnosticReportResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_diagnostic_report(
        self,
        request: ecs_20140526_models.CreateDiagnosticReportRequest,
    ) -> ecs_20140526_models.CreateDiagnosticReportResponse:
        """
        @summary Creates a diagnostic report for a resource. When you call this operation, you can configure the MetricSetId parameter to create a diagnostic report based on the specified diagnostic metric set. Then, you can call the DescribeDiagnosticReportAttributes operation based on the returned diagnostic report ID to view the details of the diagnostic report.
        
        @param request: CreateDiagnosticReportRequest
        @return: CreateDiagnosticReportResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_diagnostic_report_with_options(request, runtime)

    async def create_diagnostic_report_async(
        self,
        request: ecs_20140526_models.CreateDiagnosticReportRequest,
    ) -> ecs_20140526_models.CreateDiagnosticReportResponse:
        """
        @summary Creates a diagnostic report for a resource. When you call this operation, you can configure the MetricSetId parameter to create a diagnostic report based on the specified diagnostic metric set. Then, you can call the DescribeDiagnosticReportAttributes operation based on the returned diagnostic report ID to view the details of the diagnostic report.
        
        @param request: CreateDiagnosticReportRequest
        @return: CreateDiagnosticReportResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_diagnostic_report_with_options_async(request, runtime)

    def create_disk_with_options(
        self,
        request: ecs_20140526_models.CreateDiskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateDiskResponse:
        """
        @summary Creates a pay-as-you-go or subscription data disk.
        
        @description    You can enable the multi-attach (`MultiAttach`) feature when you create a disk. Before you enable the multi-attach feature, we recommend that you familiarize yourself with the feature and the limits on the feature. For more information, see [NVMe protocol](https://help.aliyun.com/document_detail/256487.html) and [Use the multi-attach feature to attach a cloud disk to multiple ECS instances](https://help.aliyun.com/document_detail/262105.html).
        You can create disks of the following disk categories: basic disks, ultra disks, standard SSDs, Enterprise SSDs (ESSDs), ESSD Entry disks, Regional ESSDs, ESSD AutoPL disks, standard elastic ephemeral disks, and premium elastic ephemeral disks.
        Before you can create a disk, you must complete real-name verification. Complete real-name verification on the [Real-name Verification](https://account.console.aliyun.com/#/auth/home) page in the Alibaba Cloud Management Console.
        When you create disks, you may be charged for the resources used. We recommend that you familiarize yourself with the billing methods of Elastic Compute Service (ECS) resources before you create a disk. For more information, see [Billing overview](https://help.aliyun.com/document_detail/25398.html).
        When you call this operation to create a disk, specific parameters are automatically specified.
        `DeleteAutoSnapshot` is automatically set to `true` when a disk is created. This indicates that the automatic snapshots of the disk are deleted when the disk is released. You can call the [DescribeDisks](https://help.aliyun.com/document_detail/2679767.html) operation to query the DeleteAutoSnapshot value for the disk and call the [ModifyDiskAttribute](https://help.aliyun.com/document_detail/25517.html) operation to change the DeleteAutoSnapshot value for the disk.
        If you do not specify a performance level when you create an ESSD, the performance level of the ESSD is automatically set to PL1. To change the performance level of the ESSD, you can call the [ModifyDiskSpec](https://help.aliyun.com/document_detail/123780.html) operation.
        `Portable` is automatically set to `true` when a disk is created, which indicates that the disk is a pay-as-you-go disk.
        
        @param request: CreateDiskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDiskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.advanced_features):
            query['AdvancedFeatures'] = request.advanced_features
        if not UtilClient.is_unset(request.arn):
            query['Arn'] = request.arn
        if not UtilClient.is_unset(request.bursting_enabled):
            query['BurstingEnabled'] = request.bursting_enabled
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.disk_category):
            query['DiskCategory'] = request.disk_category
        if not UtilClient.is_unset(request.disk_name):
            query['DiskName'] = request.disk_name
        if not UtilClient.is_unset(request.encrypt_algorithm):
            query['EncryptAlgorithm'] = request.encrypt_algorithm
        if not UtilClient.is_unset(request.encrypted):
            query['Encrypted'] = request.encrypted
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.kmskey_id):
            query['KMSKeyId'] = request.kmskey_id
        if not UtilClient.is_unset(request.multi_attach):
            query['MultiAttach'] = request.multi_attach
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.performance_level):
            query['PerformanceLevel'] = request.performance_level
        if not UtilClient.is_unset(request.provisioned_iops):
            query['ProvisionedIops'] = request.provisioned_iops
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.size):
            query['Size'] = request.size
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        if not UtilClient.is_unset(request.storage_cluster_id):
            query['StorageClusterId'] = request.storage_cluster_id
        if not UtilClient.is_unset(request.storage_set_id):
            query['StorageSetId'] = request.storage_set_id
        if not UtilClient.is_unset(request.storage_set_partition_number):
            query['StorageSetPartitionNumber'] = request.storage_set_partition_number
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDisk',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateDiskResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_disk_with_options_async(
        self,
        request: ecs_20140526_models.CreateDiskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateDiskResponse:
        """
        @summary Creates a pay-as-you-go or subscription data disk.
        
        @description    You can enable the multi-attach (`MultiAttach`) feature when you create a disk. Before you enable the multi-attach feature, we recommend that you familiarize yourself with the feature and the limits on the feature. For more information, see [NVMe protocol](https://help.aliyun.com/document_detail/256487.html) and [Use the multi-attach feature to attach a cloud disk to multiple ECS instances](https://help.aliyun.com/document_detail/262105.html).
        You can create disks of the following disk categories: basic disks, ultra disks, standard SSDs, Enterprise SSDs (ESSDs), ESSD Entry disks, Regional ESSDs, ESSD AutoPL disks, standard elastic ephemeral disks, and premium elastic ephemeral disks.
        Before you can create a disk, you must complete real-name verification. Complete real-name verification on the [Real-name Verification](https://account.console.aliyun.com/#/auth/home) page in the Alibaba Cloud Management Console.
        When you create disks, you may be charged for the resources used. We recommend that you familiarize yourself with the billing methods of Elastic Compute Service (ECS) resources before you create a disk. For more information, see [Billing overview](https://help.aliyun.com/document_detail/25398.html).
        When you call this operation to create a disk, specific parameters are automatically specified.
        `DeleteAutoSnapshot` is automatically set to `true` when a disk is created. This indicates that the automatic snapshots of the disk are deleted when the disk is released. You can call the [DescribeDisks](https://help.aliyun.com/document_detail/2679767.html) operation to query the DeleteAutoSnapshot value for the disk and call the [ModifyDiskAttribute](https://help.aliyun.com/document_detail/25517.html) operation to change the DeleteAutoSnapshot value for the disk.
        If you do not specify a performance level when you create an ESSD, the performance level of the ESSD is automatically set to PL1. To change the performance level of the ESSD, you can call the [ModifyDiskSpec](https://help.aliyun.com/document_detail/123780.html) operation.
        `Portable` is automatically set to `true` when a disk is created, which indicates that the disk is a pay-as-you-go disk.
        
        @param request: CreateDiskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDiskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.advanced_features):
            query['AdvancedFeatures'] = request.advanced_features
        if not UtilClient.is_unset(request.arn):
            query['Arn'] = request.arn
        if not UtilClient.is_unset(request.bursting_enabled):
            query['BurstingEnabled'] = request.bursting_enabled
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.disk_category):
            query['DiskCategory'] = request.disk_category
        if not UtilClient.is_unset(request.disk_name):
            query['DiskName'] = request.disk_name
        if not UtilClient.is_unset(request.encrypt_algorithm):
            query['EncryptAlgorithm'] = request.encrypt_algorithm
        if not UtilClient.is_unset(request.encrypted):
            query['Encrypted'] = request.encrypted
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.kmskey_id):
            query['KMSKeyId'] = request.kmskey_id
        if not UtilClient.is_unset(request.multi_attach):
            query['MultiAttach'] = request.multi_attach
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.performance_level):
            query['PerformanceLevel'] = request.performance_level
        if not UtilClient.is_unset(request.provisioned_iops):
            query['ProvisionedIops'] = request.provisioned_iops
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.size):
            query['Size'] = request.size
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        if not UtilClient.is_unset(request.storage_cluster_id):
            query['StorageClusterId'] = request.storage_cluster_id
        if not UtilClient.is_unset(request.storage_set_id):
            query['StorageSetId'] = request.storage_set_id
        if not UtilClient.is_unset(request.storage_set_partition_number):
            query['StorageSetPartitionNumber'] = request.storage_set_partition_number
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDisk',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateDiskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_disk(
        self,
        request: ecs_20140526_models.CreateDiskRequest,
    ) -> ecs_20140526_models.CreateDiskResponse:
        """
        @summary Creates a pay-as-you-go or subscription data disk.
        
        @description    You can enable the multi-attach (`MultiAttach`) feature when you create a disk. Before you enable the multi-attach feature, we recommend that you familiarize yourself with the feature and the limits on the feature. For more information, see [NVMe protocol](https://help.aliyun.com/document_detail/256487.html) and [Use the multi-attach feature to attach a cloud disk to multiple ECS instances](https://help.aliyun.com/document_detail/262105.html).
        You can create disks of the following disk categories: basic disks, ultra disks, standard SSDs, Enterprise SSDs (ESSDs), ESSD Entry disks, Regional ESSDs, ESSD AutoPL disks, standard elastic ephemeral disks, and premium elastic ephemeral disks.
        Before you can create a disk, you must complete real-name verification. Complete real-name verification on the [Real-name Verification](https://account.console.aliyun.com/#/auth/home) page in the Alibaba Cloud Management Console.
        When you create disks, you may be charged for the resources used. We recommend that you familiarize yourself with the billing methods of Elastic Compute Service (ECS) resources before you create a disk. For more information, see [Billing overview](https://help.aliyun.com/document_detail/25398.html).
        When you call this operation to create a disk, specific parameters are automatically specified.
        `DeleteAutoSnapshot` is automatically set to `true` when a disk is created. This indicates that the automatic snapshots of the disk are deleted when the disk is released. You can call the [DescribeDisks](https://help.aliyun.com/document_detail/2679767.html) operation to query the DeleteAutoSnapshot value for the disk and call the [ModifyDiskAttribute](https://help.aliyun.com/document_detail/25517.html) operation to change the DeleteAutoSnapshot value for the disk.
        If you do not specify a performance level when you create an ESSD, the performance level of the ESSD is automatically set to PL1. To change the performance level of the ESSD, you can call the [ModifyDiskSpec](https://help.aliyun.com/document_detail/123780.html) operation.
        `Portable` is automatically set to `true` when a disk is created, which indicates that the disk is a pay-as-you-go disk.
        
        @param request: CreateDiskRequest
        @return: CreateDiskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_disk_with_options(request, runtime)

    async def create_disk_async(
        self,
        request: ecs_20140526_models.CreateDiskRequest,
    ) -> ecs_20140526_models.CreateDiskResponse:
        """
        @summary Creates a pay-as-you-go or subscription data disk.
        
        @description    You can enable the multi-attach (`MultiAttach`) feature when you create a disk. Before you enable the multi-attach feature, we recommend that you familiarize yourself with the feature and the limits on the feature. For more information, see [NVMe protocol](https://help.aliyun.com/document_detail/256487.html) and [Use the multi-attach feature to attach a cloud disk to multiple ECS instances](https://help.aliyun.com/document_detail/262105.html).
        You can create disks of the following disk categories: basic disks, ultra disks, standard SSDs, Enterprise SSDs (ESSDs), ESSD Entry disks, Regional ESSDs, ESSD AutoPL disks, standard elastic ephemeral disks, and premium elastic ephemeral disks.
        Before you can create a disk, you must complete real-name verification. Complete real-name verification on the [Real-name Verification](https://account.console.aliyun.com/#/auth/home) page in the Alibaba Cloud Management Console.
        When you create disks, you may be charged for the resources used. We recommend that you familiarize yourself with the billing methods of Elastic Compute Service (ECS) resources before you create a disk. For more information, see [Billing overview](https://help.aliyun.com/document_detail/25398.html).
        When you call this operation to create a disk, specific parameters are automatically specified.
        `DeleteAutoSnapshot` is automatically set to `true` when a disk is created. This indicates that the automatic snapshots of the disk are deleted when the disk is released. You can call the [DescribeDisks](https://help.aliyun.com/document_detail/2679767.html) operation to query the DeleteAutoSnapshot value for the disk and call the [ModifyDiskAttribute](https://help.aliyun.com/document_detail/25517.html) operation to change the DeleteAutoSnapshot value for the disk.
        If you do not specify a performance level when you create an ESSD, the performance level of the ESSD is automatically set to PL1. To change the performance level of the ESSD, you can call the [ModifyDiskSpec](https://help.aliyun.com/document_detail/123780.html) operation.
        `Portable` is automatically set to `true` when a disk is created, which indicates that the disk is a pay-as-you-go disk.
        
        @param request: CreateDiskRequest
        @return: CreateDiskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_disk_with_options_async(request, runtime)

    def create_elasticity_assurance_with_options(
        self,
        request: ecs_20140526_models.CreateElasticityAssuranceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateElasticityAssuranceResponse:
        """
        @summary Creates an elasticity assurance in a region. When you call this operation, you can specify parameters, such as ZoneId, InstanceType, Period, PeriodUnit, and AutoRenew, in the request.
        
        @description Elasticity Assurance provides a new method to purchase and use guaranteed resources in a flexible manner. Elasticity Assurance is a resource reservation service that provides assured access to resources for pay-as-you-go Elastic Compute Service (ECS) instances. For more information, see [Overview of Elasticity Assurance](https://help.aliyun.com/document_detail/193630.html).
        After you purchase an elasticity assurance, you cannot request a refund for the elasticity assurance. For information about the billing of elasticity assurances, see [Resource assurance](https://help.aliyun.com/document_detail/432502.html).
        Elasticity assurances can be used to create only pay-as-you-go ECS instances.
        Elasticity assurances only support the unlimited mode. You can set `AssuranceTimes` only to `Unlimited`. Elasticity assurances in unlimited mode can be used for an unlimited number of times within their terms. Elasticity assurances in unlimited mode take effect immediately after creation.
        
        @param request: CreateElasticityAssuranceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateElasticityAssuranceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.assurance_times):
            query['AssuranceTimes'] = request.assurance_times
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_period):
            query['AutoRenewPeriod'] = request.auto_renew_period
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.instance_amount):
            query['InstanceAmount'] = request.instance_amount
        if not UtilClient.is_unset(request.instance_cpu_core_count):
            query['InstanceCpuCoreCount'] = request.instance_cpu_core_count
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.recurrence_rules):
            query['RecurrenceRules'] = request.recurrence_rules
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateElasticityAssurance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateElasticityAssuranceResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_elasticity_assurance_with_options_async(
        self,
        request: ecs_20140526_models.CreateElasticityAssuranceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateElasticityAssuranceResponse:
        """
        @summary Creates an elasticity assurance in a region. When you call this operation, you can specify parameters, such as ZoneId, InstanceType, Period, PeriodUnit, and AutoRenew, in the request.
        
        @description Elasticity Assurance provides a new method to purchase and use guaranteed resources in a flexible manner. Elasticity Assurance is a resource reservation service that provides assured access to resources for pay-as-you-go Elastic Compute Service (ECS) instances. For more information, see [Overview of Elasticity Assurance](https://help.aliyun.com/document_detail/193630.html).
        After you purchase an elasticity assurance, you cannot request a refund for the elasticity assurance. For information about the billing of elasticity assurances, see [Resource assurance](https://help.aliyun.com/document_detail/432502.html).
        Elasticity assurances can be used to create only pay-as-you-go ECS instances.
        Elasticity assurances only support the unlimited mode. You can set `AssuranceTimes` only to `Unlimited`. Elasticity assurances in unlimited mode can be used for an unlimited number of times within their terms. Elasticity assurances in unlimited mode take effect immediately after creation.
        
        @param request: CreateElasticityAssuranceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateElasticityAssuranceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.assurance_times):
            query['AssuranceTimes'] = request.assurance_times
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_period):
            query['AutoRenewPeriod'] = request.auto_renew_period
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.instance_amount):
            query['InstanceAmount'] = request.instance_amount
        if not UtilClient.is_unset(request.instance_cpu_core_count):
            query['InstanceCpuCoreCount'] = request.instance_cpu_core_count
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.recurrence_rules):
            query['RecurrenceRules'] = request.recurrence_rules
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateElasticityAssurance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateElasticityAssuranceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_elasticity_assurance(
        self,
        request: ecs_20140526_models.CreateElasticityAssuranceRequest,
    ) -> ecs_20140526_models.CreateElasticityAssuranceResponse:
        """
        @summary Creates an elasticity assurance in a region. When you call this operation, you can specify parameters, such as ZoneId, InstanceType, Period, PeriodUnit, and AutoRenew, in the request.
        
        @description Elasticity Assurance provides a new method to purchase and use guaranteed resources in a flexible manner. Elasticity Assurance is a resource reservation service that provides assured access to resources for pay-as-you-go Elastic Compute Service (ECS) instances. For more information, see [Overview of Elasticity Assurance](https://help.aliyun.com/document_detail/193630.html).
        After you purchase an elasticity assurance, you cannot request a refund for the elasticity assurance. For information about the billing of elasticity assurances, see [Resource assurance](https://help.aliyun.com/document_detail/432502.html).
        Elasticity assurances can be used to create only pay-as-you-go ECS instances.
        Elasticity assurances only support the unlimited mode. You can set `AssuranceTimes` only to `Unlimited`. Elasticity assurances in unlimited mode can be used for an unlimited number of times within their terms. Elasticity assurances in unlimited mode take effect immediately after creation.
        
        @param request: CreateElasticityAssuranceRequest
        @return: CreateElasticityAssuranceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_elasticity_assurance_with_options(request, runtime)

    async def create_elasticity_assurance_async(
        self,
        request: ecs_20140526_models.CreateElasticityAssuranceRequest,
    ) -> ecs_20140526_models.CreateElasticityAssuranceResponse:
        """
        @summary Creates an elasticity assurance in a region. When you call this operation, you can specify parameters, such as ZoneId, InstanceType, Period, PeriodUnit, and AutoRenew, in the request.
        
        @description Elasticity Assurance provides a new method to purchase and use guaranteed resources in a flexible manner. Elasticity Assurance is a resource reservation service that provides assured access to resources for pay-as-you-go Elastic Compute Service (ECS) instances. For more information, see [Overview of Elasticity Assurance](https://help.aliyun.com/document_detail/193630.html).
        After you purchase an elasticity assurance, you cannot request a refund for the elasticity assurance. For information about the billing of elasticity assurances, see [Resource assurance](https://help.aliyun.com/document_detail/432502.html).
        Elasticity assurances can be used to create only pay-as-you-go ECS instances.
        Elasticity assurances only support the unlimited mode. You can set `AssuranceTimes` only to `Unlimited`. Elasticity assurances in unlimited mode can be used for an unlimited number of times within their terms. Elasticity assurances in unlimited mode take effect immediately after creation.
        
        @param request: CreateElasticityAssuranceRequest
        @return: CreateElasticityAssuranceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_elasticity_assurance_with_options_async(request, runtime)

    def create_forward_entry_with_options(
        self,
        request: ecs_20140526_models.CreateForwardEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateForwardEntryResponse:
        """
        @deprecated OpenAPI CreateForwardEntry is deprecated, please use Vpc::2016-04-28::CreateForwardEntry instead.
        
        @summary CreateForwardEntry
        
        @param request: CreateForwardEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateForwardEntryResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.external_ip):
            query['ExternalIp'] = request.external_ip
        if not UtilClient.is_unset(request.external_port):
            query['ExternalPort'] = request.external_port
        if not UtilClient.is_unset(request.forward_table_id):
            query['ForwardTableId'] = request.forward_table_id
        if not UtilClient.is_unset(request.internal_ip):
            query['InternalIp'] = request.internal_ip
        if not UtilClient.is_unset(request.internal_port):
            query['InternalPort'] = request.internal_port
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateForwardEntry',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateForwardEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_forward_entry_with_options_async(
        self,
        request: ecs_20140526_models.CreateForwardEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateForwardEntryResponse:
        """
        @deprecated OpenAPI CreateForwardEntry is deprecated, please use Vpc::2016-04-28::CreateForwardEntry instead.
        
        @summary CreateForwardEntry
        
        @param request: CreateForwardEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateForwardEntryResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.external_ip):
            query['ExternalIp'] = request.external_ip
        if not UtilClient.is_unset(request.external_port):
            query['ExternalPort'] = request.external_port
        if not UtilClient.is_unset(request.forward_table_id):
            query['ForwardTableId'] = request.forward_table_id
        if not UtilClient.is_unset(request.internal_ip):
            query['InternalIp'] = request.internal_ip
        if not UtilClient.is_unset(request.internal_port):
            query['InternalPort'] = request.internal_port
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateForwardEntry',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateForwardEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_forward_entry(
        self,
        request: ecs_20140526_models.CreateForwardEntryRequest,
    ) -> ecs_20140526_models.CreateForwardEntryResponse:
        """
        @deprecated OpenAPI CreateForwardEntry is deprecated, please use Vpc::2016-04-28::CreateForwardEntry instead.
        
        @summary CreateForwardEntry
        
        @param request: CreateForwardEntryRequest
        @return: CreateForwardEntryResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.create_forward_entry_with_options(request, runtime)

    async def create_forward_entry_async(
        self,
        request: ecs_20140526_models.CreateForwardEntryRequest,
    ) -> ecs_20140526_models.CreateForwardEntryResponse:
        """
        @deprecated OpenAPI CreateForwardEntry is deprecated, please use Vpc::2016-04-28::CreateForwardEntry instead.
        
        @summary CreateForwardEntry
        
        @param request: CreateForwardEntryRequest
        @return: CreateForwardEntryResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_forward_entry_with_options_async(request, runtime)

    def create_ha_vip_with_options(
        self,
        request: ecs_20140526_models.CreateHaVipRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateHaVipResponse:
        """
        @deprecated OpenAPI CreateHaVip is deprecated, please use Vpc::2016-04-28::CreateHaVip instead.
        
        @summary CreateHaVip
        
        @param request: CreateHaVipRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateHaVipResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ip_address):
            query['IpAddress'] = request.ip_address
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateHaVip',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateHaVipResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_ha_vip_with_options_async(
        self,
        request: ecs_20140526_models.CreateHaVipRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateHaVipResponse:
        """
        @deprecated OpenAPI CreateHaVip is deprecated, please use Vpc::2016-04-28::CreateHaVip instead.
        
        @summary CreateHaVip
        
        @param request: CreateHaVipRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateHaVipResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ip_address):
            query['IpAddress'] = request.ip_address
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateHaVip',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateHaVipResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_ha_vip(
        self,
        request: ecs_20140526_models.CreateHaVipRequest,
    ) -> ecs_20140526_models.CreateHaVipResponse:
        """
        @deprecated OpenAPI CreateHaVip is deprecated, please use Vpc::2016-04-28::CreateHaVip instead.
        
        @summary CreateHaVip
        
        @param request: CreateHaVipRequest
        @return: CreateHaVipResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.create_ha_vip_with_options(request, runtime)

    async def create_ha_vip_async(
        self,
        request: ecs_20140526_models.CreateHaVipRequest,
    ) -> ecs_20140526_models.CreateHaVipResponse:
        """
        @deprecated OpenAPI CreateHaVip is deprecated, please use Vpc::2016-04-28::CreateHaVip instead.
        
        @summary CreateHaVip
        
        @param request: CreateHaVipRequest
        @return: CreateHaVipResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_ha_vip_with_options_async(request, runtime)

    def create_hpc_cluster_with_options(
        self,
        request: ecs_20140526_models.CreateHpcClusterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateHpcClusterResponse:
        """
        @summary Creates a high performance computing (HPC) cluster.
        
        @param request: CreateHpcClusterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateHpcClusterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateHpcCluster',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateHpcClusterResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_hpc_cluster_with_options_async(
        self,
        request: ecs_20140526_models.CreateHpcClusterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateHpcClusterResponse:
        """
        @summary Creates a high performance computing (HPC) cluster.
        
        @param request: CreateHpcClusterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateHpcClusterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateHpcCluster',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateHpcClusterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_hpc_cluster(
        self,
        request: ecs_20140526_models.CreateHpcClusterRequest,
    ) -> ecs_20140526_models.CreateHpcClusterResponse:
        """
        @summary Creates a high performance computing (HPC) cluster.
        
        @param request: CreateHpcClusterRequest
        @return: CreateHpcClusterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_hpc_cluster_with_options(request, runtime)

    async def create_hpc_cluster_async(
        self,
        request: ecs_20140526_models.CreateHpcClusterRequest,
    ) -> ecs_20140526_models.CreateHpcClusterResponse:
        """
        @summary Creates a high performance computing (HPC) cluster.
        
        @param request: CreateHpcClusterRequest
        @return: CreateHpcClusterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_hpc_cluster_with_options_async(request, runtime)

    def create_image_with_options(
        self,
        request: ecs_20140526_models.CreateImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateImageResponse:
        """
        @summary Creates a custom image. After you call this operation to create a custom image, you can call the RunInstances operation to create Elastic Compute Service (ECS) instances from the custom image or call the ReplaceSystemDisk operation to replace system disks by using the custom image.
        
        @description ### [](#)Considerations
        This operation is an asynchronous operation. After a request to create a custom image is sent, an image ID is returned but the creation of the custom image is in progress. You can call the [DescribeImage](https://help.aliyun.com/document_detail/2679797.html) operation to query the status of the custom image. When the status of the custom image is `Available` in the response, the image is created and available. For more information, see [Overview of custom images](https://help.aliyun.com/document_detail/172789.html).
        If the response contains {"OperationLocks": {"LockReason" : "security"}} when you query information about an ECS instance, the instance is locked for security reasons, and you cannot create a custom image from the instance.
        To optimize the image, we recommend that you specify `DetectionStrategy` when you create a custom image. For information about the image check feature, see [Overview](https://help.aliyun.com/document_detail/439819.html).
        You can call the CreateImage operation to create a custom image by using one of the following methods. The following request parameters are prioritized in descending order: InstanceId, DiskDeviceMapping, and SnapshotId. If your request contains two or more of these parameters, the custom image is created based on the parameter that has a higher priority.
        **Create a custom image from an instance**. Specify an instance ID (`InstanceId`).
        The ECS instance must be in the Running (`Running`) or Stopped (`Stopped`) state.
        After the CreateImage operation is called, a snapshot is created for each cloud disk of the instance.
        *\
        *Note** When you create a custom image from a running ECS instance, cache data may not be written to disks. In this case, the data of the custom image may be slightly different from the data of the instance. Before you create a custom image from the instance, we recommend that you stop the instance by calling the StopInstancesoperation.
        **Create a custom image from a snapshot. The specified snapshot must be created after July 15, 2013.**\
        **Create a custom image from a system disk snapshot of an ECS instance**. You need to only specify the ID of the system disk snapshot by using `SnapshotId`.
        **Create a custom image from a system disk snapshot and data disk snapshots of an ECS instance**. You need to establish data association between the disks by specifying `DiskDeviceMapping`.
        You can specify only one snapshot to create the system disk in the custom image.
        You can specify up to 16 snapshots to use to create data disks in the custom image. If you do not specify `DiskDeviceMapping.N.SnapshotId`, an empty data disk with the default capacity is created.
        >  When an ECS instance is released, the system disk of the instance is converted to a pay-as-you-go data disk. You cannot create a custom image from the snapshot of this disk. You must create a custom image from the snapshot of this disk before the instance is released.
        
        @param request: CreateImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.architecture):
            query['Architecture'] = request.architecture
        if not UtilClient.is_unset(request.boot_mode):
            query['BootMode'] = request.boot_mode
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.detection_strategy):
            query['DetectionStrategy'] = request.detection_strategy
        if not UtilClient.is_unset(request.disk_device_mapping):
            query['DiskDeviceMapping'] = request.disk_device_mapping
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.features):
            query['Features'] = request.features
        if not UtilClient.is_unset(request.image_family):
            query['ImageFamily'] = request.image_family
        if not UtilClient.is_unset(request.image_name):
            query['ImageName'] = request.image_name
        if not UtilClient.is_unset(request.image_version):
            query['ImageVersion'] = request.image_version
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateImage',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateImageResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_image_with_options_async(
        self,
        request: ecs_20140526_models.CreateImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateImageResponse:
        """
        @summary Creates a custom image. After you call this operation to create a custom image, you can call the RunInstances operation to create Elastic Compute Service (ECS) instances from the custom image or call the ReplaceSystemDisk operation to replace system disks by using the custom image.
        
        @description ### [](#)Considerations
        This operation is an asynchronous operation. After a request to create a custom image is sent, an image ID is returned but the creation of the custom image is in progress. You can call the [DescribeImage](https://help.aliyun.com/document_detail/2679797.html) operation to query the status of the custom image. When the status of the custom image is `Available` in the response, the image is created and available. For more information, see [Overview of custom images](https://help.aliyun.com/document_detail/172789.html).
        If the response contains {"OperationLocks": {"LockReason" : "security"}} when you query information about an ECS instance, the instance is locked for security reasons, and you cannot create a custom image from the instance.
        To optimize the image, we recommend that you specify `DetectionStrategy` when you create a custom image. For information about the image check feature, see [Overview](https://help.aliyun.com/document_detail/439819.html).
        You can call the CreateImage operation to create a custom image by using one of the following methods. The following request parameters are prioritized in descending order: InstanceId, DiskDeviceMapping, and SnapshotId. If your request contains two or more of these parameters, the custom image is created based on the parameter that has a higher priority.
        **Create a custom image from an instance**. Specify an instance ID (`InstanceId`).
        The ECS instance must be in the Running (`Running`) or Stopped (`Stopped`) state.
        After the CreateImage operation is called, a snapshot is created for each cloud disk of the instance.
        *\
        *Note** When you create a custom image from a running ECS instance, cache data may not be written to disks. In this case, the data of the custom image may be slightly different from the data of the instance. Before you create a custom image from the instance, we recommend that you stop the instance by calling the StopInstancesoperation.
        **Create a custom image from a snapshot. The specified snapshot must be created after July 15, 2013.**\
        **Create a custom image from a system disk snapshot of an ECS instance**. You need to only specify the ID of the system disk snapshot by using `SnapshotId`.
        **Create a custom image from a system disk snapshot and data disk snapshots of an ECS instance**. You need to establish data association between the disks by specifying `DiskDeviceMapping`.
        You can specify only one snapshot to create the system disk in the custom image.
        You can specify up to 16 snapshots to use to create data disks in the custom image. If you do not specify `DiskDeviceMapping.N.SnapshotId`, an empty data disk with the default capacity is created.
        >  When an ECS instance is released, the system disk of the instance is converted to a pay-as-you-go data disk. You cannot create a custom image from the snapshot of this disk. You must create a custom image from the snapshot of this disk before the instance is released.
        
        @param request: CreateImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.architecture):
            query['Architecture'] = request.architecture
        if not UtilClient.is_unset(request.boot_mode):
            query['BootMode'] = request.boot_mode
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.detection_strategy):
            query['DetectionStrategy'] = request.detection_strategy
        if not UtilClient.is_unset(request.disk_device_mapping):
            query['DiskDeviceMapping'] = request.disk_device_mapping
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.features):
            query['Features'] = request.features
        if not UtilClient.is_unset(request.image_family):
            query['ImageFamily'] = request.image_family
        if not UtilClient.is_unset(request.image_name):
            query['ImageName'] = request.image_name
        if not UtilClient.is_unset(request.image_version):
            query['ImageVersion'] = request.image_version
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateImage',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateImageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_image(
        self,
        request: ecs_20140526_models.CreateImageRequest,
    ) -> ecs_20140526_models.CreateImageResponse:
        """
        @summary Creates a custom image. After you call this operation to create a custom image, you can call the RunInstances operation to create Elastic Compute Service (ECS) instances from the custom image or call the ReplaceSystemDisk operation to replace system disks by using the custom image.
        
        @description ### [](#)Considerations
        This operation is an asynchronous operation. After a request to create a custom image is sent, an image ID is returned but the creation of the custom image is in progress. You can call the [DescribeImage](https://help.aliyun.com/document_detail/2679797.html) operation to query the status of the custom image. When the status of the custom image is `Available` in the response, the image is created and available. For more information, see [Overview of custom images](https://help.aliyun.com/document_detail/172789.html).
        If the response contains {"OperationLocks": {"LockReason" : "security"}} when you query information about an ECS instance, the instance is locked for security reasons, and you cannot create a custom image from the instance.
        To optimize the image, we recommend that you specify `DetectionStrategy` when you create a custom image. For information about the image check feature, see [Overview](https://help.aliyun.com/document_detail/439819.html).
        You can call the CreateImage operation to create a custom image by using one of the following methods. The following request parameters are prioritized in descending order: InstanceId, DiskDeviceMapping, and SnapshotId. If your request contains two or more of these parameters, the custom image is created based on the parameter that has a higher priority.
        **Create a custom image from an instance**. Specify an instance ID (`InstanceId`).
        The ECS instance must be in the Running (`Running`) or Stopped (`Stopped`) state.
        After the CreateImage operation is called, a snapshot is created for each cloud disk of the instance.
        *\
        *Note** When you create a custom image from a running ECS instance, cache data may not be written to disks. In this case, the data of the custom image may be slightly different from the data of the instance. Before you create a custom image from the instance, we recommend that you stop the instance by calling the StopInstancesoperation.
        **Create a custom image from a snapshot. The specified snapshot must be created after July 15, 2013.**\
        **Create a custom image from a system disk snapshot of an ECS instance**. You need to only specify the ID of the system disk snapshot by using `SnapshotId`.
        **Create a custom image from a system disk snapshot and data disk snapshots of an ECS instance**. You need to establish data association between the disks by specifying `DiskDeviceMapping`.
        You can specify only one snapshot to create the system disk in the custom image.
        You can specify up to 16 snapshots to use to create data disks in the custom image. If you do not specify `DiskDeviceMapping.N.SnapshotId`, an empty data disk with the default capacity is created.
        >  When an ECS instance is released, the system disk of the instance is converted to a pay-as-you-go data disk. You cannot create a custom image from the snapshot of this disk. You must create a custom image from the snapshot of this disk before the instance is released.
        
        @param request: CreateImageRequest
        @return: CreateImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_image_with_options(request, runtime)

    async def create_image_async(
        self,
        request: ecs_20140526_models.CreateImageRequest,
    ) -> ecs_20140526_models.CreateImageResponse:
        """
        @summary Creates a custom image. After you call this operation to create a custom image, you can call the RunInstances operation to create Elastic Compute Service (ECS) instances from the custom image or call the ReplaceSystemDisk operation to replace system disks by using the custom image.
        
        @description ### [](#)Considerations
        This operation is an asynchronous operation. After a request to create a custom image is sent, an image ID is returned but the creation of the custom image is in progress. You can call the [DescribeImage](https://help.aliyun.com/document_detail/2679797.html) operation to query the status of the custom image. When the status of the custom image is `Available` in the response, the image is created and available. For more information, see [Overview of custom images](https://help.aliyun.com/document_detail/172789.html).
        If the response contains {"OperationLocks": {"LockReason" : "security"}} when you query information about an ECS instance, the instance is locked for security reasons, and you cannot create a custom image from the instance.
        To optimize the image, we recommend that you specify `DetectionStrategy` when you create a custom image. For information about the image check feature, see [Overview](https://help.aliyun.com/document_detail/439819.html).
        You can call the CreateImage operation to create a custom image by using one of the following methods. The following request parameters are prioritized in descending order: InstanceId, DiskDeviceMapping, and SnapshotId. If your request contains two or more of these parameters, the custom image is created based on the parameter that has a higher priority.
        **Create a custom image from an instance**. Specify an instance ID (`InstanceId`).
        The ECS instance must be in the Running (`Running`) or Stopped (`Stopped`) state.
        After the CreateImage operation is called, a snapshot is created for each cloud disk of the instance.
        *\
        *Note** When you create a custom image from a running ECS instance, cache data may not be written to disks. In this case, the data of the custom image may be slightly different from the data of the instance. Before you create a custom image from the instance, we recommend that you stop the instance by calling the StopInstancesoperation.
        **Create a custom image from a snapshot. The specified snapshot must be created after July 15, 2013.**\
        **Create a custom image from a system disk snapshot of an ECS instance**. You need to only specify the ID of the system disk snapshot by using `SnapshotId`.
        **Create a custom image from a system disk snapshot and data disk snapshots of an ECS instance**. You need to establish data association between the disks by specifying `DiskDeviceMapping`.
        You can specify only one snapshot to create the system disk in the custom image.
        You can specify up to 16 snapshots to use to create data disks in the custom image. If you do not specify `DiskDeviceMapping.N.SnapshotId`, an empty data disk with the default capacity is created.
        >  When an ECS instance is released, the system disk of the instance is converted to a pay-as-you-go data disk. You cannot create a custom image from the snapshot of this disk. You must create a custom image from the snapshot of this disk before the instance is released.
        
        @param request: CreateImageRequest
        @return: CreateImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_image_with_options_async(request, runtime)

    def create_image_component_with_options(
        self,
        request: ecs_20140526_models.CreateImageComponentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateImageComponentResponse:
        """
        @summary Creates an image component. Image components are used to store the builder template commands that are commonly used when you create images.
        
        @description ## [](#)Usage notes
        Take note of the following items:
        You can create only custom image components.
        Each version number of an image component must be unique. When you add a version of an image component to an image template, you can specify the component by its name and version number.
        The content size of an image component cannot exceed 16 KB. For information about the commands supported by Image Builder, see [Commands supported by Image Builder](https://help.aliyun.com/document_detail/200206.html).
        For more information, see [Image Builder](https://help.aliyun.com/document_detail/197410.html).
        
        @param request: CreateImageComponentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateImageComponentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.component_type):
            query['ComponentType'] = request.component_type
        if not UtilClient.is_unset(request.component_version):
            query['ComponentVersion'] = request.component_version
        if not UtilClient.is_unset(request.content):
            query['Content'] = request.content
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.system_type):
            query['SystemType'] = request.system_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateImageComponent',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateImageComponentResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_image_component_with_options_async(
        self,
        request: ecs_20140526_models.CreateImageComponentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateImageComponentResponse:
        """
        @summary Creates an image component. Image components are used to store the builder template commands that are commonly used when you create images.
        
        @description ## [](#)Usage notes
        Take note of the following items:
        You can create only custom image components.
        Each version number of an image component must be unique. When you add a version of an image component to an image template, you can specify the component by its name and version number.
        The content size of an image component cannot exceed 16 KB. For information about the commands supported by Image Builder, see [Commands supported by Image Builder](https://help.aliyun.com/document_detail/200206.html).
        For more information, see [Image Builder](https://help.aliyun.com/document_detail/197410.html).
        
        @param request: CreateImageComponentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateImageComponentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.component_type):
            query['ComponentType'] = request.component_type
        if not UtilClient.is_unset(request.component_version):
            query['ComponentVersion'] = request.component_version
        if not UtilClient.is_unset(request.content):
            query['Content'] = request.content
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.system_type):
            query['SystemType'] = request.system_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateImageComponent',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateImageComponentResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_image_component(
        self,
        request: ecs_20140526_models.CreateImageComponentRequest,
    ) -> ecs_20140526_models.CreateImageComponentResponse:
        """
        @summary Creates an image component. Image components are used to store the builder template commands that are commonly used when you create images.
        
        @description ## [](#)Usage notes
        Take note of the following items:
        You can create only custom image components.
        Each version number of an image component must be unique. When you add a version of an image component to an image template, you can specify the component by its name and version number.
        The content size of an image component cannot exceed 16 KB. For information about the commands supported by Image Builder, see [Commands supported by Image Builder](https://help.aliyun.com/document_detail/200206.html).
        For more information, see [Image Builder](https://help.aliyun.com/document_detail/197410.html).
        
        @param request: CreateImageComponentRequest
        @return: CreateImageComponentResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_image_component_with_options(request, runtime)

    async def create_image_component_async(
        self,
        request: ecs_20140526_models.CreateImageComponentRequest,
    ) -> ecs_20140526_models.CreateImageComponentResponse:
        """
        @summary Creates an image component. Image components are used to store the builder template commands that are commonly used when you create images.
        
        @description ## [](#)Usage notes
        Take note of the following items:
        You can create only custom image components.
        Each version number of an image component must be unique. When you add a version of an image component to an image template, you can specify the component by its name and version number.
        The content size of an image component cannot exceed 16 KB. For information about the commands supported by Image Builder, see [Commands supported by Image Builder](https://help.aliyun.com/document_detail/200206.html).
        For more information, see [Image Builder](https://help.aliyun.com/document_detail/197410.html).
        
        @param request: CreateImageComponentRequest
        @return: CreateImageComponentResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_image_component_with_options_async(request, runtime)

    def create_image_pipeline_with_options(
        self,
        request: ecs_20140526_models.CreateImagePipelineRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateImagePipelineResponse:
        """
        @summary Creates an image template. Image templates can be used to create images.
        
        @description ## [](#)Usage notes
        You can use image templates to customize image content and create images across regions and accounts. Take note of the following items:
        You can create only custom image templates.
        You can specify only a public image, a custom image, a shared image, or an image family as the source image when you create an image template.
        When you use an image template to create an image, multiple intermediate instances are created. You are charged for the intermediate instances on a pay-as-you-go basis. For more information, see [Pay-as-you-go](https://help.aliyun.com/document_detail/40653.html).
        When you use `BuildContent` to specify the build content in an image template, take note of the following items:
        The `FROM` command is deprecated. Regardless of whether you specify the `FROM` command in `BuildContent`, the system uses the source image specified by `BaseImageType` and `BaseImage`. BaseImageType specifies the type of the source image and BaseImage specifies the source image.
        The size of BuildContent cannot exceed 16 KB. For information about the commands supported by Image Builder, see [Commands supported by Image Builder](https://help.aliyun.com/document_detail/200206.html).
        For more information, see [Image Builder](https://help.aliyun.com/document_detail/197410.html).
        
        @param request: CreateImagePipelineRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateImagePipelineResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.add_account):
            query['AddAccount'] = request.add_account
        if not UtilClient.is_unset(request.advanced_options):
            query['AdvancedOptions'] = request.advanced_options
        if not UtilClient.is_unset(request.base_image):
            query['BaseImage'] = request.base_image
        if not UtilClient.is_unset(request.base_image_type):
            query['BaseImageType'] = request.base_image_type
        if not UtilClient.is_unset(request.build_content):
            query['BuildContent'] = request.build_content
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.delete_instance_on_failure):
            query['DeleteInstanceOnFailure'] = request.delete_instance_on_failure
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.image_family):
            query['ImageFamily'] = request.image_family
        if not UtilClient.is_unset(request.image_name):
            query['ImageName'] = request.image_name
        if not UtilClient.is_unset(request.image_options):
            query['ImageOptions'] = request.image_options
        if not UtilClient.is_unset(request.import_image_options):
            query['ImportImageOptions'] = request.import_image_options
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.internet_max_bandwidth_out):
            query['InternetMaxBandwidthOut'] = request.internet_max_bandwidth_out
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.nvme_support):
            query['NvmeSupport'] = request.nvme_support
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repair_mode):
            query['RepairMode'] = request.repair_mode
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.system_disk_size):
            query['SystemDiskSize'] = request.system_disk_size
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.test_content):
            query['TestContent'] = request.test_content
        if not UtilClient.is_unset(request.to_region_id):
            query['ToRegionId'] = request.to_region_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateImagePipeline',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateImagePipelineResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_image_pipeline_with_options_async(
        self,
        request: ecs_20140526_models.CreateImagePipelineRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateImagePipelineResponse:
        """
        @summary Creates an image template. Image templates can be used to create images.
        
        @description ## [](#)Usage notes
        You can use image templates to customize image content and create images across regions and accounts. Take note of the following items:
        You can create only custom image templates.
        You can specify only a public image, a custom image, a shared image, or an image family as the source image when you create an image template.
        When you use an image template to create an image, multiple intermediate instances are created. You are charged for the intermediate instances on a pay-as-you-go basis. For more information, see [Pay-as-you-go](https://help.aliyun.com/document_detail/40653.html).
        When you use `BuildContent` to specify the build content in an image template, take note of the following items:
        The `FROM` command is deprecated. Regardless of whether you specify the `FROM` command in `BuildContent`, the system uses the source image specified by `BaseImageType` and `BaseImage`. BaseImageType specifies the type of the source image and BaseImage specifies the source image.
        The size of BuildContent cannot exceed 16 KB. For information about the commands supported by Image Builder, see [Commands supported by Image Builder](https://help.aliyun.com/document_detail/200206.html).
        For more information, see [Image Builder](https://help.aliyun.com/document_detail/197410.html).
        
        @param request: CreateImagePipelineRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateImagePipelineResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.add_account):
            query['AddAccount'] = request.add_account
        if not UtilClient.is_unset(request.advanced_options):
            query['AdvancedOptions'] = request.advanced_options
        if not UtilClient.is_unset(request.base_image):
            query['BaseImage'] = request.base_image
        if not UtilClient.is_unset(request.base_image_type):
            query['BaseImageType'] = request.base_image_type
        if not UtilClient.is_unset(request.build_content):
            query['BuildContent'] = request.build_content
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.delete_instance_on_failure):
            query['DeleteInstanceOnFailure'] = request.delete_instance_on_failure
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.image_family):
            query['ImageFamily'] = request.image_family
        if not UtilClient.is_unset(request.image_name):
            query['ImageName'] = request.image_name
        if not UtilClient.is_unset(request.image_options):
            query['ImageOptions'] = request.image_options
        if not UtilClient.is_unset(request.import_image_options):
            query['ImportImageOptions'] = request.import_image_options
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.internet_max_bandwidth_out):
            query['InternetMaxBandwidthOut'] = request.internet_max_bandwidth_out
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.nvme_support):
            query['NvmeSupport'] = request.nvme_support
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repair_mode):
            query['RepairMode'] = request.repair_mode
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.system_disk_size):
            query['SystemDiskSize'] = request.system_disk_size
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.test_content):
            query['TestContent'] = request.test_content
        if not UtilClient.is_unset(request.to_region_id):
            query['ToRegionId'] = request.to_region_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateImagePipeline',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateImagePipelineResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_image_pipeline(
        self,
        request: ecs_20140526_models.CreateImagePipelineRequest,
    ) -> ecs_20140526_models.CreateImagePipelineResponse:
        """
        @summary Creates an image template. Image templates can be used to create images.
        
        @description ## [](#)Usage notes
        You can use image templates to customize image content and create images across regions and accounts. Take note of the following items:
        You can create only custom image templates.
        You can specify only a public image, a custom image, a shared image, or an image family as the source image when you create an image template.
        When you use an image template to create an image, multiple intermediate instances are created. You are charged for the intermediate instances on a pay-as-you-go basis. For more information, see [Pay-as-you-go](https://help.aliyun.com/document_detail/40653.html).
        When you use `BuildContent` to specify the build content in an image template, take note of the following items:
        The `FROM` command is deprecated. Regardless of whether you specify the `FROM` command in `BuildContent`, the system uses the source image specified by `BaseImageType` and `BaseImage`. BaseImageType specifies the type of the source image and BaseImage specifies the source image.
        The size of BuildContent cannot exceed 16 KB. For information about the commands supported by Image Builder, see [Commands supported by Image Builder](https://help.aliyun.com/document_detail/200206.html).
        For more information, see [Image Builder](https://help.aliyun.com/document_detail/197410.html).
        
        @param request: CreateImagePipelineRequest
        @return: CreateImagePipelineResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_image_pipeline_with_options(request, runtime)

    async def create_image_pipeline_async(
        self,
        request: ecs_20140526_models.CreateImagePipelineRequest,
    ) -> ecs_20140526_models.CreateImagePipelineResponse:
        """
        @summary Creates an image template. Image templates can be used to create images.
        
        @description ## [](#)Usage notes
        You can use image templates to customize image content and create images across regions and accounts. Take note of the following items:
        You can create only custom image templates.
        You can specify only a public image, a custom image, a shared image, or an image family as the source image when you create an image template.
        When you use an image template to create an image, multiple intermediate instances are created. You are charged for the intermediate instances on a pay-as-you-go basis. For more information, see [Pay-as-you-go](https://help.aliyun.com/document_detail/40653.html).
        When you use `BuildContent` to specify the build content in an image template, take note of the following items:
        The `FROM` command is deprecated. Regardless of whether you specify the `FROM` command in `BuildContent`, the system uses the source image specified by `BaseImageType` and `BaseImage`. BaseImageType specifies the type of the source image and BaseImage specifies the source image.
        The size of BuildContent cannot exceed 16 KB. For information about the commands supported by Image Builder, see [Commands supported by Image Builder](https://help.aliyun.com/document_detail/200206.html).
        For more information, see [Image Builder](https://help.aliyun.com/document_detail/197410.html).
        
        @param request: CreateImagePipelineRequest
        @return: CreateImagePipelineResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_image_pipeline_with_options_async(request, runtime)

    def create_instance_with_options(
        self,
        request: ecs_20140526_models.CreateInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateInstanceResponse:
        """
        @summary Creates a subscription or pay-as-you-go Elastic Compute Service (ECS) instance. When you call this operation, you can specify different parameters to create instances based on your business requirements.
        
        @description >  This operation is no longer iterated or updated. We recommend that you call the [RunInstances](https://help.aliyun.com/document_detail/2679677.html) operation instead.
        *Before you call this operation, familiarize yourself with the billing rules and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of ECS resources.**\
        This operation is an asynchronous operation. After a request to create an ECS instance is sent, an ECS instance ID is immediately returned but the instance may be still being created. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instance. If the status of the instance is `Stopped` in the DescribeInstanceStatus response, the instance is created. In this case, you can call the [StartInstance](https://help.aliyun.com/document_detail/2679679.html) operation to start the instance.
        ### [](#)Prerequisites
        Make sure that you are familiar with the ECS billing methods because you may be charged for the resources that are used by the instance. For more information, see [Billing overview](https://help.aliyun.com/document_detail/25398.html).
        Make sure that the number of ECS instances you create or the number of vCPUs on ECS instances of all instance types you create does not exceed the corresponding quota. Go to the [Quota Center](https://quotas.console.aliyun.com/products/ecs/quotas) to view the quotas.
        Before you create ECS instances of the Virtual Private Cloud (VPC) type in a region, create a VPC in the region. For more information, see [Create a VPC](https://help.aliyun.com/document_detail/65430.html).
        ### [](#)Considerations
        If you create a subscription instance (`PrePaid`), available coupons in your account are automatically used.
        If you want to create instances with 512 MiB of memory, you cannot use Windows Server images except for Windows Server Semi-Annual Channel images. If you want to create instances with 4 GiB or more of memory, you cannot use 32-bit OS image.
        If you call the CreateInstance operation to create an instance, no public IP address is automatically assigned to the instance. If the InternetMaxBandwidthOut value of the instance is greater than 0 Mbit/s, call the [AllocatePublicIpAddress](https://help.aliyun.com/document_detail/25544.html) operation to assign a public IP address to the instance. If the InternetMaxBandwidthOut value of the instance is 0 Mbit/s, call the [ModifyInstanceNetworkSpec](https://help.aliyun.com/document_detail/2679879.html) operation to set InternetMaxBandwidthOut to a value greater than 0 Mbit/s and then call the [AllocatePublicIpAddress](https://help.aliyun.com/document_detail/25544.html) operation to assign a public IP address to the instance.
        >  For the limits on the sum of maximum public bandwidths of ECS instances that use the pay-by-bandwidth billing method for network usage per region per Alibaba Cloud account, see the [Public bandwidth limits](~~25412#BandwidthQuota~~) section of the "Limits" topic.
        ### [](#)Suggestions
        **Instance type selection**: See [Overview of instance families](https://help.aliyun.com/document_detail/25378.html) or call the [DescribeInstanceTypes](https://help.aliyun.com/document_detail/25620.html) operation to query the performance data of instance types, or see [Instance type selection](https://help.aliyun.com/document_detail/58291.html) to learn about how to select instance types.
        **Query of available resources**: Call the [DescribeAvailableResource](https://help.aliyun.com/document_detail/66186.html) operation to query resources available in a specific region or zone.
        **User data**: If the instance type supports [user data](https://help.aliyun.com/document_detail/49121.html), you can use UserData to pass in user data. We recommend that you do not pass in confidential information, such as passwords or private keys, in plaintext as user data. This is because the system does not encrypt `UserData` values when API requests are sent. If you must pass in confidential information as user data, we recommend that you encrypt and encode the information in Base64 before you pass in the information. Then, decode and decrypt the information within the instance for subsequent use.
        
        @param request: CreateInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.affinity):
            query['Affinity'] = request.affinity
        if not UtilClient.is_unset(request.arn):
            query['Arn'] = request.arn
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_period):
            query['AutoRenewPeriod'] = request.auto_renew_period
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.credit_specification):
            query['CreditSpecification'] = request.credit_specification
        if not UtilClient.is_unset(request.data_disk):
            query['DataDisk'] = request.data_disk
        if not UtilClient.is_unset(request.dedicated_host_id):
            query['DedicatedHostId'] = request.dedicated_host_id
        if not UtilClient.is_unset(request.deletion_protection):
            query['DeletionProtection'] = request.deletion_protection
        if not UtilClient.is_unset(request.deployment_set_group_no):
            query['DeploymentSetGroupNo'] = request.deployment_set_group_no
        if not UtilClient.is_unset(request.deployment_set_id):
            query['DeploymentSetId'] = request.deployment_set_id
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.host_name):
            query['HostName'] = request.host_name
        if not UtilClient.is_unset(request.hpc_cluster_id):
            query['HpcClusterId'] = request.hpc_cluster_id
        if not UtilClient.is_unset(request.http_endpoint):
            query['HttpEndpoint'] = request.http_endpoint
        if not UtilClient.is_unset(request.http_put_response_hop_limit):
            query['HttpPutResponseHopLimit'] = request.http_put_response_hop_limit
        if not UtilClient.is_unset(request.http_tokens):
            query['HttpTokens'] = request.http_tokens
        if not UtilClient.is_unset(request.image_family):
            query['ImageFamily'] = request.image_family
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.inner_ip_address):
            query['InnerIpAddress'] = request.inner_ip_address
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.internet_max_bandwidth_in):
            query['InternetMaxBandwidthIn'] = request.internet_max_bandwidth_in
        if not UtilClient.is_unset(request.internet_max_bandwidth_out):
            query['InternetMaxBandwidthOut'] = request.internet_max_bandwidth_out
        if not UtilClient.is_unset(request.io_optimized):
            query['IoOptimized'] = request.io_optimized
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.node_controller_id):
            query['NodeControllerId'] = request.node_controller_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.password):
            query['Password'] = request.password
        if not UtilClient.is_unset(request.password_inherit):
            query['PasswordInherit'] = request.password_inherit
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.ram_role_name):
            query['RamRoleName'] = request.ram_role_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_enhancement_strategy):
            query['SecurityEnhancementStrategy'] = request.security_enhancement_strategy
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.spot_duration):
            query['SpotDuration'] = request.spot_duration
        if not UtilClient.is_unset(request.spot_interruption_behavior):
            query['SpotInterruptionBehavior'] = request.spot_interruption_behavior
        if not UtilClient.is_unset(request.spot_price_limit):
            query['SpotPriceLimit'] = request.spot_price_limit
        if not UtilClient.is_unset(request.spot_strategy):
            query['SpotStrategy'] = request.spot_strategy
        if not UtilClient.is_unset(request.storage_set_id):
            query['StorageSetId'] = request.storage_set_id
        if not UtilClient.is_unset(request.storage_set_partition_number):
            query['StorageSetPartitionNumber'] = request.storage_set_partition_number
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.tenancy):
            query['Tenancy'] = request.tenancy
        if not UtilClient.is_unset(request.use_additional_service):
            query['UseAdditionalService'] = request.use_additional_service
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.vlan_id):
            query['VlanId'] = request.vlan_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.hibernation_options):
            query['HibernationOptions'] = request.hibernation_options
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        if not UtilClient.is_unset(request.system_disk):
            query['SystemDisk'] = request.system_disk
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateInstance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_instance_with_options_async(
        self,
        request: ecs_20140526_models.CreateInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateInstanceResponse:
        """
        @summary Creates a subscription or pay-as-you-go Elastic Compute Service (ECS) instance. When you call this operation, you can specify different parameters to create instances based on your business requirements.
        
        @description >  This operation is no longer iterated or updated. We recommend that you call the [RunInstances](https://help.aliyun.com/document_detail/2679677.html) operation instead.
        *Before you call this operation, familiarize yourself with the billing rules and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of ECS resources.**\
        This operation is an asynchronous operation. After a request to create an ECS instance is sent, an ECS instance ID is immediately returned but the instance may be still being created. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instance. If the status of the instance is `Stopped` in the DescribeInstanceStatus response, the instance is created. In this case, you can call the [StartInstance](https://help.aliyun.com/document_detail/2679679.html) operation to start the instance.
        ### [](#)Prerequisites
        Make sure that you are familiar with the ECS billing methods because you may be charged for the resources that are used by the instance. For more information, see [Billing overview](https://help.aliyun.com/document_detail/25398.html).
        Make sure that the number of ECS instances you create or the number of vCPUs on ECS instances of all instance types you create does not exceed the corresponding quota. Go to the [Quota Center](https://quotas.console.aliyun.com/products/ecs/quotas) to view the quotas.
        Before you create ECS instances of the Virtual Private Cloud (VPC) type in a region, create a VPC in the region. For more information, see [Create a VPC](https://help.aliyun.com/document_detail/65430.html).
        ### [](#)Considerations
        If you create a subscription instance (`PrePaid`), available coupons in your account are automatically used.
        If you want to create instances with 512 MiB of memory, you cannot use Windows Server images except for Windows Server Semi-Annual Channel images. If you want to create instances with 4 GiB or more of memory, you cannot use 32-bit OS image.
        If you call the CreateInstance operation to create an instance, no public IP address is automatically assigned to the instance. If the InternetMaxBandwidthOut value of the instance is greater than 0 Mbit/s, call the [AllocatePublicIpAddress](https://help.aliyun.com/document_detail/25544.html) operation to assign a public IP address to the instance. If the InternetMaxBandwidthOut value of the instance is 0 Mbit/s, call the [ModifyInstanceNetworkSpec](https://help.aliyun.com/document_detail/2679879.html) operation to set InternetMaxBandwidthOut to a value greater than 0 Mbit/s and then call the [AllocatePublicIpAddress](https://help.aliyun.com/document_detail/25544.html) operation to assign a public IP address to the instance.
        >  For the limits on the sum of maximum public bandwidths of ECS instances that use the pay-by-bandwidth billing method for network usage per region per Alibaba Cloud account, see the [Public bandwidth limits](~~25412#BandwidthQuota~~) section of the "Limits" topic.
        ### [](#)Suggestions
        **Instance type selection**: See [Overview of instance families](https://help.aliyun.com/document_detail/25378.html) or call the [DescribeInstanceTypes](https://help.aliyun.com/document_detail/25620.html) operation to query the performance data of instance types, or see [Instance type selection](https://help.aliyun.com/document_detail/58291.html) to learn about how to select instance types.
        **Query of available resources**: Call the [DescribeAvailableResource](https://help.aliyun.com/document_detail/66186.html) operation to query resources available in a specific region or zone.
        **User data**: If the instance type supports [user data](https://help.aliyun.com/document_detail/49121.html), you can use UserData to pass in user data. We recommend that you do not pass in confidential information, such as passwords or private keys, in plaintext as user data. This is because the system does not encrypt `UserData` values when API requests are sent. If you must pass in confidential information as user data, we recommend that you encrypt and encode the information in Base64 before you pass in the information. Then, decode and decrypt the information within the instance for subsequent use.
        
        @param request: CreateInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.affinity):
            query['Affinity'] = request.affinity
        if not UtilClient.is_unset(request.arn):
            query['Arn'] = request.arn
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_period):
            query['AutoRenewPeriod'] = request.auto_renew_period
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.credit_specification):
            query['CreditSpecification'] = request.credit_specification
        if not UtilClient.is_unset(request.data_disk):
            query['DataDisk'] = request.data_disk
        if not UtilClient.is_unset(request.dedicated_host_id):
            query['DedicatedHostId'] = request.dedicated_host_id
        if not UtilClient.is_unset(request.deletion_protection):
            query['DeletionProtection'] = request.deletion_protection
        if not UtilClient.is_unset(request.deployment_set_group_no):
            query['DeploymentSetGroupNo'] = request.deployment_set_group_no
        if not UtilClient.is_unset(request.deployment_set_id):
            query['DeploymentSetId'] = request.deployment_set_id
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.host_name):
            query['HostName'] = request.host_name
        if not UtilClient.is_unset(request.hpc_cluster_id):
            query['HpcClusterId'] = request.hpc_cluster_id
        if not UtilClient.is_unset(request.http_endpoint):
            query['HttpEndpoint'] = request.http_endpoint
        if not UtilClient.is_unset(request.http_put_response_hop_limit):
            query['HttpPutResponseHopLimit'] = request.http_put_response_hop_limit
        if not UtilClient.is_unset(request.http_tokens):
            query['HttpTokens'] = request.http_tokens
        if not UtilClient.is_unset(request.image_family):
            query['ImageFamily'] = request.image_family
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.inner_ip_address):
            query['InnerIpAddress'] = request.inner_ip_address
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.internet_max_bandwidth_in):
            query['InternetMaxBandwidthIn'] = request.internet_max_bandwidth_in
        if not UtilClient.is_unset(request.internet_max_bandwidth_out):
            query['InternetMaxBandwidthOut'] = request.internet_max_bandwidth_out
        if not UtilClient.is_unset(request.io_optimized):
            query['IoOptimized'] = request.io_optimized
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.node_controller_id):
            query['NodeControllerId'] = request.node_controller_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.password):
            query['Password'] = request.password
        if not UtilClient.is_unset(request.password_inherit):
            query['PasswordInherit'] = request.password_inherit
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.ram_role_name):
            query['RamRoleName'] = request.ram_role_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_enhancement_strategy):
            query['SecurityEnhancementStrategy'] = request.security_enhancement_strategy
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.spot_duration):
            query['SpotDuration'] = request.spot_duration
        if not UtilClient.is_unset(request.spot_interruption_behavior):
            query['SpotInterruptionBehavior'] = request.spot_interruption_behavior
        if not UtilClient.is_unset(request.spot_price_limit):
            query['SpotPriceLimit'] = request.spot_price_limit
        if not UtilClient.is_unset(request.spot_strategy):
            query['SpotStrategy'] = request.spot_strategy
        if not UtilClient.is_unset(request.storage_set_id):
            query['StorageSetId'] = request.storage_set_id
        if not UtilClient.is_unset(request.storage_set_partition_number):
            query['StorageSetPartitionNumber'] = request.storage_set_partition_number
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.tenancy):
            query['Tenancy'] = request.tenancy
        if not UtilClient.is_unset(request.use_additional_service):
            query['UseAdditionalService'] = request.use_additional_service
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.vlan_id):
            query['VlanId'] = request.vlan_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.hibernation_options):
            query['HibernationOptions'] = request.hibernation_options
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        if not UtilClient.is_unset(request.system_disk):
            query['SystemDisk'] = request.system_disk
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateInstance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_instance(
        self,
        request: ecs_20140526_models.CreateInstanceRequest,
    ) -> ecs_20140526_models.CreateInstanceResponse:
        """
        @summary Creates a subscription or pay-as-you-go Elastic Compute Service (ECS) instance. When you call this operation, you can specify different parameters to create instances based on your business requirements.
        
        @description >  This operation is no longer iterated or updated. We recommend that you call the [RunInstances](https://help.aliyun.com/document_detail/2679677.html) operation instead.
        *Before you call this operation, familiarize yourself with the billing rules and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of ECS resources.**\
        This operation is an asynchronous operation. After a request to create an ECS instance is sent, an ECS instance ID is immediately returned but the instance may be still being created. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instance. If the status of the instance is `Stopped` in the DescribeInstanceStatus response, the instance is created. In this case, you can call the [StartInstance](https://help.aliyun.com/document_detail/2679679.html) operation to start the instance.
        ### [](#)Prerequisites
        Make sure that you are familiar with the ECS billing methods because you may be charged for the resources that are used by the instance. For more information, see [Billing overview](https://help.aliyun.com/document_detail/25398.html).
        Make sure that the number of ECS instances you create or the number of vCPUs on ECS instances of all instance types you create does not exceed the corresponding quota. Go to the [Quota Center](https://quotas.console.aliyun.com/products/ecs/quotas) to view the quotas.
        Before you create ECS instances of the Virtual Private Cloud (VPC) type in a region, create a VPC in the region. For more information, see [Create a VPC](https://help.aliyun.com/document_detail/65430.html).
        ### [](#)Considerations
        If you create a subscription instance (`PrePaid`), available coupons in your account are automatically used.
        If you want to create instances with 512 MiB of memory, you cannot use Windows Server images except for Windows Server Semi-Annual Channel images. If you want to create instances with 4 GiB or more of memory, you cannot use 32-bit OS image.
        If you call the CreateInstance operation to create an instance, no public IP address is automatically assigned to the instance. If the InternetMaxBandwidthOut value of the instance is greater than 0 Mbit/s, call the [AllocatePublicIpAddress](https://help.aliyun.com/document_detail/25544.html) operation to assign a public IP address to the instance. If the InternetMaxBandwidthOut value of the instance is 0 Mbit/s, call the [ModifyInstanceNetworkSpec](https://help.aliyun.com/document_detail/2679879.html) operation to set InternetMaxBandwidthOut to a value greater than 0 Mbit/s and then call the [AllocatePublicIpAddress](https://help.aliyun.com/document_detail/25544.html) operation to assign a public IP address to the instance.
        >  For the limits on the sum of maximum public bandwidths of ECS instances that use the pay-by-bandwidth billing method for network usage per region per Alibaba Cloud account, see the [Public bandwidth limits](~~25412#BandwidthQuota~~) section of the "Limits" topic.
        ### [](#)Suggestions
        **Instance type selection**: See [Overview of instance families](https://help.aliyun.com/document_detail/25378.html) or call the [DescribeInstanceTypes](https://help.aliyun.com/document_detail/25620.html) operation to query the performance data of instance types, or see [Instance type selection](https://help.aliyun.com/document_detail/58291.html) to learn about how to select instance types.
        **Query of available resources**: Call the [DescribeAvailableResource](https://help.aliyun.com/document_detail/66186.html) operation to query resources available in a specific region or zone.
        **User data**: If the instance type supports [user data](https://help.aliyun.com/document_detail/49121.html), you can use UserData to pass in user data. We recommend that you do not pass in confidential information, such as passwords or private keys, in plaintext as user data. This is because the system does not encrypt `UserData` values when API requests are sent. If you must pass in confidential information as user data, we recommend that you encrypt and encode the information in Base64 before you pass in the information. Then, decode and decrypt the information within the instance for subsequent use.
        
        @param request: CreateInstanceRequest
        @return: CreateInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_instance_with_options(request, runtime)

    async def create_instance_async(
        self,
        request: ecs_20140526_models.CreateInstanceRequest,
    ) -> ecs_20140526_models.CreateInstanceResponse:
        """
        @summary Creates a subscription or pay-as-you-go Elastic Compute Service (ECS) instance. When you call this operation, you can specify different parameters to create instances based on your business requirements.
        
        @description >  This operation is no longer iterated or updated. We recommend that you call the [RunInstances](https://help.aliyun.com/document_detail/2679677.html) operation instead.
        *Before you call this operation, familiarize yourself with the billing rules and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of ECS resources.**\
        This operation is an asynchronous operation. After a request to create an ECS instance is sent, an ECS instance ID is immediately returned but the instance may be still being created. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instance. If the status of the instance is `Stopped` in the DescribeInstanceStatus response, the instance is created. In this case, you can call the [StartInstance](https://help.aliyun.com/document_detail/2679679.html) operation to start the instance.
        ### [](#)Prerequisites
        Make sure that you are familiar with the ECS billing methods because you may be charged for the resources that are used by the instance. For more information, see [Billing overview](https://help.aliyun.com/document_detail/25398.html).
        Make sure that the number of ECS instances you create or the number of vCPUs on ECS instances of all instance types you create does not exceed the corresponding quota. Go to the [Quota Center](https://quotas.console.aliyun.com/products/ecs/quotas) to view the quotas.
        Before you create ECS instances of the Virtual Private Cloud (VPC) type in a region, create a VPC in the region. For more information, see [Create a VPC](https://help.aliyun.com/document_detail/65430.html).
        ### [](#)Considerations
        If you create a subscription instance (`PrePaid`), available coupons in your account are automatically used.
        If you want to create instances with 512 MiB of memory, you cannot use Windows Server images except for Windows Server Semi-Annual Channel images. If you want to create instances with 4 GiB or more of memory, you cannot use 32-bit OS image.
        If you call the CreateInstance operation to create an instance, no public IP address is automatically assigned to the instance. If the InternetMaxBandwidthOut value of the instance is greater than 0 Mbit/s, call the [AllocatePublicIpAddress](https://help.aliyun.com/document_detail/25544.html) operation to assign a public IP address to the instance. If the InternetMaxBandwidthOut value of the instance is 0 Mbit/s, call the [ModifyInstanceNetworkSpec](https://help.aliyun.com/document_detail/2679879.html) operation to set InternetMaxBandwidthOut to a value greater than 0 Mbit/s and then call the [AllocatePublicIpAddress](https://help.aliyun.com/document_detail/25544.html) operation to assign a public IP address to the instance.
        >  For the limits on the sum of maximum public bandwidths of ECS instances that use the pay-by-bandwidth billing method for network usage per region per Alibaba Cloud account, see the [Public bandwidth limits](~~25412#BandwidthQuota~~) section of the "Limits" topic.
        ### [](#)Suggestions
        **Instance type selection**: See [Overview of instance families](https://help.aliyun.com/document_detail/25378.html) or call the [DescribeInstanceTypes](https://help.aliyun.com/document_detail/25620.html) operation to query the performance data of instance types, or see [Instance type selection](https://help.aliyun.com/document_detail/58291.html) to learn about how to select instance types.
        **Query of available resources**: Call the [DescribeAvailableResource](https://help.aliyun.com/document_detail/66186.html) operation to query resources available in a specific region or zone.
        **User data**: If the instance type supports [user data](https://help.aliyun.com/document_detail/49121.html), you can use UserData to pass in user data. We recommend that you do not pass in confidential information, such as passwords or private keys, in plaintext as user data. This is because the system does not encrypt `UserData` values when API requests are sent. If you must pass in confidential information as user data, we recommend that you encrypt and encode the information in Base64 before you pass in the information. Then, decode and decrypt the information within the instance for subsequent use.
        
        @param request: CreateInstanceRequest
        @return: CreateInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_instance_with_options_async(request, runtime)

    def create_key_pair_with_options(
        self,
        request: ecs_20140526_models.CreateKeyPairRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateKeyPairResponse:
        """
        @summary Creates an SSH key pair. The system stores the public key and returns the unencrypted private key. The private key is encoded with PEM in the PKCS#8 format. You must properly store the private key and ensure its confidentiality.
        
        @description In addition to calling the CreateKeyPair operation to create a key pair, you can use a third-party tool to create a key pair and then call the [ImportKeyPair](https://help.aliyun.com/document_detail/51774.html) operation to upload the key pair to an Alibaba Cloud region.
        Up to 500 key pairs can be created in each region. For more information, see the "SSH key pair limits" section in [Limits](https://help.aliyun.com/document_detail/25412.html).
        
        @param request: CreateKeyPairRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateKeyPairResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateKeyPair',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateKeyPairResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_key_pair_with_options_async(
        self,
        request: ecs_20140526_models.CreateKeyPairRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateKeyPairResponse:
        """
        @summary Creates an SSH key pair. The system stores the public key and returns the unencrypted private key. The private key is encoded with PEM in the PKCS#8 format. You must properly store the private key and ensure its confidentiality.
        
        @description In addition to calling the CreateKeyPair operation to create a key pair, you can use a third-party tool to create a key pair and then call the [ImportKeyPair](https://help.aliyun.com/document_detail/51774.html) operation to upload the key pair to an Alibaba Cloud region.
        Up to 500 key pairs can be created in each region. For more information, see the "SSH key pair limits" section in [Limits](https://help.aliyun.com/document_detail/25412.html).
        
        @param request: CreateKeyPairRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateKeyPairResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateKeyPair',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateKeyPairResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_key_pair(
        self,
        request: ecs_20140526_models.CreateKeyPairRequest,
    ) -> ecs_20140526_models.CreateKeyPairResponse:
        """
        @summary Creates an SSH key pair. The system stores the public key and returns the unencrypted private key. The private key is encoded with PEM in the PKCS#8 format. You must properly store the private key and ensure its confidentiality.
        
        @description In addition to calling the CreateKeyPair operation to create a key pair, you can use a third-party tool to create a key pair and then call the [ImportKeyPair](https://help.aliyun.com/document_detail/51774.html) operation to upload the key pair to an Alibaba Cloud region.
        Up to 500 key pairs can be created in each region. For more information, see the "SSH key pair limits" section in [Limits](https://help.aliyun.com/document_detail/25412.html).
        
        @param request: CreateKeyPairRequest
        @return: CreateKeyPairResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_key_pair_with_options(request, runtime)

    async def create_key_pair_async(
        self,
        request: ecs_20140526_models.CreateKeyPairRequest,
    ) -> ecs_20140526_models.CreateKeyPairResponse:
        """
        @summary Creates an SSH key pair. The system stores the public key and returns the unencrypted private key. The private key is encoded with PEM in the PKCS#8 format. You must properly store the private key and ensure its confidentiality.
        
        @description In addition to calling the CreateKeyPair operation to create a key pair, you can use a third-party tool to create a key pair and then call the [ImportKeyPair](https://help.aliyun.com/document_detail/51774.html) operation to upload the key pair to an Alibaba Cloud region.
        Up to 500 key pairs can be created in each region. For more information, see the "SSH key pair limits" section in [Limits](https://help.aliyun.com/document_detail/25412.html).
        
        @param request: CreateKeyPairRequest
        @return: CreateKeyPairResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_key_pair_with_options_async(request, runtime)

    def create_launch_template_with_options(
        self,
        request: ecs_20140526_models.CreateLaunchTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateLaunchTemplateResponse:
        """
        @summary Creates a launch template. A launch template eliminates the need to configure a large number of parameters every time you create an Elastic Compute Service (ECS) instance.
        
        @description After you create a launch template by calling the CreateLaunchTemplate operation, a default version that has a version number of 1 is automatically generated for the launch template. You can call the `CreateLaunchTemplateVersion` operation to create additional versions for the launch template. Version numbers start from 1 and increment by 1. If you specify a launch template but do not specify a launch template version number when you call the [RunInstances](https://help.aliyun.com/document_detail/63440.html) operation to create instances, the default version of the launch template is used.
        Launch templates contain preset configurations that are used to create instances, such as the region ID, image ID, instance type, security group ID, and public bandwidth settings. If a specific parameter is not included in a launch template, you need to manually specify the parameter when you use the launch template to create instances.
        Take note of the following items:
        You can retain up to 30 launch templates in each region in your Alibaba Cloud account. Each launch template can have up to 30 versions.
        Most parameters in launch templates are optional. When you create a launch template, ECS does not verify the existence or validity of specified parameter values. The parameter values are verified only when you use the launch template to create instances.
        If you configured a specific parameter in a launch template, you cannot filter out the parameter when you call the [RunInstances](https://help.aliyun.com/document_detail/63440.html) operation to create instances from the launch template. For example, if you set `HostName` to LocalHost in a launch template but do not specify `HostName` when you call the `RunInstances` operation to create instances from the launch template, the hostname of the created instances is `LocalHost`. If you want to overwrite `LocalHost`, which is the value of HostName in the launch template, you can set `HostName` to MyHost or a different value when you call the `RunInstances` operation.
        
        @param request: CreateLaunchTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLaunchTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_release_time):
            query['AutoReleaseTime'] = request.auto_release_time
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_period):
            query['AutoRenewPeriod'] = request.auto_renew_period
        if not UtilClient.is_unset(request.credit_specification):
            query['CreditSpecification'] = request.credit_specification
        if not UtilClient.is_unset(request.data_disk):
            query['DataDisk'] = request.data_disk
        if not UtilClient.is_unset(request.deletion_protection):
            query['DeletionProtection'] = request.deletion_protection
        if not UtilClient.is_unset(request.deployment_set_id):
            query['DeploymentSetId'] = request.deployment_set_id
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enable_vm_os_config):
            query['EnableVmOsConfig'] = request.enable_vm_os_config
        if not UtilClient.is_unset(request.host_name):
            query['HostName'] = request.host_name
        if not UtilClient.is_unset(request.http_endpoint):
            query['HttpEndpoint'] = request.http_endpoint
        if not UtilClient.is_unset(request.http_put_response_hop_limit):
            query['HttpPutResponseHopLimit'] = request.http_put_response_hop_limit
        if not UtilClient.is_unset(request.http_tokens):
            query['HttpTokens'] = request.http_tokens
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.image_options):
            query['ImageOptions'] = request.image_options
        if not UtilClient.is_unset(request.image_owner_alias):
            query['ImageOwnerAlias'] = request.image_owner_alias
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.internet_max_bandwidth_in):
            query['InternetMaxBandwidthIn'] = request.internet_max_bandwidth_in
        if not UtilClient.is_unset(request.internet_max_bandwidth_out):
            query['InternetMaxBandwidthOut'] = request.internet_max_bandwidth_out
        if not UtilClient.is_unset(request.io_optimized):
            query['IoOptimized'] = request.io_optimized
        if not UtilClient.is_unset(request.ipv_6address_count):
            query['Ipv6AddressCount'] = request.ipv_6address_count
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.launch_template_name):
            query['LaunchTemplateName'] = request.launch_template_name
        if not UtilClient.is_unset(request.network_interface):
            query['NetworkInterface'] = request.network_interface
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.password_inherit):
            query['PasswordInherit'] = request.password_inherit
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.ram_role_name):
            query['RamRoleName'] = request.ram_role_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_enhancement_strategy):
            query['SecurityEnhancementStrategy'] = request.security_enhancement_strategy
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_ids):
            query['SecurityGroupIds'] = request.security_group_ids
        if not UtilClient.is_unset(request.spot_duration):
            query['SpotDuration'] = request.spot_duration
        if not UtilClient.is_unset(request.spot_price_limit):
            query['SpotPriceLimit'] = request.spot_price_limit
        if not UtilClient.is_unset(request.spot_strategy):
            query['SpotStrategy'] = request.spot_strategy
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.template_resource_group_id):
            query['TemplateResourceGroupId'] = request.template_resource_group_id
        if not UtilClient.is_unset(request.template_tag):
            query['TemplateTag'] = request.template_tag
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.version_description):
            query['VersionDescription'] = request.version_description
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.system_disk):
            query['SystemDisk'] = request.system_disk
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLaunchTemplate',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateLaunchTemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_launch_template_with_options_async(
        self,
        request: ecs_20140526_models.CreateLaunchTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateLaunchTemplateResponse:
        """
        @summary Creates a launch template. A launch template eliminates the need to configure a large number of parameters every time you create an Elastic Compute Service (ECS) instance.
        
        @description After you create a launch template by calling the CreateLaunchTemplate operation, a default version that has a version number of 1 is automatically generated for the launch template. You can call the `CreateLaunchTemplateVersion` operation to create additional versions for the launch template. Version numbers start from 1 and increment by 1. If you specify a launch template but do not specify a launch template version number when you call the [RunInstances](https://help.aliyun.com/document_detail/63440.html) operation to create instances, the default version of the launch template is used.
        Launch templates contain preset configurations that are used to create instances, such as the region ID, image ID, instance type, security group ID, and public bandwidth settings. If a specific parameter is not included in a launch template, you need to manually specify the parameter when you use the launch template to create instances.
        Take note of the following items:
        You can retain up to 30 launch templates in each region in your Alibaba Cloud account. Each launch template can have up to 30 versions.
        Most parameters in launch templates are optional. When you create a launch template, ECS does not verify the existence or validity of specified parameter values. The parameter values are verified only when you use the launch template to create instances.
        If you configured a specific parameter in a launch template, you cannot filter out the parameter when you call the [RunInstances](https://help.aliyun.com/document_detail/63440.html) operation to create instances from the launch template. For example, if you set `HostName` to LocalHost in a launch template but do not specify `HostName` when you call the `RunInstances` operation to create instances from the launch template, the hostname of the created instances is `LocalHost`. If you want to overwrite `LocalHost`, which is the value of HostName in the launch template, you can set `HostName` to MyHost or a different value when you call the `RunInstances` operation.
        
        @param request: CreateLaunchTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLaunchTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_release_time):
            query['AutoReleaseTime'] = request.auto_release_time
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_period):
            query['AutoRenewPeriod'] = request.auto_renew_period
        if not UtilClient.is_unset(request.credit_specification):
            query['CreditSpecification'] = request.credit_specification
        if not UtilClient.is_unset(request.data_disk):
            query['DataDisk'] = request.data_disk
        if not UtilClient.is_unset(request.deletion_protection):
            query['DeletionProtection'] = request.deletion_protection
        if not UtilClient.is_unset(request.deployment_set_id):
            query['DeploymentSetId'] = request.deployment_set_id
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enable_vm_os_config):
            query['EnableVmOsConfig'] = request.enable_vm_os_config
        if not UtilClient.is_unset(request.host_name):
            query['HostName'] = request.host_name
        if not UtilClient.is_unset(request.http_endpoint):
            query['HttpEndpoint'] = request.http_endpoint
        if not UtilClient.is_unset(request.http_put_response_hop_limit):
            query['HttpPutResponseHopLimit'] = request.http_put_response_hop_limit
        if not UtilClient.is_unset(request.http_tokens):
            query['HttpTokens'] = request.http_tokens
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.image_options):
            query['ImageOptions'] = request.image_options
        if not UtilClient.is_unset(request.image_owner_alias):
            query['ImageOwnerAlias'] = request.image_owner_alias
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.internet_max_bandwidth_in):
            query['InternetMaxBandwidthIn'] = request.internet_max_bandwidth_in
        if not UtilClient.is_unset(request.internet_max_bandwidth_out):
            query['InternetMaxBandwidthOut'] = request.internet_max_bandwidth_out
        if not UtilClient.is_unset(request.io_optimized):
            query['IoOptimized'] = request.io_optimized
        if not UtilClient.is_unset(request.ipv_6address_count):
            query['Ipv6AddressCount'] = request.ipv_6address_count
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.launch_template_name):
            query['LaunchTemplateName'] = request.launch_template_name
        if not UtilClient.is_unset(request.network_interface):
            query['NetworkInterface'] = request.network_interface
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.password_inherit):
            query['PasswordInherit'] = request.password_inherit
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.ram_role_name):
            query['RamRoleName'] = request.ram_role_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_enhancement_strategy):
            query['SecurityEnhancementStrategy'] = request.security_enhancement_strategy
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_ids):
            query['SecurityGroupIds'] = request.security_group_ids
        if not UtilClient.is_unset(request.spot_duration):
            query['SpotDuration'] = request.spot_duration
        if not UtilClient.is_unset(request.spot_price_limit):
            query['SpotPriceLimit'] = request.spot_price_limit
        if not UtilClient.is_unset(request.spot_strategy):
            query['SpotStrategy'] = request.spot_strategy
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.template_resource_group_id):
            query['TemplateResourceGroupId'] = request.template_resource_group_id
        if not UtilClient.is_unset(request.template_tag):
            query['TemplateTag'] = request.template_tag
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.version_description):
            query['VersionDescription'] = request.version_description
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.system_disk):
            query['SystemDisk'] = request.system_disk
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLaunchTemplate',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateLaunchTemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_launch_template(
        self,
        request: ecs_20140526_models.CreateLaunchTemplateRequest,
    ) -> ecs_20140526_models.CreateLaunchTemplateResponse:
        """
        @summary Creates a launch template. A launch template eliminates the need to configure a large number of parameters every time you create an Elastic Compute Service (ECS) instance.
        
        @description After you create a launch template by calling the CreateLaunchTemplate operation, a default version that has a version number of 1 is automatically generated for the launch template. You can call the `CreateLaunchTemplateVersion` operation to create additional versions for the launch template. Version numbers start from 1 and increment by 1. If you specify a launch template but do not specify a launch template version number when you call the [RunInstances](https://help.aliyun.com/document_detail/63440.html) operation to create instances, the default version of the launch template is used.
        Launch templates contain preset configurations that are used to create instances, such as the region ID, image ID, instance type, security group ID, and public bandwidth settings. If a specific parameter is not included in a launch template, you need to manually specify the parameter when you use the launch template to create instances.
        Take note of the following items:
        You can retain up to 30 launch templates in each region in your Alibaba Cloud account. Each launch template can have up to 30 versions.
        Most parameters in launch templates are optional. When you create a launch template, ECS does not verify the existence or validity of specified parameter values. The parameter values are verified only when you use the launch template to create instances.
        If you configured a specific parameter in a launch template, you cannot filter out the parameter when you call the [RunInstances](https://help.aliyun.com/document_detail/63440.html) operation to create instances from the launch template. For example, if you set `HostName` to LocalHost in a launch template but do not specify `HostName` when you call the `RunInstances` operation to create instances from the launch template, the hostname of the created instances is `LocalHost`. If you want to overwrite `LocalHost`, which is the value of HostName in the launch template, you can set `HostName` to MyHost or a different value when you call the `RunInstances` operation.
        
        @param request: CreateLaunchTemplateRequest
        @return: CreateLaunchTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_launch_template_with_options(request, runtime)

    async def create_launch_template_async(
        self,
        request: ecs_20140526_models.CreateLaunchTemplateRequest,
    ) -> ecs_20140526_models.CreateLaunchTemplateResponse:
        """
        @summary Creates a launch template. A launch template eliminates the need to configure a large number of parameters every time you create an Elastic Compute Service (ECS) instance.
        
        @description After you create a launch template by calling the CreateLaunchTemplate operation, a default version that has a version number of 1 is automatically generated for the launch template. You can call the `CreateLaunchTemplateVersion` operation to create additional versions for the launch template. Version numbers start from 1 and increment by 1. If you specify a launch template but do not specify a launch template version number when you call the [RunInstances](https://help.aliyun.com/document_detail/63440.html) operation to create instances, the default version of the launch template is used.
        Launch templates contain preset configurations that are used to create instances, such as the region ID, image ID, instance type, security group ID, and public bandwidth settings. If a specific parameter is not included in a launch template, you need to manually specify the parameter when you use the launch template to create instances.
        Take note of the following items:
        You can retain up to 30 launch templates in each region in your Alibaba Cloud account. Each launch template can have up to 30 versions.
        Most parameters in launch templates are optional. When you create a launch template, ECS does not verify the existence or validity of specified parameter values. The parameter values are verified only when you use the launch template to create instances.
        If you configured a specific parameter in a launch template, you cannot filter out the parameter when you call the [RunInstances](https://help.aliyun.com/document_detail/63440.html) operation to create instances from the launch template. For example, if you set `HostName` to LocalHost in a launch template but do not specify `HostName` when you call the `RunInstances` operation to create instances from the launch template, the hostname of the created instances is `LocalHost`. If you want to overwrite `LocalHost`, which is the value of HostName in the launch template, you can set `HostName` to MyHost or a different value when you call the `RunInstances` operation.
        
        @param request: CreateLaunchTemplateRequest
        @return: CreateLaunchTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_launch_template_with_options_async(request, runtime)

    def create_launch_template_version_with_options(
        self,
        request: ecs_20140526_models.CreateLaunchTemplateVersionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateLaunchTemplateVersionResponse:
        """
        @summary Creates a version for a launch template. You can use the created version to create Elastic Compute Service (ECS) instances, scaling groups, or auto provisioning groups.
        
        @description ## [](#)Usage notes
        If you want to modify the parameters of a launch template version, you can create another version with different parameter settings for the launch template. You can create up to 30 versions for each launch template.
        
        @param request: CreateLaunchTemplateVersionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLaunchTemplateVersionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_release_time):
            query['AutoReleaseTime'] = request.auto_release_time
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_period):
            query['AutoRenewPeriod'] = request.auto_renew_period
        if not UtilClient.is_unset(request.credit_specification):
            query['CreditSpecification'] = request.credit_specification
        if not UtilClient.is_unset(request.data_disk):
            query['DataDisk'] = request.data_disk
        if not UtilClient.is_unset(request.deletion_protection):
            query['DeletionProtection'] = request.deletion_protection
        if not UtilClient.is_unset(request.deployment_set_id):
            query['DeploymentSetId'] = request.deployment_set_id
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enable_vm_os_config):
            query['EnableVmOsConfig'] = request.enable_vm_os_config
        if not UtilClient.is_unset(request.host_name):
            query['HostName'] = request.host_name
        if not UtilClient.is_unset(request.http_endpoint):
            query['HttpEndpoint'] = request.http_endpoint
        if not UtilClient.is_unset(request.http_put_response_hop_limit):
            query['HttpPutResponseHopLimit'] = request.http_put_response_hop_limit
        if not UtilClient.is_unset(request.http_tokens):
            query['HttpTokens'] = request.http_tokens
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.image_options):
            query['ImageOptions'] = request.image_options
        if not UtilClient.is_unset(request.image_owner_alias):
            query['ImageOwnerAlias'] = request.image_owner_alias
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.internet_max_bandwidth_in):
            query['InternetMaxBandwidthIn'] = request.internet_max_bandwidth_in
        if not UtilClient.is_unset(request.internet_max_bandwidth_out):
            query['InternetMaxBandwidthOut'] = request.internet_max_bandwidth_out
        if not UtilClient.is_unset(request.io_optimized):
            query['IoOptimized'] = request.io_optimized
        if not UtilClient.is_unset(request.ipv_6address_count):
            query['Ipv6AddressCount'] = request.ipv_6address_count
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.launch_template_id):
            query['LaunchTemplateId'] = request.launch_template_id
        if not UtilClient.is_unset(request.launch_template_name):
            query['LaunchTemplateName'] = request.launch_template_name
        if not UtilClient.is_unset(request.network_interface):
            query['NetworkInterface'] = request.network_interface
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.password_inherit):
            query['PasswordInherit'] = request.password_inherit
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.ram_role_name):
            query['RamRoleName'] = request.ram_role_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_enhancement_strategy):
            query['SecurityEnhancementStrategy'] = request.security_enhancement_strategy
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_ids):
            query['SecurityGroupIds'] = request.security_group_ids
        if not UtilClient.is_unset(request.spot_duration):
            query['SpotDuration'] = request.spot_duration
        if not UtilClient.is_unset(request.spot_price_limit):
            query['SpotPriceLimit'] = request.spot_price_limit
        if not UtilClient.is_unset(request.spot_strategy):
            query['SpotStrategy'] = request.spot_strategy
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.version_description):
            query['VersionDescription'] = request.version_description
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.system_disk):
            query['SystemDisk'] = request.system_disk
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLaunchTemplateVersion',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateLaunchTemplateVersionResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_launch_template_version_with_options_async(
        self,
        request: ecs_20140526_models.CreateLaunchTemplateVersionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateLaunchTemplateVersionResponse:
        """
        @summary Creates a version for a launch template. You can use the created version to create Elastic Compute Service (ECS) instances, scaling groups, or auto provisioning groups.
        
        @description ## [](#)Usage notes
        If you want to modify the parameters of a launch template version, you can create another version with different parameter settings for the launch template. You can create up to 30 versions for each launch template.
        
        @param request: CreateLaunchTemplateVersionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLaunchTemplateVersionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_release_time):
            query['AutoReleaseTime'] = request.auto_release_time
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_period):
            query['AutoRenewPeriod'] = request.auto_renew_period
        if not UtilClient.is_unset(request.credit_specification):
            query['CreditSpecification'] = request.credit_specification
        if not UtilClient.is_unset(request.data_disk):
            query['DataDisk'] = request.data_disk
        if not UtilClient.is_unset(request.deletion_protection):
            query['DeletionProtection'] = request.deletion_protection
        if not UtilClient.is_unset(request.deployment_set_id):
            query['DeploymentSetId'] = request.deployment_set_id
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enable_vm_os_config):
            query['EnableVmOsConfig'] = request.enable_vm_os_config
        if not UtilClient.is_unset(request.host_name):
            query['HostName'] = request.host_name
        if not UtilClient.is_unset(request.http_endpoint):
            query['HttpEndpoint'] = request.http_endpoint
        if not UtilClient.is_unset(request.http_put_response_hop_limit):
            query['HttpPutResponseHopLimit'] = request.http_put_response_hop_limit
        if not UtilClient.is_unset(request.http_tokens):
            query['HttpTokens'] = request.http_tokens
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.image_options):
            query['ImageOptions'] = request.image_options
        if not UtilClient.is_unset(request.image_owner_alias):
            query['ImageOwnerAlias'] = request.image_owner_alias
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.internet_max_bandwidth_in):
            query['InternetMaxBandwidthIn'] = request.internet_max_bandwidth_in
        if not UtilClient.is_unset(request.internet_max_bandwidth_out):
            query['InternetMaxBandwidthOut'] = request.internet_max_bandwidth_out
        if not UtilClient.is_unset(request.io_optimized):
            query['IoOptimized'] = request.io_optimized
        if not UtilClient.is_unset(request.ipv_6address_count):
            query['Ipv6AddressCount'] = request.ipv_6address_count
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.launch_template_id):
            query['LaunchTemplateId'] = request.launch_template_id
        if not UtilClient.is_unset(request.launch_template_name):
            query['LaunchTemplateName'] = request.launch_template_name
        if not UtilClient.is_unset(request.network_interface):
            query['NetworkInterface'] = request.network_interface
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.password_inherit):
            query['PasswordInherit'] = request.password_inherit
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.ram_role_name):
            query['RamRoleName'] = request.ram_role_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_enhancement_strategy):
            query['SecurityEnhancementStrategy'] = request.security_enhancement_strategy
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_ids):
            query['SecurityGroupIds'] = request.security_group_ids
        if not UtilClient.is_unset(request.spot_duration):
            query['SpotDuration'] = request.spot_duration
        if not UtilClient.is_unset(request.spot_price_limit):
            query['SpotPriceLimit'] = request.spot_price_limit
        if not UtilClient.is_unset(request.spot_strategy):
            query['SpotStrategy'] = request.spot_strategy
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.version_description):
            query['VersionDescription'] = request.version_description
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.system_disk):
            query['SystemDisk'] = request.system_disk
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLaunchTemplateVersion',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateLaunchTemplateVersionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_launch_template_version(
        self,
        request: ecs_20140526_models.CreateLaunchTemplateVersionRequest,
    ) -> ecs_20140526_models.CreateLaunchTemplateVersionResponse:
        """
        @summary Creates a version for a launch template. You can use the created version to create Elastic Compute Service (ECS) instances, scaling groups, or auto provisioning groups.
        
        @description ## [](#)Usage notes
        If you want to modify the parameters of a launch template version, you can create another version with different parameter settings for the launch template. You can create up to 30 versions for each launch template.
        
        @param request: CreateLaunchTemplateVersionRequest
        @return: CreateLaunchTemplateVersionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_launch_template_version_with_options(request, runtime)

    async def create_launch_template_version_async(
        self,
        request: ecs_20140526_models.CreateLaunchTemplateVersionRequest,
    ) -> ecs_20140526_models.CreateLaunchTemplateVersionResponse:
        """
        @summary Creates a version for a launch template. You can use the created version to create Elastic Compute Service (ECS) instances, scaling groups, or auto provisioning groups.
        
        @description ## [](#)Usage notes
        If you want to modify the parameters of a launch template version, you can create another version with different parameter settings for the launch template. You can create up to 30 versions for each launch template.
        
        @param request: CreateLaunchTemplateVersionRequest
        @return: CreateLaunchTemplateVersionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_launch_template_version_with_options_async(request, runtime)

    def create_nat_gateway_with_options(
        self,
        request: ecs_20140526_models.CreateNatGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateNatGatewayResponse:
        """
        @deprecated OpenAPI CreateNatGateway is deprecated, please use Vpc::2016-04-28::CreateNatGateway instead.
        
        @summary CreateNatGateway
        
        @param request: CreateNatGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateNatGatewayResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package):
            query['BandwidthPackage'] = request.bandwidth_package
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateNatGateway',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateNatGatewayResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_nat_gateway_with_options_async(
        self,
        request: ecs_20140526_models.CreateNatGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateNatGatewayResponse:
        """
        @deprecated OpenAPI CreateNatGateway is deprecated, please use Vpc::2016-04-28::CreateNatGateway instead.
        
        @summary CreateNatGateway
        
        @param request: CreateNatGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateNatGatewayResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package):
            query['BandwidthPackage'] = request.bandwidth_package
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateNatGateway',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateNatGatewayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_nat_gateway(
        self,
        request: ecs_20140526_models.CreateNatGatewayRequest,
    ) -> ecs_20140526_models.CreateNatGatewayResponse:
        """
        @deprecated OpenAPI CreateNatGateway is deprecated, please use Vpc::2016-04-28::CreateNatGateway instead.
        
        @summary CreateNatGateway
        
        @param request: CreateNatGatewayRequest
        @return: CreateNatGatewayResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.create_nat_gateway_with_options(request, runtime)

    async def create_nat_gateway_async(
        self,
        request: ecs_20140526_models.CreateNatGatewayRequest,
    ) -> ecs_20140526_models.CreateNatGatewayResponse:
        """
        @deprecated OpenAPI CreateNatGateway is deprecated, please use Vpc::2016-04-28::CreateNatGateway instead.
        
        @summary CreateNatGateway
        
        @param request: CreateNatGatewayRequest
        @return: CreateNatGatewayResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_nat_gateway_with_options_async(request, runtime)

    def create_network_interface_with_options(
        self,
        request: ecs_20140526_models.CreateNetworkInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateNetworkInterfaceResponse:
        """
        @summary Creates an elastic network interface (ENI). You can specify an IP address as the primary private IP address of the ENI.
        
        @description Take note of the following items:
        This operation is a synchronous operation. After an ENI is created, the ENI immediately enters the Available (`Available`) state and can be attached to an Elastic Compute Service (ECS) instance.
        If `NetworkInterfaceId` is empty in the response, no ENI is created. Recall the operation to create an ENI.
        An ENI can be attached only to a single ECS instance that resides in a virtual private cloud (VPC).
        When an ENI is detached from an ECS instance and attached to another ECS instance, the attributes of the ENI remain unchanged and network traffic is redirected to the new instance.
        When you call this operation to create an ENI, you can assign up to 49 secondary private IP addresses to the ENI.
        If you want to assign IPv6 addresses when you create an ENI, make sure that IPv6 is enabled for the vSwitch with which you want to associate the ENI. For more information, see [What is an IPv6 gateway?](https://help.aliyun.com/document_detail/98896.html)
        A limit is imposed on the number of ENIs that can be created per Alibaba Cloud region per account. You can view the quota limit in the ECS console. For more information, see [Manage ECS quotas](https://help.aliyun.com/document_detail/184115.html).
        ### [](#)Sample requests
        *Create an ENI**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.SecurityGroupId:  sg-bp10jztp6b0sdsyl***,   // Specify the ID of the security group in which to create the ENI.VSwitchId:  vsw-bp19wo63nleroq22g****,   // Specify the ID of the vSwitch to which to connect the ENI.
        *Create an ENI and specify an IP address as the primary private IP address of the ENI**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.SecurityGroupId:  sg-bp10jztp6b0sdsyl***,   // Specify the ID of the security group in which to create the ENI.VSwitchId:  vsw-bp19wo63nleroq22g****,   // Specify the ID of the vSwitch to which to connect the ENI.PrimaryIpAddress:  192.168.0.*,   // Specify an IP address as the primary private IP address of the ENI.
        
        @param request: CreateNetworkInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateNetworkInterfaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.connection_tracking_configuration):
            query['ConnectionTrackingConfiguration'] = request.connection_tracking_configuration
        if not UtilClient.is_unset(request.delete_on_release):
            query['DeleteOnRelease'] = request.delete_on_release
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enhanced_network):
            query['EnhancedNetwork'] = request.enhanced_network
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.ipv_4prefix):
            query['Ipv4Prefix'] = request.ipv_4prefix
        if not UtilClient.is_unset(request.ipv_4prefix_count):
            query['Ipv4PrefixCount'] = request.ipv_4prefix_count
        if not UtilClient.is_unset(request.ipv_6address):
            query['Ipv6Address'] = request.ipv_6address
        if not UtilClient.is_unset(request.ipv_6address_count):
            query['Ipv6AddressCount'] = request.ipv_6address_count
        if not UtilClient.is_unset(request.ipv_6prefix):
            query['Ipv6Prefix'] = request.ipv_6prefix
        if not UtilClient.is_unset(request.ipv_6prefix_count):
            query['Ipv6PrefixCount'] = request.ipv_6prefix_count
        if not UtilClient.is_unset(request.network_interface_name):
            query['NetworkInterfaceName'] = request.network_interface_name
        if not UtilClient.is_unset(request.network_interface_traffic_config):
            query['NetworkInterfaceTrafficConfig'] = request.network_interface_traffic_config
        if not UtilClient.is_unset(request.network_interface_traffic_mode):
            query['NetworkInterfaceTrafficMode'] = request.network_interface_traffic_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.primary_ip_address):
            query['PrimaryIpAddress'] = request.primary_ip_address
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.queue_number):
            query['QueueNumber'] = request.queue_number
        if not UtilClient.is_unset(request.queue_pair_number):
            query['QueuePairNumber'] = request.queue_pair_number
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.rx_queue_size):
            query['RxQueueSize'] = request.rx_queue_size
        if not UtilClient.is_unset(request.secondary_private_ip_address_count):
            query['SecondaryPrivateIpAddressCount'] = request.secondary_private_ip_address_count
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_ids):
            query['SecurityGroupIds'] = request.security_group_ids
        if not UtilClient.is_unset(request.source_dest_check):
            query['SourceDestCheck'] = request.source_dest_check
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.tx_queue_size):
            query['TxQueueSize'] = request.tx_queue_size
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.visible):
            query['Visible'] = request.visible
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateNetworkInterface',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateNetworkInterfaceResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_network_interface_with_options_async(
        self,
        request: ecs_20140526_models.CreateNetworkInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateNetworkInterfaceResponse:
        """
        @summary Creates an elastic network interface (ENI). You can specify an IP address as the primary private IP address of the ENI.
        
        @description Take note of the following items:
        This operation is a synchronous operation. After an ENI is created, the ENI immediately enters the Available (`Available`) state and can be attached to an Elastic Compute Service (ECS) instance.
        If `NetworkInterfaceId` is empty in the response, no ENI is created. Recall the operation to create an ENI.
        An ENI can be attached only to a single ECS instance that resides in a virtual private cloud (VPC).
        When an ENI is detached from an ECS instance and attached to another ECS instance, the attributes of the ENI remain unchanged and network traffic is redirected to the new instance.
        When you call this operation to create an ENI, you can assign up to 49 secondary private IP addresses to the ENI.
        If you want to assign IPv6 addresses when you create an ENI, make sure that IPv6 is enabled for the vSwitch with which you want to associate the ENI. For more information, see [What is an IPv6 gateway?](https://help.aliyun.com/document_detail/98896.html)
        A limit is imposed on the number of ENIs that can be created per Alibaba Cloud region per account. You can view the quota limit in the ECS console. For more information, see [Manage ECS quotas](https://help.aliyun.com/document_detail/184115.html).
        ### [](#)Sample requests
        *Create an ENI**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.SecurityGroupId:  sg-bp10jztp6b0sdsyl***,   // Specify the ID of the security group in which to create the ENI.VSwitchId:  vsw-bp19wo63nleroq22g****,   // Specify the ID of the vSwitch to which to connect the ENI.
        *Create an ENI and specify an IP address as the primary private IP address of the ENI**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.SecurityGroupId:  sg-bp10jztp6b0sdsyl***,   // Specify the ID of the security group in which to create the ENI.VSwitchId:  vsw-bp19wo63nleroq22g****,   // Specify the ID of the vSwitch to which to connect the ENI.PrimaryIpAddress:  192.168.0.*,   // Specify an IP address as the primary private IP address of the ENI.
        
        @param request: CreateNetworkInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateNetworkInterfaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.connection_tracking_configuration):
            query['ConnectionTrackingConfiguration'] = request.connection_tracking_configuration
        if not UtilClient.is_unset(request.delete_on_release):
            query['DeleteOnRelease'] = request.delete_on_release
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enhanced_network):
            query['EnhancedNetwork'] = request.enhanced_network
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.ipv_4prefix):
            query['Ipv4Prefix'] = request.ipv_4prefix
        if not UtilClient.is_unset(request.ipv_4prefix_count):
            query['Ipv4PrefixCount'] = request.ipv_4prefix_count
        if not UtilClient.is_unset(request.ipv_6address):
            query['Ipv6Address'] = request.ipv_6address
        if not UtilClient.is_unset(request.ipv_6address_count):
            query['Ipv6AddressCount'] = request.ipv_6address_count
        if not UtilClient.is_unset(request.ipv_6prefix):
            query['Ipv6Prefix'] = request.ipv_6prefix
        if not UtilClient.is_unset(request.ipv_6prefix_count):
            query['Ipv6PrefixCount'] = request.ipv_6prefix_count
        if not UtilClient.is_unset(request.network_interface_name):
            query['NetworkInterfaceName'] = request.network_interface_name
        if not UtilClient.is_unset(request.network_interface_traffic_config):
            query['NetworkInterfaceTrafficConfig'] = request.network_interface_traffic_config
        if not UtilClient.is_unset(request.network_interface_traffic_mode):
            query['NetworkInterfaceTrafficMode'] = request.network_interface_traffic_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.primary_ip_address):
            query['PrimaryIpAddress'] = request.primary_ip_address
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.queue_number):
            query['QueueNumber'] = request.queue_number
        if not UtilClient.is_unset(request.queue_pair_number):
            query['QueuePairNumber'] = request.queue_pair_number
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.rx_queue_size):
            query['RxQueueSize'] = request.rx_queue_size
        if not UtilClient.is_unset(request.secondary_private_ip_address_count):
            query['SecondaryPrivateIpAddressCount'] = request.secondary_private_ip_address_count
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_ids):
            query['SecurityGroupIds'] = request.security_group_ids
        if not UtilClient.is_unset(request.source_dest_check):
            query['SourceDestCheck'] = request.source_dest_check
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.tx_queue_size):
            query['TxQueueSize'] = request.tx_queue_size
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.visible):
            query['Visible'] = request.visible
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateNetworkInterface',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateNetworkInterfaceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_network_interface(
        self,
        request: ecs_20140526_models.CreateNetworkInterfaceRequest,
    ) -> ecs_20140526_models.CreateNetworkInterfaceResponse:
        """
        @summary Creates an elastic network interface (ENI). You can specify an IP address as the primary private IP address of the ENI.
        
        @description Take note of the following items:
        This operation is a synchronous operation. After an ENI is created, the ENI immediately enters the Available (`Available`) state and can be attached to an Elastic Compute Service (ECS) instance.
        If `NetworkInterfaceId` is empty in the response, no ENI is created. Recall the operation to create an ENI.
        An ENI can be attached only to a single ECS instance that resides in a virtual private cloud (VPC).
        When an ENI is detached from an ECS instance and attached to another ECS instance, the attributes of the ENI remain unchanged and network traffic is redirected to the new instance.
        When you call this operation to create an ENI, you can assign up to 49 secondary private IP addresses to the ENI.
        If you want to assign IPv6 addresses when you create an ENI, make sure that IPv6 is enabled for the vSwitch with which you want to associate the ENI. For more information, see [What is an IPv6 gateway?](https://help.aliyun.com/document_detail/98896.html)
        A limit is imposed on the number of ENIs that can be created per Alibaba Cloud region per account. You can view the quota limit in the ECS console. For more information, see [Manage ECS quotas](https://help.aliyun.com/document_detail/184115.html).
        ### [](#)Sample requests
        *Create an ENI**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.SecurityGroupId:  sg-bp10jztp6b0sdsyl***,   // Specify the ID of the security group in which to create the ENI.VSwitchId:  vsw-bp19wo63nleroq22g****,   // Specify the ID of the vSwitch to which to connect the ENI.
        *Create an ENI and specify an IP address as the primary private IP address of the ENI**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.SecurityGroupId:  sg-bp10jztp6b0sdsyl***,   // Specify the ID of the security group in which to create the ENI.VSwitchId:  vsw-bp19wo63nleroq22g****,   // Specify the ID of the vSwitch to which to connect the ENI.PrimaryIpAddress:  192.168.0.*,   // Specify an IP address as the primary private IP address of the ENI.
        
        @param request: CreateNetworkInterfaceRequest
        @return: CreateNetworkInterfaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_network_interface_with_options(request, runtime)

    async def create_network_interface_async(
        self,
        request: ecs_20140526_models.CreateNetworkInterfaceRequest,
    ) -> ecs_20140526_models.CreateNetworkInterfaceResponse:
        """
        @summary Creates an elastic network interface (ENI). You can specify an IP address as the primary private IP address of the ENI.
        
        @description Take note of the following items:
        This operation is a synchronous operation. After an ENI is created, the ENI immediately enters the Available (`Available`) state and can be attached to an Elastic Compute Service (ECS) instance.
        If `NetworkInterfaceId` is empty in the response, no ENI is created. Recall the operation to create an ENI.
        An ENI can be attached only to a single ECS instance that resides in a virtual private cloud (VPC).
        When an ENI is detached from an ECS instance and attached to another ECS instance, the attributes of the ENI remain unchanged and network traffic is redirected to the new instance.
        When you call this operation to create an ENI, you can assign up to 49 secondary private IP addresses to the ENI.
        If you want to assign IPv6 addresses when you create an ENI, make sure that IPv6 is enabled for the vSwitch with which you want to associate the ENI. For more information, see [What is an IPv6 gateway?](https://help.aliyun.com/document_detail/98896.html)
        A limit is imposed on the number of ENIs that can be created per Alibaba Cloud region per account. You can view the quota limit in the ECS console. For more information, see [Manage ECS quotas](https://help.aliyun.com/document_detail/184115.html).
        ### [](#)Sample requests
        *Create an ENI**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.SecurityGroupId:  sg-bp10jztp6b0sdsyl***,   // Specify the ID of the security group in which to create the ENI.VSwitchId:  vsw-bp19wo63nleroq22g****,   // Specify the ID of the vSwitch to which to connect the ENI.
        *Create an ENI and specify an IP address as the primary private IP address of the ENI**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.SecurityGroupId:  sg-bp10jztp6b0sdsyl***,   // Specify the ID of the security group in which to create the ENI.VSwitchId:  vsw-bp19wo63nleroq22g****,   // Specify the ID of the vSwitch to which to connect the ENI.PrimaryIpAddress:  192.168.0.*,   // Specify an IP address as the primary private IP address of the ENI.
        
        @param request: CreateNetworkInterfaceRequest
        @return: CreateNetworkInterfaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_network_interface_with_options_async(request, runtime)

    def create_network_interface_permission_with_options(
        self,
        request: ecs_20140526_models.CreateNetworkInterfacePermissionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateNetworkInterfacePermissionResponse:
        """
        @summary Grants a permission on an elastic network interface (ENI) to an Alibaba Cloud partner (a certified ISV) or an individual user.
        
        @description Before you call this operation, submit a ticket to apply for using this operation.
        
        @param request: CreateNetworkInterfacePermissionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateNetworkInterfacePermissionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.account_id):
            query['AccountId'] = request.account_id
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.permission):
            query['Permission'] = request.permission
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateNetworkInterfacePermission',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateNetworkInterfacePermissionResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_network_interface_permission_with_options_async(
        self,
        request: ecs_20140526_models.CreateNetworkInterfacePermissionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateNetworkInterfacePermissionResponse:
        """
        @summary Grants a permission on an elastic network interface (ENI) to an Alibaba Cloud partner (a certified ISV) or an individual user.
        
        @description Before you call this operation, submit a ticket to apply for using this operation.
        
        @param request: CreateNetworkInterfacePermissionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateNetworkInterfacePermissionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.account_id):
            query['AccountId'] = request.account_id
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.permission):
            query['Permission'] = request.permission
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateNetworkInterfacePermission',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateNetworkInterfacePermissionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_network_interface_permission(
        self,
        request: ecs_20140526_models.CreateNetworkInterfacePermissionRequest,
    ) -> ecs_20140526_models.CreateNetworkInterfacePermissionResponse:
        """
        @summary Grants a permission on an elastic network interface (ENI) to an Alibaba Cloud partner (a certified ISV) or an individual user.
        
        @description Before you call this operation, submit a ticket to apply for using this operation.
        
        @param request: CreateNetworkInterfacePermissionRequest
        @return: CreateNetworkInterfacePermissionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_network_interface_permission_with_options(request, runtime)

    async def create_network_interface_permission_async(
        self,
        request: ecs_20140526_models.CreateNetworkInterfacePermissionRequest,
    ) -> ecs_20140526_models.CreateNetworkInterfacePermissionResponse:
        """
        @summary Grants a permission on an elastic network interface (ENI) to an Alibaba Cloud partner (a certified ISV) or an individual user.
        
        @description Before you call this operation, submit a ticket to apply for using this operation.
        
        @param request: CreateNetworkInterfacePermissionRequest
        @return: CreateNetworkInterfacePermissionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_network_interface_permission_with_options_async(request, runtime)

    def create_physical_connection_with_options(
        self,
        request: ecs_20140526_models.CreatePhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreatePhysicalConnectionResponse:
        """
        @deprecated OpenAPI CreatePhysicalConnection is deprecated, please use Vpc::2016-04-28::CreatePhysicalConnection instead.
        
        @summary CreatePhysicalConnection
        
        @param request: CreatePhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePhysicalConnectionResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.access_point_id):
            query['AccessPointId'] = request.access_point_id
        if not UtilClient.is_unset(request.circuit_code):
            query['CircuitCode'] = request.circuit_code
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.line_operator):
            query['LineOperator'] = request.line_operator
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_location):
            query['PeerLocation'] = request.peer_location
        if not UtilClient.is_unset(request.port_type):
            query['PortType'] = request.port_type
        if not UtilClient.is_unset(request.redundant_physical_connection_id):
            query['RedundantPhysicalConnectionId'] = request.redundant_physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.bandwidth):
            query['bandwidth'] = request.bandwidth
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreatePhysicalConnection',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreatePhysicalConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_physical_connection_with_options_async(
        self,
        request: ecs_20140526_models.CreatePhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreatePhysicalConnectionResponse:
        """
        @deprecated OpenAPI CreatePhysicalConnection is deprecated, please use Vpc::2016-04-28::CreatePhysicalConnection instead.
        
        @summary CreatePhysicalConnection
        
        @param request: CreatePhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePhysicalConnectionResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.access_point_id):
            query['AccessPointId'] = request.access_point_id
        if not UtilClient.is_unset(request.circuit_code):
            query['CircuitCode'] = request.circuit_code
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.line_operator):
            query['LineOperator'] = request.line_operator
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_location):
            query['PeerLocation'] = request.peer_location
        if not UtilClient.is_unset(request.port_type):
            query['PortType'] = request.port_type
        if not UtilClient.is_unset(request.redundant_physical_connection_id):
            query['RedundantPhysicalConnectionId'] = request.redundant_physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.bandwidth):
            query['bandwidth'] = request.bandwidth
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreatePhysicalConnection',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreatePhysicalConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_physical_connection(
        self,
        request: ecs_20140526_models.CreatePhysicalConnectionRequest,
    ) -> ecs_20140526_models.CreatePhysicalConnectionResponse:
        """
        @deprecated OpenAPI CreatePhysicalConnection is deprecated, please use Vpc::2016-04-28::CreatePhysicalConnection instead.
        
        @summary CreatePhysicalConnection
        
        @param request: CreatePhysicalConnectionRequest
        @return: CreatePhysicalConnectionResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.create_physical_connection_with_options(request, runtime)

    async def create_physical_connection_async(
        self,
        request: ecs_20140526_models.CreatePhysicalConnectionRequest,
    ) -> ecs_20140526_models.CreatePhysicalConnectionResponse:
        """
        @deprecated OpenAPI CreatePhysicalConnection is deprecated, please use Vpc::2016-04-28::CreatePhysicalConnection instead.
        
        @summary CreatePhysicalConnection
        
        @param request: CreatePhysicalConnectionRequest
        @return: CreatePhysicalConnectionResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_physical_connection_with_options_async(request, runtime)

    def create_port_range_list_with_options(
        self,
        request: ecs_20140526_models.CreatePortRangeListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreatePortRangeListResponse:
        """
        @summary Creates a port list. You can associate a port list with resources, such as security groups.
        
        @param request: CreatePortRangeListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePortRangeListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.entry):
            query['Entry'] = request.entry
        if not UtilClient.is_unset(request.max_entries):
            query['MaxEntries'] = request.max_entries
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_range_list_name):
            query['PortRangeListName'] = request.port_range_list_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreatePortRangeList',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreatePortRangeListResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_port_range_list_with_options_async(
        self,
        request: ecs_20140526_models.CreatePortRangeListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreatePortRangeListResponse:
        """
        @summary Creates a port list. You can associate a port list with resources, such as security groups.
        
        @param request: CreatePortRangeListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePortRangeListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.entry):
            query['Entry'] = request.entry
        if not UtilClient.is_unset(request.max_entries):
            query['MaxEntries'] = request.max_entries
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_range_list_name):
            query['PortRangeListName'] = request.port_range_list_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreatePortRangeList',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreatePortRangeListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_port_range_list(
        self,
        request: ecs_20140526_models.CreatePortRangeListRequest,
    ) -> ecs_20140526_models.CreatePortRangeListResponse:
        """
        @summary Creates a port list. You can associate a port list with resources, such as security groups.
        
        @param request: CreatePortRangeListRequest
        @return: CreatePortRangeListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_port_range_list_with_options(request, runtime)

    async def create_port_range_list_async(
        self,
        request: ecs_20140526_models.CreatePortRangeListRequest,
    ) -> ecs_20140526_models.CreatePortRangeListResponse:
        """
        @summary Creates a port list. You can associate a port list with resources, such as security groups.
        
        @param request: CreatePortRangeListRequest
        @return: CreatePortRangeListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_port_range_list_with_options_async(request, runtime)

    def create_prefix_list_with_options(
        self,
        request: ecs_20140526_models.CreatePrefixListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreatePrefixListResponse:
        """
        @summary Creates a prefix list.
        
        @description ## [](#)Usage notes
        A prefix list is a collection of network prefixes (CIDR blocks) and can be referenced to configure network rules for other resources. For more information, see [Overview](https://help.aliyun.com/document_detail/206223.html).
        When you create a prefix list, take note of the following items:
        You must specify an IP address family (IPv4 or IPv6) for the prefix list, and cannot change the IP address family after the prefix list is created. You cannot combine IPv4 and IPv6 CIDR blocks in a single prefix list.
        You must specify the maximum number of entries that the prefix list can contain. You cannot modify the maximum number of entries after the prefix list is created.
        You can specify entries for the prefix list. Each entry consists of a CIDR block and the description for the CIDR block. The total number of entries cannot exceed the maximum number of entries that you specified.
        For more information about the limits on prefix lists and other resources, see [Limits](https://help.aliyun.com/document_detail/25412.html).
        You can create Resource Access Management (RAM) users and grant them minimum permissions. This eliminates the need to share the AccessKey pair of your Alibaba Cloud account with other users and reduces security risks for your enterprises. For information about how to grant permissions on prefix lists to RAM users, see [Grant a RAM user permissions on prefix lists](https://help.aliyun.com/document_detail/206175.html)
        
        @param request: CreatePrefixListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePrefixListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.address_family):
            query['AddressFamily'] = request.address_family
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.entry):
            query['Entry'] = request.entry
        if not UtilClient.is_unset(request.max_entries):
            query['MaxEntries'] = request.max_entries
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_name):
            query['PrefixListName'] = request.prefix_list_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreatePrefixList',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreatePrefixListResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_prefix_list_with_options_async(
        self,
        request: ecs_20140526_models.CreatePrefixListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreatePrefixListResponse:
        """
        @summary Creates a prefix list.
        
        @description ## [](#)Usage notes
        A prefix list is a collection of network prefixes (CIDR blocks) and can be referenced to configure network rules for other resources. For more information, see [Overview](https://help.aliyun.com/document_detail/206223.html).
        When you create a prefix list, take note of the following items:
        You must specify an IP address family (IPv4 or IPv6) for the prefix list, and cannot change the IP address family after the prefix list is created. You cannot combine IPv4 and IPv6 CIDR blocks in a single prefix list.
        You must specify the maximum number of entries that the prefix list can contain. You cannot modify the maximum number of entries after the prefix list is created.
        You can specify entries for the prefix list. Each entry consists of a CIDR block and the description for the CIDR block. The total number of entries cannot exceed the maximum number of entries that you specified.
        For more information about the limits on prefix lists and other resources, see [Limits](https://help.aliyun.com/document_detail/25412.html).
        You can create Resource Access Management (RAM) users and grant them minimum permissions. This eliminates the need to share the AccessKey pair of your Alibaba Cloud account with other users and reduces security risks for your enterprises. For information about how to grant permissions on prefix lists to RAM users, see [Grant a RAM user permissions on prefix lists](https://help.aliyun.com/document_detail/206175.html)
        
        @param request: CreatePrefixListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePrefixListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.address_family):
            query['AddressFamily'] = request.address_family
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.entry):
            query['Entry'] = request.entry
        if not UtilClient.is_unset(request.max_entries):
            query['MaxEntries'] = request.max_entries
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_name):
            query['PrefixListName'] = request.prefix_list_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreatePrefixList',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreatePrefixListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_prefix_list(
        self,
        request: ecs_20140526_models.CreatePrefixListRequest,
    ) -> ecs_20140526_models.CreatePrefixListResponse:
        """
        @summary Creates a prefix list.
        
        @description ## [](#)Usage notes
        A prefix list is a collection of network prefixes (CIDR blocks) and can be referenced to configure network rules for other resources. For more information, see [Overview](https://help.aliyun.com/document_detail/206223.html).
        When you create a prefix list, take note of the following items:
        You must specify an IP address family (IPv4 or IPv6) for the prefix list, and cannot change the IP address family after the prefix list is created. You cannot combine IPv4 and IPv6 CIDR blocks in a single prefix list.
        You must specify the maximum number of entries that the prefix list can contain. You cannot modify the maximum number of entries after the prefix list is created.
        You can specify entries for the prefix list. Each entry consists of a CIDR block and the description for the CIDR block. The total number of entries cannot exceed the maximum number of entries that you specified.
        For more information about the limits on prefix lists and other resources, see [Limits](https://help.aliyun.com/document_detail/25412.html).
        You can create Resource Access Management (RAM) users and grant them minimum permissions. This eliminates the need to share the AccessKey pair of your Alibaba Cloud account with other users and reduces security risks for your enterprises. For information about how to grant permissions on prefix lists to RAM users, see [Grant a RAM user permissions on prefix lists](https://help.aliyun.com/document_detail/206175.html)
        
        @param request: CreatePrefixListRequest
        @return: CreatePrefixListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_prefix_list_with_options(request, runtime)

    async def create_prefix_list_async(
        self,
        request: ecs_20140526_models.CreatePrefixListRequest,
    ) -> ecs_20140526_models.CreatePrefixListResponse:
        """
        @summary Creates a prefix list.
        
        @description ## [](#)Usage notes
        A prefix list is a collection of network prefixes (CIDR blocks) and can be referenced to configure network rules for other resources. For more information, see [Overview](https://help.aliyun.com/document_detail/206223.html).
        When you create a prefix list, take note of the following items:
        You must specify an IP address family (IPv4 or IPv6) for the prefix list, and cannot change the IP address family after the prefix list is created. You cannot combine IPv4 and IPv6 CIDR blocks in a single prefix list.
        You must specify the maximum number of entries that the prefix list can contain. You cannot modify the maximum number of entries after the prefix list is created.
        You can specify entries for the prefix list. Each entry consists of a CIDR block and the description for the CIDR block. The total number of entries cannot exceed the maximum number of entries that you specified.
        For more information about the limits on prefix lists and other resources, see [Limits](https://help.aliyun.com/document_detail/25412.html).
        You can create Resource Access Management (RAM) users and grant them minimum permissions. This eliminates the need to share the AccessKey pair of your Alibaba Cloud account with other users and reduces security risks for your enterprises. For information about how to grant permissions on prefix lists to RAM users, see [Grant a RAM user permissions on prefix lists](https://help.aliyun.com/document_detail/206175.html)
        
        @param request: CreatePrefixListRequest
        @return: CreatePrefixListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_prefix_list_with_options_async(request, runtime)

    def create_route_entry_with_options(
        self,
        request: ecs_20140526_models.CreateRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateRouteEntryResponse:
        """
        @deprecated OpenAPI CreateRouteEntry is deprecated, please use Vpc::2016-04-28::CreateRouteEntry instead.
        
        @summary CreateRouteEntry
        
        @param request: CreateRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRouteEntryResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.destination_cidr_block):
            query['DestinationCidrBlock'] = request.destination_cidr_block
        if not UtilClient.is_unset(request.next_hop_id):
            query['NextHopId'] = request.next_hop_id
        if not UtilClient.is_unset(request.next_hop_list):
            query['NextHopList'] = request.next_hop_list
        if not UtilClient.is_unset(request.next_hop_type):
            query['NextHopType'] = request.next_hop_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRouteEntry',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateRouteEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_route_entry_with_options_async(
        self,
        request: ecs_20140526_models.CreateRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateRouteEntryResponse:
        """
        @deprecated OpenAPI CreateRouteEntry is deprecated, please use Vpc::2016-04-28::CreateRouteEntry instead.
        
        @summary CreateRouteEntry
        
        @param request: CreateRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRouteEntryResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.destination_cidr_block):
            query['DestinationCidrBlock'] = request.destination_cidr_block
        if not UtilClient.is_unset(request.next_hop_id):
            query['NextHopId'] = request.next_hop_id
        if not UtilClient.is_unset(request.next_hop_list):
            query['NextHopList'] = request.next_hop_list
        if not UtilClient.is_unset(request.next_hop_type):
            query['NextHopType'] = request.next_hop_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRouteEntry',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateRouteEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_route_entry(
        self,
        request: ecs_20140526_models.CreateRouteEntryRequest,
    ) -> ecs_20140526_models.CreateRouteEntryResponse:
        """
        @deprecated OpenAPI CreateRouteEntry is deprecated, please use Vpc::2016-04-28::CreateRouteEntry instead.
        
        @summary CreateRouteEntry
        
        @param request: CreateRouteEntryRequest
        @return: CreateRouteEntryResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.create_route_entry_with_options(request, runtime)

    async def create_route_entry_async(
        self,
        request: ecs_20140526_models.CreateRouteEntryRequest,
    ) -> ecs_20140526_models.CreateRouteEntryResponse:
        """
        @deprecated OpenAPI CreateRouteEntry is deprecated, please use Vpc::2016-04-28::CreateRouteEntry instead.
        
        @summary CreateRouteEntry
        
        @param request: CreateRouteEntryRequest
        @return: CreateRouteEntryResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_route_entry_with_options_async(request, runtime)

    def create_router_interface_with_options(
        self,
        request: ecs_20140526_models.CreateRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateRouterInterfaceResponse:
        """
        @deprecated OpenAPI CreateRouterInterface is deprecated, please use Vpc::2016-04-28::CreateRouterInterface instead.
        
        @summary CreateRouterInterface
        
        @param request: CreateRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRouterInterfaceResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.access_point_id):
            query['AccessPointId'] = request.access_point_id
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.health_check_source_ip):
            query['HealthCheckSourceIp'] = request.health_check_source_ip
        if not UtilClient.is_unset(request.health_check_target_ip):
            query['HealthCheckTargetIp'] = request.health_check_target_ip
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.opposite_access_point_id):
            query['OppositeAccessPointId'] = request.opposite_access_point_id
        if not UtilClient.is_unset(request.opposite_interface_id):
            query['OppositeInterfaceId'] = request.opposite_interface_id
        if not UtilClient.is_unset(request.opposite_interface_owner_id):
            query['OppositeInterfaceOwnerId'] = request.opposite_interface_owner_id
        if not UtilClient.is_unset(request.opposite_region_id):
            query['OppositeRegionId'] = request.opposite_region_id
        if not UtilClient.is_unset(request.opposite_router_id):
            query['OppositeRouterId'] = request.opposite_router_id
        if not UtilClient.is_unset(request.opposite_router_type):
            query['OppositeRouterType'] = request.opposite_router_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.pricing_cycle):
            query['PricingCycle'] = request.pricing_cycle
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.role):
            query['Role'] = request.role
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        if not UtilClient.is_unset(request.router_type):
            query['RouterType'] = request.router_type
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRouterInterface',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateRouterInterfaceResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_router_interface_with_options_async(
        self,
        request: ecs_20140526_models.CreateRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateRouterInterfaceResponse:
        """
        @deprecated OpenAPI CreateRouterInterface is deprecated, please use Vpc::2016-04-28::CreateRouterInterface instead.
        
        @summary CreateRouterInterface
        
        @param request: CreateRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRouterInterfaceResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.access_point_id):
            query['AccessPointId'] = request.access_point_id
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.health_check_source_ip):
            query['HealthCheckSourceIp'] = request.health_check_source_ip
        if not UtilClient.is_unset(request.health_check_target_ip):
            query['HealthCheckTargetIp'] = request.health_check_target_ip
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.opposite_access_point_id):
            query['OppositeAccessPointId'] = request.opposite_access_point_id
        if not UtilClient.is_unset(request.opposite_interface_id):
            query['OppositeInterfaceId'] = request.opposite_interface_id
        if not UtilClient.is_unset(request.opposite_interface_owner_id):
            query['OppositeInterfaceOwnerId'] = request.opposite_interface_owner_id
        if not UtilClient.is_unset(request.opposite_region_id):
            query['OppositeRegionId'] = request.opposite_region_id
        if not UtilClient.is_unset(request.opposite_router_id):
            query['OppositeRouterId'] = request.opposite_router_id
        if not UtilClient.is_unset(request.opposite_router_type):
            query['OppositeRouterType'] = request.opposite_router_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.pricing_cycle):
            query['PricingCycle'] = request.pricing_cycle
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.role):
            query['Role'] = request.role
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        if not UtilClient.is_unset(request.router_type):
            query['RouterType'] = request.router_type
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRouterInterface',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateRouterInterfaceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_router_interface(
        self,
        request: ecs_20140526_models.CreateRouterInterfaceRequest,
    ) -> ecs_20140526_models.CreateRouterInterfaceResponse:
        """
        @deprecated OpenAPI CreateRouterInterface is deprecated, please use Vpc::2016-04-28::CreateRouterInterface instead.
        
        @summary CreateRouterInterface
        
        @param request: CreateRouterInterfaceRequest
        @return: CreateRouterInterfaceResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.create_router_interface_with_options(request, runtime)

    async def create_router_interface_async(
        self,
        request: ecs_20140526_models.CreateRouterInterfaceRequest,
    ) -> ecs_20140526_models.CreateRouterInterfaceResponse:
        """
        @deprecated OpenAPI CreateRouterInterface is deprecated, please use Vpc::2016-04-28::CreateRouterInterface instead.
        
        @summary CreateRouterInterface
        
        @param request: CreateRouterInterfaceRequest
        @return: CreateRouterInterfaceResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_router_interface_with_options_async(request, runtime)

    def create_savings_plan_with_options(
        self,
        request: ecs_20140526_models.CreateSavingsPlanRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateSavingsPlanResponse:
        """
        @summary 购买节省计划并预付费换购按量付费
        
        @param request: CreateSavingsPlanRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSavingsPlanResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.charge_type):
            query['ChargeType'] = request.charge_type
        if not UtilClient.is_unset(request.committed_amount):
            query['CommittedAmount'] = request.committed_amount
        if not UtilClient.is_unset(request.instance_type_family):
            query['InstanceTypeFamily'] = request.instance_type_family
        if not UtilClient.is_unset(request.instance_type_family_group):
            query['InstanceTypeFamilyGroup'] = request.instance_type_family_group
        if not UtilClient.is_unset(request.offering_type):
            query['OfferingType'] = request.offering_type
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.plan_type):
            query['PlanType'] = request.plan_type
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateSavingsPlan',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateSavingsPlanResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_savings_plan_with_options_async(
        self,
        request: ecs_20140526_models.CreateSavingsPlanRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateSavingsPlanResponse:
        """
        @summary 购买节省计划并预付费换购按量付费
        
        @param request: CreateSavingsPlanRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSavingsPlanResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.charge_type):
            query['ChargeType'] = request.charge_type
        if not UtilClient.is_unset(request.committed_amount):
            query['CommittedAmount'] = request.committed_amount
        if not UtilClient.is_unset(request.instance_type_family):
            query['InstanceTypeFamily'] = request.instance_type_family
        if not UtilClient.is_unset(request.instance_type_family_group):
            query['InstanceTypeFamilyGroup'] = request.instance_type_family_group
        if not UtilClient.is_unset(request.offering_type):
            query['OfferingType'] = request.offering_type
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.plan_type):
            query['PlanType'] = request.plan_type
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateSavingsPlan',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateSavingsPlanResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_savings_plan(
        self,
        request: ecs_20140526_models.CreateSavingsPlanRequest,
    ) -> ecs_20140526_models.CreateSavingsPlanResponse:
        """
        @summary 购买节省计划并预付费换购按量付费
        
        @param request: CreateSavingsPlanRequest
        @return: CreateSavingsPlanResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_savings_plan_with_options(request, runtime)

    async def create_savings_plan_async(
        self,
        request: ecs_20140526_models.CreateSavingsPlanRequest,
    ) -> ecs_20140526_models.CreateSavingsPlanResponse:
        """
        @summary 购买节省计划并预付费换购按量付费
        
        @param request: CreateSavingsPlanRequest
        @return: CreateSavingsPlanResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_savings_plan_with_options_async(request, runtime)

    def create_security_group_with_options(
        self,
        request: ecs_20140526_models.CreateSecurityGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateSecurityGroupResponse:
        """
        @summary Creates a security group.
        
        @description    By default, the internal access control policy (InnerAccessPolicy) of the basic security group that you create by calling this operation is internal interconnectivity (**Accept**). You can call the [ModifySecurityGroupPolicy](https://help.aliyun.com/document_detail/2679846.html) operation to change the value of InnerAccessPolicy for the basic security group.
        By default, the internal access control policy (InnerAccessPolicy) of the advanced security group that you create by calling this operation is internal isolation (**Drop**). The InnerAccessPolicy value of the advanced security group cannot be changed.
        You can create a limited number of security groups per region. You can create at least 100 security groups per region. For more information, see the [Security group limits](~~25412#SecurityGroupQuota1~~) section in the "Limits" topic.
        To create a security group of the Virtual Private Cloud (VPC) type, you must specify VpcId.
        
        @param request: CreateSecurityGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSecurityGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_name):
            query['SecurityGroupName'] = request.security_group_name
        if not UtilClient.is_unset(request.security_group_type):
            query['SecurityGroupType'] = request.security_group_type
        if not UtilClient.is_unset(request.service_managed):
            query['ServiceManaged'] = request.service_managed
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateSecurityGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateSecurityGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_security_group_with_options_async(
        self,
        request: ecs_20140526_models.CreateSecurityGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateSecurityGroupResponse:
        """
        @summary Creates a security group.
        
        @description    By default, the internal access control policy (InnerAccessPolicy) of the basic security group that you create by calling this operation is internal interconnectivity (**Accept**). You can call the [ModifySecurityGroupPolicy](https://help.aliyun.com/document_detail/2679846.html) operation to change the value of InnerAccessPolicy for the basic security group.
        By default, the internal access control policy (InnerAccessPolicy) of the advanced security group that you create by calling this operation is internal isolation (**Drop**). The InnerAccessPolicy value of the advanced security group cannot be changed.
        You can create a limited number of security groups per region. You can create at least 100 security groups per region. For more information, see the [Security group limits](~~25412#SecurityGroupQuota1~~) section in the "Limits" topic.
        To create a security group of the Virtual Private Cloud (VPC) type, you must specify VpcId.
        
        @param request: CreateSecurityGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSecurityGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_name):
            query['SecurityGroupName'] = request.security_group_name
        if not UtilClient.is_unset(request.security_group_type):
            query['SecurityGroupType'] = request.security_group_type
        if not UtilClient.is_unset(request.service_managed):
            query['ServiceManaged'] = request.service_managed
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateSecurityGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateSecurityGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_security_group(
        self,
        request: ecs_20140526_models.CreateSecurityGroupRequest,
    ) -> ecs_20140526_models.CreateSecurityGroupResponse:
        """
        @summary Creates a security group.
        
        @description    By default, the internal access control policy (InnerAccessPolicy) of the basic security group that you create by calling this operation is internal interconnectivity (**Accept**). You can call the [ModifySecurityGroupPolicy](https://help.aliyun.com/document_detail/2679846.html) operation to change the value of InnerAccessPolicy for the basic security group.
        By default, the internal access control policy (InnerAccessPolicy) of the advanced security group that you create by calling this operation is internal isolation (**Drop**). The InnerAccessPolicy value of the advanced security group cannot be changed.
        You can create a limited number of security groups per region. You can create at least 100 security groups per region. For more information, see the [Security group limits](~~25412#SecurityGroupQuota1~~) section in the "Limits" topic.
        To create a security group of the Virtual Private Cloud (VPC) type, you must specify VpcId.
        
        @param request: CreateSecurityGroupRequest
        @return: CreateSecurityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_security_group_with_options(request, runtime)

    async def create_security_group_async(
        self,
        request: ecs_20140526_models.CreateSecurityGroupRequest,
    ) -> ecs_20140526_models.CreateSecurityGroupResponse:
        """
        @summary Creates a security group.
        
        @description    By default, the internal access control policy (InnerAccessPolicy) of the basic security group that you create by calling this operation is internal interconnectivity (**Accept**). You can call the [ModifySecurityGroupPolicy](https://help.aliyun.com/document_detail/2679846.html) operation to change the value of InnerAccessPolicy for the basic security group.
        By default, the internal access control policy (InnerAccessPolicy) of the advanced security group that you create by calling this operation is internal isolation (**Drop**). The InnerAccessPolicy value of the advanced security group cannot be changed.
        You can create a limited number of security groups per region. You can create at least 100 security groups per region. For more information, see the [Security group limits](~~25412#SecurityGroupQuota1~~) section in the "Limits" topic.
        To create a security group of the Virtual Private Cloud (VPC) type, you must specify VpcId.
        
        @param request: CreateSecurityGroupRequest
        @return: CreateSecurityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_security_group_with_options_async(request, runtime)

    def create_simulated_system_events_with_options(
        self,
        request: ecs_20140526_models.CreateSimulatedSystemEventsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateSimulatedSystemEventsResponse:
        """
        @summary Schedules simulated system events of Elastic Compute Service (ECS) instances. The simulated system events do not actually occur on or affect ECS instances.
        
        @description You can use the ECS console, call [ECS API](https://help.aliyun.com/document_detail/63962.html) operations, or use CloudMonitor to view the scheduled simulated system events.
        The following descriptions provide the lifecycle of a simulated system event:
        Scheduled: The state of the simulated system event is automatically changed to Scheduled after it is scheduled.
        Executed: The state of the simulated system event is automatically changed to Executed at the time specified by the NotBefore parameter if no manual intervention is involved.
        Canceled: The state of the simulated system event is changed to Canceled if you cancel the event by calling the [CancelSimulatedSystemEvents](https://help.aliyun.com/document_detail/88808.html) operation.
        Avoided: The state of the simulated system event generated from maintenance-triggered instance restart can be changed to Avoided if you restart the instance before the scheduled time of the simulated system event. The maintenance-triggered instance restart is indicated by the SystemMaintenance.Reboot value. For more information, see [RebootInstance](https://help.aliyun.com/document_detail/25502.html).
        
        @param request: CreateSimulatedSystemEventsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSimulatedSystemEventsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.event_type):
            query['EventType'] = request.event_type
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.not_before):
            query['NotBefore'] = request.not_before
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateSimulatedSystemEvents',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateSimulatedSystemEventsResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_simulated_system_events_with_options_async(
        self,
        request: ecs_20140526_models.CreateSimulatedSystemEventsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateSimulatedSystemEventsResponse:
        """
        @summary Schedules simulated system events of Elastic Compute Service (ECS) instances. The simulated system events do not actually occur on or affect ECS instances.
        
        @description You can use the ECS console, call [ECS API](https://help.aliyun.com/document_detail/63962.html) operations, or use CloudMonitor to view the scheduled simulated system events.
        The following descriptions provide the lifecycle of a simulated system event:
        Scheduled: The state of the simulated system event is automatically changed to Scheduled after it is scheduled.
        Executed: The state of the simulated system event is automatically changed to Executed at the time specified by the NotBefore parameter if no manual intervention is involved.
        Canceled: The state of the simulated system event is changed to Canceled if you cancel the event by calling the [CancelSimulatedSystemEvents](https://help.aliyun.com/document_detail/88808.html) operation.
        Avoided: The state of the simulated system event generated from maintenance-triggered instance restart can be changed to Avoided if you restart the instance before the scheduled time of the simulated system event. The maintenance-triggered instance restart is indicated by the SystemMaintenance.Reboot value. For more information, see [RebootInstance](https://help.aliyun.com/document_detail/25502.html).
        
        @param request: CreateSimulatedSystemEventsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSimulatedSystemEventsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.event_type):
            query['EventType'] = request.event_type
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.not_before):
            query['NotBefore'] = request.not_before
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateSimulatedSystemEvents',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateSimulatedSystemEventsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_simulated_system_events(
        self,
        request: ecs_20140526_models.CreateSimulatedSystemEventsRequest,
    ) -> ecs_20140526_models.CreateSimulatedSystemEventsResponse:
        """
        @summary Schedules simulated system events of Elastic Compute Service (ECS) instances. The simulated system events do not actually occur on or affect ECS instances.
        
        @description You can use the ECS console, call [ECS API](https://help.aliyun.com/document_detail/63962.html) operations, or use CloudMonitor to view the scheduled simulated system events.
        The following descriptions provide the lifecycle of a simulated system event:
        Scheduled: The state of the simulated system event is automatically changed to Scheduled after it is scheduled.
        Executed: The state of the simulated system event is automatically changed to Executed at the time specified by the NotBefore parameter if no manual intervention is involved.
        Canceled: The state of the simulated system event is changed to Canceled if you cancel the event by calling the [CancelSimulatedSystemEvents](https://help.aliyun.com/document_detail/88808.html) operation.
        Avoided: The state of the simulated system event generated from maintenance-triggered instance restart can be changed to Avoided if you restart the instance before the scheduled time of the simulated system event. The maintenance-triggered instance restart is indicated by the SystemMaintenance.Reboot value. For more information, see [RebootInstance](https://help.aliyun.com/document_detail/25502.html).
        
        @param request: CreateSimulatedSystemEventsRequest
        @return: CreateSimulatedSystemEventsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_simulated_system_events_with_options(request, runtime)

    async def create_simulated_system_events_async(
        self,
        request: ecs_20140526_models.CreateSimulatedSystemEventsRequest,
    ) -> ecs_20140526_models.CreateSimulatedSystemEventsResponse:
        """
        @summary Schedules simulated system events of Elastic Compute Service (ECS) instances. The simulated system events do not actually occur on or affect ECS instances.
        
        @description You can use the ECS console, call [ECS API](https://help.aliyun.com/document_detail/63962.html) operations, or use CloudMonitor to view the scheduled simulated system events.
        The following descriptions provide the lifecycle of a simulated system event:
        Scheduled: The state of the simulated system event is automatically changed to Scheduled after it is scheduled.
        Executed: The state of the simulated system event is automatically changed to Executed at the time specified by the NotBefore parameter if no manual intervention is involved.
        Canceled: The state of the simulated system event is changed to Canceled if you cancel the event by calling the [CancelSimulatedSystemEvents](https://help.aliyun.com/document_detail/88808.html) operation.
        Avoided: The state of the simulated system event generated from maintenance-triggered instance restart can be changed to Avoided if you restart the instance before the scheduled time of the simulated system event. The maintenance-triggered instance restart is indicated by the SystemMaintenance.Reboot value. For more information, see [RebootInstance](https://help.aliyun.com/document_detail/25502.html).
        
        @param request: CreateSimulatedSystemEventsRequest
        @return: CreateSimulatedSystemEventsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_simulated_system_events_with_options_async(request, runtime)

    def create_snapshot_with_options(
        self,
        request: ecs_20140526_models.CreateSnapshotRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateSnapshotResponse:
        """
        @summary Creates a snapshot for a cloud disk.
        
        @description The local snapshot feature is replaced by the instant access feature. Take note of the following items:
        If you have used the local snapshot feature before December 14, 2020, you can use `Category`.
        If you have not used the local snapshot feature before December 14, 2020, new snapshots of your Enterprise SSD (ESSD) series disks are instantly available after creation without the need for additional configurations, regardless of whether the snapshots are manually or automatically created. ESSD-series disks include ESSDs, ESSD AutoPL disks, ESSD Entry disks, and Regional ESSDs. InstantAccess, InstantAccessRetentionDays, and DisableInstantAccess that are related to the instant access feature no longer take effect in API operations. Available is added to the DescribeSnapshots and DescribeSnapshotGroups operations to indicate whether snapshots are available.
        Prerequisites:
        Elastic Compute Service (ECS) Snapshot is activated. For more information, see [Activate ECS Snapshot](https://help.aliyun.com/document_detail/108381.html).
        The disk for which you want to create a snapshot is in the **In_use** or **Available** state. Take note of the following items:
        If the disk is in the **In_use** state, make sure that the ECS instance to which the disk is attached is in the **Running** or **Stopped** state.
        If the disk is in the **Available** state, make sure that the disk was attached to an ECS instance. Snapshots cannot be created for disks that have never been attached to an ECS instance.
        When you use a disk to create a dynamic extended volume or a RAID array, we recommend that you create a snapshot-consistent group and enable the application-consistent snapshot feature to back up data. When a business system involves multiple disks, you can create a snapshot-consistent group to ensure a consistent write order and the crash consistency of business system data. For more information, see [Create a snapshot-consistent group](https://help.aliyun.com/document_detail/199625.html) and [Create application-consistent snapshots](https://help.aliyun.com/document_detail/208589.html).
        When you create a snapshot, take note of the following items:
        We recommend that you create snapshots during off-peak hours because snapshot creation degrades disk I/O performance by up to 10% and slows down data reads and writes.
        If a snapshot is being created, you cannot use this snapshot to create a custom image by calling the [CreateImage](https://help.aliyun.com/document_detail/25535.html) operation.
        If operations are performed on the disk and incremental data is generated when a snapshot is being created, the incremental data is not included in the snapshot.
        When a snapshot is being created for a disk that is attached to an ECS instance, do not perform operations that change the status of the instance, such as stopping or restarting the instance. Otherwise, the snapshot may fail to be created.
        You cannot resize a disk for which a snapshot is being created. Wait until the snapshot is created before you resize the disk.
        You can create snapshots for a disk that is in the **Expired** (`Expired`) state. If the release time scheduled for a disk arrives while a snapshot is being created for the disk, the snapshot is in the **Creating** (`Creating`) state and is deleted when the disk is released.
        After you create snapshots, you are charged snapshot storage fees per region based on the total size of the snapshots that are stored in the region. For more information, see [Snapshots](https://help.aliyun.com/document_detail/56159.html).
        In the following scenarios, you cannot create snapshots for a disk:
        The number of manual snapshots of the disk has reached 256.
        A snapshot is being created for the disk.
        If the response contains `{"OperationLocks": {"LockReason" : "security"}}` when you query information about an ECS instance, the instance is locked for security reasons and no operations are allowed on the instance.
        
        @param request: CreateSnapshotRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSnapshotResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category):
            query['Category'] = request.category
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.instant_access):
            query['InstantAccess'] = request.instant_access
        if not UtilClient.is_unset(request.instant_access_retention_days):
            query['InstantAccessRetentionDays'] = request.instant_access_retention_days
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.retention_days):
            query['RetentionDays'] = request.retention_days
        if not UtilClient.is_unset(request.snapshot_name):
            query['SnapshotName'] = request.snapshot_name
        if not UtilClient.is_unset(request.storage_location_arn):
            query['StorageLocationArn'] = request.storage_location_arn
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateSnapshot',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateSnapshotResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_snapshot_with_options_async(
        self,
        request: ecs_20140526_models.CreateSnapshotRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateSnapshotResponse:
        """
        @summary Creates a snapshot for a cloud disk.
        
        @description The local snapshot feature is replaced by the instant access feature. Take note of the following items:
        If you have used the local snapshot feature before December 14, 2020, you can use `Category`.
        If you have not used the local snapshot feature before December 14, 2020, new snapshots of your Enterprise SSD (ESSD) series disks are instantly available after creation without the need for additional configurations, regardless of whether the snapshots are manually or automatically created. ESSD-series disks include ESSDs, ESSD AutoPL disks, ESSD Entry disks, and Regional ESSDs. InstantAccess, InstantAccessRetentionDays, and DisableInstantAccess that are related to the instant access feature no longer take effect in API operations. Available is added to the DescribeSnapshots and DescribeSnapshotGroups operations to indicate whether snapshots are available.
        Prerequisites:
        Elastic Compute Service (ECS) Snapshot is activated. For more information, see [Activate ECS Snapshot](https://help.aliyun.com/document_detail/108381.html).
        The disk for which you want to create a snapshot is in the **In_use** or **Available** state. Take note of the following items:
        If the disk is in the **In_use** state, make sure that the ECS instance to which the disk is attached is in the **Running** or **Stopped** state.
        If the disk is in the **Available** state, make sure that the disk was attached to an ECS instance. Snapshots cannot be created for disks that have never been attached to an ECS instance.
        When you use a disk to create a dynamic extended volume or a RAID array, we recommend that you create a snapshot-consistent group and enable the application-consistent snapshot feature to back up data. When a business system involves multiple disks, you can create a snapshot-consistent group to ensure a consistent write order and the crash consistency of business system data. For more information, see [Create a snapshot-consistent group](https://help.aliyun.com/document_detail/199625.html) and [Create application-consistent snapshots](https://help.aliyun.com/document_detail/208589.html).
        When you create a snapshot, take note of the following items:
        We recommend that you create snapshots during off-peak hours because snapshot creation degrades disk I/O performance by up to 10% and slows down data reads and writes.
        If a snapshot is being created, you cannot use this snapshot to create a custom image by calling the [CreateImage](https://help.aliyun.com/document_detail/25535.html) operation.
        If operations are performed on the disk and incremental data is generated when a snapshot is being created, the incremental data is not included in the snapshot.
        When a snapshot is being created for a disk that is attached to an ECS instance, do not perform operations that change the status of the instance, such as stopping or restarting the instance. Otherwise, the snapshot may fail to be created.
        You cannot resize a disk for which a snapshot is being created. Wait until the snapshot is created before you resize the disk.
        You can create snapshots for a disk that is in the **Expired** (`Expired`) state. If the release time scheduled for a disk arrives while a snapshot is being created for the disk, the snapshot is in the **Creating** (`Creating`) state and is deleted when the disk is released.
        After you create snapshots, you are charged snapshot storage fees per region based on the total size of the snapshots that are stored in the region. For more information, see [Snapshots](https://help.aliyun.com/document_detail/56159.html).
        In the following scenarios, you cannot create snapshots for a disk:
        The number of manual snapshots of the disk has reached 256.
        A snapshot is being created for the disk.
        If the response contains `{"OperationLocks": {"LockReason" : "security"}}` when you query information about an ECS instance, the instance is locked for security reasons and no operations are allowed on the instance.
        
        @param request: CreateSnapshotRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSnapshotResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category):
            query['Category'] = request.category
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.instant_access):
            query['InstantAccess'] = request.instant_access
        if not UtilClient.is_unset(request.instant_access_retention_days):
            query['InstantAccessRetentionDays'] = request.instant_access_retention_days
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.retention_days):
            query['RetentionDays'] = request.retention_days
        if not UtilClient.is_unset(request.snapshot_name):
            query['SnapshotName'] = request.snapshot_name
        if not UtilClient.is_unset(request.storage_location_arn):
            query['StorageLocationArn'] = request.storage_location_arn
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateSnapshot',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateSnapshotResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_snapshot(
        self,
        request: ecs_20140526_models.CreateSnapshotRequest,
    ) -> ecs_20140526_models.CreateSnapshotResponse:
        """
        @summary Creates a snapshot for a cloud disk.
        
        @description The local snapshot feature is replaced by the instant access feature. Take note of the following items:
        If you have used the local snapshot feature before December 14, 2020, you can use `Category`.
        If you have not used the local snapshot feature before December 14, 2020, new snapshots of your Enterprise SSD (ESSD) series disks are instantly available after creation without the need for additional configurations, regardless of whether the snapshots are manually or automatically created. ESSD-series disks include ESSDs, ESSD AutoPL disks, ESSD Entry disks, and Regional ESSDs. InstantAccess, InstantAccessRetentionDays, and DisableInstantAccess that are related to the instant access feature no longer take effect in API operations. Available is added to the DescribeSnapshots and DescribeSnapshotGroups operations to indicate whether snapshots are available.
        Prerequisites:
        Elastic Compute Service (ECS) Snapshot is activated. For more information, see [Activate ECS Snapshot](https://help.aliyun.com/document_detail/108381.html).
        The disk for which you want to create a snapshot is in the **In_use** or **Available** state. Take note of the following items:
        If the disk is in the **In_use** state, make sure that the ECS instance to which the disk is attached is in the **Running** or **Stopped** state.
        If the disk is in the **Available** state, make sure that the disk was attached to an ECS instance. Snapshots cannot be created for disks that have never been attached to an ECS instance.
        When you use a disk to create a dynamic extended volume or a RAID array, we recommend that you create a snapshot-consistent group and enable the application-consistent snapshot feature to back up data. When a business system involves multiple disks, you can create a snapshot-consistent group to ensure a consistent write order and the crash consistency of business system data. For more information, see [Create a snapshot-consistent group](https://help.aliyun.com/document_detail/199625.html) and [Create application-consistent snapshots](https://help.aliyun.com/document_detail/208589.html).
        When you create a snapshot, take note of the following items:
        We recommend that you create snapshots during off-peak hours because snapshot creation degrades disk I/O performance by up to 10% and slows down data reads and writes.
        If a snapshot is being created, you cannot use this snapshot to create a custom image by calling the [CreateImage](https://help.aliyun.com/document_detail/25535.html) operation.
        If operations are performed on the disk and incremental data is generated when a snapshot is being created, the incremental data is not included in the snapshot.
        When a snapshot is being created for a disk that is attached to an ECS instance, do not perform operations that change the status of the instance, such as stopping or restarting the instance. Otherwise, the snapshot may fail to be created.
        You cannot resize a disk for which a snapshot is being created. Wait until the snapshot is created before you resize the disk.
        You can create snapshots for a disk that is in the **Expired** (`Expired`) state. If the release time scheduled for a disk arrives while a snapshot is being created for the disk, the snapshot is in the **Creating** (`Creating`) state and is deleted when the disk is released.
        After you create snapshots, you are charged snapshot storage fees per region based on the total size of the snapshots that are stored in the region. For more information, see [Snapshots](https://help.aliyun.com/document_detail/56159.html).
        In the following scenarios, you cannot create snapshots for a disk:
        The number of manual snapshots of the disk has reached 256.
        A snapshot is being created for the disk.
        If the response contains `{"OperationLocks": {"LockReason" : "security"}}` when you query information about an ECS instance, the instance is locked for security reasons and no operations are allowed on the instance.
        
        @param request: CreateSnapshotRequest
        @return: CreateSnapshotResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_snapshot_with_options(request, runtime)

    async def create_snapshot_async(
        self,
        request: ecs_20140526_models.CreateSnapshotRequest,
    ) -> ecs_20140526_models.CreateSnapshotResponse:
        """
        @summary Creates a snapshot for a cloud disk.
        
        @description The local snapshot feature is replaced by the instant access feature. Take note of the following items:
        If you have used the local snapshot feature before December 14, 2020, you can use `Category`.
        If you have not used the local snapshot feature before December 14, 2020, new snapshots of your Enterprise SSD (ESSD) series disks are instantly available after creation without the need for additional configurations, regardless of whether the snapshots are manually or automatically created. ESSD-series disks include ESSDs, ESSD AutoPL disks, ESSD Entry disks, and Regional ESSDs. InstantAccess, InstantAccessRetentionDays, and DisableInstantAccess that are related to the instant access feature no longer take effect in API operations. Available is added to the DescribeSnapshots and DescribeSnapshotGroups operations to indicate whether snapshots are available.
        Prerequisites:
        Elastic Compute Service (ECS) Snapshot is activated. For more information, see [Activate ECS Snapshot](https://help.aliyun.com/document_detail/108381.html).
        The disk for which you want to create a snapshot is in the **In_use** or **Available** state. Take note of the following items:
        If the disk is in the **In_use** state, make sure that the ECS instance to which the disk is attached is in the **Running** or **Stopped** state.
        If the disk is in the **Available** state, make sure that the disk was attached to an ECS instance. Snapshots cannot be created for disks that have never been attached to an ECS instance.
        When you use a disk to create a dynamic extended volume or a RAID array, we recommend that you create a snapshot-consistent group and enable the application-consistent snapshot feature to back up data. When a business system involves multiple disks, you can create a snapshot-consistent group to ensure a consistent write order and the crash consistency of business system data. For more information, see [Create a snapshot-consistent group](https://help.aliyun.com/document_detail/199625.html) and [Create application-consistent snapshots](https://help.aliyun.com/document_detail/208589.html).
        When you create a snapshot, take note of the following items:
        We recommend that you create snapshots during off-peak hours because snapshot creation degrades disk I/O performance by up to 10% and slows down data reads and writes.
        If a snapshot is being created, you cannot use this snapshot to create a custom image by calling the [CreateImage](https://help.aliyun.com/document_detail/25535.html) operation.
        If operations are performed on the disk and incremental data is generated when a snapshot is being created, the incremental data is not included in the snapshot.
        When a snapshot is being created for a disk that is attached to an ECS instance, do not perform operations that change the status of the instance, such as stopping or restarting the instance. Otherwise, the snapshot may fail to be created.
        You cannot resize a disk for which a snapshot is being created. Wait until the snapshot is created before you resize the disk.
        You can create snapshots for a disk that is in the **Expired** (`Expired`) state. If the release time scheduled for a disk arrives while a snapshot is being created for the disk, the snapshot is in the **Creating** (`Creating`) state and is deleted when the disk is released.
        After you create snapshots, you are charged snapshot storage fees per region based on the total size of the snapshots that are stored in the region. For more information, see [Snapshots](https://help.aliyun.com/document_detail/56159.html).
        In the following scenarios, you cannot create snapshots for a disk:
        The number of manual snapshots of the disk has reached 256.
        A snapshot is being created for the disk.
        If the response contains `{"OperationLocks": {"LockReason" : "security"}}` when you query information about an ECS instance, the instance is locked for security reasons and no operations are allowed on the instance.
        
        @param request: CreateSnapshotRequest
        @return: CreateSnapshotResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_snapshot_with_options_async(request, runtime)

    def create_snapshot_group_with_options(
        self,
        request: ecs_20140526_models.CreateSnapshotGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateSnapshotGroupResponse:
        """
        @summary Creates a snapshot-consistent group for the disks of an Elastic Compute Service (ECS) instance. A snapshot-consistent group contains snapshots of one or more disks.
        
        @description You can specify `InstanceId` to create a snapshot-consistent group for disks on a specific ECS instance. You can also specify `DiskId.N` to create a snapshot-consistent group for multiple disks on multiple ECS instances within the same zone.
        >  You cannot specify both `DiskId.N` and `ExcludeDiskId.N` in the same request. If you specify `InstanceId`, you can use `DiskId.N` to specify only disks on the specified ECS instance and cannot use DiskId.N to specify disks across ECS instances.
        Take note of the following items:
        The disks for which you want to create a snapshot must be in the **In Use** (`In_use`) or **Unattached** (`Available`) state.
        If a disk is in the **In Use** (`In_use`) state, make sure that the ECS instance to which the disk is attached is in the **Running** (`Running`) or **Stopped** (`Stopped`) state.
        If a disk is in the **Unattached** (`Available`) state, make sure that the disk has been attached to ECS instances. Snapshots cannot be created for disks that have never been attached to an ECS instance.
        Snapshot-consistent groups can be used to create snapshots only for Enterprise SSDs (ESSDs), ESSD AutoPL disks, and ESSD Entry disks.
        A snapshot-consistent group can contain snapshots of up to 16 disks, including system disks and data disks, and cannot exceed 32 TiB in size.
        Snapshots that you created are stored indefinitely until you delete the snapshots. We recommend that you delete unnecessary snapshots on a regular basis to prevent excess snapshot storage fees.
        Snapshot-consistent groups cannot be created for disks for which multi-attach feature is enabled. If disks for which the multi-attach feature is enabled are attached to an ECS instance, you must specify the `ExcludeDiskId.N` parameter to exclude the disks.
        For more information about the snapshot-consistent group feature, see [Create a snapshot-consistent group](https://help.aliyun.com/document_detail/199625.html).
        
        @param request: CreateSnapshotGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSnapshotGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.exclude_disk_id):
            query['ExcludeDiskId'] = request.exclude_disk_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instant_access):
            query['InstantAccess'] = request.instant_access
        if not UtilClient.is_unset(request.instant_access_retention_days):
            query['InstantAccessRetentionDays'] = request.instant_access_retention_days
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_location_arn):
            query['StorageLocationArn'] = request.storage_location_arn
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateSnapshotGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateSnapshotGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_snapshot_group_with_options_async(
        self,
        request: ecs_20140526_models.CreateSnapshotGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateSnapshotGroupResponse:
        """
        @summary Creates a snapshot-consistent group for the disks of an Elastic Compute Service (ECS) instance. A snapshot-consistent group contains snapshots of one or more disks.
        
        @description You can specify `InstanceId` to create a snapshot-consistent group for disks on a specific ECS instance. You can also specify `DiskId.N` to create a snapshot-consistent group for multiple disks on multiple ECS instances within the same zone.
        >  You cannot specify both `DiskId.N` and `ExcludeDiskId.N` in the same request. If you specify `InstanceId`, you can use `DiskId.N` to specify only disks on the specified ECS instance and cannot use DiskId.N to specify disks across ECS instances.
        Take note of the following items:
        The disks for which you want to create a snapshot must be in the **In Use** (`In_use`) or **Unattached** (`Available`) state.
        If a disk is in the **In Use** (`In_use`) state, make sure that the ECS instance to which the disk is attached is in the **Running** (`Running`) or **Stopped** (`Stopped`) state.
        If a disk is in the **Unattached** (`Available`) state, make sure that the disk has been attached to ECS instances. Snapshots cannot be created for disks that have never been attached to an ECS instance.
        Snapshot-consistent groups can be used to create snapshots only for Enterprise SSDs (ESSDs), ESSD AutoPL disks, and ESSD Entry disks.
        A snapshot-consistent group can contain snapshots of up to 16 disks, including system disks and data disks, and cannot exceed 32 TiB in size.
        Snapshots that you created are stored indefinitely until you delete the snapshots. We recommend that you delete unnecessary snapshots on a regular basis to prevent excess snapshot storage fees.
        Snapshot-consistent groups cannot be created for disks for which multi-attach feature is enabled. If disks for which the multi-attach feature is enabled are attached to an ECS instance, you must specify the `ExcludeDiskId.N` parameter to exclude the disks.
        For more information about the snapshot-consistent group feature, see [Create a snapshot-consistent group](https://help.aliyun.com/document_detail/199625.html).
        
        @param request: CreateSnapshotGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSnapshotGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.exclude_disk_id):
            query['ExcludeDiskId'] = request.exclude_disk_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instant_access):
            query['InstantAccess'] = request.instant_access
        if not UtilClient.is_unset(request.instant_access_retention_days):
            query['InstantAccessRetentionDays'] = request.instant_access_retention_days
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_location_arn):
            query['StorageLocationArn'] = request.storage_location_arn
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateSnapshotGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateSnapshotGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_snapshot_group(
        self,
        request: ecs_20140526_models.CreateSnapshotGroupRequest,
    ) -> ecs_20140526_models.CreateSnapshotGroupResponse:
        """
        @summary Creates a snapshot-consistent group for the disks of an Elastic Compute Service (ECS) instance. A snapshot-consistent group contains snapshots of one or more disks.
        
        @description You can specify `InstanceId` to create a snapshot-consistent group for disks on a specific ECS instance. You can also specify `DiskId.N` to create a snapshot-consistent group for multiple disks on multiple ECS instances within the same zone.
        >  You cannot specify both `DiskId.N` and `ExcludeDiskId.N` in the same request. If you specify `InstanceId`, you can use `DiskId.N` to specify only disks on the specified ECS instance and cannot use DiskId.N to specify disks across ECS instances.
        Take note of the following items:
        The disks for which you want to create a snapshot must be in the **In Use** (`In_use`) or **Unattached** (`Available`) state.
        If a disk is in the **In Use** (`In_use`) state, make sure that the ECS instance to which the disk is attached is in the **Running** (`Running`) or **Stopped** (`Stopped`) state.
        If a disk is in the **Unattached** (`Available`) state, make sure that the disk has been attached to ECS instances. Snapshots cannot be created for disks that have never been attached to an ECS instance.
        Snapshot-consistent groups can be used to create snapshots only for Enterprise SSDs (ESSDs), ESSD AutoPL disks, and ESSD Entry disks.
        A snapshot-consistent group can contain snapshots of up to 16 disks, including system disks and data disks, and cannot exceed 32 TiB in size.
        Snapshots that you created are stored indefinitely until you delete the snapshots. We recommend that you delete unnecessary snapshots on a regular basis to prevent excess snapshot storage fees.
        Snapshot-consistent groups cannot be created for disks for which multi-attach feature is enabled. If disks for which the multi-attach feature is enabled are attached to an ECS instance, you must specify the `ExcludeDiskId.N` parameter to exclude the disks.
        For more information about the snapshot-consistent group feature, see [Create a snapshot-consistent group](https://help.aliyun.com/document_detail/199625.html).
        
        @param request: CreateSnapshotGroupRequest
        @return: CreateSnapshotGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_snapshot_group_with_options(request, runtime)

    async def create_snapshot_group_async(
        self,
        request: ecs_20140526_models.CreateSnapshotGroupRequest,
    ) -> ecs_20140526_models.CreateSnapshotGroupResponse:
        """
        @summary Creates a snapshot-consistent group for the disks of an Elastic Compute Service (ECS) instance. A snapshot-consistent group contains snapshots of one or more disks.
        
        @description You can specify `InstanceId` to create a snapshot-consistent group for disks on a specific ECS instance. You can also specify `DiskId.N` to create a snapshot-consistent group for multiple disks on multiple ECS instances within the same zone.
        >  You cannot specify both `DiskId.N` and `ExcludeDiskId.N` in the same request. If you specify `InstanceId`, you can use `DiskId.N` to specify only disks on the specified ECS instance and cannot use DiskId.N to specify disks across ECS instances.
        Take note of the following items:
        The disks for which you want to create a snapshot must be in the **In Use** (`In_use`) or **Unattached** (`Available`) state.
        If a disk is in the **In Use** (`In_use`) state, make sure that the ECS instance to which the disk is attached is in the **Running** (`Running`) or **Stopped** (`Stopped`) state.
        If a disk is in the **Unattached** (`Available`) state, make sure that the disk has been attached to ECS instances. Snapshots cannot be created for disks that have never been attached to an ECS instance.
        Snapshot-consistent groups can be used to create snapshots only for Enterprise SSDs (ESSDs), ESSD AutoPL disks, and ESSD Entry disks.
        A snapshot-consistent group can contain snapshots of up to 16 disks, including system disks and data disks, and cannot exceed 32 TiB in size.
        Snapshots that you created are stored indefinitely until you delete the snapshots. We recommend that you delete unnecessary snapshots on a regular basis to prevent excess snapshot storage fees.
        Snapshot-consistent groups cannot be created for disks for which multi-attach feature is enabled. If disks for which the multi-attach feature is enabled are attached to an ECS instance, you must specify the `ExcludeDiskId.N` parameter to exclude the disks.
        For more information about the snapshot-consistent group feature, see [Create a snapshot-consistent group](https://help.aliyun.com/document_detail/199625.html).
        
        @param request: CreateSnapshotGroupRequest
        @return: CreateSnapshotGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_snapshot_group_with_options_async(request, runtime)

    def create_storage_set_with_options(
        self,
        request: ecs_20140526_models.CreateStorageSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateStorageSetResponse:
        """
        @summary (Beta) Creates a storage set in a zone of a region.
        
        @description A storage set can distribute disks or Shared Block Storage devices to different locations. You can specify the number of partitions in a storage set. A larger number of partitions indicate more discrete distribution of disks or Shared Block Storage devices.
        When you call this operation, take note of the following items:
        The number of storage sets that you can create in a region is limited. You can call the [DescribeAccountAttributes](https://help.aliyun.com/document_detail/73772.html) operation to query the limit.
        The number of partitions in a zone is limited. You can call the [DescribeAccountAttributes](https://help.aliyun.com/document_detail/73772.html) operation to query the limit.
        
        @param request: CreateStorageSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateStorageSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.max_partition_number):
            query['MaxPartitionNumber'] = request.max_partition_number
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_set_name):
            query['StorageSetName'] = request.storage_set_name
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateStorageSet',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateStorageSetResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_storage_set_with_options_async(
        self,
        request: ecs_20140526_models.CreateStorageSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateStorageSetResponse:
        """
        @summary (Beta) Creates a storage set in a zone of a region.
        
        @description A storage set can distribute disks or Shared Block Storage devices to different locations. You can specify the number of partitions in a storage set. A larger number of partitions indicate more discrete distribution of disks or Shared Block Storage devices.
        When you call this operation, take note of the following items:
        The number of storage sets that you can create in a region is limited. You can call the [DescribeAccountAttributes](https://help.aliyun.com/document_detail/73772.html) operation to query the limit.
        The number of partitions in a zone is limited. You can call the [DescribeAccountAttributes](https://help.aliyun.com/document_detail/73772.html) operation to query the limit.
        
        @param request: CreateStorageSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateStorageSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.max_partition_number):
            query['MaxPartitionNumber'] = request.max_partition_number
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_set_name):
            query['StorageSetName'] = request.storage_set_name
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateStorageSet',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateStorageSetResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_storage_set(
        self,
        request: ecs_20140526_models.CreateStorageSetRequest,
    ) -> ecs_20140526_models.CreateStorageSetResponse:
        """
        @summary (Beta) Creates a storage set in a zone of a region.
        
        @description A storage set can distribute disks or Shared Block Storage devices to different locations. You can specify the number of partitions in a storage set. A larger number of partitions indicate more discrete distribution of disks or Shared Block Storage devices.
        When you call this operation, take note of the following items:
        The number of storage sets that you can create in a region is limited. You can call the [DescribeAccountAttributes](https://help.aliyun.com/document_detail/73772.html) operation to query the limit.
        The number of partitions in a zone is limited. You can call the [DescribeAccountAttributes](https://help.aliyun.com/document_detail/73772.html) operation to query the limit.
        
        @param request: CreateStorageSetRequest
        @return: CreateStorageSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_storage_set_with_options(request, runtime)

    async def create_storage_set_async(
        self,
        request: ecs_20140526_models.CreateStorageSetRequest,
    ) -> ecs_20140526_models.CreateStorageSetResponse:
        """
        @summary (Beta) Creates a storage set in a zone of a region.
        
        @description A storage set can distribute disks or Shared Block Storage devices to different locations. You can specify the number of partitions in a storage set. A larger number of partitions indicate more discrete distribution of disks or Shared Block Storage devices.
        When you call this operation, take note of the following items:
        The number of storage sets that you can create in a region is limited. You can call the [DescribeAccountAttributes](https://help.aliyun.com/document_detail/73772.html) operation to query the limit.
        The number of partitions in a zone is limited. You can call the [DescribeAccountAttributes](https://help.aliyun.com/document_detail/73772.html) operation to query the limit.
        
        @param request: CreateStorageSetRequest
        @return: CreateStorageSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_storage_set_with_options_async(request, runtime)

    def create_vswitch_with_options(
        self,
        request: ecs_20140526_models.CreateVSwitchRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateVSwitchResponse:
        """
        @deprecated OpenAPI CreateVSwitch is deprecated, please use Vpc::2016-04-28::CreateVSwitch instead.
        
        @summary CreateVSwitch
        
        @param request: CreateVSwitchRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVSwitchResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cidr_block):
            query['CidrBlock'] = request.cidr_block
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_name):
            query['VSwitchName'] = request.v_switch_name
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVSwitch',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateVSwitchResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_vswitch_with_options_async(
        self,
        request: ecs_20140526_models.CreateVSwitchRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateVSwitchResponse:
        """
        @deprecated OpenAPI CreateVSwitch is deprecated, please use Vpc::2016-04-28::CreateVSwitch instead.
        
        @summary CreateVSwitch
        
        @param request: CreateVSwitchRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVSwitchResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cidr_block):
            query['CidrBlock'] = request.cidr_block
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_name):
            query['VSwitchName'] = request.v_switch_name
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVSwitch',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateVSwitchResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_vswitch(
        self,
        request: ecs_20140526_models.CreateVSwitchRequest,
    ) -> ecs_20140526_models.CreateVSwitchResponse:
        """
        @deprecated OpenAPI CreateVSwitch is deprecated, please use Vpc::2016-04-28::CreateVSwitch instead.
        
        @summary CreateVSwitch
        
        @param request: CreateVSwitchRequest
        @return: CreateVSwitchResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.create_vswitch_with_options(request, runtime)

    async def create_vswitch_async(
        self,
        request: ecs_20140526_models.CreateVSwitchRequest,
    ) -> ecs_20140526_models.CreateVSwitchResponse:
        """
        @deprecated OpenAPI CreateVSwitch is deprecated, please use Vpc::2016-04-28::CreateVSwitch instead.
        
        @summary CreateVSwitch
        
        @param request: CreateVSwitchRequest
        @return: CreateVSwitchResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_vswitch_with_options_async(request, runtime)

    def create_virtual_border_router_with_options(
        self,
        request: ecs_20140526_models.CreateVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateVirtualBorderRouterResponse:
        """
        @deprecated OpenAPI CreateVirtualBorderRouter is deprecated, please use Vpc::2016-04-28::CreateVirtualBorderRouter instead.
        
        @summary CreateVirtualBorderRouter
        
        @param request: CreateVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVirtualBorderRouterResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.circuit_code):
            query['CircuitCode'] = request.circuit_code
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.local_gateway_ip):
            query['LocalGatewayIp'] = request.local_gateway_ip
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_gateway_ip):
            query['PeerGatewayIp'] = request.peer_gateway_ip
        if not UtilClient.is_unset(request.peering_subnet_mask):
            query['PeeringSubnetMask'] = request.peering_subnet_mask
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.vbr_owner_id):
            query['VbrOwnerId'] = request.vbr_owner_id
        if not UtilClient.is_unset(request.vlan_id):
            query['VlanId'] = request.vlan_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVirtualBorderRouter',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateVirtualBorderRouterResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_virtual_border_router_with_options_async(
        self,
        request: ecs_20140526_models.CreateVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateVirtualBorderRouterResponse:
        """
        @deprecated OpenAPI CreateVirtualBorderRouter is deprecated, please use Vpc::2016-04-28::CreateVirtualBorderRouter instead.
        
        @summary CreateVirtualBorderRouter
        
        @param request: CreateVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVirtualBorderRouterResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.circuit_code):
            query['CircuitCode'] = request.circuit_code
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.local_gateway_ip):
            query['LocalGatewayIp'] = request.local_gateway_ip
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_gateway_ip):
            query['PeerGatewayIp'] = request.peer_gateway_ip
        if not UtilClient.is_unset(request.peering_subnet_mask):
            query['PeeringSubnetMask'] = request.peering_subnet_mask
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.vbr_owner_id):
            query['VbrOwnerId'] = request.vbr_owner_id
        if not UtilClient.is_unset(request.vlan_id):
            query['VlanId'] = request.vlan_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVirtualBorderRouter',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateVirtualBorderRouterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_virtual_border_router(
        self,
        request: ecs_20140526_models.CreateVirtualBorderRouterRequest,
    ) -> ecs_20140526_models.CreateVirtualBorderRouterResponse:
        """
        @deprecated OpenAPI CreateVirtualBorderRouter is deprecated, please use Vpc::2016-04-28::CreateVirtualBorderRouter instead.
        
        @summary CreateVirtualBorderRouter
        
        @param request: CreateVirtualBorderRouterRequest
        @return: CreateVirtualBorderRouterResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.create_virtual_border_router_with_options(request, runtime)

    async def create_virtual_border_router_async(
        self,
        request: ecs_20140526_models.CreateVirtualBorderRouterRequest,
    ) -> ecs_20140526_models.CreateVirtualBorderRouterResponse:
        """
        @deprecated OpenAPI CreateVirtualBorderRouter is deprecated, please use Vpc::2016-04-28::CreateVirtualBorderRouter instead.
        
        @summary CreateVirtualBorderRouter
        
        @param request: CreateVirtualBorderRouterRequest
        @return: CreateVirtualBorderRouterResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_virtual_border_router_with_options_async(request, runtime)

    def create_vpc_with_options(
        self,
        request: ecs_20140526_models.CreateVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateVpcResponse:
        """
        @deprecated OpenAPI CreateVpc is deprecated, please use Vpc::2016-04-28::CreateVpc instead.
        
        @summary CreateVpc
        
        @param request: CreateVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpcResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cidr_block):
            query['CidrBlock'] = request.cidr_block
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.vpc_name):
            query['VpcName'] = request.vpc_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVpc',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateVpcResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_vpc_with_options_async(
        self,
        request: ecs_20140526_models.CreateVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.CreateVpcResponse:
        """
        @deprecated OpenAPI CreateVpc is deprecated, please use Vpc::2016-04-28::CreateVpc instead.
        
        @summary CreateVpc
        
        @param request: CreateVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpcResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cidr_block):
            query['CidrBlock'] = request.cidr_block
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.vpc_name):
            query['VpcName'] = request.vpc_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVpc',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.CreateVpcResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_vpc(
        self,
        request: ecs_20140526_models.CreateVpcRequest,
    ) -> ecs_20140526_models.CreateVpcResponse:
        """
        @deprecated OpenAPI CreateVpc is deprecated, please use Vpc::2016-04-28::CreateVpc instead.
        
        @summary CreateVpc
        
        @param request: CreateVpcRequest
        @return: CreateVpcResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.create_vpc_with_options(request, runtime)

    async def create_vpc_async(
        self,
        request: ecs_20140526_models.CreateVpcRequest,
    ) -> ecs_20140526_models.CreateVpcResponse:
        """
        @deprecated OpenAPI CreateVpc is deprecated, please use Vpc::2016-04-28::CreateVpc instead.
        
        @summary CreateVpc
        
        @param request: CreateVpcRequest
        @return: CreateVpcResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_vpc_with_options_async(request, runtime)

    def deactivate_router_interface_with_options(
        self,
        request: ecs_20140526_models.DeactivateRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeactivateRouterInterfaceResponse:
        """
        @deprecated OpenAPI DeactivateRouterInterface is deprecated, please use Vpc::2016-04-28::DeactivateRouterInterface instead.
        
        @summary DeactivateRouterInterface
        
        @param request: DeactivateRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeactivateRouterInterfaceResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeactivateRouterInterface',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeactivateRouterInterfaceResponse(),
            self.call_api(params, req, runtime)
        )

    async def deactivate_router_interface_with_options_async(
        self,
        request: ecs_20140526_models.DeactivateRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeactivateRouterInterfaceResponse:
        """
        @deprecated OpenAPI DeactivateRouterInterface is deprecated, please use Vpc::2016-04-28::DeactivateRouterInterface instead.
        
        @summary DeactivateRouterInterface
        
        @param request: DeactivateRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeactivateRouterInterfaceResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeactivateRouterInterface',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeactivateRouterInterfaceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def deactivate_router_interface(
        self,
        request: ecs_20140526_models.DeactivateRouterInterfaceRequest,
    ) -> ecs_20140526_models.DeactivateRouterInterfaceResponse:
        """
        @deprecated OpenAPI DeactivateRouterInterface is deprecated, please use Vpc::2016-04-28::DeactivateRouterInterface instead.
        
        @summary DeactivateRouterInterface
        
        @param request: DeactivateRouterInterfaceRequest
        @return: DeactivateRouterInterfaceResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.deactivate_router_interface_with_options(request, runtime)

    async def deactivate_router_interface_async(
        self,
        request: ecs_20140526_models.DeactivateRouterInterfaceRequest,
    ) -> ecs_20140526_models.DeactivateRouterInterfaceResponse:
        """
        @deprecated OpenAPI DeactivateRouterInterface is deprecated, please use Vpc::2016-04-28::DeactivateRouterInterface instead.
        
        @summary DeactivateRouterInterface
        
        @param request: DeactivateRouterInterfaceRequest
        @return: DeactivateRouterInterfaceResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.deactivate_router_interface_with_options_async(request, runtime)

    def delete_activation_with_options(
        self,
        request: ecs_20140526_models.DeleteActivationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteActivationResponse:
        """
        @summary Deletes an unused activation code.
        
        @description ## [](#)Usage notes
        Before you call this operation to delete an activation code, make sure that no managed instances are registered with the activation code.
        
        @param request: DeleteActivationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteActivationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.activation_id):
            query['ActivationId'] = request.activation_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteActivation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteActivationResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_activation_with_options_async(
        self,
        request: ecs_20140526_models.DeleteActivationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteActivationResponse:
        """
        @summary Deletes an unused activation code.
        
        @description ## [](#)Usage notes
        Before you call this operation to delete an activation code, make sure that no managed instances are registered with the activation code.
        
        @param request: DeleteActivationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteActivationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.activation_id):
            query['ActivationId'] = request.activation_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteActivation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteActivationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_activation(
        self,
        request: ecs_20140526_models.DeleteActivationRequest,
    ) -> ecs_20140526_models.DeleteActivationResponse:
        """
        @summary Deletes an unused activation code.
        
        @description ## [](#)Usage notes
        Before you call this operation to delete an activation code, make sure that no managed instances are registered with the activation code.
        
        @param request: DeleteActivationRequest
        @return: DeleteActivationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_activation_with_options(request, runtime)

    async def delete_activation_async(
        self,
        request: ecs_20140526_models.DeleteActivationRequest,
    ) -> ecs_20140526_models.DeleteActivationResponse:
        """
        @summary Deletes an unused activation code.
        
        @description ## [](#)Usage notes
        Before you call this operation to delete an activation code, make sure that no managed instances are registered with the activation code.
        
        @param request: DeleteActivationRequest
        @return: DeleteActivationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_activation_with_options_async(request, runtime)

    def delete_auto_provisioning_group_with_options(
        self,
        request: ecs_20140526_models.DeleteAutoProvisioningGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteAutoProvisioningGroupResponse:
        """
        @summary Deletes an auto provisioning group. When you call this operation, you can specify AutoProvisioningGroupId and TerminateInstances in the request.
        
        @param request: DeleteAutoProvisioningGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAutoProvisioningGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_provisioning_group_id):
            query['AutoProvisioningGroupId'] = request.auto_provisioning_group_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.terminate_instances):
            query['TerminateInstances'] = request.terminate_instances
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAutoProvisioningGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteAutoProvisioningGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_auto_provisioning_group_with_options_async(
        self,
        request: ecs_20140526_models.DeleteAutoProvisioningGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteAutoProvisioningGroupResponse:
        """
        @summary Deletes an auto provisioning group. When you call this operation, you can specify AutoProvisioningGroupId and TerminateInstances in the request.
        
        @param request: DeleteAutoProvisioningGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAutoProvisioningGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_provisioning_group_id):
            query['AutoProvisioningGroupId'] = request.auto_provisioning_group_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.terminate_instances):
            query['TerminateInstances'] = request.terminate_instances
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAutoProvisioningGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteAutoProvisioningGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_auto_provisioning_group(
        self,
        request: ecs_20140526_models.DeleteAutoProvisioningGroupRequest,
    ) -> ecs_20140526_models.DeleteAutoProvisioningGroupResponse:
        """
        @summary Deletes an auto provisioning group. When you call this operation, you can specify AutoProvisioningGroupId and TerminateInstances in the request.
        
        @param request: DeleteAutoProvisioningGroupRequest
        @return: DeleteAutoProvisioningGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_auto_provisioning_group_with_options(request, runtime)

    async def delete_auto_provisioning_group_async(
        self,
        request: ecs_20140526_models.DeleteAutoProvisioningGroupRequest,
    ) -> ecs_20140526_models.DeleteAutoProvisioningGroupResponse:
        """
        @summary Deletes an auto provisioning group. When you call this operation, you can specify AutoProvisioningGroupId and TerminateInstances in the request.
        
        @param request: DeleteAutoProvisioningGroupRequest
        @return: DeleteAutoProvisioningGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_auto_provisioning_group_with_options_async(request, runtime)

    def delete_auto_snapshot_policy_with_options(
        self,
        request: ecs_20140526_models.DeleteAutoSnapshotPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteAutoSnapshotPolicyResponse:
        """
        @summary Deletes an automatic snapshot policy. After you delete an automatic snapshot policy, the policy is no longer applied to the disks on which it previously took effect.
        
        @param request: DeleteAutoSnapshotPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAutoSnapshotPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.auto_snapshot_policy_id):
            query['autoSnapshotPolicyId'] = request.auto_snapshot_policy_id
        if not UtilClient.is_unset(request.region_id):
            query['regionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAutoSnapshotPolicy',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteAutoSnapshotPolicyResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_auto_snapshot_policy_with_options_async(
        self,
        request: ecs_20140526_models.DeleteAutoSnapshotPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteAutoSnapshotPolicyResponse:
        """
        @summary Deletes an automatic snapshot policy. After you delete an automatic snapshot policy, the policy is no longer applied to the disks on which it previously took effect.
        
        @param request: DeleteAutoSnapshotPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAutoSnapshotPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.auto_snapshot_policy_id):
            query['autoSnapshotPolicyId'] = request.auto_snapshot_policy_id
        if not UtilClient.is_unset(request.region_id):
            query['regionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAutoSnapshotPolicy',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteAutoSnapshotPolicyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_auto_snapshot_policy(
        self,
        request: ecs_20140526_models.DeleteAutoSnapshotPolicyRequest,
    ) -> ecs_20140526_models.DeleteAutoSnapshotPolicyResponse:
        """
        @summary Deletes an automatic snapshot policy. After you delete an automatic snapshot policy, the policy is no longer applied to the disks on which it previously took effect.
        
        @param request: DeleteAutoSnapshotPolicyRequest
        @return: DeleteAutoSnapshotPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_auto_snapshot_policy_with_options(request, runtime)

    async def delete_auto_snapshot_policy_async(
        self,
        request: ecs_20140526_models.DeleteAutoSnapshotPolicyRequest,
    ) -> ecs_20140526_models.DeleteAutoSnapshotPolicyResponse:
        """
        @summary Deletes an automatic snapshot policy. After you delete an automatic snapshot policy, the policy is no longer applied to the disks on which it previously took effect.
        
        @param request: DeleteAutoSnapshotPolicyRequest
        @return: DeleteAutoSnapshotPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_auto_snapshot_policy_with_options_async(request, runtime)

    def delete_bandwidth_package_with_options(
        self,
        request: ecs_20140526_models.DeleteBandwidthPackageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteBandwidthPackageResponse:
        """
        @deprecated OpenAPI DeleteBandwidthPackage is deprecated, please use Vpc::2016-04-28::DeleteBandwidthPackage instead.
        
        @summary DeleteBandwidthPackage
        
        @param request: DeleteBandwidthPackageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteBandwidthPackageResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteBandwidthPackage',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteBandwidthPackageResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_bandwidth_package_with_options_async(
        self,
        request: ecs_20140526_models.DeleteBandwidthPackageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteBandwidthPackageResponse:
        """
        @deprecated OpenAPI DeleteBandwidthPackage is deprecated, please use Vpc::2016-04-28::DeleteBandwidthPackage instead.
        
        @summary DeleteBandwidthPackage
        
        @param request: DeleteBandwidthPackageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteBandwidthPackageResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteBandwidthPackage',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteBandwidthPackageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_bandwidth_package(
        self,
        request: ecs_20140526_models.DeleteBandwidthPackageRequest,
    ) -> ecs_20140526_models.DeleteBandwidthPackageResponse:
        """
        @deprecated OpenAPI DeleteBandwidthPackage is deprecated, please use Vpc::2016-04-28::DeleteBandwidthPackage instead.
        
        @summary DeleteBandwidthPackage
        
        @param request: DeleteBandwidthPackageRequest
        @return: DeleteBandwidthPackageResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_bandwidth_package_with_options(request, runtime)

    async def delete_bandwidth_package_async(
        self,
        request: ecs_20140526_models.DeleteBandwidthPackageRequest,
    ) -> ecs_20140526_models.DeleteBandwidthPackageResponse:
        """
        @deprecated OpenAPI DeleteBandwidthPackage is deprecated, please use Vpc::2016-04-28::DeleteBandwidthPackage instead.
        
        @summary DeleteBandwidthPackage
        
        @param request: DeleteBandwidthPackageRequest
        @return: DeleteBandwidthPackageResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_bandwidth_package_with_options_async(request, runtime)

    def delete_command_with_options(
        self,
        request: ecs_20140526_models.DeleteCommandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteCommandResponse:
        """
        @summary Deletes a Cloud Assistant command in a region. This operation cannot delete Cloud Assistant commands that are being run.
        
        @param request: DeleteCommandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCommandResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.command_id):
            query['CommandId'] = request.command_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCommand',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteCommandResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_command_with_options_async(
        self,
        request: ecs_20140526_models.DeleteCommandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteCommandResponse:
        """
        @summary Deletes a Cloud Assistant command in a region. This operation cannot delete Cloud Assistant commands that are being run.
        
        @param request: DeleteCommandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCommandResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.command_id):
            query['CommandId'] = request.command_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCommand',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteCommandResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_command(
        self,
        request: ecs_20140526_models.DeleteCommandRequest,
    ) -> ecs_20140526_models.DeleteCommandResponse:
        """
        @summary Deletes a Cloud Assistant command in a region. This operation cannot delete Cloud Assistant commands that are being run.
        
        @param request: DeleteCommandRequest
        @return: DeleteCommandResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_command_with_options(request, runtime)

    async def delete_command_async(
        self,
        request: ecs_20140526_models.DeleteCommandRequest,
    ) -> ecs_20140526_models.DeleteCommandResponse:
        """
        @summary Deletes a Cloud Assistant command in a region. This operation cannot delete Cloud Assistant commands that are being run.
        
        @param request: DeleteCommandRequest
        @return: DeleteCommandResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_command_with_options_async(request, runtime)

    def delete_dedicated_host_cluster_with_options(
        self,
        request: ecs_20140526_models.DeleteDedicatedHostClusterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteDedicatedHostClusterResponse:
        """
        @summary Deletes a dedicated host group. Before you call the API operation, you must migrate the dedicated hosts in the host group to another host group.
        
        @param request: DeleteDedicatedHostClusterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDedicatedHostClusterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dedicated_host_cluster_id):
            query['DedicatedHostClusterId'] = request.dedicated_host_cluster_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDedicatedHostCluster',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteDedicatedHostClusterResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_dedicated_host_cluster_with_options_async(
        self,
        request: ecs_20140526_models.DeleteDedicatedHostClusterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteDedicatedHostClusterResponse:
        """
        @summary Deletes a dedicated host group. Before you call the API operation, you must migrate the dedicated hosts in the host group to another host group.
        
        @param request: DeleteDedicatedHostClusterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDedicatedHostClusterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dedicated_host_cluster_id):
            query['DedicatedHostClusterId'] = request.dedicated_host_cluster_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDedicatedHostCluster',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteDedicatedHostClusterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_dedicated_host_cluster(
        self,
        request: ecs_20140526_models.DeleteDedicatedHostClusterRequest,
    ) -> ecs_20140526_models.DeleteDedicatedHostClusterResponse:
        """
        @summary Deletes a dedicated host group. Before you call the API operation, you must migrate the dedicated hosts in the host group to another host group.
        
        @param request: DeleteDedicatedHostClusterRequest
        @return: DeleteDedicatedHostClusterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_dedicated_host_cluster_with_options(request, runtime)

    async def delete_dedicated_host_cluster_async(
        self,
        request: ecs_20140526_models.DeleteDedicatedHostClusterRequest,
    ) -> ecs_20140526_models.DeleteDedicatedHostClusterResponse:
        """
        @summary Deletes a dedicated host group. Before you call the API operation, you must migrate the dedicated hosts in the host group to another host group.
        
        @param request: DeleteDedicatedHostClusterRequest
        @return: DeleteDedicatedHostClusterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_dedicated_host_cluster_with_options_async(request, runtime)

    def delete_deployment_set_with_options(
        self,
        request: ecs_20140526_models.DeleteDeploymentSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteDeploymentSetResponse:
        """
        @summary Deletes a deployment set.
        
        @description Before you delete a deployment set, make sure that no instances exist in the deployment set. If instances exist in the deployment set, move the instances to a different deployment set or release the instances before you delete the deployment set. For more information, see [Change the deployment set of an instance](https://help.aliyun.com/document_detail/108407.html) and [Release an ECS instance](https://help.aliyun.com/document_detail/25442.html).
        
        @param request: DeleteDeploymentSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDeploymentSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.deployment_set_id):
            query['DeploymentSetId'] = request.deployment_set_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDeploymentSet',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteDeploymentSetResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_deployment_set_with_options_async(
        self,
        request: ecs_20140526_models.DeleteDeploymentSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteDeploymentSetResponse:
        """
        @summary Deletes a deployment set.
        
        @description Before you delete a deployment set, make sure that no instances exist in the deployment set. If instances exist in the deployment set, move the instances to a different deployment set or release the instances before you delete the deployment set. For more information, see [Change the deployment set of an instance](https://help.aliyun.com/document_detail/108407.html) and [Release an ECS instance](https://help.aliyun.com/document_detail/25442.html).
        
        @param request: DeleteDeploymentSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDeploymentSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.deployment_set_id):
            query['DeploymentSetId'] = request.deployment_set_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDeploymentSet',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteDeploymentSetResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_deployment_set(
        self,
        request: ecs_20140526_models.DeleteDeploymentSetRequest,
    ) -> ecs_20140526_models.DeleteDeploymentSetResponse:
        """
        @summary Deletes a deployment set.
        
        @description Before you delete a deployment set, make sure that no instances exist in the deployment set. If instances exist in the deployment set, move the instances to a different deployment set or release the instances before you delete the deployment set. For more information, see [Change the deployment set of an instance](https://help.aliyun.com/document_detail/108407.html) and [Release an ECS instance](https://help.aliyun.com/document_detail/25442.html).
        
        @param request: DeleteDeploymentSetRequest
        @return: DeleteDeploymentSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_deployment_set_with_options(request, runtime)

    async def delete_deployment_set_async(
        self,
        request: ecs_20140526_models.DeleteDeploymentSetRequest,
    ) -> ecs_20140526_models.DeleteDeploymentSetResponse:
        """
        @summary Deletes a deployment set.
        
        @description Before you delete a deployment set, make sure that no instances exist in the deployment set. If instances exist in the deployment set, move the instances to a different deployment set or release the instances before you delete the deployment set. For more information, see [Change the deployment set of an instance](https://help.aliyun.com/document_detail/108407.html) and [Release an ECS instance](https://help.aliyun.com/document_detail/25442.html).
        
        @param request: DeleteDeploymentSetRequest
        @return: DeleteDeploymentSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_deployment_set_with_options_async(request, runtime)

    def delete_diagnostic_metric_sets_with_options(
        self,
        request: ecs_20140526_models.DeleteDiagnosticMetricSetsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteDiagnosticMetricSetsResponse:
        """
        @summary Deletes diagnostic metric sets.
        
        @param request: DeleteDiagnosticMetricSetsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDiagnosticMetricSetsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.metric_set_ids):
            query['MetricSetIds'] = request.metric_set_ids
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDiagnosticMetricSets',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteDiagnosticMetricSetsResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_diagnostic_metric_sets_with_options_async(
        self,
        request: ecs_20140526_models.DeleteDiagnosticMetricSetsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteDiagnosticMetricSetsResponse:
        """
        @summary Deletes diagnostic metric sets.
        
        @param request: DeleteDiagnosticMetricSetsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDiagnosticMetricSetsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.metric_set_ids):
            query['MetricSetIds'] = request.metric_set_ids
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDiagnosticMetricSets',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteDiagnosticMetricSetsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_diagnostic_metric_sets(
        self,
        request: ecs_20140526_models.DeleteDiagnosticMetricSetsRequest,
    ) -> ecs_20140526_models.DeleteDiagnosticMetricSetsResponse:
        """
        @summary Deletes diagnostic metric sets.
        
        @param request: DeleteDiagnosticMetricSetsRequest
        @return: DeleteDiagnosticMetricSetsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_diagnostic_metric_sets_with_options(request, runtime)

    async def delete_diagnostic_metric_sets_async(
        self,
        request: ecs_20140526_models.DeleteDiagnosticMetricSetsRequest,
    ) -> ecs_20140526_models.DeleteDiagnosticMetricSetsResponse:
        """
        @summary Deletes diagnostic metric sets.
        
        @param request: DeleteDiagnosticMetricSetsRequest
        @return: DeleteDiagnosticMetricSetsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_diagnostic_metric_sets_with_options_async(request, runtime)

    def delete_diagnostic_reports_with_options(
        self,
        request: ecs_20140526_models.DeleteDiagnosticReportsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteDiagnosticReportsResponse:
        """
        @summary Deletes diagnostic reports.
        
        @description You can call this operation to delete the diagnostic reports that are no longer needed.
        
        @param request: DeleteDiagnosticReportsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDiagnosticReportsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.report_ids):
            query['ReportIds'] = request.report_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDiagnosticReports',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteDiagnosticReportsResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_diagnostic_reports_with_options_async(
        self,
        request: ecs_20140526_models.DeleteDiagnosticReportsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteDiagnosticReportsResponse:
        """
        @summary Deletes diagnostic reports.
        
        @description You can call this operation to delete the diagnostic reports that are no longer needed.
        
        @param request: DeleteDiagnosticReportsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDiagnosticReportsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.report_ids):
            query['ReportIds'] = request.report_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDiagnosticReports',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteDiagnosticReportsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_diagnostic_reports(
        self,
        request: ecs_20140526_models.DeleteDiagnosticReportsRequest,
    ) -> ecs_20140526_models.DeleteDiagnosticReportsResponse:
        """
        @summary Deletes diagnostic reports.
        
        @description You can call this operation to delete the diagnostic reports that are no longer needed.
        
        @param request: DeleteDiagnosticReportsRequest
        @return: DeleteDiagnosticReportsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_diagnostic_reports_with_options(request, runtime)

    async def delete_diagnostic_reports_async(
        self,
        request: ecs_20140526_models.DeleteDiagnosticReportsRequest,
    ) -> ecs_20140526_models.DeleteDiagnosticReportsResponse:
        """
        @summary Deletes diagnostic reports.
        
        @description You can call this operation to delete the diagnostic reports that are no longer needed.
        
        @param request: DeleteDiagnosticReportsRequest
        @return: DeleteDiagnosticReportsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_diagnostic_reports_with_options_async(request, runtime)

    def delete_disk_with_options(
        self,
        request: ecs_20140526_models.DeleteDiskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteDiskResponse:
        """
        @summary Deletes a pay-as-you-go data disk. The data disk can be a basic disk, an ultra disk, a standard SSD, or an Enterprise SSD (ESSD).
        
        @description When you call this operation, take note of the following items:
        Manual snapshots of the disk are retained.
        You can call the [ModifyDiskAttribute](https://help.aliyun.com/document_detail/25517.html) operation to configure whether to retain automatic snapshots of the disk or release the snapshots along with the disk. We recommend that you delete the snapshots that are no longer needed to maintain a sufficient quota for new automatic snapshots.
        The disk must be in the Unattached (Available) state.
        If the specified DiskId parameter does not exist, the request is ignored.
        
        @param request: DeleteDiskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDiskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDisk',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteDiskResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_disk_with_options_async(
        self,
        request: ecs_20140526_models.DeleteDiskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteDiskResponse:
        """
        @summary Deletes a pay-as-you-go data disk. The data disk can be a basic disk, an ultra disk, a standard SSD, or an Enterprise SSD (ESSD).
        
        @description When you call this operation, take note of the following items:
        Manual snapshots of the disk are retained.
        You can call the [ModifyDiskAttribute](https://help.aliyun.com/document_detail/25517.html) operation to configure whether to retain automatic snapshots of the disk or release the snapshots along with the disk. We recommend that you delete the snapshots that are no longer needed to maintain a sufficient quota for new automatic snapshots.
        The disk must be in the Unattached (Available) state.
        If the specified DiskId parameter does not exist, the request is ignored.
        
        @param request: DeleteDiskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDiskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDisk',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteDiskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_disk(
        self,
        request: ecs_20140526_models.DeleteDiskRequest,
    ) -> ecs_20140526_models.DeleteDiskResponse:
        """
        @summary Deletes a pay-as-you-go data disk. The data disk can be a basic disk, an ultra disk, a standard SSD, or an Enterprise SSD (ESSD).
        
        @description When you call this operation, take note of the following items:
        Manual snapshots of the disk are retained.
        You can call the [ModifyDiskAttribute](https://help.aliyun.com/document_detail/25517.html) operation to configure whether to retain automatic snapshots of the disk or release the snapshots along with the disk. We recommend that you delete the snapshots that are no longer needed to maintain a sufficient quota for new automatic snapshots.
        The disk must be in the Unattached (Available) state.
        If the specified DiskId parameter does not exist, the request is ignored.
        
        @param request: DeleteDiskRequest
        @return: DeleteDiskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_disk_with_options(request, runtime)

    async def delete_disk_async(
        self,
        request: ecs_20140526_models.DeleteDiskRequest,
    ) -> ecs_20140526_models.DeleteDiskResponse:
        """
        @summary Deletes a pay-as-you-go data disk. The data disk can be a basic disk, an ultra disk, a standard SSD, or an Enterprise SSD (ESSD).
        
        @description When you call this operation, take note of the following items:
        Manual snapshots of the disk are retained.
        You can call the [ModifyDiskAttribute](https://help.aliyun.com/document_detail/25517.html) operation to configure whether to retain automatic snapshots of the disk or release the snapshots along with the disk. We recommend that you delete the snapshots that are no longer needed to maintain a sufficient quota for new automatic snapshots.
        The disk must be in the Unattached (Available) state.
        If the specified DiskId parameter does not exist, the request is ignored.
        
        @param request: DeleteDiskRequest
        @return: DeleteDiskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_disk_with_options_async(request, runtime)

    def delete_forward_entry_with_options(
        self,
        request: ecs_20140526_models.DeleteForwardEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteForwardEntryResponse:
        """
        @deprecated OpenAPI DeleteForwardEntry is deprecated, please use Vpc::2016-04-28::DeleteForwardEntry instead.
        
        @summary DeleteForwardEntry
        
        @param request: DeleteForwardEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteForwardEntryResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.forward_entry_id):
            query['ForwardEntryId'] = request.forward_entry_id
        if not UtilClient.is_unset(request.forward_table_id):
            query['ForwardTableId'] = request.forward_table_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteForwardEntry',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteForwardEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_forward_entry_with_options_async(
        self,
        request: ecs_20140526_models.DeleteForwardEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteForwardEntryResponse:
        """
        @deprecated OpenAPI DeleteForwardEntry is deprecated, please use Vpc::2016-04-28::DeleteForwardEntry instead.
        
        @summary DeleteForwardEntry
        
        @param request: DeleteForwardEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteForwardEntryResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.forward_entry_id):
            query['ForwardEntryId'] = request.forward_entry_id
        if not UtilClient.is_unset(request.forward_table_id):
            query['ForwardTableId'] = request.forward_table_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteForwardEntry',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteForwardEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_forward_entry(
        self,
        request: ecs_20140526_models.DeleteForwardEntryRequest,
    ) -> ecs_20140526_models.DeleteForwardEntryResponse:
        """
        @deprecated OpenAPI DeleteForwardEntry is deprecated, please use Vpc::2016-04-28::DeleteForwardEntry instead.
        
        @summary DeleteForwardEntry
        
        @param request: DeleteForwardEntryRequest
        @return: DeleteForwardEntryResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_forward_entry_with_options(request, runtime)

    async def delete_forward_entry_async(
        self,
        request: ecs_20140526_models.DeleteForwardEntryRequest,
    ) -> ecs_20140526_models.DeleteForwardEntryResponse:
        """
        @deprecated OpenAPI DeleteForwardEntry is deprecated, please use Vpc::2016-04-28::DeleteForwardEntry instead.
        
        @summary DeleteForwardEntry
        
        @param request: DeleteForwardEntryRequest
        @return: DeleteForwardEntryResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_forward_entry_with_options_async(request, runtime)

    def delete_ha_vip_with_options(
        self,
        request: ecs_20140526_models.DeleteHaVipRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteHaVipResponse:
        """
        @deprecated OpenAPI DeleteHaVip is deprecated, please use Vpc::2016-04-28::DeleteHaVip instead.
        
        @summary DeleteHaVip
        
        @param request: DeleteHaVipRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteHaVipResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ha_vip_id):
            query['HaVipId'] = request.ha_vip_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteHaVip',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteHaVipResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_ha_vip_with_options_async(
        self,
        request: ecs_20140526_models.DeleteHaVipRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteHaVipResponse:
        """
        @deprecated OpenAPI DeleteHaVip is deprecated, please use Vpc::2016-04-28::DeleteHaVip instead.
        
        @summary DeleteHaVip
        
        @param request: DeleteHaVipRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteHaVipResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ha_vip_id):
            query['HaVipId'] = request.ha_vip_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteHaVip',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteHaVipResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_ha_vip(
        self,
        request: ecs_20140526_models.DeleteHaVipRequest,
    ) -> ecs_20140526_models.DeleteHaVipResponse:
        """
        @deprecated OpenAPI DeleteHaVip is deprecated, please use Vpc::2016-04-28::DeleteHaVip instead.
        
        @summary DeleteHaVip
        
        @param request: DeleteHaVipRequest
        @return: DeleteHaVipResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_ha_vip_with_options(request, runtime)

    async def delete_ha_vip_async(
        self,
        request: ecs_20140526_models.DeleteHaVipRequest,
    ) -> ecs_20140526_models.DeleteHaVipResponse:
        """
        @deprecated OpenAPI DeleteHaVip is deprecated, please use Vpc::2016-04-28::DeleteHaVip instead.
        
        @summary DeleteHaVip
        
        @param request: DeleteHaVipRequest
        @return: DeleteHaVipResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_ha_vip_with_options_async(request, runtime)

    def delete_hpc_cluster_with_options(
        self,
        request: ecs_20140526_models.DeleteHpcClusterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteHpcClusterResponse:
        """
        @summary Deletes a high performance computing (HPC) cluster.
        
        @param request: DeleteHpcClusterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteHpcClusterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.hpc_cluster_id):
            query['HpcClusterId'] = request.hpc_cluster_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteHpcCluster',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteHpcClusterResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_hpc_cluster_with_options_async(
        self,
        request: ecs_20140526_models.DeleteHpcClusterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteHpcClusterResponse:
        """
        @summary Deletes a high performance computing (HPC) cluster.
        
        @param request: DeleteHpcClusterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteHpcClusterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.hpc_cluster_id):
            query['HpcClusterId'] = request.hpc_cluster_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteHpcCluster',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteHpcClusterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_hpc_cluster(
        self,
        request: ecs_20140526_models.DeleteHpcClusterRequest,
    ) -> ecs_20140526_models.DeleteHpcClusterResponse:
        """
        @summary Deletes a high performance computing (HPC) cluster.
        
        @param request: DeleteHpcClusterRequest
        @return: DeleteHpcClusterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_hpc_cluster_with_options(request, runtime)

    async def delete_hpc_cluster_async(
        self,
        request: ecs_20140526_models.DeleteHpcClusterRequest,
    ) -> ecs_20140526_models.DeleteHpcClusterResponse:
        """
        @summary Deletes a high performance computing (HPC) cluster.
        
        @param request: DeleteHpcClusterRequest
        @return: DeleteHpcClusterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_hpc_cluster_with_options_async(request, runtime)

    def delete_image_with_options(
        self,
        request: ecs_20140526_models.DeleteImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteImageResponse:
        """
        @summary Deletes a custom image. When you call this operation, you can specify ImageId and Force in the request.
        
        @description For information about scenarios in which you cannot delete a custom image and the considerations related to custom image deletion, see [Delete a custom image](https://help.aliyun.com/document_detail/25466.html).
        
        @param request: DeleteImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteImage',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteImageResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_image_with_options_async(
        self,
        request: ecs_20140526_models.DeleteImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteImageResponse:
        """
        @summary Deletes a custom image. When you call this operation, you can specify ImageId and Force in the request.
        
        @description For information about scenarios in which you cannot delete a custom image and the considerations related to custom image deletion, see [Delete a custom image](https://help.aliyun.com/document_detail/25466.html).
        
        @param request: DeleteImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteImage',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteImageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_image(
        self,
        request: ecs_20140526_models.DeleteImageRequest,
    ) -> ecs_20140526_models.DeleteImageResponse:
        """
        @summary Deletes a custom image. When you call this operation, you can specify ImageId and Force in the request.
        
        @description For information about scenarios in which you cannot delete a custom image and the considerations related to custom image deletion, see [Delete a custom image](https://help.aliyun.com/document_detail/25466.html).
        
        @param request: DeleteImageRequest
        @return: DeleteImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_image_with_options(request, runtime)

    async def delete_image_async(
        self,
        request: ecs_20140526_models.DeleteImageRequest,
    ) -> ecs_20140526_models.DeleteImageResponse:
        """
        @summary Deletes a custom image. When you call this operation, you can specify ImageId and Force in the request.
        
        @description For information about scenarios in which you cannot delete a custom image and the considerations related to custom image deletion, see [Delete a custom image](https://help.aliyun.com/document_detail/25466.html).
        
        @param request: DeleteImageRequest
        @return: DeleteImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_image_with_options_async(request, runtime)

    def delete_image_component_with_options(
        self,
        request: ecs_20140526_models.DeleteImageComponentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteImageComponentResponse:
        """
        @summary Deletes an image component. You can specify RegionId and ImageComponentId in the request.
        
        @description    Only custom image components can be deleted.
        When you delete a component, make sure that the component is not used in the template. Otherwise, the component fails to be deleted.
        
        @param request: DeleteImageComponentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteImageComponentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.image_component_id):
            query['ImageComponentId'] = request.image_component_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteImageComponent',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteImageComponentResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_image_component_with_options_async(
        self,
        request: ecs_20140526_models.DeleteImageComponentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteImageComponentResponse:
        """
        @summary Deletes an image component. You can specify RegionId and ImageComponentId in the request.
        
        @description    Only custom image components can be deleted.
        When you delete a component, make sure that the component is not used in the template. Otherwise, the component fails to be deleted.
        
        @param request: DeleteImageComponentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteImageComponentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.image_component_id):
            query['ImageComponentId'] = request.image_component_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteImageComponent',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteImageComponentResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_image_component(
        self,
        request: ecs_20140526_models.DeleteImageComponentRequest,
    ) -> ecs_20140526_models.DeleteImageComponentResponse:
        """
        @summary Deletes an image component. You can specify RegionId and ImageComponentId in the request.
        
        @description    Only custom image components can be deleted.
        When you delete a component, make sure that the component is not used in the template. Otherwise, the component fails to be deleted.
        
        @param request: DeleteImageComponentRequest
        @return: DeleteImageComponentResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_image_component_with_options(request, runtime)

    async def delete_image_component_async(
        self,
        request: ecs_20140526_models.DeleteImageComponentRequest,
    ) -> ecs_20140526_models.DeleteImageComponentResponse:
        """
        @summary Deletes an image component. You can specify RegionId and ImageComponentId in the request.
        
        @description    Only custom image components can be deleted.
        When you delete a component, make sure that the component is not used in the template. Otherwise, the component fails to be deleted.
        
        @param request: DeleteImageComponentRequest
        @return: DeleteImageComponentResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_image_component_with_options_async(request, runtime)

    def delete_image_pipeline_with_options(
        self,
        request: ecs_20140526_models.DeleteImagePipelineRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteImagePipelineResponse:
        """
        @summary Deletes an image template.
        
        @description If an ongoing image building task is associated with an image template, you cannot delete the image template. You can delete the image template only if the image building task reaches the SUCCESS, FAILED, TEST_FAILED, PARTITION_SUCCESS, or CANCELLED state. You can call the DescribeImagePipelineExecutions operation to query the details of an image building task.
        
        @param request: DeleteImagePipelineRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteImagePipelineResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.image_pipeline_id):
            query['ImagePipelineId'] = request.image_pipeline_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteImagePipeline',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteImagePipelineResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_image_pipeline_with_options_async(
        self,
        request: ecs_20140526_models.DeleteImagePipelineRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteImagePipelineResponse:
        """
        @summary Deletes an image template.
        
        @description If an ongoing image building task is associated with an image template, you cannot delete the image template. You can delete the image template only if the image building task reaches the SUCCESS, FAILED, TEST_FAILED, PARTITION_SUCCESS, or CANCELLED state. You can call the DescribeImagePipelineExecutions operation to query the details of an image building task.
        
        @param request: DeleteImagePipelineRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteImagePipelineResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.image_pipeline_id):
            query['ImagePipelineId'] = request.image_pipeline_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteImagePipeline',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteImagePipelineResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_image_pipeline(
        self,
        request: ecs_20140526_models.DeleteImagePipelineRequest,
    ) -> ecs_20140526_models.DeleteImagePipelineResponse:
        """
        @summary Deletes an image template.
        
        @description If an ongoing image building task is associated with an image template, you cannot delete the image template. You can delete the image template only if the image building task reaches the SUCCESS, FAILED, TEST_FAILED, PARTITION_SUCCESS, or CANCELLED state. You can call the DescribeImagePipelineExecutions operation to query the details of an image building task.
        
        @param request: DeleteImagePipelineRequest
        @return: DeleteImagePipelineResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_image_pipeline_with_options(request, runtime)

    async def delete_image_pipeline_async(
        self,
        request: ecs_20140526_models.DeleteImagePipelineRequest,
    ) -> ecs_20140526_models.DeleteImagePipelineResponse:
        """
        @summary Deletes an image template.
        
        @description If an ongoing image building task is associated with an image template, you cannot delete the image template. You can delete the image template only if the image building task reaches the SUCCESS, FAILED, TEST_FAILED, PARTITION_SUCCESS, or CANCELLED state. You can call the DescribeImagePipelineExecutions operation to query the details of an image building task.
        
        @param request: DeleteImagePipelineRequest
        @return: DeleteImagePipelineResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_image_pipeline_with_options_async(request, runtime)

    def delete_instance_with_options(
        self,
        request: ecs_20140526_models.DeleteInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteInstanceResponse:
        """
        @summary Deletes or releases a pay-as-you-go Elastic Compute Service (ECS) instance or an expired subscription ECS instance. You can configure parameters to specify whether to release the disks attached to the instance or retain the disks as pay-as-you-go disks.
        
        @description *\
        *Warning** After you release an instance, the physical resources used by the instance are recycled. Relevant data is erased and cannot be restored.
        After you release an instance, manual snapshots of the cloud disks attached to the instance are retained and continue to be billed. You can call the [DeleteSnapshot](https://help.aliyun.com/document_detail/2679824.html) operation to delete the snapshots.
        After you release an instance, whether the cloud disks attached to the instance and the automatic snapshots of the disks are released is determined by the disk attributes. Before you release an instance, you can call the [DescribeDisks](https://help.aliyun.com/document_detail/2679767.html) and [ModifyDiskAttribute](https://help.aliyun.com/document_detail/2679770.html) operations to query and modify disk attributes.
        The cloud disks for which `DeleteWithInstance` is set to false are retained as pay-as-you-go disks after the instance is released. The cloud disks for which DeleteWithInstance is set to true are released along with the instance.
        If `DeleteAutoSnapshot` is set to false for a cloud disk attached to the instance, the automatic snapshots of the cloud disk are retained when the instance is released. If DeleteAutoSnapshot is set to true for the cloud disk, the automatic snapshots of the disk are released along with the instance.
        Elastic IP addresses (EIPs) are not released together with instances. You can call the [ReleaseEipAddress](https://help.aliyun.com/document_detail/448702.html) operation to release EIPs.
        *\
        *Note** When you release an instance that is locked for security reasons, the cloud disks attached to the instance are released even if DeleteWithInstance is set to false.
        
        @param request: DeleteInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.force_stop):
            query['ForceStop'] = request.force_stop
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.terminate_subscription):
            query['TerminateSubscription'] = request.terminate_subscription
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteInstance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_instance_with_options_async(
        self,
        request: ecs_20140526_models.DeleteInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteInstanceResponse:
        """
        @summary Deletes or releases a pay-as-you-go Elastic Compute Service (ECS) instance or an expired subscription ECS instance. You can configure parameters to specify whether to release the disks attached to the instance or retain the disks as pay-as-you-go disks.
        
        @description *\
        *Warning** After you release an instance, the physical resources used by the instance are recycled. Relevant data is erased and cannot be restored.
        After you release an instance, manual snapshots of the cloud disks attached to the instance are retained and continue to be billed. You can call the [DeleteSnapshot](https://help.aliyun.com/document_detail/2679824.html) operation to delete the snapshots.
        After you release an instance, whether the cloud disks attached to the instance and the automatic snapshots of the disks are released is determined by the disk attributes. Before you release an instance, you can call the [DescribeDisks](https://help.aliyun.com/document_detail/2679767.html) and [ModifyDiskAttribute](https://help.aliyun.com/document_detail/2679770.html) operations to query and modify disk attributes.
        The cloud disks for which `DeleteWithInstance` is set to false are retained as pay-as-you-go disks after the instance is released. The cloud disks for which DeleteWithInstance is set to true are released along with the instance.
        If `DeleteAutoSnapshot` is set to false for a cloud disk attached to the instance, the automatic snapshots of the cloud disk are retained when the instance is released. If DeleteAutoSnapshot is set to true for the cloud disk, the automatic snapshots of the disk are released along with the instance.
        Elastic IP addresses (EIPs) are not released together with instances. You can call the [ReleaseEipAddress](https://help.aliyun.com/document_detail/448702.html) operation to release EIPs.
        *\
        *Note** When you release an instance that is locked for security reasons, the cloud disks attached to the instance are released even if DeleteWithInstance is set to false.
        
        @param request: DeleteInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.force_stop):
            query['ForceStop'] = request.force_stop
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.terminate_subscription):
            query['TerminateSubscription'] = request.terminate_subscription
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteInstance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_instance(
        self,
        request: ecs_20140526_models.DeleteInstanceRequest,
    ) -> ecs_20140526_models.DeleteInstanceResponse:
        """
        @summary Deletes or releases a pay-as-you-go Elastic Compute Service (ECS) instance or an expired subscription ECS instance. You can configure parameters to specify whether to release the disks attached to the instance or retain the disks as pay-as-you-go disks.
        
        @description *\
        *Warning** After you release an instance, the physical resources used by the instance are recycled. Relevant data is erased and cannot be restored.
        After you release an instance, manual snapshots of the cloud disks attached to the instance are retained and continue to be billed. You can call the [DeleteSnapshot](https://help.aliyun.com/document_detail/2679824.html) operation to delete the snapshots.
        After you release an instance, whether the cloud disks attached to the instance and the automatic snapshots of the disks are released is determined by the disk attributes. Before you release an instance, you can call the [DescribeDisks](https://help.aliyun.com/document_detail/2679767.html) and [ModifyDiskAttribute](https://help.aliyun.com/document_detail/2679770.html) operations to query and modify disk attributes.
        The cloud disks for which `DeleteWithInstance` is set to false are retained as pay-as-you-go disks after the instance is released. The cloud disks for which DeleteWithInstance is set to true are released along with the instance.
        If `DeleteAutoSnapshot` is set to false for a cloud disk attached to the instance, the automatic snapshots of the cloud disk are retained when the instance is released. If DeleteAutoSnapshot is set to true for the cloud disk, the automatic snapshots of the disk are released along with the instance.
        Elastic IP addresses (EIPs) are not released together with instances. You can call the [ReleaseEipAddress](https://help.aliyun.com/document_detail/448702.html) operation to release EIPs.
        *\
        *Note** When you release an instance that is locked for security reasons, the cloud disks attached to the instance are released even if DeleteWithInstance is set to false.
        
        @param request: DeleteInstanceRequest
        @return: DeleteInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_instance_with_options(request, runtime)

    async def delete_instance_async(
        self,
        request: ecs_20140526_models.DeleteInstanceRequest,
    ) -> ecs_20140526_models.DeleteInstanceResponse:
        """
        @summary Deletes or releases a pay-as-you-go Elastic Compute Service (ECS) instance or an expired subscription ECS instance. You can configure parameters to specify whether to release the disks attached to the instance or retain the disks as pay-as-you-go disks.
        
        @description *\
        *Warning** After you release an instance, the physical resources used by the instance are recycled. Relevant data is erased and cannot be restored.
        After you release an instance, manual snapshots of the cloud disks attached to the instance are retained and continue to be billed. You can call the [DeleteSnapshot](https://help.aliyun.com/document_detail/2679824.html) operation to delete the snapshots.
        After you release an instance, whether the cloud disks attached to the instance and the automatic snapshots of the disks are released is determined by the disk attributes. Before you release an instance, you can call the [DescribeDisks](https://help.aliyun.com/document_detail/2679767.html) and [ModifyDiskAttribute](https://help.aliyun.com/document_detail/2679770.html) operations to query and modify disk attributes.
        The cloud disks for which `DeleteWithInstance` is set to false are retained as pay-as-you-go disks after the instance is released. The cloud disks for which DeleteWithInstance is set to true are released along with the instance.
        If `DeleteAutoSnapshot` is set to false for a cloud disk attached to the instance, the automatic snapshots of the cloud disk are retained when the instance is released. If DeleteAutoSnapshot is set to true for the cloud disk, the automatic snapshots of the disk are released along with the instance.
        Elastic IP addresses (EIPs) are not released together with instances. You can call the [ReleaseEipAddress](https://help.aliyun.com/document_detail/448702.html) operation to release EIPs.
        *\
        *Note** When you release an instance that is locked for security reasons, the cloud disks attached to the instance are released even if DeleteWithInstance is set to false.
        
        @param request: DeleteInstanceRequest
        @return: DeleteInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_instance_with_options_async(request, runtime)

    def delete_instances_with_options(
        self,
        request: ecs_20140526_models.DeleteInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteInstancesResponse:
        """
        @summary Releases multiple pay-as-you-go Elastic Compute Service (ECS) instances or expired subscription ECS instances at a time. You can configure parameters to specify whether to release the disks attached to the instances or retain the disks as pay-as-you-go disks.
        
        @description >Warning: After you release an instance, the physical resources used by the instance are recycled. Relevant data is erased and cannot be restored.
        After you release an instance, manual snapshots of the cloud disks attached to the instance are retained and continue to be billed. You can call the [DeleteSnapshot](https://help.aliyun.com/document_detail/2679824.html) operation to delete the snapshots.
        After you release an instance, whether the cloud disks attached to the instance and the automatic snapshots of the disks are released is determined by the disk attributes. Before you release an instance, you can call the [DescribeDisks](https://help.aliyun.com/document_detail/2679767.html) and [ModifyDiskAttribute](https://help.aliyun.com/document_detail/2679770.html) operations to query and modify disk attributes.
        If `DeleteWithInstance` is set to false for a cloud disk attached to the instance, the cloud disk is changed to a pay-as-you-go disk and retained after the instance is released. If DeleteWithInstance is set to true for the cloud disk, the disk is released together with the instance.
        If `DeleteAutoSnapshot` is set to false for a cloud disk attached to the instance, the automatic snapshots of the disk are retained when the instance is released. If DeleteAutoSnapshot is set to true for the cloud disk, the automatic snapshots of the disk are released together with the instance.
        Elastic IP addresses (EIPs) are not released together with instances. You can call the [ReleaseEipAddress](https://help.aliyun.com/document_detail/448702.html) operation to release EIPs.
        > When you release an instance that is locked for security reasons, the cloud disks attached to the instance are released together with the instance even if DeleteWithInstance is set to false for the disks.
        
        @param request: DeleteInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.force_stop):
            query['ForceStop'] = request.force_stop
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.terminate_subscription):
            query['TerminateSubscription'] = request.terminate_subscription
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteInstancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_instances_with_options_async(
        self,
        request: ecs_20140526_models.DeleteInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteInstancesResponse:
        """
        @summary Releases multiple pay-as-you-go Elastic Compute Service (ECS) instances or expired subscription ECS instances at a time. You can configure parameters to specify whether to release the disks attached to the instances or retain the disks as pay-as-you-go disks.
        
        @description >Warning: After you release an instance, the physical resources used by the instance are recycled. Relevant data is erased and cannot be restored.
        After you release an instance, manual snapshots of the cloud disks attached to the instance are retained and continue to be billed. You can call the [DeleteSnapshot](https://help.aliyun.com/document_detail/2679824.html) operation to delete the snapshots.
        After you release an instance, whether the cloud disks attached to the instance and the automatic snapshots of the disks are released is determined by the disk attributes. Before you release an instance, you can call the [DescribeDisks](https://help.aliyun.com/document_detail/2679767.html) and [ModifyDiskAttribute](https://help.aliyun.com/document_detail/2679770.html) operations to query and modify disk attributes.
        If `DeleteWithInstance` is set to false for a cloud disk attached to the instance, the cloud disk is changed to a pay-as-you-go disk and retained after the instance is released. If DeleteWithInstance is set to true for the cloud disk, the disk is released together with the instance.
        If `DeleteAutoSnapshot` is set to false for a cloud disk attached to the instance, the automatic snapshots of the disk are retained when the instance is released. If DeleteAutoSnapshot is set to true for the cloud disk, the automatic snapshots of the disk are released together with the instance.
        Elastic IP addresses (EIPs) are not released together with instances. You can call the [ReleaseEipAddress](https://help.aliyun.com/document_detail/448702.html) operation to release EIPs.
        > When you release an instance that is locked for security reasons, the cloud disks attached to the instance are released together with the instance even if DeleteWithInstance is set to false for the disks.
        
        @param request: DeleteInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.force_stop):
            query['ForceStop'] = request.force_stop
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.terminate_subscription):
            query['TerminateSubscription'] = request.terminate_subscription
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteInstancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_instances(
        self,
        request: ecs_20140526_models.DeleteInstancesRequest,
    ) -> ecs_20140526_models.DeleteInstancesResponse:
        """
        @summary Releases multiple pay-as-you-go Elastic Compute Service (ECS) instances or expired subscription ECS instances at a time. You can configure parameters to specify whether to release the disks attached to the instances or retain the disks as pay-as-you-go disks.
        
        @description >Warning: After you release an instance, the physical resources used by the instance are recycled. Relevant data is erased and cannot be restored.
        After you release an instance, manual snapshots of the cloud disks attached to the instance are retained and continue to be billed. You can call the [DeleteSnapshot](https://help.aliyun.com/document_detail/2679824.html) operation to delete the snapshots.
        After you release an instance, whether the cloud disks attached to the instance and the automatic snapshots of the disks are released is determined by the disk attributes. Before you release an instance, you can call the [DescribeDisks](https://help.aliyun.com/document_detail/2679767.html) and [ModifyDiskAttribute](https://help.aliyun.com/document_detail/2679770.html) operations to query and modify disk attributes.
        If `DeleteWithInstance` is set to false for a cloud disk attached to the instance, the cloud disk is changed to a pay-as-you-go disk and retained after the instance is released. If DeleteWithInstance is set to true for the cloud disk, the disk is released together with the instance.
        If `DeleteAutoSnapshot` is set to false for a cloud disk attached to the instance, the automatic snapshots of the disk are retained when the instance is released. If DeleteAutoSnapshot is set to true for the cloud disk, the automatic snapshots of the disk are released together with the instance.
        Elastic IP addresses (EIPs) are not released together with instances. You can call the [ReleaseEipAddress](https://help.aliyun.com/document_detail/448702.html) operation to release EIPs.
        > When you release an instance that is locked for security reasons, the cloud disks attached to the instance are released together with the instance even if DeleteWithInstance is set to false for the disks.
        
        @param request: DeleteInstancesRequest
        @return: DeleteInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_instances_with_options(request, runtime)

    async def delete_instances_async(
        self,
        request: ecs_20140526_models.DeleteInstancesRequest,
    ) -> ecs_20140526_models.DeleteInstancesResponse:
        """
        @summary Releases multiple pay-as-you-go Elastic Compute Service (ECS) instances or expired subscription ECS instances at a time. You can configure parameters to specify whether to release the disks attached to the instances or retain the disks as pay-as-you-go disks.
        
        @description >Warning: After you release an instance, the physical resources used by the instance are recycled. Relevant data is erased and cannot be restored.
        After you release an instance, manual snapshots of the cloud disks attached to the instance are retained and continue to be billed. You can call the [DeleteSnapshot](https://help.aliyun.com/document_detail/2679824.html) operation to delete the snapshots.
        After you release an instance, whether the cloud disks attached to the instance and the automatic snapshots of the disks are released is determined by the disk attributes. Before you release an instance, you can call the [DescribeDisks](https://help.aliyun.com/document_detail/2679767.html) and [ModifyDiskAttribute](https://help.aliyun.com/document_detail/2679770.html) operations to query and modify disk attributes.
        If `DeleteWithInstance` is set to false for a cloud disk attached to the instance, the cloud disk is changed to a pay-as-you-go disk and retained after the instance is released. If DeleteWithInstance is set to true for the cloud disk, the disk is released together with the instance.
        If `DeleteAutoSnapshot` is set to false for a cloud disk attached to the instance, the automatic snapshots of the disk are retained when the instance is released. If DeleteAutoSnapshot is set to true for the cloud disk, the automatic snapshots of the disk are released together with the instance.
        Elastic IP addresses (EIPs) are not released together with instances. You can call the [ReleaseEipAddress](https://help.aliyun.com/document_detail/448702.html) operation to release EIPs.
        > When you release an instance that is locked for security reasons, the cloud disks attached to the instance are released together with the instance even if DeleteWithInstance is set to false for the disks.
        
        @param request: DeleteInstancesRequest
        @return: DeleteInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_instances_with_options_async(request, runtime)

    def delete_key_pairs_with_options(
        self,
        request: ecs_20140526_models.DeleteKeyPairsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteKeyPairsResponse:
        """
        @summary Deletes one or more SSH key pairs.
        
        @description When you call this operation, take note of the following items:
        After an SSH key pair is deleted, you cannot query the SSH key pair by calling the [DescribeKeyPairs](https://help.aliyun.com/document_detail/51773.html) operation.
        If an SSH key pair is bound to one or more Elastic Compute Service (ECS) instances, the SSH key pair cannot be deleted.
        
        @param request: DeleteKeyPairsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteKeyPairsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.key_pair_names):
            query['KeyPairNames'] = request.key_pair_names
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteKeyPairs',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteKeyPairsResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_key_pairs_with_options_async(
        self,
        request: ecs_20140526_models.DeleteKeyPairsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteKeyPairsResponse:
        """
        @summary Deletes one or more SSH key pairs.
        
        @description When you call this operation, take note of the following items:
        After an SSH key pair is deleted, you cannot query the SSH key pair by calling the [DescribeKeyPairs](https://help.aliyun.com/document_detail/51773.html) operation.
        If an SSH key pair is bound to one or more Elastic Compute Service (ECS) instances, the SSH key pair cannot be deleted.
        
        @param request: DeleteKeyPairsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteKeyPairsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.key_pair_names):
            query['KeyPairNames'] = request.key_pair_names
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteKeyPairs',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteKeyPairsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_key_pairs(
        self,
        request: ecs_20140526_models.DeleteKeyPairsRequest,
    ) -> ecs_20140526_models.DeleteKeyPairsResponse:
        """
        @summary Deletes one or more SSH key pairs.
        
        @description When you call this operation, take note of the following items:
        After an SSH key pair is deleted, you cannot query the SSH key pair by calling the [DescribeKeyPairs](https://help.aliyun.com/document_detail/51773.html) operation.
        If an SSH key pair is bound to one or more Elastic Compute Service (ECS) instances, the SSH key pair cannot be deleted.
        
        @param request: DeleteKeyPairsRequest
        @return: DeleteKeyPairsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_key_pairs_with_options(request, runtime)

    async def delete_key_pairs_async(
        self,
        request: ecs_20140526_models.DeleteKeyPairsRequest,
    ) -> ecs_20140526_models.DeleteKeyPairsResponse:
        """
        @summary Deletes one or more SSH key pairs.
        
        @description When you call this operation, take note of the following items:
        After an SSH key pair is deleted, you cannot query the SSH key pair by calling the [DescribeKeyPairs](https://help.aliyun.com/document_detail/51773.html) operation.
        If an SSH key pair is bound to one or more Elastic Compute Service (ECS) instances, the SSH key pair cannot be deleted.
        
        @param request: DeleteKeyPairsRequest
        @return: DeleteKeyPairsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_key_pairs_with_options_async(request, runtime)

    def delete_launch_template_with_options(
        self,
        request: ecs_20140526_models.DeleteLaunchTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteLaunchTemplateResponse:
        """
        @summary Deletes a launch template. You can use the LaunchTemplateId or LaunchTemplateName parameter to specify the launch template that you want to delete from the specified region.
        
        @description Take note of the following items:
        After you delete a launch template, Elastic Compute Service (ECS) instances created based on the launch template are not affected.
        After you delete a launch template, all versions of the launch template are deleted and cannot be restored. If you want to delete only a specific version of the launch template, call the [DeleteLaunchTemplateVersion](https://help.aliyun.com/document_detail/2679735.html) operation.
        
        @param request: DeleteLaunchTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLaunchTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.launch_template_id):
            query['LaunchTemplateId'] = request.launch_template_id
        if not UtilClient.is_unset(request.launch_template_name):
            query['LaunchTemplateName'] = request.launch_template_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLaunchTemplate',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteLaunchTemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_launch_template_with_options_async(
        self,
        request: ecs_20140526_models.DeleteLaunchTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteLaunchTemplateResponse:
        """
        @summary Deletes a launch template. You can use the LaunchTemplateId or LaunchTemplateName parameter to specify the launch template that you want to delete from the specified region.
        
        @description Take note of the following items:
        After you delete a launch template, Elastic Compute Service (ECS) instances created based on the launch template are not affected.
        After you delete a launch template, all versions of the launch template are deleted and cannot be restored. If you want to delete only a specific version of the launch template, call the [DeleteLaunchTemplateVersion](https://help.aliyun.com/document_detail/2679735.html) operation.
        
        @param request: DeleteLaunchTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLaunchTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.launch_template_id):
            query['LaunchTemplateId'] = request.launch_template_id
        if not UtilClient.is_unset(request.launch_template_name):
            query['LaunchTemplateName'] = request.launch_template_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLaunchTemplate',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteLaunchTemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_launch_template(
        self,
        request: ecs_20140526_models.DeleteLaunchTemplateRequest,
    ) -> ecs_20140526_models.DeleteLaunchTemplateResponse:
        """
        @summary Deletes a launch template. You can use the LaunchTemplateId or LaunchTemplateName parameter to specify the launch template that you want to delete from the specified region.
        
        @description Take note of the following items:
        After you delete a launch template, Elastic Compute Service (ECS) instances created based on the launch template are not affected.
        After you delete a launch template, all versions of the launch template are deleted and cannot be restored. If you want to delete only a specific version of the launch template, call the [DeleteLaunchTemplateVersion](https://help.aliyun.com/document_detail/2679735.html) operation.
        
        @param request: DeleteLaunchTemplateRequest
        @return: DeleteLaunchTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_launch_template_with_options(request, runtime)

    async def delete_launch_template_async(
        self,
        request: ecs_20140526_models.DeleteLaunchTemplateRequest,
    ) -> ecs_20140526_models.DeleteLaunchTemplateResponse:
        """
        @summary Deletes a launch template. You can use the LaunchTemplateId or LaunchTemplateName parameter to specify the launch template that you want to delete from the specified region.
        
        @description Take note of the following items:
        After you delete a launch template, Elastic Compute Service (ECS) instances created based on the launch template are not affected.
        After you delete a launch template, all versions of the launch template are deleted and cannot be restored. If you want to delete only a specific version of the launch template, call the [DeleteLaunchTemplateVersion](https://help.aliyun.com/document_detail/2679735.html) operation.
        
        @param request: DeleteLaunchTemplateRequest
        @return: DeleteLaunchTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_launch_template_with_options_async(request, runtime)

    def delete_launch_template_version_with_options(
        self,
        request: ecs_20140526_models.DeleteLaunchTemplateVersionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteLaunchTemplateVersionResponse:
        """
        @summary Deletes versions of a launch template. When you call this operation, you can specify parameters, such as LaunchTemplateId and DeleteVersion, in the request.
        
        @description Take note of the following items:
        You cannot delete the default version of a launch template by calling this operation. To delete the default version of a launch template, you must delete the launch template.
        If the version of a launch template that you want to delete is the default version, call the [ModifyLaunchTemplateDefaultVersion](https://help.aliyun.com/document_detail/2679734.html) operation or go to the **Launch Templates** page in the Elastic Compute Service (ECS) console to change the default version to a different version, and then delete the original default version.
        After you delete a version of a launch template, the ECS instances that were created based on the version are not affected.
        
        @param request: DeleteLaunchTemplateVersionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLaunchTemplateVersionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.delete_version):
            query['DeleteVersion'] = request.delete_version
        if not UtilClient.is_unset(request.launch_template_id):
            query['LaunchTemplateId'] = request.launch_template_id
        if not UtilClient.is_unset(request.launch_template_name):
            query['LaunchTemplateName'] = request.launch_template_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLaunchTemplateVersion',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteLaunchTemplateVersionResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_launch_template_version_with_options_async(
        self,
        request: ecs_20140526_models.DeleteLaunchTemplateVersionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteLaunchTemplateVersionResponse:
        """
        @summary Deletes versions of a launch template. When you call this operation, you can specify parameters, such as LaunchTemplateId and DeleteVersion, in the request.
        
        @description Take note of the following items:
        You cannot delete the default version of a launch template by calling this operation. To delete the default version of a launch template, you must delete the launch template.
        If the version of a launch template that you want to delete is the default version, call the [ModifyLaunchTemplateDefaultVersion](https://help.aliyun.com/document_detail/2679734.html) operation or go to the **Launch Templates** page in the Elastic Compute Service (ECS) console to change the default version to a different version, and then delete the original default version.
        After you delete a version of a launch template, the ECS instances that were created based on the version are not affected.
        
        @param request: DeleteLaunchTemplateVersionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLaunchTemplateVersionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.delete_version):
            query['DeleteVersion'] = request.delete_version
        if not UtilClient.is_unset(request.launch_template_id):
            query['LaunchTemplateId'] = request.launch_template_id
        if not UtilClient.is_unset(request.launch_template_name):
            query['LaunchTemplateName'] = request.launch_template_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLaunchTemplateVersion',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteLaunchTemplateVersionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_launch_template_version(
        self,
        request: ecs_20140526_models.DeleteLaunchTemplateVersionRequest,
    ) -> ecs_20140526_models.DeleteLaunchTemplateVersionResponse:
        """
        @summary Deletes versions of a launch template. When you call this operation, you can specify parameters, such as LaunchTemplateId and DeleteVersion, in the request.
        
        @description Take note of the following items:
        You cannot delete the default version of a launch template by calling this operation. To delete the default version of a launch template, you must delete the launch template.
        If the version of a launch template that you want to delete is the default version, call the [ModifyLaunchTemplateDefaultVersion](https://help.aliyun.com/document_detail/2679734.html) operation or go to the **Launch Templates** page in the Elastic Compute Service (ECS) console to change the default version to a different version, and then delete the original default version.
        After you delete a version of a launch template, the ECS instances that were created based on the version are not affected.
        
        @param request: DeleteLaunchTemplateVersionRequest
        @return: DeleteLaunchTemplateVersionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_launch_template_version_with_options(request, runtime)

    async def delete_launch_template_version_async(
        self,
        request: ecs_20140526_models.DeleteLaunchTemplateVersionRequest,
    ) -> ecs_20140526_models.DeleteLaunchTemplateVersionResponse:
        """
        @summary Deletes versions of a launch template. When you call this operation, you can specify parameters, such as LaunchTemplateId and DeleteVersion, in the request.
        
        @description Take note of the following items:
        You cannot delete the default version of a launch template by calling this operation. To delete the default version of a launch template, you must delete the launch template.
        If the version of a launch template that you want to delete is the default version, call the [ModifyLaunchTemplateDefaultVersion](https://help.aliyun.com/document_detail/2679734.html) operation or go to the **Launch Templates** page in the Elastic Compute Service (ECS) console to change the default version to a different version, and then delete the original default version.
        After you delete a version of a launch template, the ECS instances that were created based on the version are not affected.
        
        @param request: DeleteLaunchTemplateVersionRequest
        @return: DeleteLaunchTemplateVersionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_launch_template_version_with_options_async(request, runtime)

    def delete_nat_gateway_with_options(
        self,
        request: ecs_20140526_models.DeleteNatGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteNatGatewayResponse:
        """
        @deprecated OpenAPI DeleteNatGateway is deprecated, please use Vpc::2016-04-28::DeleteNatGateway instead.
        
        @summary DeleteNatGateway
        
        @param request: DeleteNatGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteNatGatewayResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteNatGateway',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteNatGatewayResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_nat_gateway_with_options_async(
        self,
        request: ecs_20140526_models.DeleteNatGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteNatGatewayResponse:
        """
        @deprecated OpenAPI DeleteNatGateway is deprecated, please use Vpc::2016-04-28::DeleteNatGateway instead.
        
        @summary DeleteNatGateway
        
        @param request: DeleteNatGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteNatGatewayResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteNatGateway',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteNatGatewayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_nat_gateway(
        self,
        request: ecs_20140526_models.DeleteNatGatewayRequest,
    ) -> ecs_20140526_models.DeleteNatGatewayResponse:
        """
        @deprecated OpenAPI DeleteNatGateway is deprecated, please use Vpc::2016-04-28::DeleteNatGateway instead.
        
        @summary DeleteNatGateway
        
        @param request: DeleteNatGatewayRequest
        @return: DeleteNatGatewayResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_nat_gateway_with_options(request, runtime)

    async def delete_nat_gateway_async(
        self,
        request: ecs_20140526_models.DeleteNatGatewayRequest,
    ) -> ecs_20140526_models.DeleteNatGatewayResponse:
        """
        @deprecated OpenAPI DeleteNatGateway is deprecated, please use Vpc::2016-04-28::DeleteNatGateway instead.
        
        @summary DeleteNatGateway
        
        @param request: DeleteNatGatewayRequest
        @return: DeleteNatGatewayResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_nat_gateway_with_options_async(request, runtime)

    def delete_network_interface_with_options(
        self,
        request: ecs_20140526_models.DeleteNetworkInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteNetworkInterfaceResponse:
        """
        @summary Deletes an elastic network interface (ENI) in a region. DeleteNetworkInterface is an asynchronous operation.
        
        @description Take note of the following items:
        The ENI to be deleted must be in the Available state.
        If the ENI to be deleted is attached to an Elastic Compute Service (ECS) instance, you must detach the ENI from the instance before you can delete the ENI. To detach the ENI, you can call the [DetachNetworkInterface](https://help.aliyun.com/document_detail/58514.html) operation.
        After an ENI is deleted, the following situations occur:
        All private IP addresses (including primary and secondary private IP addresses) of the ENI are automatically released.
        The ENI is automatically removed from all security groups.
        The DeleteNetworkInterface operation is an asynchronous operation. After this operation is called to delete an ENI, you can check the status or events of the ENI to determine whether the ENI is deleted. The following figure shows the transitions between the states of the ENI.
        ![](https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/file-manage-files/en-US/20230223/krcd/DeleteNetworkInterface.png)
        If the ENI is in the Deleting state, the ENI deletion request is sent and the ENI is being deleted.
        If the ENI is not found, the ENI is deleted.
        If the ENI is stuck in the Deleting state, the ENI fails to be deleted. You can re-initiate the request to delete the ENI.
        For information about examples on how to call the DeleteNetworkInterface operation, see [Delete an ENI](https://help.aliyun.com/document_detail/471553.html).
        
        @param request: DeleteNetworkInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteNetworkInterfaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteNetworkInterface',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteNetworkInterfaceResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_network_interface_with_options_async(
        self,
        request: ecs_20140526_models.DeleteNetworkInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteNetworkInterfaceResponse:
        """
        @summary Deletes an elastic network interface (ENI) in a region. DeleteNetworkInterface is an asynchronous operation.
        
        @description Take note of the following items:
        The ENI to be deleted must be in the Available state.
        If the ENI to be deleted is attached to an Elastic Compute Service (ECS) instance, you must detach the ENI from the instance before you can delete the ENI. To detach the ENI, you can call the [DetachNetworkInterface](https://help.aliyun.com/document_detail/58514.html) operation.
        After an ENI is deleted, the following situations occur:
        All private IP addresses (including primary and secondary private IP addresses) of the ENI are automatically released.
        The ENI is automatically removed from all security groups.
        The DeleteNetworkInterface operation is an asynchronous operation. After this operation is called to delete an ENI, you can check the status or events of the ENI to determine whether the ENI is deleted. The following figure shows the transitions between the states of the ENI.
        ![](https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/file-manage-files/en-US/20230223/krcd/DeleteNetworkInterface.png)
        If the ENI is in the Deleting state, the ENI deletion request is sent and the ENI is being deleted.
        If the ENI is not found, the ENI is deleted.
        If the ENI is stuck in the Deleting state, the ENI fails to be deleted. You can re-initiate the request to delete the ENI.
        For information about examples on how to call the DeleteNetworkInterface operation, see [Delete an ENI](https://help.aliyun.com/document_detail/471553.html).
        
        @param request: DeleteNetworkInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteNetworkInterfaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteNetworkInterface',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteNetworkInterfaceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_network_interface(
        self,
        request: ecs_20140526_models.DeleteNetworkInterfaceRequest,
    ) -> ecs_20140526_models.DeleteNetworkInterfaceResponse:
        """
        @summary Deletes an elastic network interface (ENI) in a region. DeleteNetworkInterface is an asynchronous operation.
        
        @description Take note of the following items:
        The ENI to be deleted must be in the Available state.
        If the ENI to be deleted is attached to an Elastic Compute Service (ECS) instance, you must detach the ENI from the instance before you can delete the ENI. To detach the ENI, you can call the [DetachNetworkInterface](https://help.aliyun.com/document_detail/58514.html) operation.
        After an ENI is deleted, the following situations occur:
        All private IP addresses (including primary and secondary private IP addresses) of the ENI are automatically released.
        The ENI is automatically removed from all security groups.
        The DeleteNetworkInterface operation is an asynchronous operation. After this operation is called to delete an ENI, you can check the status or events of the ENI to determine whether the ENI is deleted. The following figure shows the transitions between the states of the ENI.
        ![](https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/file-manage-files/en-US/20230223/krcd/DeleteNetworkInterface.png)
        If the ENI is in the Deleting state, the ENI deletion request is sent and the ENI is being deleted.
        If the ENI is not found, the ENI is deleted.
        If the ENI is stuck in the Deleting state, the ENI fails to be deleted. You can re-initiate the request to delete the ENI.
        For information about examples on how to call the DeleteNetworkInterface operation, see [Delete an ENI](https://help.aliyun.com/document_detail/471553.html).
        
        @param request: DeleteNetworkInterfaceRequest
        @return: DeleteNetworkInterfaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_network_interface_with_options(request, runtime)

    async def delete_network_interface_async(
        self,
        request: ecs_20140526_models.DeleteNetworkInterfaceRequest,
    ) -> ecs_20140526_models.DeleteNetworkInterfaceResponse:
        """
        @summary Deletes an elastic network interface (ENI) in a region. DeleteNetworkInterface is an asynchronous operation.
        
        @description Take note of the following items:
        The ENI to be deleted must be in the Available state.
        If the ENI to be deleted is attached to an Elastic Compute Service (ECS) instance, you must detach the ENI from the instance before you can delete the ENI. To detach the ENI, you can call the [DetachNetworkInterface](https://help.aliyun.com/document_detail/58514.html) operation.
        After an ENI is deleted, the following situations occur:
        All private IP addresses (including primary and secondary private IP addresses) of the ENI are automatically released.
        The ENI is automatically removed from all security groups.
        The DeleteNetworkInterface operation is an asynchronous operation. After this operation is called to delete an ENI, you can check the status or events of the ENI to determine whether the ENI is deleted. The following figure shows the transitions between the states of the ENI.
        ![](https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/file-manage-files/en-US/20230223/krcd/DeleteNetworkInterface.png)
        If the ENI is in the Deleting state, the ENI deletion request is sent and the ENI is being deleted.
        If the ENI is not found, the ENI is deleted.
        If the ENI is stuck in the Deleting state, the ENI fails to be deleted. You can re-initiate the request to delete the ENI.
        For information about examples on how to call the DeleteNetworkInterface operation, see [Delete an ENI](https://help.aliyun.com/document_detail/471553.html).
        
        @param request: DeleteNetworkInterfaceRequest
        @return: DeleteNetworkInterfaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_network_interface_with_options_async(request, runtime)

    def delete_network_interface_permission_with_options(
        self,
        request: ecs_20140526_models.DeleteNetworkInterfacePermissionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteNetworkInterfacePermissionResponse:
        """
        @deprecated OpenAPI DeleteNetworkInterfacePermission is deprecated, please use Ecs::2014-05-26::DeleteNetworkInterface instead.
        
        @summary 删除操作弹性网卡的权限
        
        @param request: DeleteNetworkInterfacePermissionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteNetworkInterfacePermissionResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.network_interface_permission_id):
            query['NetworkInterfacePermissionId'] = request.network_interface_permission_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteNetworkInterfacePermission',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteNetworkInterfacePermissionResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_network_interface_permission_with_options_async(
        self,
        request: ecs_20140526_models.DeleteNetworkInterfacePermissionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteNetworkInterfacePermissionResponse:
        """
        @deprecated OpenAPI DeleteNetworkInterfacePermission is deprecated, please use Ecs::2014-05-26::DeleteNetworkInterface instead.
        
        @summary 删除操作弹性网卡的权限
        
        @param request: DeleteNetworkInterfacePermissionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteNetworkInterfacePermissionResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.network_interface_permission_id):
            query['NetworkInterfacePermissionId'] = request.network_interface_permission_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteNetworkInterfacePermission',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteNetworkInterfacePermissionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_network_interface_permission(
        self,
        request: ecs_20140526_models.DeleteNetworkInterfacePermissionRequest,
    ) -> ecs_20140526_models.DeleteNetworkInterfacePermissionResponse:
        """
        @deprecated OpenAPI DeleteNetworkInterfacePermission is deprecated, please use Ecs::2014-05-26::DeleteNetworkInterface instead.
        
        @summary 删除操作弹性网卡的权限
        
        @param request: DeleteNetworkInterfacePermissionRequest
        @return: DeleteNetworkInterfacePermissionResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_network_interface_permission_with_options(request, runtime)

    async def delete_network_interface_permission_async(
        self,
        request: ecs_20140526_models.DeleteNetworkInterfacePermissionRequest,
    ) -> ecs_20140526_models.DeleteNetworkInterfacePermissionResponse:
        """
        @deprecated OpenAPI DeleteNetworkInterfacePermission is deprecated, please use Ecs::2014-05-26::DeleteNetworkInterface instead.
        
        @summary 删除操作弹性网卡的权限
        
        @param request: DeleteNetworkInterfacePermissionRequest
        @return: DeleteNetworkInterfacePermissionResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_network_interface_permission_with_options_async(request, runtime)

    def delete_physical_connection_with_options(
        self,
        request: ecs_20140526_models.DeletePhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeletePhysicalConnectionResponse:
        """
        @deprecated OpenAPI DeletePhysicalConnection is deprecated, please use Vpc::2016-04-28::DeletePhysicalConnection instead.
        
        @summary DeletePhysicalConnection
        
        @param request: DeletePhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePhysicalConnectionResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletePhysicalConnection',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeletePhysicalConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_physical_connection_with_options_async(
        self,
        request: ecs_20140526_models.DeletePhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeletePhysicalConnectionResponse:
        """
        @deprecated OpenAPI DeletePhysicalConnection is deprecated, please use Vpc::2016-04-28::DeletePhysicalConnection instead.
        
        @summary DeletePhysicalConnection
        
        @param request: DeletePhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePhysicalConnectionResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletePhysicalConnection',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeletePhysicalConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_physical_connection(
        self,
        request: ecs_20140526_models.DeletePhysicalConnectionRequest,
    ) -> ecs_20140526_models.DeletePhysicalConnectionResponse:
        """
        @deprecated OpenAPI DeletePhysicalConnection is deprecated, please use Vpc::2016-04-28::DeletePhysicalConnection instead.
        
        @summary DeletePhysicalConnection
        
        @param request: DeletePhysicalConnectionRequest
        @return: DeletePhysicalConnectionResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_physical_connection_with_options(request, runtime)

    async def delete_physical_connection_async(
        self,
        request: ecs_20140526_models.DeletePhysicalConnectionRequest,
    ) -> ecs_20140526_models.DeletePhysicalConnectionResponse:
        """
        @deprecated OpenAPI DeletePhysicalConnection is deprecated, please use Vpc::2016-04-28::DeletePhysicalConnection instead.
        
        @summary DeletePhysicalConnection
        
        @param request: DeletePhysicalConnectionRequest
        @return: DeletePhysicalConnectionResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_physical_connection_with_options_async(request, runtime)

    def delete_port_range_list_with_options(
        self,
        request: ecs_20140526_models.DeletePortRangeListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeletePortRangeListResponse:
        """
        @summary Deletes a port list and all entries in the port list.
        
        @param request: DeletePortRangeListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePortRangeListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_range_list_id):
            query['PortRangeListId'] = request.port_range_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletePortRangeList',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeletePortRangeListResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_port_range_list_with_options_async(
        self,
        request: ecs_20140526_models.DeletePortRangeListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeletePortRangeListResponse:
        """
        @summary Deletes a port list and all entries in the port list.
        
        @param request: DeletePortRangeListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePortRangeListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_range_list_id):
            query['PortRangeListId'] = request.port_range_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletePortRangeList',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeletePortRangeListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_port_range_list(
        self,
        request: ecs_20140526_models.DeletePortRangeListRequest,
    ) -> ecs_20140526_models.DeletePortRangeListResponse:
        """
        @summary Deletes a port list and all entries in the port list.
        
        @param request: DeletePortRangeListRequest
        @return: DeletePortRangeListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_port_range_list_with_options(request, runtime)

    async def delete_port_range_list_async(
        self,
        request: ecs_20140526_models.DeletePortRangeListRequest,
    ) -> ecs_20140526_models.DeletePortRangeListResponse:
        """
        @summary Deletes a port list and all entries in the port list.
        
        @param request: DeletePortRangeListRequest
        @return: DeletePortRangeListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_port_range_list_with_options_async(request, runtime)

    def delete_prefix_list_with_options(
        self,
        request: ecs_20140526_models.DeletePrefixListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeletePrefixListResponse:
        """
        @summary Deletes a prefix list and all entries in the prefix list.
        
        @description If a prefix list is associated with resources, you cannot delete the prefix list. You must disassociate the prefix list from the resources before you delete the prefix list. You can call the [DescribePrefixListAssociations](https://help.aliyun.com/document_detail/204724.html) operation to query resources that are associated with a specific prefix list.
        
        @param request: DeletePrefixListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePrefixListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletePrefixList',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeletePrefixListResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_prefix_list_with_options_async(
        self,
        request: ecs_20140526_models.DeletePrefixListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeletePrefixListResponse:
        """
        @summary Deletes a prefix list and all entries in the prefix list.
        
        @description If a prefix list is associated with resources, you cannot delete the prefix list. You must disassociate the prefix list from the resources before you delete the prefix list. You can call the [DescribePrefixListAssociations](https://help.aliyun.com/document_detail/204724.html) operation to query resources that are associated with a specific prefix list.
        
        @param request: DeletePrefixListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePrefixListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletePrefixList',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeletePrefixListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_prefix_list(
        self,
        request: ecs_20140526_models.DeletePrefixListRequest,
    ) -> ecs_20140526_models.DeletePrefixListResponse:
        """
        @summary Deletes a prefix list and all entries in the prefix list.
        
        @description If a prefix list is associated with resources, you cannot delete the prefix list. You must disassociate the prefix list from the resources before you delete the prefix list. You can call the [DescribePrefixListAssociations](https://help.aliyun.com/document_detail/204724.html) operation to query resources that are associated with a specific prefix list.
        
        @param request: DeletePrefixListRequest
        @return: DeletePrefixListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_prefix_list_with_options(request, runtime)

    async def delete_prefix_list_async(
        self,
        request: ecs_20140526_models.DeletePrefixListRequest,
    ) -> ecs_20140526_models.DeletePrefixListResponse:
        """
        @summary Deletes a prefix list and all entries in the prefix list.
        
        @description If a prefix list is associated with resources, you cannot delete the prefix list. You must disassociate the prefix list from the resources before you delete the prefix list. You can call the [DescribePrefixListAssociations](https://help.aliyun.com/document_detail/204724.html) operation to query resources that are associated with a specific prefix list.
        
        @param request: DeletePrefixListRequest
        @return: DeletePrefixListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_prefix_list_with_options_async(request, runtime)

    def delete_route_entry_with_options(
        self,
        request: ecs_20140526_models.DeleteRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteRouteEntryResponse:
        """
        @deprecated OpenAPI DeleteRouteEntry is deprecated, please use Vpc::2016-04-28::DeleteRouteEntry instead.
        
        @summary DeleteRouteEntry
        
        @param request: DeleteRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteRouteEntryResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.destination_cidr_block):
            query['DestinationCidrBlock'] = request.destination_cidr_block
        if not UtilClient.is_unset(request.next_hop_id):
            query['NextHopId'] = request.next_hop_id
        if not UtilClient.is_unset(request.next_hop_list):
            query['NextHopList'] = request.next_hop_list
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteRouteEntry',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteRouteEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_route_entry_with_options_async(
        self,
        request: ecs_20140526_models.DeleteRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteRouteEntryResponse:
        """
        @deprecated OpenAPI DeleteRouteEntry is deprecated, please use Vpc::2016-04-28::DeleteRouteEntry instead.
        
        @summary DeleteRouteEntry
        
        @param request: DeleteRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteRouteEntryResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.destination_cidr_block):
            query['DestinationCidrBlock'] = request.destination_cidr_block
        if not UtilClient.is_unset(request.next_hop_id):
            query['NextHopId'] = request.next_hop_id
        if not UtilClient.is_unset(request.next_hop_list):
            query['NextHopList'] = request.next_hop_list
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteRouteEntry',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteRouteEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_route_entry(
        self,
        request: ecs_20140526_models.DeleteRouteEntryRequest,
    ) -> ecs_20140526_models.DeleteRouteEntryResponse:
        """
        @deprecated OpenAPI DeleteRouteEntry is deprecated, please use Vpc::2016-04-28::DeleteRouteEntry instead.
        
        @summary DeleteRouteEntry
        
        @param request: DeleteRouteEntryRequest
        @return: DeleteRouteEntryResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_route_entry_with_options(request, runtime)

    async def delete_route_entry_async(
        self,
        request: ecs_20140526_models.DeleteRouteEntryRequest,
    ) -> ecs_20140526_models.DeleteRouteEntryResponse:
        """
        @deprecated OpenAPI DeleteRouteEntry is deprecated, please use Vpc::2016-04-28::DeleteRouteEntry instead.
        
        @summary DeleteRouteEntry
        
        @param request: DeleteRouteEntryRequest
        @return: DeleteRouteEntryResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_route_entry_with_options_async(request, runtime)

    def delete_router_interface_with_options(
        self,
        request: ecs_20140526_models.DeleteRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteRouterInterfaceResponse:
        """
        @deprecated OpenAPI DeleteRouterInterface is deprecated, please use Vpc::2016-04-28::DeleteRouterInterface instead.
        
        @summary DeleteRouterInterface
        
        @param request: DeleteRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteRouterInterfaceResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteRouterInterface',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteRouterInterfaceResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_router_interface_with_options_async(
        self,
        request: ecs_20140526_models.DeleteRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteRouterInterfaceResponse:
        """
        @deprecated OpenAPI DeleteRouterInterface is deprecated, please use Vpc::2016-04-28::DeleteRouterInterface instead.
        
        @summary DeleteRouterInterface
        
        @param request: DeleteRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteRouterInterfaceResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteRouterInterface',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteRouterInterfaceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_router_interface(
        self,
        request: ecs_20140526_models.DeleteRouterInterfaceRequest,
    ) -> ecs_20140526_models.DeleteRouterInterfaceResponse:
        """
        @deprecated OpenAPI DeleteRouterInterface is deprecated, please use Vpc::2016-04-28::DeleteRouterInterface instead.
        
        @summary DeleteRouterInterface
        
        @param request: DeleteRouterInterfaceRequest
        @return: DeleteRouterInterfaceResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_router_interface_with_options(request, runtime)

    async def delete_router_interface_async(
        self,
        request: ecs_20140526_models.DeleteRouterInterfaceRequest,
    ) -> ecs_20140526_models.DeleteRouterInterfaceResponse:
        """
        @deprecated OpenAPI DeleteRouterInterface is deprecated, please use Vpc::2016-04-28::DeleteRouterInterface instead.
        
        @summary DeleteRouterInterface
        
        @param request: DeleteRouterInterfaceRequest
        @return: DeleteRouterInterfaceResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_router_interface_with_options_async(request, runtime)

    def delete_security_group_with_options(
        self,
        request: ecs_20140526_models.DeleteSecurityGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteSecurityGroupResponse:
        """
        @summary Deletes a security group and all security group rules in the security group.
        
        @description    Make sure that no Elastic Compute Service (ECS) instances exist in the security group. You can query instances by calling the [DescribeInstances](https://help.aliyun.com/document_detail/2679689.html) operation.
        Make sure that no elastic network interfaces (ENIs) exist in the security group. You can query ENIs by calling the [DescribeNetworkInterfaces](https://help.aliyun.com/document_detail/2679884.html) operation.
        Make sure that the security group that you want to delete is not referenced by rules of other security groups. You can query the associations by calling the [DescribeSecurityGroupReferences](https://help.aliyun.com/document_detail/57320.html) operation.
        If the `InvalidOperation.DeletionProtection` error code is returned when you call the DeleteSecurityGroup operation to delete a security group, the deletion protection feature is enabled for the security group. When you create a Container Service for Kubernetes (ACK) cluster, the deletion protection feature is enabled for an associated security group to prevent accidental deletion. You cannot manually disable the deletion protection feature for the security group. The deletion protection feature can be automatically disabled only after the ACK cluster is deleted. For more information, see the [Disable deletion protection for a security group](https://help.aliyun.com/document_detail/353191.html) section of the "Configure and manage security groups for an ACK cluster" topic.
        
        @param request: DeleteSecurityGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSecurityGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSecurityGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteSecurityGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_security_group_with_options_async(
        self,
        request: ecs_20140526_models.DeleteSecurityGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteSecurityGroupResponse:
        """
        @summary Deletes a security group and all security group rules in the security group.
        
        @description    Make sure that no Elastic Compute Service (ECS) instances exist in the security group. You can query instances by calling the [DescribeInstances](https://help.aliyun.com/document_detail/2679689.html) operation.
        Make sure that no elastic network interfaces (ENIs) exist in the security group. You can query ENIs by calling the [DescribeNetworkInterfaces](https://help.aliyun.com/document_detail/2679884.html) operation.
        Make sure that the security group that you want to delete is not referenced by rules of other security groups. You can query the associations by calling the [DescribeSecurityGroupReferences](https://help.aliyun.com/document_detail/57320.html) operation.
        If the `InvalidOperation.DeletionProtection` error code is returned when you call the DeleteSecurityGroup operation to delete a security group, the deletion protection feature is enabled for the security group. When you create a Container Service for Kubernetes (ACK) cluster, the deletion protection feature is enabled for an associated security group to prevent accidental deletion. You cannot manually disable the deletion protection feature for the security group. The deletion protection feature can be automatically disabled only after the ACK cluster is deleted. For more information, see the [Disable deletion protection for a security group](https://help.aliyun.com/document_detail/353191.html) section of the "Configure and manage security groups for an ACK cluster" topic.
        
        @param request: DeleteSecurityGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSecurityGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSecurityGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteSecurityGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_security_group(
        self,
        request: ecs_20140526_models.DeleteSecurityGroupRequest,
    ) -> ecs_20140526_models.DeleteSecurityGroupResponse:
        """
        @summary Deletes a security group and all security group rules in the security group.
        
        @description    Make sure that no Elastic Compute Service (ECS) instances exist in the security group. You can query instances by calling the [DescribeInstances](https://help.aliyun.com/document_detail/2679689.html) operation.
        Make sure that no elastic network interfaces (ENIs) exist in the security group. You can query ENIs by calling the [DescribeNetworkInterfaces](https://help.aliyun.com/document_detail/2679884.html) operation.
        Make sure that the security group that you want to delete is not referenced by rules of other security groups. You can query the associations by calling the [DescribeSecurityGroupReferences](https://help.aliyun.com/document_detail/57320.html) operation.
        If the `InvalidOperation.DeletionProtection` error code is returned when you call the DeleteSecurityGroup operation to delete a security group, the deletion protection feature is enabled for the security group. When you create a Container Service for Kubernetes (ACK) cluster, the deletion protection feature is enabled for an associated security group to prevent accidental deletion. You cannot manually disable the deletion protection feature for the security group. The deletion protection feature can be automatically disabled only after the ACK cluster is deleted. For more information, see the [Disable deletion protection for a security group](https://help.aliyun.com/document_detail/353191.html) section of the "Configure and manage security groups for an ACK cluster" topic.
        
        @param request: DeleteSecurityGroupRequest
        @return: DeleteSecurityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_security_group_with_options(request, runtime)

    async def delete_security_group_async(
        self,
        request: ecs_20140526_models.DeleteSecurityGroupRequest,
    ) -> ecs_20140526_models.DeleteSecurityGroupResponse:
        """
        @summary Deletes a security group and all security group rules in the security group.
        
        @description    Make sure that no Elastic Compute Service (ECS) instances exist in the security group. You can query instances by calling the [DescribeInstances](https://help.aliyun.com/document_detail/2679689.html) operation.
        Make sure that no elastic network interfaces (ENIs) exist in the security group. You can query ENIs by calling the [DescribeNetworkInterfaces](https://help.aliyun.com/document_detail/2679884.html) operation.
        Make sure that the security group that you want to delete is not referenced by rules of other security groups. You can query the associations by calling the [DescribeSecurityGroupReferences](https://help.aliyun.com/document_detail/57320.html) operation.
        If the `InvalidOperation.DeletionProtection` error code is returned when you call the DeleteSecurityGroup operation to delete a security group, the deletion protection feature is enabled for the security group. When you create a Container Service for Kubernetes (ACK) cluster, the deletion protection feature is enabled for an associated security group to prevent accidental deletion. You cannot manually disable the deletion protection feature for the security group. The deletion protection feature can be automatically disabled only after the ACK cluster is deleted. For more information, see the [Disable deletion protection for a security group](https://help.aliyun.com/document_detail/353191.html) section of the "Configure and manage security groups for an ACK cluster" topic.
        
        @param request: DeleteSecurityGroupRequest
        @return: DeleteSecurityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_security_group_with_options_async(request, runtime)

    def delete_snapshot_with_options(
        self,
        request: ecs_20140526_models.DeleteSnapshotRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteSnapshotResponse:
        """
        @summary Deletes a specified snapshot. If you call this operation to delete a snapshot that is being created, the associated snapshot creation task is also canceled.
        
        @description Take note of the following items:
        If the snapshot does not exist, the request is ignored.
        If the snapshot has been used to create custom images, the snapshot cannot be deleted. You need to call the [DeleteImage](https://help.aliyun.com/document_detail/25537.html) operation to delete the custom images before you can delete the snapshot.
        If the snapshot has been used to create disks and `Force` is not specified or is set to `false`, the snapshot cannot be deleted directly. If you want to delete the snapshot, set `Force` to true to forcibly delete the snapshot. The disks created from the snapshot cannot be re-initialized after the snapshot is forcibly deleted.
        
        @param request: DeleteSnapshotRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSnapshotResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSnapshot',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteSnapshotResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_snapshot_with_options_async(
        self,
        request: ecs_20140526_models.DeleteSnapshotRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteSnapshotResponse:
        """
        @summary Deletes a specified snapshot. If you call this operation to delete a snapshot that is being created, the associated snapshot creation task is also canceled.
        
        @description Take note of the following items:
        If the snapshot does not exist, the request is ignored.
        If the snapshot has been used to create custom images, the snapshot cannot be deleted. You need to call the [DeleteImage](https://help.aliyun.com/document_detail/25537.html) operation to delete the custom images before you can delete the snapshot.
        If the snapshot has been used to create disks and `Force` is not specified or is set to `false`, the snapshot cannot be deleted directly. If you want to delete the snapshot, set `Force` to true to forcibly delete the snapshot. The disks created from the snapshot cannot be re-initialized after the snapshot is forcibly deleted.
        
        @param request: DeleteSnapshotRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSnapshotResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSnapshot',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteSnapshotResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_snapshot(
        self,
        request: ecs_20140526_models.DeleteSnapshotRequest,
    ) -> ecs_20140526_models.DeleteSnapshotResponse:
        """
        @summary Deletes a specified snapshot. If you call this operation to delete a snapshot that is being created, the associated snapshot creation task is also canceled.
        
        @description Take note of the following items:
        If the snapshot does not exist, the request is ignored.
        If the snapshot has been used to create custom images, the snapshot cannot be deleted. You need to call the [DeleteImage](https://help.aliyun.com/document_detail/25537.html) operation to delete the custom images before you can delete the snapshot.
        If the snapshot has been used to create disks and `Force` is not specified or is set to `false`, the snapshot cannot be deleted directly. If you want to delete the snapshot, set `Force` to true to forcibly delete the snapshot. The disks created from the snapshot cannot be re-initialized after the snapshot is forcibly deleted.
        
        @param request: DeleteSnapshotRequest
        @return: DeleteSnapshotResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_snapshot_with_options(request, runtime)

    async def delete_snapshot_async(
        self,
        request: ecs_20140526_models.DeleteSnapshotRequest,
    ) -> ecs_20140526_models.DeleteSnapshotResponse:
        """
        @summary Deletes a specified snapshot. If you call this operation to delete a snapshot that is being created, the associated snapshot creation task is also canceled.
        
        @description Take note of the following items:
        If the snapshot does not exist, the request is ignored.
        If the snapshot has been used to create custom images, the snapshot cannot be deleted. You need to call the [DeleteImage](https://help.aliyun.com/document_detail/25537.html) operation to delete the custom images before you can delete the snapshot.
        If the snapshot has been used to create disks and `Force` is not specified or is set to `false`, the snapshot cannot be deleted directly. If you want to delete the snapshot, set `Force` to true to forcibly delete the snapshot. The disks created from the snapshot cannot be re-initialized after the snapshot is forcibly deleted.
        
        @param request: DeleteSnapshotRequest
        @return: DeleteSnapshotResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_snapshot_with_options_async(request, runtime)

    def delete_snapshot_group_with_options(
        self,
        request: ecs_20140526_models.DeleteSnapshotGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteSnapshotGroupResponse:
        """
        @summary Deletes snapshot-consistent groups.
        
        @description If a disk snapshot that is contained in a snapshot-consistent group has been used to create a custom image, the disk snapshot is retained after the snapshot-consistent group is deleted. Before you can delete the disk snapshot, you must call the [DeleteImage](https://help.aliyun.com/document_detail/25537.html) operation to delete the custom image. Then, you can call the [DeleteSnapshot](https://help.aliyun.com/document_detail/25525.html) operation to delete the disk snapshot.
        
        @param request: DeleteSnapshotGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSnapshotGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snapshot_group_id):
            query['SnapshotGroupId'] = request.snapshot_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSnapshotGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteSnapshotGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_snapshot_group_with_options_async(
        self,
        request: ecs_20140526_models.DeleteSnapshotGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteSnapshotGroupResponse:
        """
        @summary Deletes snapshot-consistent groups.
        
        @description If a disk snapshot that is contained in a snapshot-consistent group has been used to create a custom image, the disk snapshot is retained after the snapshot-consistent group is deleted. Before you can delete the disk snapshot, you must call the [DeleteImage](https://help.aliyun.com/document_detail/25537.html) operation to delete the custom image. Then, you can call the [DeleteSnapshot](https://help.aliyun.com/document_detail/25525.html) operation to delete the disk snapshot.
        
        @param request: DeleteSnapshotGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSnapshotGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snapshot_group_id):
            query['SnapshotGroupId'] = request.snapshot_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSnapshotGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteSnapshotGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_snapshot_group(
        self,
        request: ecs_20140526_models.DeleteSnapshotGroupRequest,
    ) -> ecs_20140526_models.DeleteSnapshotGroupResponse:
        """
        @summary Deletes snapshot-consistent groups.
        
        @description If a disk snapshot that is contained in a snapshot-consistent group has been used to create a custom image, the disk snapshot is retained after the snapshot-consistent group is deleted. Before you can delete the disk snapshot, you must call the [DeleteImage](https://help.aliyun.com/document_detail/25537.html) operation to delete the custom image. Then, you can call the [DeleteSnapshot](https://help.aliyun.com/document_detail/25525.html) operation to delete the disk snapshot.
        
        @param request: DeleteSnapshotGroupRequest
        @return: DeleteSnapshotGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_snapshot_group_with_options(request, runtime)

    async def delete_snapshot_group_async(
        self,
        request: ecs_20140526_models.DeleteSnapshotGroupRequest,
    ) -> ecs_20140526_models.DeleteSnapshotGroupResponse:
        """
        @summary Deletes snapshot-consistent groups.
        
        @description If a disk snapshot that is contained in a snapshot-consistent group has been used to create a custom image, the disk snapshot is retained after the snapshot-consistent group is deleted. Before you can delete the disk snapshot, you must call the [DeleteImage](https://help.aliyun.com/document_detail/25537.html) operation to delete the custom image. Then, you can call the [DeleteSnapshot](https://help.aliyun.com/document_detail/25525.html) operation to delete the disk snapshot.
        
        @param request: DeleteSnapshotGroupRequest
        @return: DeleteSnapshotGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_snapshot_group_with_options_async(request, runtime)

    def delete_storage_set_with_options(
        self,
        request: ecs_20140526_models.DeleteStorageSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteStorageSetResponse:
        """
        @summary (Beta) Deletes an empty storage set. The storage set that you want to delete must be empty and do not contain disks or Shared Block Storage devices.
        
        @param request: DeleteStorageSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteStorageSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_set_id):
            query['StorageSetId'] = request.storage_set_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteStorageSet',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteStorageSetResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_storage_set_with_options_async(
        self,
        request: ecs_20140526_models.DeleteStorageSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteStorageSetResponse:
        """
        @summary (Beta) Deletes an empty storage set. The storage set that you want to delete must be empty and do not contain disks or Shared Block Storage devices.
        
        @param request: DeleteStorageSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteStorageSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_set_id):
            query['StorageSetId'] = request.storage_set_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteStorageSet',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteStorageSetResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_storage_set(
        self,
        request: ecs_20140526_models.DeleteStorageSetRequest,
    ) -> ecs_20140526_models.DeleteStorageSetResponse:
        """
        @summary (Beta) Deletes an empty storage set. The storage set that you want to delete must be empty and do not contain disks or Shared Block Storage devices.
        
        @param request: DeleteStorageSetRequest
        @return: DeleteStorageSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_storage_set_with_options(request, runtime)

    async def delete_storage_set_async(
        self,
        request: ecs_20140526_models.DeleteStorageSetRequest,
    ) -> ecs_20140526_models.DeleteStorageSetResponse:
        """
        @summary (Beta) Deletes an empty storage set. The storage set that you want to delete must be empty and do not contain disks or Shared Block Storage devices.
        
        @param request: DeleteStorageSetRequest
        @return: DeleteStorageSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_storage_set_with_options_async(request, runtime)

    def delete_vswitch_with_options(
        self,
        request: ecs_20140526_models.DeleteVSwitchRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteVSwitchResponse:
        """
        @deprecated OpenAPI DeleteVSwitch is deprecated, please use Vpc::2016-04-28::DeleteVSwitch instead.
        
        @summary DeleteVSwitch
        
        @param request: DeleteVSwitchRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVSwitchResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVSwitch',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteVSwitchResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_vswitch_with_options_async(
        self,
        request: ecs_20140526_models.DeleteVSwitchRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteVSwitchResponse:
        """
        @deprecated OpenAPI DeleteVSwitch is deprecated, please use Vpc::2016-04-28::DeleteVSwitch instead.
        
        @summary DeleteVSwitch
        
        @param request: DeleteVSwitchRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVSwitchResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVSwitch',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteVSwitchResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_vswitch(
        self,
        request: ecs_20140526_models.DeleteVSwitchRequest,
    ) -> ecs_20140526_models.DeleteVSwitchResponse:
        """
        @deprecated OpenAPI DeleteVSwitch is deprecated, please use Vpc::2016-04-28::DeleteVSwitch instead.
        
        @summary DeleteVSwitch
        
        @param request: DeleteVSwitchRequest
        @return: DeleteVSwitchResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_vswitch_with_options(request, runtime)

    async def delete_vswitch_async(
        self,
        request: ecs_20140526_models.DeleteVSwitchRequest,
    ) -> ecs_20140526_models.DeleteVSwitchResponse:
        """
        @deprecated OpenAPI DeleteVSwitch is deprecated, please use Vpc::2016-04-28::DeleteVSwitch instead.
        
        @summary DeleteVSwitch
        
        @param request: DeleteVSwitchRequest
        @return: DeleteVSwitchResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_vswitch_with_options_async(request, runtime)

    def delete_virtual_border_router_with_options(
        self,
        request: ecs_20140526_models.DeleteVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteVirtualBorderRouterResponse:
        """
        @deprecated OpenAPI DeleteVirtualBorderRouter is deprecated, please use Vpc::2016-04-28::DeleteVirtualBorderRouter instead.
        
        @summary DeleteVirtualBorderRouter
        
        @param request: DeleteVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVirtualBorderRouterResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVirtualBorderRouter',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteVirtualBorderRouterResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_virtual_border_router_with_options_async(
        self,
        request: ecs_20140526_models.DeleteVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteVirtualBorderRouterResponse:
        """
        @deprecated OpenAPI DeleteVirtualBorderRouter is deprecated, please use Vpc::2016-04-28::DeleteVirtualBorderRouter instead.
        
        @summary DeleteVirtualBorderRouter
        
        @param request: DeleteVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVirtualBorderRouterResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVirtualBorderRouter',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteVirtualBorderRouterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_virtual_border_router(
        self,
        request: ecs_20140526_models.DeleteVirtualBorderRouterRequest,
    ) -> ecs_20140526_models.DeleteVirtualBorderRouterResponse:
        """
        @deprecated OpenAPI DeleteVirtualBorderRouter is deprecated, please use Vpc::2016-04-28::DeleteVirtualBorderRouter instead.
        
        @summary DeleteVirtualBorderRouter
        
        @param request: DeleteVirtualBorderRouterRequest
        @return: DeleteVirtualBorderRouterResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_virtual_border_router_with_options(request, runtime)

    async def delete_virtual_border_router_async(
        self,
        request: ecs_20140526_models.DeleteVirtualBorderRouterRequest,
    ) -> ecs_20140526_models.DeleteVirtualBorderRouterResponse:
        """
        @deprecated OpenAPI DeleteVirtualBorderRouter is deprecated, please use Vpc::2016-04-28::DeleteVirtualBorderRouter instead.
        
        @summary DeleteVirtualBorderRouter
        
        @param request: DeleteVirtualBorderRouterRequest
        @return: DeleteVirtualBorderRouterResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_virtual_border_router_with_options_async(request, runtime)

    def delete_vpc_with_options(
        self,
        request: ecs_20140526_models.DeleteVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteVpcResponse:
        """
        @deprecated OpenAPI DeleteVpc is deprecated, please use Vpc::2016-04-28::DeleteVpc instead.
        
        @summary 删除VPC
        
        @param request: DeleteVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVpcResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVpc',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteVpcResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_vpc_with_options_async(
        self,
        request: ecs_20140526_models.DeleteVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeleteVpcResponse:
        """
        @deprecated OpenAPI DeleteVpc is deprecated, please use Vpc::2016-04-28::DeleteVpc instead.
        
        @summary 删除VPC
        
        @param request: DeleteVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVpcResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVpc',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeleteVpcResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_vpc(
        self,
        request: ecs_20140526_models.DeleteVpcRequest,
    ) -> ecs_20140526_models.DeleteVpcResponse:
        """
        @deprecated OpenAPI DeleteVpc is deprecated, please use Vpc::2016-04-28::DeleteVpc instead.
        
        @summary 删除VPC
        
        @param request: DeleteVpcRequest
        @return: DeleteVpcResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_vpc_with_options(request, runtime)

    async def delete_vpc_async(
        self,
        request: ecs_20140526_models.DeleteVpcRequest,
    ) -> ecs_20140526_models.DeleteVpcResponse:
        """
        @deprecated OpenAPI DeleteVpc is deprecated, please use Vpc::2016-04-28::DeleteVpc instead.
        
        @summary 删除VPC
        
        @param request: DeleteVpcRequest
        @return: DeleteVpcResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_vpc_with_options_async(request, runtime)

    def deregister_managed_instance_with_options(
        self,
        request: ecs_20140526_models.DeregisterManagedInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeregisterManagedInstanceResponse:
        """
        @summary Deregisters a managed instance. After you deregister the managed instance, you can no longer use Cloud Assistant to send commands or files to the instance.
        
        @param request: DeregisterManagedInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeregisterManagedInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeregisterManagedInstance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeregisterManagedInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def deregister_managed_instance_with_options_async(
        self,
        request: ecs_20140526_models.DeregisterManagedInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DeregisterManagedInstanceResponse:
        """
        @summary Deregisters a managed instance. After you deregister the managed instance, you can no longer use Cloud Assistant to send commands or files to the instance.
        
        @param request: DeregisterManagedInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeregisterManagedInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeregisterManagedInstance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DeregisterManagedInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def deregister_managed_instance(
        self,
        request: ecs_20140526_models.DeregisterManagedInstanceRequest,
    ) -> ecs_20140526_models.DeregisterManagedInstanceResponse:
        """
        @summary Deregisters a managed instance. After you deregister the managed instance, you can no longer use Cloud Assistant to send commands or files to the instance.
        
        @param request: DeregisterManagedInstanceRequest
        @return: DeregisterManagedInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.deregister_managed_instance_with_options(request, runtime)

    async def deregister_managed_instance_async(
        self,
        request: ecs_20140526_models.DeregisterManagedInstanceRequest,
    ) -> ecs_20140526_models.DeregisterManagedInstanceResponse:
        """
        @summary Deregisters a managed instance. After you deregister the managed instance, you can no longer use Cloud Assistant to send commands or files to the instance.
        
        @param request: DeregisterManagedInstanceRequest
        @return: DeregisterManagedInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.deregister_managed_instance_with_options_async(request, runtime)

    def describe_access_points_with_options(
        self,
        request: ecs_20140526_models.DescribeAccessPointsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeAccessPointsResponse:
        """
        @deprecated OpenAPI DescribeAccessPoints is deprecated, please use Vpc::2016-04-28::DescribeAccessPoints instead.
        
        @summary DescribeAccessPoints
        
        @param request: DescribeAccessPointsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAccessPointsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAccessPoints',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeAccessPointsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_access_points_with_options_async(
        self,
        request: ecs_20140526_models.DescribeAccessPointsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeAccessPointsResponse:
        """
        @deprecated OpenAPI DescribeAccessPoints is deprecated, please use Vpc::2016-04-28::DescribeAccessPoints instead.
        
        @summary DescribeAccessPoints
        
        @param request: DescribeAccessPointsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAccessPointsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAccessPoints',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeAccessPointsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_access_points(
        self,
        request: ecs_20140526_models.DescribeAccessPointsRequest,
    ) -> ecs_20140526_models.DescribeAccessPointsResponse:
        """
        @deprecated OpenAPI DescribeAccessPoints is deprecated, please use Vpc::2016-04-28::DescribeAccessPoints instead.
        
        @summary DescribeAccessPoints
        
        @param request: DescribeAccessPointsRequest
        @return: DescribeAccessPointsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_access_points_with_options(request, runtime)

    async def describe_access_points_async(
        self,
        request: ecs_20140526_models.DescribeAccessPointsRequest,
    ) -> ecs_20140526_models.DescribeAccessPointsResponse:
        """
        @deprecated OpenAPI DescribeAccessPoints is deprecated, please use Vpc::2016-04-28::DescribeAccessPoints instead.
        
        @summary DescribeAccessPoints
        
        @param request: DescribeAccessPointsRequest
        @return: DescribeAccessPointsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_access_points_with_options_async(request, runtime)

    def describe_account_attributes_with_options(
        self,
        request: ecs_20140526_models.DescribeAccountAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeAccountAttributesResponse:
        """
        @summary Queries the quotas of Elastic Compute Service (ECS) resources that you can create in an Alibaba Cloud region. For a specific region, you can query the maximum numbers of security groups, elastic network interfaces (ENIs), vCPUs for pay-as-you-go instances, vCPUs for spot instances, and dedicated hosts that you can create and the capacity quotas for pay-as-you-go disks that you can create. You can also query information such as network types or whether an account has completed real-name verification.
        
        @description After you [create](https://account.alibabacloud.com/register/intl_register.htm) an Alibaba Cloud account, you can create a specific number of ECS instances in different regions within the account. For more information, see [Limits](https://help.aliyun.com/document_detail/25412.html).
        You can apply for a quota increase in the [Quota Center console](https://quotas.console.aliyun.com/products).
        
        @param request: DescribeAccountAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAccountAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.attribute_name):
            query['AttributeName'] = request.attribute_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAccountAttributes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeAccountAttributesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_account_attributes_with_options_async(
        self,
        request: ecs_20140526_models.DescribeAccountAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeAccountAttributesResponse:
        """
        @summary Queries the quotas of Elastic Compute Service (ECS) resources that you can create in an Alibaba Cloud region. For a specific region, you can query the maximum numbers of security groups, elastic network interfaces (ENIs), vCPUs for pay-as-you-go instances, vCPUs for spot instances, and dedicated hosts that you can create and the capacity quotas for pay-as-you-go disks that you can create. You can also query information such as network types or whether an account has completed real-name verification.
        
        @description After you [create](https://account.alibabacloud.com/register/intl_register.htm) an Alibaba Cloud account, you can create a specific number of ECS instances in different regions within the account. For more information, see [Limits](https://help.aliyun.com/document_detail/25412.html).
        You can apply for a quota increase in the [Quota Center console](https://quotas.console.aliyun.com/products).
        
        @param request: DescribeAccountAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAccountAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.attribute_name):
            query['AttributeName'] = request.attribute_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAccountAttributes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeAccountAttributesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_account_attributes(
        self,
        request: ecs_20140526_models.DescribeAccountAttributesRequest,
    ) -> ecs_20140526_models.DescribeAccountAttributesResponse:
        """
        @summary Queries the quotas of Elastic Compute Service (ECS) resources that you can create in an Alibaba Cloud region. For a specific region, you can query the maximum numbers of security groups, elastic network interfaces (ENIs), vCPUs for pay-as-you-go instances, vCPUs for spot instances, and dedicated hosts that you can create and the capacity quotas for pay-as-you-go disks that you can create. You can also query information such as network types or whether an account has completed real-name verification.
        
        @description After you [create](https://account.alibabacloud.com/register/intl_register.htm) an Alibaba Cloud account, you can create a specific number of ECS instances in different regions within the account. For more information, see [Limits](https://help.aliyun.com/document_detail/25412.html).
        You can apply for a quota increase in the [Quota Center console](https://quotas.console.aliyun.com/products).
        
        @param request: DescribeAccountAttributesRequest
        @return: DescribeAccountAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_account_attributes_with_options(request, runtime)

    async def describe_account_attributes_async(
        self,
        request: ecs_20140526_models.DescribeAccountAttributesRequest,
    ) -> ecs_20140526_models.DescribeAccountAttributesResponse:
        """
        @summary Queries the quotas of Elastic Compute Service (ECS) resources that you can create in an Alibaba Cloud region. For a specific region, you can query the maximum numbers of security groups, elastic network interfaces (ENIs), vCPUs for pay-as-you-go instances, vCPUs for spot instances, and dedicated hosts that you can create and the capacity quotas for pay-as-you-go disks that you can create. You can also query information such as network types or whether an account has completed real-name verification.
        
        @description After you [create](https://account.alibabacloud.com/register/intl_register.htm) an Alibaba Cloud account, you can create a specific number of ECS instances in different regions within the account. For more information, see [Limits](https://help.aliyun.com/document_detail/25412.html).
        You can apply for a quota increase in the [Quota Center console](https://quotas.console.aliyun.com/products).
        
        @param request: DescribeAccountAttributesRequest
        @return: DescribeAccountAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_account_attributes_with_options_async(request, runtime)

    def describe_activations_with_options(
        self,
        request: ecs_20140526_models.DescribeActivationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeActivationsResponse:
        """
        @summary Queries existing activation codes and their usage information.
        
        @description ## [](#)Usage notes
        You can use one of the following methods to check the responses:
        Method 1: During a paged query, when you call the DescribeActivations operation to retrieve the first page of results, use `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token, which you can use in the next request to retrieve a new page of results. When you call the DescribeActivations operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        Method 2: Use `PageSize` to specify the number of entries to return on each page, and then use `PageNumber` to specify the number of the page to return. You can use only one of the preceding methods. If you specify `MaxResults` or `NextToken`, the `PageSize` and `PageNumber` request parameters do not take effect and the `TotalCount` response parameter is invalid.
        
        @param request: DescribeActivationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeActivationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.activation_id):
            query['ActivationId'] = request.activation_id
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeActivations',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeActivationsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_activations_with_options_async(
        self,
        request: ecs_20140526_models.DescribeActivationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeActivationsResponse:
        """
        @summary Queries existing activation codes and their usage information.
        
        @description ## [](#)Usage notes
        You can use one of the following methods to check the responses:
        Method 1: During a paged query, when you call the DescribeActivations operation to retrieve the first page of results, use `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token, which you can use in the next request to retrieve a new page of results. When you call the DescribeActivations operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        Method 2: Use `PageSize` to specify the number of entries to return on each page, and then use `PageNumber` to specify the number of the page to return. You can use only one of the preceding methods. If you specify `MaxResults` or `NextToken`, the `PageSize` and `PageNumber` request parameters do not take effect and the `TotalCount` response parameter is invalid.
        
        @param request: DescribeActivationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeActivationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.activation_id):
            query['ActivationId'] = request.activation_id
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeActivations',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeActivationsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_activations(
        self,
        request: ecs_20140526_models.DescribeActivationsRequest,
    ) -> ecs_20140526_models.DescribeActivationsResponse:
        """
        @summary Queries existing activation codes and their usage information.
        
        @description ## [](#)Usage notes
        You can use one of the following methods to check the responses:
        Method 1: During a paged query, when you call the DescribeActivations operation to retrieve the first page of results, use `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token, which you can use in the next request to retrieve a new page of results. When you call the DescribeActivations operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        Method 2: Use `PageSize` to specify the number of entries to return on each page, and then use `PageNumber` to specify the number of the page to return. You can use only one of the preceding methods. If you specify `MaxResults` or `NextToken`, the `PageSize` and `PageNumber` request parameters do not take effect and the `TotalCount` response parameter is invalid.
        
        @param request: DescribeActivationsRequest
        @return: DescribeActivationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_activations_with_options(request, runtime)

    async def describe_activations_async(
        self,
        request: ecs_20140526_models.DescribeActivationsRequest,
    ) -> ecs_20140526_models.DescribeActivationsResponse:
        """
        @summary Queries existing activation codes and their usage information.
        
        @description ## [](#)Usage notes
        You can use one of the following methods to check the responses:
        Method 1: During a paged query, when you call the DescribeActivations operation to retrieve the first page of results, use `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token, which you can use in the next request to retrieve a new page of results. When you call the DescribeActivations operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        Method 2: Use `PageSize` to specify the number of entries to return on each page, and then use `PageNumber` to specify the number of the page to return. You can use only one of the preceding methods. If you specify `MaxResults` or `NextToken`, the `PageSize` and `PageNumber` request parameters do not take effect and the `TotalCount` response parameter is invalid.
        
        @param request: DescribeActivationsRequest
        @return: DescribeActivationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_activations_with_options_async(request, runtime)

    def describe_auto_provisioning_group_history_with_options(
        self,
        request: ecs_20140526_models.DescribeAutoProvisioningGroupHistoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeAutoProvisioningGroupHistoryResponse:
        """
        @summary Queries the scheduling tasks of an auto provisioning group.
        
        @param request: DescribeAutoProvisioningGroupHistoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAutoProvisioningGroupHistoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_provisioning_group_id):
            query['AutoProvisioningGroupId'] = request.auto_provisioning_group_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAutoProvisioningGroupHistory',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeAutoProvisioningGroupHistoryResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_auto_provisioning_group_history_with_options_async(
        self,
        request: ecs_20140526_models.DescribeAutoProvisioningGroupHistoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeAutoProvisioningGroupHistoryResponse:
        """
        @summary Queries the scheduling tasks of an auto provisioning group.
        
        @param request: DescribeAutoProvisioningGroupHistoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAutoProvisioningGroupHistoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_provisioning_group_id):
            query['AutoProvisioningGroupId'] = request.auto_provisioning_group_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAutoProvisioningGroupHistory',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeAutoProvisioningGroupHistoryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_auto_provisioning_group_history(
        self,
        request: ecs_20140526_models.DescribeAutoProvisioningGroupHistoryRequest,
    ) -> ecs_20140526_models.DescribeAutoProvisioningGroupHistoryResponse:
        """
        @summary Queries the scheduling tasks of an auto provisioning group.
        
        @param request: DescribeAutoProvisioningGroupHistoryRequest
        @return: DescribeAutoProvisioningGroupHistoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_auto_provisioning_group_history_with_options(request, runtime)

    async def describe_auto_provisioning_group_history_async(
        self,
        request: ecs_20140526_models.DescribeAutoProvisioningGroupHistoryRequest,
    ) -> ecs_20140526_models.DescribeAutoProvisioningGroupHistoryResponse:
        """
        @summary Queries the scheduling tasks of an auto provisioning group.
        
        @param request: DescribeAutoProvisioningGroupHistoryRequest
        @return: DescribeAutoProvisioningGroupHistoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_auto_provisioning_group_history_with_options_async(request, runtime)

    def describe_auto_provisioning_group_instances_with_options(
        self,
        request: ecs_20140526_models.DescribeAutoProvisioningGroupInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeAutoProvisioningGroupInstancesResponse:
        """
        @summary Queries information about Elastic Compute Service (ECS) instances in an auto provisioning group.
        
        @param request: DescribeAutoProvisioningGroupInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAutoProvisioningGroupInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_provisioning_group_id):
            query['AutoProvisioningGroupId'] = request.auto_provisioning_group_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAutoProvisioningGroupInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeAutoProvisioningGroupInstancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_auto_provisioning_group_instances_with_options_async(
        self,
        request: ecs_20140526_models.DescribeAutoProvisioningGroupInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeAutoProvisioningGroupInstancesResponse:
        """
        @summary Queries information about Elastic Compute Service (ECS) instances in an auto provisioning group.
        
        @param request: DescribeAutoProvisioningGroupInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAutoProvisioningGroupInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_provisioning_group_id):
            query['AutoProvisioningGroupId'] = request.auto_provisioning_group_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAutoProvisioningGroupInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeAutoProvisioningGroupInstancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_auto_provisioning_group_instances(
        self,
        request: ecs_20140526_models.DescribeAutoProvisioningGroupInstancesRequest,
    ) -> ecs_20140526_models.DescribeAutoProvisioningGroupInstancesResponse:
        """
        @summary Queries information about Elastic Compute Service (ECS) instances in an auto provisioning group.
        
        @param request: DescribeAutoProvisioningGroupInstancesRequest
        @return: DescribeAutoProvisioningGroupInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_auto_provisioning_group_instances_with_options(request, runtime)

    async def describe_auto_provisioning_group_instances_async(
        self,
        request: ecs_20140526_models.DescribeAutoProvisioningGroupInstancesRequest,
    ) -> ecs_20140526_models.DescribeAutoProvisioningGroupInstancesResponse:
        """
        @summary Queries information about Elastic Compute Service (ECS) instances in an auto provisioning group.
        
        @param request: DescribeAutoProvisioningGroupInstancesRequest
        @return: DescribeAutoProvisioningGroupInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_auto_provisioning_group_instances_with_options_async(request, runtime)

    def describe_auto_provisioning_groups_with_options(
        self,
        request: ecs_20140526_models.DescribeAutoProvisioningGroupsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeAutoProvisioningGroupsResponse:
        """
        @summary Queries information about one or more auto provisioning groups.
        
        @param request: DescribeAutoProvisioningGroupsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAutoProvisioningGroupsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_provisioning_group_id):
            query['AutoProvisioningGroupId'] = request.auto_provisioning_group_id
        if not UtilClient.is_unset(request.auto_provisioning_group_name):
            query['AutoProvisioningGroupName'] = request.auto_provisioning_group_name
        if not UtilClient.is_unset(request.auto_provisioning_group_status):
            query['AutoProvisioningGroupStatus'] = request.auto_provisioning_group_status
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAutoProvisioningGroups',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeAutoProvisioningGroupsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_auto_provisioning_groups_with_options_async(
        self,
        request: ecs_20140526_models.DescribeAutoProvisioningGroupsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeAutoProvisioningGroupsResponse:
        """
        @summary Queries information about one or more auto provisioning groups.
        
        @param request: DescribeAutoProvisioningGroupsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAutoProvisioningGroupsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_provisioning_group_id):
            query['AutoProvisioningGroupId'] = request.auto_provisioning_group_id
        if not UtilClient.is_unset(request.auto_provisioning_group_name):
            query['AutoProvisioningGroupName'] = request.auto_provisioning_group_name
        if not UtilClient.is_unset(request.auto_provisioning_group_status):
            query['AutoProvisioningGroupStatus'] = request.auto_provisioning_group_status
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAutoProvisioningGroups',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeAutoProvisioningGroupsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_auto_provisioning_groups(
        self,
        request: ecs_20140526_models.DescribeAutoProvisioningGroupsRequest,
    ) -> ecs_20140526_models.DescribeAutoProvisioningGroupsResponse:
        """
        @summary Queries information about one or more auto provisioning groups.
        
        @param request: DescribeAutoProvisioningGroupsRequest
        @return: DescribeAutoProvisioningGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_auto_provisioning_groups_with_options(request, runtime)

    async def describe_auto_provisioning_groups_async(
        self,
        request: ecs_20140526_models.DescribeAutoProvisioningGroupsRequest,
    ) -> ecs_20140526_models.DescribeAutoProvisioningGroupsResponse:
        """
        @summary Queries information about one or more auto provisioning groups.
        
        @param request: DescribeAutoProvisioningGroupsRequest
        @return: DescribeAutoProvisioningGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_auto_provisioning_groups_with_options_async(request, runtime)

    def describe_auto_snapshot_policy_associations_with_options(
        self,
        request: ecs_20140526_models.DescribeAutoSnapshotPolicyAssociationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeAutoSnapshotPolicyAssociationsResponse:
        """
        @summary 查询自动快照策略的关联关系
        
        @param request: DescribeAutoSnapshotPolicyAssociationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAutoSnapshotPolicyAssociationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_snapshot_policy_id):
            query['AutoSnapshotPolicyId'] = request.auto_snapshot_policy_id
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAutoSnapshotPolicyAssociations',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeAutoSnapshotPolicyAssociationsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_auto_snapshot_policy_associations_with_options_async(
        self,
        request: ecs_20140526_models.DescribeAutoSnapshotPolicyAssociationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeAutoSnapshotPolicyAssociationsResponse:
        """
        @summary 查询自动快照策略的关联关系
        
        @param request: DescribeAutoSnapshotPolicyAssociationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAutoSnapshotPolicyAssociationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_snapshot_policy_id):
            query['AutoSnapshotPolicyId'] = request.auto_snapshot_policy_id
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAutoSnapshotPolicyAssociations',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeAutoSnapshotPolicyAssociationsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_auto_snapshot_policy_associations(
        self,
        request: ecs_20140526_models.DescribeAutoSnapshotPolicyAssociationsRequest,
    ) -> ecs_20140526_models.DescribeAutoSnapshotPolicyAssociationsResponse:
        """
        @summary 查询自动快照策略的关联关系
        
        @param request: DescribeAutoSnapshotPolicyAssociationsRequest
        @return: DescribeAutoSnapshotPolicyAssociationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_auto_snapshot_policy_associations_with_options(request, runtime)

    async def describe_auto_snapshot_policy_associations_async(
        self,
        request: ecs_20140526_models.DescribeAutoSnapshotPolicyAssociationsRequest,
    ) -> ecs_20140526_models.DescribeAutoSnapshotPolicyAssociationsResponse:
        """
        @summary 查询自动快照策略的关联关系
        
        @param request: DescribeAutoSnapshotPolicyAssociationsRequest
        @return: DescribeAutoSnapshotPolicyAssociationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_auto_snapshot_policy_associations_with_options_async(request, runtime)

    def describe_auto_snapshot_policy_ex_with_options(
        self,
        request: ecs_20140526_models.DescribeAutoSnapshotPolicyExRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeAutoSnapshotPolicyExResponse:
        """
        @summary Queries the details of automatic snapshot policies that are created in a specific region.
        
        @param request: DescribeAutoSnapshotPolicyExRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAutoSnapshotPolicyExResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_snapshot_policy_id):
            query['AutoSnapshotPolicyId'] = request.auto_snapshot_policy_id
        if not UtilClient.is_unset(request.auto_snapshot_policy_name):
            query['AutoSnapshotPolicyName'] = request.auto_snapshot_policy_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAutoSnapshotPolicyEx',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeAutoSnapshotPolicyExResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_auto_snapshot_policy_ex_with_options_async(
        self,
        request: ecs_20140526_models.DescribeAutoSnapshotPolicyExRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeAutoSnapshotPolicyExResponse:
        """
        @summary Queries the details of automatic snapshot policies that are created in a specific region.
        
        @param request: DescribeAutoSnapshotPolicyExRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAutoSnapshotPolicyExResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_snapshot_policy_id):
            query['AutoSnapshotPolicyId'] = request.auto_snapshot_policy_id
        if not UtilClient.is_unset(request.auto_snapshot_policy_name):
            query['AutoSnapshotPolicyName'] = request.auto_snapshot_policy_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAutoSnapshotPolicyEx',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeAutoSnapshotPolicyExResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_auto_snapshot_policy_ex(
        self,
        request: ecs_20140526_models.DescribeAutoSnapshotPolicyExRequest,
    ) -> ecs_20140526_models.DescribeAutoSnapshotPolicyExResponse:
        """
        @summary Queries the details of automatic snapshot policies that are created in a specific region.
        
        @param request: DescribeAutoSnapshotPolicyExRequest
        @return: DescribeAutoSnapshotPolicyExResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_auto_snapshot_policy_ex_with_options(request, runtime)

    async def describe_auto_snapshot_policy_ex_async(
        self,
        request: ecs_20140526_models.DescribeAutoSnapshotPolicyExRequest,
    ) -> ecs_20140526_models.DescribeAutoSnapshotPolicyExResponse:
        """
        @summary Queries the details of automatic snapshot policies that are created in a specific region.
        
        @param request: DescribeAutoSnapshotPolicyExRequest
        @return: DescribeAutoSnapshotPolicyExResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_auto_snapshot_policy_ex_with_options_async(request, runtime)

    def describe_available_resource_with_options(
        self,
        request: ecs_20140526_models.DescribeAvailableResourceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeAvailableResourceResponse:
        """
        @summary Queries resources in a zone. You can query the resources available in a zone before you create Elastic Compute Service (ECS) instances by calling the RunInstances operation or before you change instance types by calling the ModifyInstanceSpec operation.
        
        @description The value of `DestinationResource` determines whether you need to specify additional parameters. When you select a value in the following chain for DestinationResource, the more to the right the selected value is ordered, the more parameters you must specify.
        Sequence: `Zone > IoOptimized > InstanceType = Network = ddh > SystemDisk > DataDisk`
        Examples:
        If you set `DestinationResource` to `DataDisk`, take note of the following items:
        If you set `ResourceType` to `disk` to query the categories of data disks regardless of whether the disks are attached to ECS instances, you can leave `InstanceType` empty.
        If you set `ResourceType` to `instance` to query the categories of data disks that are attached to ECS instances, you must specify `InstanceType` and `DataDiskCategory` due to instance type-specific limits on data disks.
        If you set `DestinationResource` to `SystemDisk` and `ResourceType` to `instance`, you must specify `InstanceType` due to instance type-specific limits on system disks.
        If you set `DestinationResource` to `InstanceType`, we recommend that you specify `IoOptimized` and `InstanceType`.
        To query the ecs.g5.large instance type in all zones of the China (Hangzhou) region, set `RegionId to cn-hangzhou, DestinationResource to InstanceType, IoOptimized to optimized, and InstanceType to ecs.g5.large`.
        To query the zones in which the ecs.g5.large instance type is available in the China (Hangzhou) region, set `RegionId to cn-hangzhou, DestinationResource to Zone, IoOptimized to optimized, and InstanceType to ecs.g5.large`.
        *To query the zones in which the ecs.g5.large instance type is available in the China (Hangzhou) region, specify parameters as follows:**\
        "RegionId": "cn-hangzhou",
        "DestinationResource": "Zone",
        "InstanceType": "ecs.g5.large"
        *To query the ecs.g5.large instance type in all zones of the China (Hangzhou) region, specify parameters as follows:**\
        "RegionId": "cn-hangzhou",
        "DestinationResource": "InstanceType""InstanceType": "ecs.g5.large"
        *To query data disks of the ultra disk category in Hangzhou Zone B regardless of whether the disks are attached to ECS instances, specify parameters as follows:**\
        "RegionId": "cn-hangzhou",
        "ZoneId": "cn-hangzhou-b",
        "ResourceType": "disk",
        "DestinationResource": "DataDisk"
        *To query data disks purchased together with ecs.g7.large instances that reside in Hangzhou Zone B and use Enterprise SSDs (ESSDs) as system disks, specify parameters as follows:**\
        "RegionId": "cn-hangzhou",
        "ZoneId": "cn-hangzhou-b",
        "ResourceType": "instance",
        "InstanceType": "ecs.g7.large",
        "DestinationResource": "SystemDisk",
        "SystemDiskCategory": "cloud_essd"
        
        @param request: DescribeAvailableResourceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAvailableResourceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cores):
            query['Cores'] = request.cores
        if not UtilClient.is_unset(request.data_disk_category):
            query['DataDiskCategory'] = request.data_disk_category
        if not UtilClient.is_unset(request.dedicated_host_id):
            query['DedicatedHostId'] = request.dedicated_host_id
        if not UtilClient.is_unset(request.destination_resource):
            query['DestinationResource'] = request.destination_resource
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.io_optimized):
            query['IoOptimized'] = request.io_optimized
        if not UtilClient.is_unset(request.memory):
            query['Memory'] = request.memory
        if not UtilClient.is_unset(request.network_category):
            query['NetworkCategory'] = request.network_category
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.scope):
            query['Scope'] = request.scope
        if not UtilClient.is_unset(request.spot_duration):
            query['SpotDuration'] = request.spot_duration
        if not UtilClient.is_unset(request.spot_strategy):
            query['SpotStrategy'] = request.spot_strategy
        if not UtilClient.is_unset(request.system_disk_category):
            query['SystemDiskCategory'] = request.system_disk_category
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAvailableResource',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeAvailableResourceResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_available_resource_with_options_async(
        self,
        request: ecs_20140526_models.DescribeAvailableResourceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeAvailableResourceResponse:
        """
        @summary Queries resources in a zone. You can query the resources available in a zone before you create Elastic Compute Service (ECS) instances by calling the RunInstances operation or before you change instance types by calling the ModifyInstanceSpec operation.
        
        @description The value of `DestinationResource` determines whether you need to specify additional parameters. When you select a value in the following chain for DestinationResource, the more to the right the selected value is ordered, the more parameters you must specify.
        Sequence: `Zone > IoOptimized > InstanceType = Network = ddh > SystemDisk > DataDisk`
        Examples:
        If you set `DestinationResource` to `DataDisk`, take note of the following items:
        If you set `ResourceType` to `disk` to query the categories of data disks regardless of whether the disks are attached to ECS instances, you can leave `InstanceType` empty.
        If you set `ResourceType` to `instance` to query the categories of data disks that are attached to ECS instances, you must specify `InstanceType` and `DataDiskCategory` due to instance type-specific limits on data disks.
        If you set `DestinationResource` to `SystemDisk` and `ResourceType` to `instance`, you must specify `InstanceType` due to instance type-specific limits on system disks.
        If you set `DestinationResource` to `InstanceType`, we recommend that you specify `IoOptimized` and `InstanceType`.
        To query the ecs.g5.large instance type in all zones of the China (Hangzhou) region, set `RegionId to cn-hangzhou, DestinationResource to InstanceType, IoOptimized to optimized, and InstanceType to ecs.g5.large`.
        To query the zones in which the ecs.g5.large instance type is available in the China (Hangzhou) region, set `RegionId to cn-hangzhou, DestinationResource to Zone, IoOptimized to optimized, and InstanceType to ecs.g5.large`.
        *To query the zones in which the ecs.g5.large instance type is available in the China (Hangzhou) region, specify parameters as follows:**\
        "RegionId": "cn-hangzhou",
        "DestinationResource": "Zone",
        "InstanceType": "ecs.g5.large"
        *To query the ecs.g5.large instance type in all zones of the China (Hangzhou) region, specify parameters as follows:**\
        "RegionId": "cn-hangzhou",
        "DestinationResource": "InstanceType""InstanceType": "ecs.g5.large"
        *To query data disks of the ultra disk category in Hangzhou Zone B regardless of whether the disks are attached to ECS instances, specify parameters as follows:**\
        "RegionId": "cn-hangzhou",
        "ZoneId": "cn-hangzhou-b",
        "ResourceType": "disk",
        "DestinationResource": "DataDisk"
        *To query data disks purchased together with ecs.g7.large instances that reside in Hangzhou Zone B and use Enterprise SSDs (ESSDs) as system disks, specify parameters as follows:**\
        "RegionId": "cn-hangzhou",
        "ZoneId": "cn-hangzhou-b",
        "ResourceType": "instance",
        "InstanceType": "ecs.g7.large",
        "DestinationResource": "SystemDisk",
        "SystemDiskCategory": "cloud_essd"
        
        @param request: DescribeAvailableResourceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAvailableResourceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cores):
            query['Cores'] = request.cores
        if not UtilClient.is_unset(request.data_disk_category):
            query['DataDiskCategory'] = request.data_disk_category
        if not UtilClient.is_unset(request.dedicated_host_id):
            query['DedicatedHostId'] = request.dedicated_host_id
        if not UtilClient.is_unset(request.destination_resource):
            query['DestinationResource'] = request.destination_resource
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.io_optimized):
            query['IoOptimized'] = request.io_optimized
        if not UtilClient.is_unset(request.memory):
            query['Memory'] = request.memory
        if not UtilClient.is_unset(request.network_category):
            query['NetworkCategory'] = request.network_category
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.scope):
            query['Scope'] = request.scope
        if not UtilClient.is_unset(request.spot_duration):
            query['SpotDuration'] = request.spot_duration
        if not UtilClient.is_unset(request.spot_strategy):
            query['SpotStrategy'] = request.spot_strategy
        if not UtilClient.is_unset(request.system_disk_category):
            query['SystemDiskCategory'] = request.system_disk_category
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAvailableResource',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeAvailableResourceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_available_resource(
        self,
        request: ecs_20140526_models.DescribeAvailableResourceRequest,
    ) -> ecs_20140526_models.DescribeAvailableResourceResponse:
        """
        @summary Queries resources in a zone. You can query the resources available in a zone before you create Elastic Compute Service (ECS) instances by calling the RunInstances operation or before you change instance types by calling the ModifyInstanceSpec operation.
        
        @description The value of `DestinationResource` determines whether you need to specify additional parameters. When you select a value in the following chain for DestinationResource, the more to the right the selected value is ordered, the more parameters you must specify.
        Sequence: `Zone > IoOptimized > InstanceType = Network = ddh > SystemDisk > DataDisk`
        Examples:
        If you set `DestinationResource` to `DataDisk`, take note of the following items:
        If you set `ResourceType` to `disk` to query the categories of data disks regardless of whether the disks are attached to ECS instances, you can leave `InstanceType` empty.
        If you set `ResourceType` to `instance` to query the categories of data disks that are attached to ECS instances, you must specify `InstanceType` and `DataDiskCategory` due to instance type-specific limits on data disks.
        If you set `DestinationResource` to `SystemDisk` and `ResourceType` to `instance`, you must specify `InstanceType` due to instance type-specific limits on system disks.
        If you set `DestinationResource` to `InstanceType`, we recommend that you specify `IoOptimized` and `InstanceType`.
        To query the ecs.g5.large instance type in all zones of the China (Hangzhou) region, set `RegionId to cn-hangzhou, DestinationResource to InstanceType, IoOptimized to optimized, and InstanceType to ecs.g5.large`.
        To query the zones in which the ecs.g5.large instance type is available in the China (Hangzhou) region, set `RegionId to cn-hangzhou, DestinationResource to Zone, IoOptimized to optimized, and InstanceType to ecs.g5.large`.
        *To query the zones in which the ecs.g5.large instance type is available in the China (Hangzhou) region, specify parameters as follows:**\
        "RegionId": "cn-hangzhou",
        "DestinationResource": "Zone",
        "InstanceType": "ecs.g5.large"
        *To query the ecs.g5.large instance type in all zones of the China (Hangzhou) region, specify parameters as follows:**\
        "RegionId": "cn-hangzhou",
        "DestinationResource": "InstanceType""InstanceType": "ecs.g5.large"
        *To query data disks of the ultra disk category in Hangzhou Zone B regardless of whether the disks are attached to ECS instances, specify parameters as follows:**\
        "RegionId": "cn-hangzhou",
        "ZoneId": "cn-hangzhou-b",
        "ResourceType": "disk",
        "DestinationResource": "DataDisk"
        *To query data disks purchased together with ecs.g7.large instances that reside in Hangzhou Zone B and use Enterprise SSDs (ESSDs) as system disks, specify parameters as follows:**\
        "RegionId": "cn-hangzhou",
        "ZoneId": "cn-hangzhou-b",
        "ResourceType": "instance",
        "InstanceType": "ecs.g7.large",
        "DestinationResource": "SystemDisk",
        "SystemDiskCategory": "cloud_essd"
        
        @param request: DescribeAvailableResourceRequest
        @return: DescribeAvailableResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_available_resource_with_options(request, runtime)

    async def describe_available_resource_async(
        self,
        request: ecs_20140526_models.DescribeAvailableResourceRequest,
    ) -> ecs_20140526_models.DescribeAvailableResourceResponse:
        """
        @summary Queries resources in a zone. You can query the resources available in a zone before you create Elastic Compute Service (ECS) instances by calling the RunInstances operation or before you change instance types by calling the ModifyInstanceSpec operation.
        
        @description The value of `DestinationResource` determines whether you need to specify additional parameters. When you select a value in the following chain for DestinationResource, the more to the right the selected value is ordered, the more parameters you must specify.
        Sequence: `Zone > IoOptimized > InstanceType = Network = ddh > SystemDisk > DataDisk`
        Examples:
        If you set `DestinationResource` to `DataDisk`, take note of the following items:
        If you set `ResourceType` to `disk` to query the categories of data disks regardless of whether the disks are attached to ECS instances, you can leave `InstanceType` empty.
        If you set `ResourceType` to `instance` to query the categories of data disks that are attached to ECS instances, you must specify `InstanceType` and `DataDiskCategory` due to instance type-specific limits on data disks.
        If you set `DestinationResource` to `SystemDisk` and `ResourceType` to `instance`, you must specify `InstanceType` due to instance type-specific limits on system disks.
        If you set `DestinationResource` to `InstanceType`, we recommend that you specify `IoOptimized` and `InstanceType`.
        To query the ecs.g5.large instance type in all zones of the China (Hangzhou) region, set `RegionId to cn-hangzhou, DestinationResource to InstanceType, IoOptimized to optimized, and InstanceType to ecs.g5.large`.
        To query the zones in which the ecs.g5.large instance type is available in the China (Hangzhou) region, set `RegionId to cn-hangzhou, DestinationResource to Zone, IoOptimized to optimized, and InstanceType to ecs.g5.large`.
        *To query the zones in which the ecs.g5.large instance type is available in the China (Hangzhou) region, specify parameters as follows:**\
        "RegionId": "cn-hangzhou",
        "DestinationResource": "Zone",
        "InstanceType": "ecs.g5.large"
        *To query the ecs.g5.large instance type in all zones of the China (Hangzhou) region, specify parameters as follows:**\
        "RegionId": "cn-hangzhou",
        "DestinationResource": "InstanceType""InstanceType": "ecs.g5.large"
        *To query data disks of the ultra disk category in Hangzhou Zone B regardless of whether the disks are attached to ECS instances, specify parameters as follows:**\
        "RegionId": "cn-hangzhou",
        "ZoneId": "cn-hangzhou-b",
        "ResourceType": "disk",
        "DestinationResource": "DataDisk"
        *To query data disks purchased together with ecs.g7.large instances that reside in Hangzhou Zone B and use Enterprise SSDs (ESSDs) as system disks, specify parameters as follows:**\
        "RegionId": "cn-hangzhou",
        "ZoneId": "cn-hangzhou-b",
        "ResourceType": "instance",
        "InstanceType": "ecs.g7.large",
        "DestinationResource": "SystemDisk",
        "SystemDiskCategory": "cloud_essd"
        
        @param request: DescribeAvailableResourceRequest
        @return: DescribeAvailableResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_available_resource_with_options_async(request, runtime)

    def describe_bandwidth_limitation_with_options(
        self,
        request: ecs_20140526_models.DescribeBandwidthLimitationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeBandwidthLimitationResponse:
        """
        @summary Queries the maximum public bandwidth that can be purchased, upgraded, or downgraded for various Elastic Compute Service (ECS) instance types.
        
        @param request: DescribeBandwidthLimitationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeBandwidthLimitationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.operation_type):
            query['OperationType'] = request.operation_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.spot_strategy):
            query['SpotStrategy'] = request.spot_strategy
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeBandwidthLimitation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeBandwidthLimitationResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_bandwidth_limitation_with_options_async(
        self,
        request: ecs_20140526_models.DescribeBandwidthLimitationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeBandwidthLimitationResponse:
        """
        @summary Queries the maximum public bandwidth that can be purchased, upgraded, or downgraded for various Elastic Compute Service (ECS) instance types.
        
        @param request: DescribeBandwidthLimitationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeBandwidthLimitationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.operation_type):
            query['OperationType'] = request.operation_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.spot_strategy):
            query['SpotStrategy'] = request.spot_strategy
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeBandwidthLimitation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeBandwidthLimitationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_bandwidth_limitation(
        self,
        request: ecs_20140526_models.DescribeBandwidthLimitationRequest,
    ) -> ecs_20140526_models.DescribeBandwidthLimitationResponse:
        """
        @summary Queries the maximum public bandwidth that can be purchased, upgraded, or downgraded for various Elastic Compute Service (ECS) instance types.
        
        @param request: DescribeBandwidthLimitationRequest
        @return: DescribeBandwidthLimitationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_bandwidth_limitation_with_options(request, runtime)

    async def describe_bandwidth_limitation_async(
        self,
        request: ecs_20140526_models.DescribeBandwidthLimitationRequest,
    ) -> ecs_20140526_models.DescribeBandwidthLimitationResponse:
        """
        @summary Queries the maximum public bandwidth that can be purchased, upgraded, or downgraded for various Elastic Compute Service (ECS) instance types.
        
        @param request: DescribeBandwidthLimitationRequest
        @return: DescribeBandwidthLimitationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_bandwidth_limitation_with_options_async(request, runtime)

    def describe_bandwidth_packages_with_options(
        self,
        request: ecs_20140526_models.DescribeBandwidthPackagesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeBandwidthPackagesResponse:
        """
        @deprecated OpenAPI DescribeBandwidthPackages is deprecated, please use Vpc::2016-04-28::DescribeBandwidthPackages instead.
        
        @summary DescribeBandwidthPackages
        
        @param request: DescribeBandwidthPackagesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeBandwidthPackagesResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeBandwidthPackages',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeBandwidthPackagesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_bandwidth_packages_with_options_async(
        self,
        request: ecs_20140526_models.DescribeBandwidthPackagesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeBandwidthPackagesResponse:
        """
        @deprecated OpenAPI DescribeBandwidthPackages is deprecated, please use Vpc::2016-04-28::DescribeBandwidthPackages instead.
        
        @summary DescribeBandwidthPackages
        
        @param request: DescribeBandwidthPackagesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeBandwidthPackagesResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeBandwidthPackages',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeBandwidthPackagesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_bandwidth_packages(
        self,
        request: ecs_20140526_models.DescribeBandwidthPackagesRequest,
    ) -> ecs_20140526_models.DescribeBandwidthPackagesResponse:
        """
        @deprecated OpenAPI DescribeBandwidthPackages is deprecated, please use Vpc::2016-04-28::DescribeBandwidthPackages instead.
        
        @summary DescribeBandwidthPackages
        
        @param request: DescribeBandwidthPackagesRequest
        @return: DescribeBandwidthPackagesResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_bandwidth_packages_with_options(request, runtime)

    async def describe_bandwidth_packages_async(
        self,
        request: ecs_20140526_models.DescribeBandwidthPackagesRequest,
    ) -> ecs_20140526_models.DescribeBandwidthPackagesResponse:
        """
        @deprecated OpenAPI DescribeBandwidthPackages is deprecated, please use Vpc::2016-04-28::DescribeBandwidthPackages instead.
        
        @summary DescribeBandwidthPackages
        
        @param request: DescribeBandwidthPackagesRequest
        @return: DescribeBandwidthPackagesResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_bandwidth_packages_with_options_async(request, runtime)

    def describe_capacity_reservation_instances_with_options(
        self,
        request: ecs_20140526_models.DescribeCapacityReservationInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeCapacityReservationInstancesResponse:
        """
        @summary Queries the Elastic Compute Service (ECS) instances that match a capacity reservation.
        
        @param request: DescribeCapacityReservationInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCapacityReservationInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCapacityReservationInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeCapacityReservationInstancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_capacity_reservation_instances_with_options_async(
        self,
        request: ecs_20140526_models.DescribeCapacityReservationInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeCapacityReservationInstancesResponse:
        """
        @summary Queries the Elastic Compute Service (ECS) instances that match a capacity reservation.
        
        @param request: DescribeCapacityReservationInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCapacityReservationInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCapacityReservationInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeCapacityReservationInstancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_capacity_reservation_instances(
        self,
        request: ecs_20140526_models.DescribeCapacityReservationInstancesRequest,
    ) -> ecs_20140526_models.DescribeCapacityReservationInstancesResponse:
        """
        @summary Queries the Elastic Compute Service (ECS) instances that match a capacity reservation.
        
        @param request: DescribeCapacityReservationInstancesRequest
        @return: DescribeCapacityReservationInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_capacity_reservation_instances_with_options(request, runtime)

    async def describe_capacity_reservation_instances_async(
        self,
        request: ecs_20140526_models.DescribeCapacityReservationInstancesRequest,
    ) -> ecs_20140526_models.DescribeCapacityReservationInstancesResponse:
        """
        @summary Queries the Elastic Compute Service (ECS) instances that match a capacity reservation.
        
        @param request: DescribeCapacityReservationInstancesRequest
        @return: DescribeCapacityReservationInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_capacity_reservation_instances_with_options_async(request, runtime)

    def describe_capacity_reservations_with_options(
        self,
        request: ecs_20140526_models.DescribeCapacityReservationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeCapacityReservationsResponse:
        """
        @summary Queries the details of capacity reservations.
        
        @param request: DescribeCapacityReservationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCapacityReservationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCapacityReservations',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeCapacityReservationsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_capacity_reservations_with_options_async(
        self,
        request: ecs_20140526_models.DescribeCapacityReservationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeCapacityReservationsResponse:
        """
        @summary Queries the details of capacity reservations.
        
        @param request: DescribeCapacityReservationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCapacityReservationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCapacityReservations',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeCapacityReservationsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_capacity_reservations(
        self,
        request: ecs_20140526_models.DescribeCapacityReservationsRequest,
    ) -> ecs_20140526_models.DescribeCapacityReservationsResponse:
        """
        @summary Queries the details of capacity reservations.
        
        @param request: DescribeCapacityReservationsRequest
        @return: DescribeCapacityReservationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_capacity_reservations_with_options(request, runtime)

    async def describe_capacity_reservations_async(
        self,
        request: ecs_20140526_models.DescribeCapacityReservationsRequest,
    ) -> ecs_20140526_models.DescribeCapacityReservationsResponse:
        """
        @summary Queries the details of capacity reservations.
        
        @param request: DescribeCapacityReservationsRequest
        @return: DescribeCapacityReservationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_capacity_reservations_with_options_async(request, runtime)

    def describe_classic_link_instances_with_options(
        self,
        request: ecs_20140526_models.DescribeClassicLinkInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeClassicLinkInstancesResponse:
        """
        @summary Queries instances located in the classic network that have established ClassicLink connections to virtual private clouds (VPCs).
        
        @description Take note of the following items:
        This operation applies only to instances that reside in the classic network.
        You can query a maximum of 100 instances that reside in the classic network at a time.
        At least one of the `VpcId` and `InstanceId` parameters must be configured.
        
        @param request: DescribeClassicLinkInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeClassicLinkInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeClassicLinkInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeClassicLinkInstancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_classic_link_instances_with_options_async(
        self,
        request: ecs_20140526_models.DescribeClassicLinkInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeClassicLinkInstancesResponse:
        """
        @summary Queries instances located in the classic network that have established ClassicLink connections to virtual private clouds (VPCs).
        
        @description Take note of the following items:
        This operation applies only to instances that reside in the classic network.
        You can query a maximum of 100 instances that reside in the classic network at a time.
        At least one of the `VpcId` and `InstanceId` parameters must be configured.
        
        @param request: DescribeClassicLinkInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeClassicLinkInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeClassicLinkInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeClassicLinkInstancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_classic_link_instances(
        self,
        request: ecs_20140526_models.DescribeClassicLinkInstancesRequest,
    ) -> ecs_20140526_models.DescribeClassicLinkInstancesResponse:
        """
        @summary Queries instances located in the classic network that have established ClassicLink connections to virtual private clouds (VPCs).
        
        @description Take note of the following items:
        This operation applies only to instances that reside in the classic network.
        You can query a maximum of 100 instances that reside in the classic network at a time.
        At least one of the `VpcId` and `InstanceId` parameters must be configured.
        
        @param request: DescribeClassicLinkInstancesRequest
        @return: DescribeClassicLinkInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_classic_link_instances_with_options(request, runtime)

    async def describe_classic_link_instances_async(
        self,
        request: ecs_20140526_models.DescribeClassicLinkInstancesRequest,
    ) -> ecs_20140526_models.DescribeClassicLinkInstancesResponse:
        """
        @summary Queries instances located in the classic network that have established ClassicLink connections to virtual private clouds (VPCs).
        
        @description Take note of the following items:
        This operation applies only to instances that reside in the classic network.
        You can query a maximum of 100 instances that reside in the classic network at a time.
        At least one of the `VpcId` and `InstanceId` parameters must be configured.
        
        @param request: DescribeClassicLinkInstancesRequest
        @return: DescribeClassicLinkInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_classic_link_instances_with_options_async(request, runtime)

    def describe_cloud_assistant_settings_with_options(
        self,
        request: ecs_20140526_models.DescribeCloudAssistantSettingsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeCloudAssistantSettingsResponse:
        """
        @summary Queries the configurations of Cloud Assistant features.
        
        @param request: DescribeCloudAssistantSettingsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCloudAssistantSettingsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.setting_type):
            query['SettingType'] = request.setting_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCloudAssistantSettings',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeCloudAssistantSettingsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_cloud_assistant_settings_with_options_async(
        self,
        request: ecs_20140526_models.DescribeCloudAssistantSettingsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeCloudAssistantSettingsResponse:
        """
        @summary Queries the configurations of Cloud Assistant features.
        
        @param request: DescribeCloudAssistantSettingsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCloudAssistantSettingsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.setting_type):
            query['SettingType'] = request.setting_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCloudAssistantSettings',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeCloudAssistantSettingsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_cloud_assistant_settings(
        self,
        request: ecs_20140526_models.DescribeCloudAssistantSettingsRequest,
    ) -> ecs_20140526_models.DescribeCloudAssistantSettingsResponse:
        """
        @summary Queries the configurations of Cloud Assistant features.
        
        @param request: DescribeCloudAssistantSettingsRequest
        @return: DescribeCloudAssistantSettingsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_cloud_assistant_settings_with_options(request, runtime)

    async def describe_cloud_assistant_settings_async(
        self,
        request: ecs_20140526_models.DescribeCloudAssistantSettingsRequest,
    ) -> ecs_20140526_models.DescribeCloudAssistantSettingsResponse:
        """
        @summary Queries the configurations of Cloud Assistant features.
        
        @param request: DescribeCloudAssistantSettingsRequest
        @return: DescribeCloudAssistantSettingsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_cloud_assistant_settings_with_options_async(request, runtime)

    def describe_cloud_assistant_status_with_options(
        self,
        request: ecs_20140526_models.DescribeCloudAssistantStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeCloudAssistantStatusResponse:
        """
        @summary Queries whether Cloud Assistant Agent is installed on instances. If Cloud Assistant Agent is installed, the system queries the total number of Cloud Assistant commands that have been run, the number of Cloud Assistant commands that are being run, and the time when Cloud Assistant commands were last run.
        
        @description ## [](#)Usage notes
        Before you run commands on or send files to instances, especially new instances, we recommend that you query the status of Cloud Assistant on the instances by calling this operation and checking the return value of CloudAssistantStatus. Run commands on or send files to the instances only when the return value is true.
        During a paged query, when you call the DescribeCloudAssistantStatus operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeCloudAssistantStatus operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeCloudAssistantStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCloudAssistantStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.ostype):
            query['OSType'] = request.ostype
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCloudAssistantStatus',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeCloudAssistantStatusResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_cloud_assistant_status_with_options_async(
        self,
        request: ecs_20140526_models.DescribeCloudAssistantStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeCloudAssistantStatusResponse:
        """
        @summary Queries whether Cloud Assistant Agent is installed on instances. If Cloud Assistant Agent is installed, the system queries the total number of Cloud Assistant commands that have been run, the number of Cloud Assistant commands that are being run, and the time when Cloud Assistant commands were last run.
        
        @description ## [](#)Usage notes
        Before you run commands on or send files to instances, especially new instances, we recommend that you query the status of Cloud Assistant on the instances by calling this operation and checking the return value of CloudAssistantStatus. Run commands on or send files to the instances only when the return value is true.
        During a paged query, when you call the DescribeCloudAssistantStatus operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeCloudAssistantStatus operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeCloudAssistantStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCloudAssistantStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.ostype):
            query['OSType'] = request.ostype
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCloudAssistantStatus',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeCloudAssistantStatusResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_cloud_assistant_status(
        self,
        request: ecs_20140526_models.DescribeCloudAssistantStatusRequest,
    ) -> ecs_20140526_models.DescribeCloudAssistantStatusResponse:
        """
        @summary Queries whether Cloud Assistant Agent is installed on instances. If Cloud Assistant Agent is installed, the system queries the total number of Cloud Assistant commands that have been run, the number of Cloud Assistant commands that are being run, and the time when Cloud Assistant commands were last run.
        
        @description ## [](#)Usage notes
        Before you run commands on or send files to instances, especially new instances, we recommend that you query the status of Cloud Assistant on the instances by calling this operation and checking the return value of CloudAssistantStatus. Run commands on or send files to the instances only when the return value is true.
        During a paged query, when you call the DescribeCloudAssistantStatus operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeCloudAssistantStatus operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeCloudAssistantStatusRequest
        @return: DescribeCloudAssistantStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_cloud_assistant_status_with_options(request, runtime)

    async def describe_cloud_assistant_status_async(
        self,
        request: ecs_20140526_models.DescribeCloudAssistantStatusRequest,
    ) -> ecs_20140526_models.DescribeCloudAssistantStatusResponse:
        """
        @summary Queries whether Cloud Assistant Agent is installed on instances. If Cloud Assistant Agent is installed, the system queries the total number of Cloud Assistant commands that have been run, the number of Cloud Assistant commands that are being run, and the time when Cloud Assistant commands were last run.
        
        @description ## [](#)Usage notes
        Before you run commands on or send files to instances, especially new instances, we recommend that you query the status of Cloud Assistant on the instances by calling this operation and checking the return value of CloudAssistantStatus. Run commands on or send files to the instances only when the return value is true.
        During a paged query, when you call the DescribeCloudAssistantStatus operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeCloudAssistantStatus operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeCloudAssistantStatusRequest
        @return: DescribeCloudAssistantStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_cloud_assistant_status_with_options_async(request, runtime)

    def describe_clusters_with_options(
        self,
        request: ecs_20140526_models.DescribeClustersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeClustersResponse:
        """
        @deprecated OpenAPI DescribeClusters is deprecated
        
        @summary 查询集群
        
        @param request: DescribeClustersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeClustersResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeClusters',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeClustersResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_clusters_with_options_async(
        self,
        request: ecs_20140526_models.DescribeClustersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeClustersResponse:
        """
        @deprecated OpenAPI DescribeClusters is deprecated
        
        @summary 查询集群
        
        @param request: DescribeClustersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeClustersResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeClusters',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeClustersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_clusters(
        self,
        request: ecs_20140526_models.DescribeClustersRequest,
    ) -> ecs_20140526_models.DescribeClustersResponse:
        """
        @deprecated OpenAPI DescribeClusters is deprecated
        
        @summary 查询集群
        
        @param request: DescribeClustersRequest
        @return: DescribeClustersResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_clusters_with_options(request, runtime)

    async def describe_clusters_async(
        self,
        request: ecs_20140526_models.DescribeClustersRequest,
    ) -> ecs_20140526_models.DescribeClustersResponse:
        """
        @deprecated OpenAPI DescribeClusters is deprecated
        
        @summary 查询集群
        
        @param request: DescribeClustersRequest
        @return: DescribeClustersResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_clusters_with_options_async(request, runtime)

    def describe_commands_with_options(
        self,
        request: ecs_20140526_models.DescribeCommandsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeCommandsResponse:
        """
        @summary Queries the Cloud Assistant commands that you created or the common Cloud Assistant commands that Alibaba Cloud provides.
        
        @description ## [](#)Usage notes
        If you specify only `Action` and `RegionId`, all available commands (`CommandId`) that you created in the specified region are queried by default.
        During a paged query, when you call the DescribeCommands operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeCommands operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeCommandsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCommandsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.command_id):
            query['CommandId'] = request.command_id
        if not UtilClient.is_unset(request.content_encoding):
            query['ContentEncoding'] = request.content_encoding
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.latest):
            query['Latest'] = request.latest
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.provider):
            query['Provider'] = request.provider
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCommands',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeCommandsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_commands_with_options_async(
        self,
        request: ecs_20140526_models.DescribeCommandsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeCommandsResponse:
        """
        @summary Queries the Cloud Assistant commands that you created or the common Cloud Assistant commands that Alibaba Cloud provides.
        
        @description ## [](#)Usage notes
        If you specify only `Action` and `RegionId`, all available commands (`CommandId`) that you created in the specified region are queried by default.
        During a paged query, when you call the DescribeCommands operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeCommands operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeCommandsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCommandsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.command_id):
            query['CommandId'] = request.command_id
        if not UtilClient.is_unset(request.content_encoding):
            query['ContentEncoding'] = request.content_encoding
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.latest):
            query['Latest'] = request.latest
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.provider):
            query['Provider'] = request.provider
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCommands',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeCommandsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_commands(
        self,
        request: ecs_20140526_models.DescribeCommandsRequest,
    ) -> ecs_20140526_models.DescribeCommandsResponse:
        """
        @summary Queries the Cloud Assistant commands that you created or the common Cloud Assistant commands that Alibaba Cloud provides.
        
        @description ## [](#)Usage notes
        If you specify only `Action` and `RegionId`, all available commands (`CommandId`) that you created in the specified region are queried by default.
        During a paged query, when you call the DescribeCommands operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeCommands operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeCommandsRequest
        @return: DescribeCommandsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_commands_with_options(request, runtime)

    async def describe_commands_async(
        self,
        request: ecs_20140526_models.DescribeCommandsRequest,
    ) -> ecs_20140526_models.DescribeCommandsResponse:
        """
        @summary Queries the Cloud Assistant commands that you created or the common Cloud Assistant commands that Alibaba Cloud provides.
        
        @description ## [](#)Usage notes
        If you specify only `Action` and `RegionId`, all available commands (`CommandId`) that you created in the specified region are queried by default.
        During a paged query, when you call the DescribeCommands operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeCommands operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeCommandsRequest
        @return: DescribeCommandsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_commands_with_options_async(request, runtime)

    def describe_dedicated_host_auto_renew_with_options(
        self,
        request: ecs_20140526_models.DescribeDedicatedHostAutoRenewRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDedicatedHostAutoRenewResponse:
        """
        @summary Queries the auto-renewal status of one or more subscription dedicated hosts.
        
        @param request: DescribeDedicatedHostAutoRenewRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDedicatedHostAutoRenewResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dedicated_host_ids):
            query['DedicatedHostIds'] = request.dedicated_host_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDedicatedHostAutoRenew',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDedicatedHostAutoRenewResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_dedicated_host_auto_renew_with_options_async(
        self,
        request: ecs_20140526_models.DescribeDedicatedHostAutoRenewRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDedicatedHostAutoRenewResponse:
        """
        @summary Queries the auto-renewal status of one or more subscription dedicated hosts.
        
        @param request: DescribeDedicatedHostAutoRenewRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDedicatedHostAutoRenewResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dedicated_host_ids):
            query['DedicatedHostIds'] = request.dedicated_host_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDedicatedHostAutoRenew',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDedicatedHostAutoRenewResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_dedicated_host_auto_renew(
        self,
        request: ecs_20140526_models.DescribeDedicatedHostAutoRenewRequest,
    ) -> ecs_20140526_models.DescribeDedicatedHostAutoRenewResponse:
        """
        @summary Queries the auto-renewal status of one or more subscription dedicated hosts.
        
        @param request: DescribeDedicatedHostAutoRenewRequest
        @return: DescribeDedicatedHostAutoRenewResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_dedicated_host_auto_renew_with_options(request, runtime)

    async def describe_dedicated_host_auto_renew_async(
        self,
        request: ecs_20140526_models.DescribeDedicatedHostAutoRenewRequest,
    ) -> ecs_20140526_models.DescribeDedicatedHostAutoRenewResponse:
        """
        @summary Queries the auto-renewal status of one or more subscription dedicated hosts.
        
        @param request: DescribeDedicatedHostAutoRenewRequest
        @return: DescribeDedicatedHostAutoRenewResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_dedicated_host_auto_renew_with_options_async(request, runtime)

    def describe_dedicated_host_clusters_with_options(
        self,
        request: ecs_20140526_models.DescribeDedicatedHostClustersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDedicatedHostClustersResponse:
        """
        @summary Queries the details of one or more dedicated host groups.
        
        @description ## [](#)Usage notes
        You can specify multiple request parameters to filter query results. Specified request parameters have logical AND relations. Only the specified parameters are included in the filter conditions. However, if `DedicatedHostClusterIds` is set to an empty JSON array (`[]`), this parameter is regarded as a valid filter condition and an empty result is returned.
        
        @param request: DescribeDedicatedHostClustersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDedicatedHostClustersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dedicated_host_cluster_ids):
            query['DedicatedHostClusterIds'] = request.dedicated_host_cluster_ids
        if not UtilClient.is_unset(request.dedicated_host_cluster_name):
            query['DedicatedHostClusterName'] = request.dedicated_host_cluster_name
        if not UtilClient.is_unset(request.lock_reason):
            query['LockReason'] = request.lock_reason
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDedicatedHostClusters',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDedicatedHostClustersResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_dedicated_host_clusters_with_options_async(
        self,
        request: ecs_20140526_models.DescribeDedicatedHostClustersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDedicatedHostClustersResponse:
        """
        @summary Queries the details of one or more dedicated host groups.
        
        @description ## [](#)Usage notes
        You can specify multiple request parameters to filter query results. Specified request parameters have logical AND relations. Only the specified parameters are included in the filter conditions. However, if `DedicatedHostClusterIds` is set to an empty JSON array (`[]`), this parameter is regarded as a valid filter condition and an empty result is returned.
        
        @param request: DescribeDedicatedHostClustersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDedicatedHostClustersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dedicated_host_cluster_ids):
            query['DedicatedHostClusterIds'] = request.dedicated_host_cluster_ids
        if not UtilClient.is_unset(request.dedicated_host_cluster_name):
            query['DedicatedHostClusterName'] = request.dedicated_host_cluster_name
        if not UtilClient.is_unset(request.lock_reason):
            query['LockReason'] = request.lock_reason
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDedicatedHostClusters',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDedicatedHostClustersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_dedicated_host_clusters(
        self,
        request: ecs_20140526_models.DescribeDedicatedHostClustersRequest,
    ) -> ecs_20140526_models.DescribeDedicatedHostClustersResponse:
        """
        @summary Queries the details of one or more dedicated host groups.
        
        @description ## [](#)Usage notes
        You can specify multiple request parameters to filter query results. Specified request parameters have logical AND relations. Only the specified parameters are included in the filter conditions. However, if `DedicatedHostClusterIds` is set to an empty JSON array (`[]`), this parameter is regarded as a valid filter condition and an empty result is returned.
        
        @param request: DescribeDedicatedHostClustersRequest
        @return: DescribeDedicatedHostClustersResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_dedicated_host_clusters_with_options(request, runtime)

    async def describe_dedicated_host_clusters_async(
        self,
        request: ecs_20140526_models.DescribeDedicatedHostClustersRequest,
    ) -> ecs_20140526_models.DescribeDedicatedHostClustersResponse:
        """
        @summary Queries the details of one or more dedicated host groups.
        
        @description ## [](#)Usage notes
        You can specify multiple request parameters to filter query results. Specified request parameters have logical AND relations. Only the specified parameters are included in the filter conditions. However, if `DedicatedHostClusterIds` is set to an empty JSON array (`[]`), this parameter is regarded as a valid filter condition and an empty result is returned.
        
        @param request: DescribeDedicatedHostClustersRequest
        @return: DescribeDedicatedHostClustersResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_dedicated_host_clusters_with_options_async(request, runtime)

    def describe_dedicated_host_types_with_options(
        self,
        request: ecs_20140526_models.DescribeDedicatedHostTypesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDedicatedHostTypesResponse:
        """
        @summary Queries the details of dedicated host types supported in a region, or the Elastic Compute Service (ECS) instance families supported by a specific dedicated host type.
        
        @param request: DescribeDedicatedHostTypesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDedicatedHostTypesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dedicated_host_type):
            query['DedicatedHostType'] = request.dedicated_host_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.supported_instance_type_family):
            query['SupportedInstanceTypeFamily'] = request.supported_instance_type_family
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDedicatedHostTypes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDedicatedHostTypesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_dedicated_host_types_with_options_async(
        self,
        request: ecs_20140526_models.DescribeDedicatedHostTypesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDedicatedHostTypesResponse:
        """
        @summary Queries the details of dedicated host types supported in a region, or the Elastic Compute Service (ECS) instance families supported by a specific dedicated host type.
        
        @param request: DescribeDedicatedHostTypesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDedicatedHostTypesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dedicated_host_type):
            query['DedicatedHostType'] = request.dedicated_host_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.supported_instance_type_family):
            query['SupportedInstanceTypeFamily'] = request.supported_instance_type_family
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDedicatedHostTypes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDedicatedHostTypesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_dedicated_host_types(
        self,
        request: ecs_20140526_models.DescribeDedicatedHostTypesRequest,
    ) -> ecs_20140526_models.DescribeDedicatedHostTypesResponse:
        """
        @summary Queries the details of dedicated host types supported in a region, or the Elastic Compute Service (ECS) instance families supported by a specific dedicated host type.
        
        @param request: DescribeDedicatedHostTypesRequest
        @return: DescribeDedicatedHostTypesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_dedicated_host_types_with_options(request, runtime)

    async def describe_dedicated_host_types_async(
        self,
        request: ecs_20140526_models.DescribeDedicatedHostTypesRequest,
    ) -> ecs_20140526_models.DescribeDedicatedHostTypesResponse:
        """
        @summary Queries the details of dedicated host types supported in a region, or the Elastic Compute Service (ECS) instance families supported by a specific dedicated host type.
        
        @param request: DescribeDedicatedHostTypesRequest
        @return: DescribeDedicatedHostTypesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_dedicated_host_types_with_options_async(request, runtime)

    def describe_dedicated_hosts_with_options(
        self,
        request: ecs_20140526_models.DescribeDedicatedHostsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDedicatedHostsResponse:
        """
        @summary Queries the details of one or more Dedicated Hosts (DDHs). You can call this operation to obtain information about a DDH, including the physical performance specifications, machine code, service status, and the list of created ECS instances. You can specify relevant parameters, such as DDH IDs, DDH cluster IDs, hostname, and status, to query the required DDH details. This helps you efficiently manage and optimize cloud computing resources.
        
        @description ## [](#)Usage notes
        You can use one of the following methods to query the information about dedicated hosts:
        Specify `DedicatedHostIds` to query the details of specified dedicated hosts.
        Specify `DedicatedHostClusterId` to query the details of dedicated hosts in a dedicated host cluster.
        
        @param request: DescribeDedicatedHostsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDedicatedHostsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dedicated_host_cluster_id):
            query['DedicatedHostClusterId'] = request.dedicated_host_cluster_id
        if not UtilClient.is_unset(request.dedicated_host_ids):
            query['DedicatedHostIds'] = request.dedicated_host_ids
        if not UtilClient.is_unset(request.dedicated_host_name):
            query['DedicatedHostName'] = request.dedicated_host_name
        if not UtilClient.is_unset(request.dedicated_host_type):
            query['DedicatedHostType'] = request.dedicated_host_type
        if not UtilClient.is_unset(request.lock_reason):
            query['LockReason'] = request.lock_reason
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.query_inventory):
            query['QueryInventory'] = request.query_inventory
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.socket_details):
            query['SocketDetails'] = request.socket_details
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDedicatedHosts',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDedicatedHostsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_dedicated_hosts_with_options_async(
        self,
        request: ecs_20140526_models.DescribeDedicatedHostsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDedicatedHostsResponse:
        """
        @summary Queries the details of one or more Dedicated Hosts (DDHs). You can call this operation to obtain information about a DDH, including the physical performance specifications, machine code, service status, and the list of created ECS instances. You can specify relevant parameters, such as DDH IDs, DDH cluster IDs, hostname, and status, to query the required DDH details. This helps you efficiently manage and optimize cloud computing resources.
        
        @description ## [](#)Usage notes
        You can use one of the following methods to query the information about dedicated hosts:
        Specify `DedicatedHostIds` to query the details of specified dedicated hosts.
        Specify `DedicatedHostClusterId` to query the details of dedicated hosts in a dedicated host cluster.
        
        @param request: DescribeDedicatedHostsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDedicatedHostsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dedicated_host_cluster_id):
            query['DedicatedHostClusterId'] = request.dedicated_host_cluster_id
        if not UtilClient.is_unset(request.dedicated_host_ids):
            query['DedicatedHostIds'] = request.dedicated_host_ids
        if not UtilClient.is_unset(request.dedicated_host_name):
            query['DedicatedHostName'] = request.dedicated_host_name
        if not UtilClient.is_unset(request.dedicated_host_type):
            query['DedicatedHostType'] = request.dedicated_host_type
        if not UtilClient.is_unset(request.lock_reason):
            query['LockReason'] = request.lock_reason
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.query_inventory):
            query['QueryInventory'] = request.query_inventory
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.socket_details):
            query['SocketDetails'] = request.socket_details
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDedicatedHosts',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDedicatedHostsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_dedicated_hosts(
        self,
        request: ecs_20140526_models.DescribeDedicatedHostsRequest,
    ) -> ecs_20140526_models.DescribeDedicatedHostsResponse:
        """
        @summary Queries the details of one or more Dedicated Hosts (DDHs). You can call this operation to obtain information about a DDH, including the physical performance specifications, machine code, service status, and the list of created ECS instances. You can specify relevant parameters, such as DDH IDs, DDH cluster IDs, hostname, and status, to query the required DDH details. This helps you efficiently manage and optimize cloud computing resources.
        
        @description ## [](#)Usage notes
        You can use one of the following methods to query the information about dedicated hosts:
        Specify `DedicatedHostIds` to query the details of specified dedicated hosts.
        Specify `DedicatedHostClusterId` to query the details of dedicated hosts in a dedicated host cluster.
        
        @param request: DescribeDedicatedHostsRequest
        @return: DescribeDedicatedHostsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_dedicated_hosts_with_options(request, runtime)

    async def describe_dedicated_hosts_async(
        self,
        request: ecs_20140526_models.DescribeDedicatedHostsRequest,
    ) -> ecs_20140526_models.DescribeDedicatedHostsResponse:
        """
        @summary Queries the details of one or more Dedicated Hosts (DDHs). You can call this operation to obtain information about a DDH, including the physical performance specifications, machine code, service status, and the list of created ECS instances. You can specify relevant parameters, such as DDH IDs, DDH cluster IDs, hostname, and status, to query the required DDH details. This helps you efficiently manage and optimize cloud computing resources.
        
        @description ## [](#)Usage notes
        You can use one of the following methods to query the information about dedicated hosts:
        Specify `DedicatedHostIds` to query the details of specified dedicated hosts.
        Specify `DedicatedHostClusterId` to query the details of dedicated hosts in a dedicated host cluster.
        
        @param request: DescribeDedicatedHostsRequest
        @return: DescribeDedicatedHostsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_dedicated_hosts_with_options_async(request, runtime)

    def describe_deployment_set_supported_instance_type_family_with_options(
        self,
        request: ecs_20140526_models.DescribeDeploymentSetSupportedInstanceTypeFamilyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDeploymentSetSupportedInstanceTypeFamilyResponse:
        """
        @summary Queries the instance families that support different deployment strategies. When you call this operation, specify parameters, such as RegionId and Strategy, in the request.
        
        @description ## [](#)Usage notes
        For information about instance families, see [Overview of instance families](https://help.aliyun.com/document_detail/25378.html).
        
        @param request: DescribeDeploymentSetSupportedInstanceTypeFamilyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDeploymentSetSupportedInstanceTypeFamilyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.strategy):
            query['Strategy'] = request.strategy
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDeploymentSetSupportedInstanceTypeFamily',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDeploymentSetSupportedInstanceTypeFamilyResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_deployment_set_supported_instance_type_family_with_options_async(
        self,
        request: ecs_20140526_models.DescribeDeploymentSetSupportedInstanceTypeFamilyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDeploymentSetSupportedInstanceTypeFamilyResponse:
        """
        @summary Queries the instance families that support different deployment strategies. When you call this operation, specify parameters, such as RegionId and Strategy, in the request.
        
        @description ## [](#)Usage notes
        For information about instance families, see [Overview of instance families](https://help.aliyun.com/document_detail/25378.html).
        
        @param request: DescribeDeploymentSetSupportedInstanceTypeFamilyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDeploymentSetSupportedInstanceTypeFamilyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.strategy):
            query['Strategy'] = request.strategy
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDeploymentSetSupportedInstanceTypeFamily',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDeploymentSetSupportedInstanceTypeFamilyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_deployment_set_supported_instance_type_family(
        self,
        request: ecs_20140526_models.DescribeDeploymentSetSupportedInstanceTypeFamilyRequest,
    ) -> ecs_20140526_models.DescribeDeploymentSetSupportedInstanceTypeFamilyResponse:
        """
        @summary Queries the instance families that support different deployment strategies. When you call this operation, specify parameters, such as RegionId and Strategy, in the request.
        
        @description ## [](#)Usage notes
        For information about instance families, see [Overview of instance families](https://help.aliyun.com/document_detail/25378.html).
        
        @param request: DescribeDeploymentSetSupportedInstanceTypeFamilyRequest
        @return: DescribeDeploymentSetSupportedInstanceTypeFamilyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_deployment_set_supported_instance_type_family_with_options(request, runtime)

    async def describe_deployment_set_supported_instance_type_family_async(
        self,
        request: ecs_20140526_models.DescribeDeploymentSetSupportedInstanceTypeFamilyRequest,
    ) -> ecs_20140526_models.DescribeDeploymentSetSupportedInstanceTypeFamilyResponse:
        """
        @summary Queries the instance families that support different deployment strategies. When you call this operation, specify parameters, such as RegionId and Strategy, in the request.
        
        @description ## [](#)Usage notes
        For information about instance families, see [Overview of instance families](https://help.aliyun.com/document_detail/25378.html).
        
        @param request: DescribeDeploymentSetSupportedInstanceTypeFamilyRequest
        @return: DescribeDeploymentSetSupportedInstanceTypeFamilyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_deployment_set_supported_instance_type_family_with_options_async(request, runtime)

    def describe_deployment_sets_with_options(
        self,
        request: ecs_20140526_models.DescribeDeploymentSetsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDeploymentSetsResponse:
        """
        @summary Queries detailed information about one or more deployment sets.
        
        @param request: DescribeDeploymentSetsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDeploymentSetsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.deployment_set_ids):
            query['DeploymentSetIds'] = request.deployment_set_ids
        if not UtilClient.is_unset(request.deployment_set_name):
            query['DeploymentSetName'] = request.deployment_set_name
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.granularity):
            query['Granularity'] = request.granularity
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.strategy):
            query['Strategy'] = request.strategy
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDeploymentSets',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDeploymentSetsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_deployment_sets_with_options_async(
        self,
        request: ecs_20140526_models.DescribeDeploymentSetsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDeploymentSetsResponse:
        """
        @summary Queries detailed information about one or more deployment sets.
        
        @param request: DescribeDeploymentSetsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDeploymentSetsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.deployment_set_ids):
            query['DeploymentSetIds'] = request.deployment_set_ids
        if not UtilClient.is_unset(request.deployment_set_name):
            query['DeploymentSetName'] = request.deployment_set_name
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.granularity):
            query['Granularity'] = request.granularity
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.strategy):
            query['Strategy'] = request.strategy
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDeploymentSets',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDeploymentSetsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_deployment_sets(
        self,
        request: ecs_20140526_models.DescribeDeploymentSetsRequest,
    ) -> ecs_20140526_models.DescribeDeploymentSetsResponse:
        """
        @summary Queries detailed information about one or more deployment sets.
        
        @param request: DescribeDeploymentSetsRequest
        @return: DescribeDeploymentSetsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_deployment_sets_with_options(request, runtime)

    async def describe_deployment_sets_async(
        self,
        request: ecs_20140526_models.DescribeDeploymentSetsRequest,
    ) -> ecs_20140526_models.DescribeDeploymentSetsResponse:
        """
        @summary Queries detailed information about one or more deployment sets.
        
        @param request: DescribeDeploymentSetsRequest
        @return: DescribeDeploymentSetsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_deployment_sets_with_options_async(request, runtime)

    def describe_diagnostic_metric_sets_with_options(
        self,
        request: ecs_20140526_models.DescribeDiagnosticMetricSetsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDiagnosticMetricSetsResponse:
        """
        @summary Queries diagnostic metric sets.
        
        @param request: DescribeDiagnosticMetricSetsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDiagnosticMetricSetsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.metric_set_ids):
            query['MetricSetIds'] = request.metric_set_ids
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDiagnosticMetricSets',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDiagnosticMetricSetsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_diagnostic_metric_sets_with_options_async(
        self,
        request: ecs_20140526_models.DescribeDiagnosticMetricSetsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDiagnosticMetricSetsResponse:
        """
        @summary Queries diagnostic metric sets.
        
        @param request: DescribeDiagnosticMetricSetsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDiagnosticMetricSetsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.metric_set_ids):
            query['MetricSetIds'] = request.metric_set_ids
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDiagnosticMetricSets',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDiagnosticMetricSetsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_diagnostic_metric_sets(
        self,
        request: ecs_20140526_models.DescribeDiagnosticMetricSetsRequest,
    ) -> ecs_20140526_models.DescribeDiagnosticMetricSetsResponse:
        """
        @summary Queries diagnostic metric sets.
        
        @param request: DescribeDiagnosticMetricSetsRequest
        @return: DescribeDiagnosticMetricSetsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_diagnostic_metric_sets_with_options(request, runtime)

    async def describe_diagnostic_metric_sets_async(
        self,
        request: ecs_20140526_models.DescribeDiagnosticMetricSetsRequest,
    ) -> ecs_20140526_models.DescribeDiagnosticMetricSetsResponse:
        """
        @summary Queries diagnostic metric sets.
        
        @param request: DescribeDiagnosticMetricSetsRequest
        @return: DescribeDiagnosticMetricSetsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_diagnostic_metric_sets_with_options_async(request, runtime)

    def describe_diagnostic_metrics_with_options(
        self,
        request: ecs_20140526_models.DescribeDiagnosticMetricsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDiagnosticMetricsResponse:
        """
        @summary Queries diagnostic metrics.
        
        @param request: DescribeDiagnosticMetricsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDiagnosticMetricsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.metric_ids):
            query['MetricIds'] = request.metric_ids
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDiagnosticMetrics',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDiagnosticMetricsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_diagnostic_metrics_with_options_async(
        self,
        request: ecs_20140526_models.DescribeDiagnosticMetricsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDiagnosticMetricsResponse:
        """
        @summary Queries diagnostic metrics.
        
        @param request: DescribeDiagnosticMetricsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDiagnosticMetricsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.metric_ids):
            query['MetricIds'] = request.metric_ids
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDiagnosticMetrics',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDiagnosticMetricsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_diagnostic_metrics(
        self,
        request: ecs_20140526_models.DescribeDiagnosticMetricsRequest,
    ) -> ecs_20140526_models.DescribeDiagnosticMetricsResponse:
        """
        @summary Queries diagnostic metrics.
        
        @param request: DescribeDiagnosticMetricsRequest
        @return: DescribeDiagnosticMetricsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_diagnostic_metrics_with_options(request, runtime)

    async def describe_diagnostic_metrics_async(
        self,
        request: ecs_20140526_models.DescribeDiagnosticMetricsRequest,
    ) -> ecs_20140526_models.DescribeDiagnosticMetricsResponse:
        """
        @summary Queries diagnostic metrics.
        
        @param request: DescribeDiagnosticMetricsRequest
        @return: DescribeDiagnosticMetricsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_diagnostic_metrics_with_options_async(request, runtime)

    def describe_diagnostic_report_attributes_with_options(
        self,
        request: ecs_20140526_models.DescribeDiagnosticReportAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDiagnosticReportAttributesResponse:
        """
        @summary Queries the details of a diagnostic report.
        
        @param request: DescribeDiagnosticReportAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDiagnosticReportAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.report_id):
            query['ReportId'] = request.report_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDiagnosticReportAttributes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDiagnosticReportAttributesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_diagnostic_report_attributes_with_options_async(
        self,
        request: ecs_20140526_models.DescribeDiagnosticReportAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDiagnosticReportAttributesResponse:
        """
        @summary Queries the details of a diagnostic report.
        
        @param request: DescribeDiagnosticReportAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDiagnosticReportAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.report_id):
            query['ReportId'] = request.report_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDiagnosticReportAttributes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDiagnosticReportAttributesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_diagnostic_report_attributes(
        self,
        request: ecs_20140526_models.DescribeDiagnosticReportAttributesRequest,
    ) -> ecs_20140526_models.DescribeDiagnosticReportAttributesResponse:
        """
        @summary Queries the details of a diagnostic report.
        
        @param request: DescribeDiagnosticReportAttributesRequest
        @return: DescribeDiagnosticReportAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_diagnostic_report_attributes_with_options(request, runtime)

    async def describe_diagnostic_report_attributes_async(
        self,
        request: ecs_20140526_models.DescribeDiagnosticReportAttributesRequest,
    ) -> ecs_20140526_models.DescribeDiagnosticReportAttributesResponse:
        """
        @summary Queries the details of a diagnostic report.
        
        @param request: DescribeDiagnosticReportAttributesRequest
        @return: DescribeDiagnosticReportAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_diagnostic_report_attributes_with_options_async(request, runtime)

    def describe_diagnostic_reports_with_options(
        self,
        request: ecs_20140526_models.DescribeDiagnosticReportsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDiagnosticReportsResponse:
        """
        @summary Queries resource diagnostic reports.
        
        @param request: DescribeDiagnosticReportsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDiagnosticReportsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.report_ids):
            query['ReportIds'] = request.report_ids
        if not UtilClient.is_unset(request.resource_ids):
            query['ResourceIds'] = request.resource_ids
        if not UtilClient.is_unset(request.severity):
            query['Severity'] = request.severity
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDiagnosticReports',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDiagnosticReportsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_diagnostic_reports_with_options_async(
        self,
        request: ecs_20140526_models.DescribeDiagnosticReportsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDiagnosticReportsResponse:
        """
        @summary Queries resource diagnostic reports.
        
        @param request: DescribeDiagnosticReportsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDiagnosticReportsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.report_ids):
            query['ReportIds'] = request.report_ids
        if not UtilClient.is_unset(request.resource_ids):
            query['ResourceIds'] = request.resource_ids
        if not UtilClient.is_unset(request.severity):
            query['Severity'] = request.severity
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDiagnosticReports',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDiagnosticReportsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_diagnostic_reports(
        self,
        request: ecs_20140526_models.DescribeDiagnosticReportsRequest,
    ) -> ecs_20140526_models.DescribeDiagnosticReportsResponse:
        """
        @summary Queries resource diagnostic reports.
        
        @param request: DescribeDiagnosticReportsRequest
        @return: DescribeDiagnosticReportsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_diagnostic_reports_with_options(request, runtime)

    async def describe_diagnostic_reports_async(
        self,
        request: ecs_20140526_models.DescribeDiagnosticReportsRequest,
    ) -> ecs_20140526_models.DescribeDiagnosticReportsResponse:
        """
        @summary Queries resource diagnostic reports.
        
        @param request: DescribeDiagnosticReportsRequest
        @return: DescribeDiagnosticReportsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_diagnostic_reports_with_options_async(request, runtime)

    def describe_disk_default_kmskey_id_with_options(
        self,
        request: ecs_20140526_models.DescribeDiskDefaultKMSKeyIdRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDiskDefaultKMSKeyIdResponse:
        """
        @summary Queries the Key Management Service (KMS) key used by the Account-level Elastic Block Storage (EBS) Default Encryption feature in a region.
        
        @param request: DescribeDiskDefaultKMSKeyIdRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDiskDefaultKMSKeyIdResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDiskDefaultKMSKeyId',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDiskDefaultKMSKeyIdResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_disk_default_kmskey_id_with_options_async(
        self,
        request: ecs_20140526_models.DescribeDiskDefaultKMSKeyIdRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDiskDefaultKMSKeyIdResponse:
        """
        @summary Queries the Key Management Service (KMS) key used by the Account-level Elastic Block Storage (EBS) Default Encryption feature in a region.
        
        @param request: DescribeDiskDefaultKMSKeyIdRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDiskDefaultKMSKeyIdResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDiskDefaultKMSKeyId',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDiskDefaultKMSKeyIdResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_disk_default_kmskey_id(
        self,
        request: ecs_20140526_models.DescribeDiskDefaultKMSKeyIdRequest,
    ) -> ecs_20140526_models.DescribeDiskDefaultKMSKeyIdResponse:
        """
        @summary Queries the Key Management Service (KMS) key used by the Account-level Elastic Block Storage (EBS) Default Encryption feature in a region.
        
        @param request: DescribeDiskDefaultKMSKeyIdRequest
        @return: DescribeDiskDefaultKMSKeyIdResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_disk_default_kmskey_id_with_options(request, runtime)

    async def describe_disk_default_kmskey_id_async(
        self,
        request: ecs_20140526_models.DescribeDiskDefaultKMSKeyIdRequest,
    ) -> ecs_20140526_models.DescribeDiskDefaultKMSKeyIdResponse:
        """
        @summary Queries the Key Management Service (KMS) key used by the Account-level Elastic Block Storage (EBS) Default Encryption feature in a region.
        
        @param request: DescribeDiskDefaultKMSKeyIdRequest
        @return: DescribeDiskDefaultKMSKeyIdResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_disk_default_kmskey_id_with_options_async(request, runtime)

    def describe_disk_encryption_by_default_status_with_options(
        self,
        request: ecs_20140526_models.DescribeDiskEncryptionByDefaultStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDiskEncryptionByDefaultStatusResponse:
        """
        @summary Queries whether account-level default encryption of Elastic Block Storage (EBS) resources is enabled in a region.
        
        @param request: DescribeDiskEncryptionByDefaultStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDiskEncryptionByDefaultStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDiskEncryptionByDefaultStatus',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDiskEncryptionByDefaultStatusResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_disk_encryption_by_default_status_with_options_async(
        self,
        request: ecs_20140526_models.DescribeDiskEncryptionByDefaultStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDiskEncryptionByDefaultStatusResponse:
        """
        @summary Queries whether account-level default encryption of Elastic Block Storage (EBS) resources is enabled in a region.
        
        @param request: DescribeDiskEncryptionByDefaultStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDiskEncryptionByDefaultStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDiskEncryptionByDefaultStatus',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDiskEncryptionByDefaultStatusResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_disk_encryption_by_default_status(
        self,
        request: ecs_20140526_models.DescribeDiskEncryptionByDefaultStatusRequest,
    ) -> ecs_20140526_models.DescribeDiskEncryptionByDefaultStatusResponse:
        """
        @summary Queries whether account-level default encryption of Elastic Block Storage (EBS) resources is enabled in a region.
        
        @param request: DescribeDiskEncryptionByDefaultStatusRequest
        @return: DescribeDiskEncryptionByDefaultStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_disk_encryption_by_default_status_with_options(request, runtime)

    async def describe_disk_encryption_by_default_status_async(
        self,
        request: ecs_20140526_models.DescribeDiskEncryptionByDefaultStatusRequest,
    ) -> ecs_20140526_models.DescribeDiskEncryptionByDefaultStatusResponse:
        """
        @summary Queries whether account-level default encryption of Elastic Block Storage (EBS) resources is enabled in a region.
        
        @param request: DescribeDiskEncryptionByDefaultStatusRequest
        @return: DescribeDiskEncryptionByDefaultStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_disk_encryption_by_default_status_with_options_async(request, runtime)

    def describe_disk_monitor_data_with_options(
        self,
        request: ecs_20140526_models.DescribeDiskMonitorDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDiskMonitorDataResponse:
        """
        @summary Queries the monitoring data of a cloud disk within a specific period of time, such as the read IOPS, write IOPS, read bandwidth (byte/s), write bandwidth (byte/s), read latency (microseconds), and write latency (microseconds).
        
        @description Take note of the following items:
        Monitoring data of only disks that are in the In Use (`In_use`) state can be queried. For more information, see [Disk states](https://help.aliyun.com/document_detail/25689.html).
        *\
        *Note** Some information may be missing from the monitoring data of a disk because the disk is not in the In Use `(In_use)` state and the system cannot obtain the relevant information.
        Up to 400 monitoring data entries can be returned at a time. Make sure that the `TotalCount` value does not exceed 400. The value is calculated by using the following formula: `TotalCount = (EndTime - StartTime)/Period`. If the TotalCount value is greater than 400, the `InvalidParameter.TooManyDataQueried` error is returned.
        You can query the monitoring data in the last 30 days. If the value of `StartTime` is more than 30 days earlier than the current time, an error is returned.
        ## [](#)Sample requests
        For example, you want to query the monitoring data of a cloud disk whose ID is `d-bp14emm68wx98vjk***` in the China (Hangzhou) region every 600 seconds from `2025-02-17T00:00:00Z` to `2025-02-18T10:00:00Z`. Request parameters:
        RegionId:"cn-hangzhou", // Set the region ID to cn-hangzhou, which specifies the China (Hangzhou) region.
        DiskId:"d-bp14emm68wx98vjk***", // Specify the disk ID.
        StartTime:"2025-02-15T00:00:00Z", // Specify the beginning of the time range to query.
        EndTime:"2025-02-17T00:00:00Z", // Specify the end of the time range to query.
        Period:"600", // Specify the interval at which to retrieve the monitoring data.
        
        @param request: DescribeDiskMonitorDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDiskMonitorDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDiskMonitorData',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDiskMonitorDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_disk_monitor_data_with_options_async(
        self,
        request: ecs_20140526_models.DescribeDiskMonitorDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDiskMonitorDataResponse:
        """
        @summary Queries the monitoring data of a cloud disk within a specific period of time, such as the read IOPS, write IOPS, read bandwidth (byte/s), write bandwidth (byte/s), read latency (microseconds), and write latency (microseconds).
        
        @description Take note of the following items:
        Monitoring data of only disks that are in the In Use (`In_use`) state can be queried. For more information, see [Disk states](https://help.aliyun.com/document_detail/25689.html).
        *\
        *Note** Some information may be missing from the monitoring data of a disk because the disk is not in the In Use `(In_use)` state and the system cannot obtain the relevant information.
        Up to 400 monitoring data entries can be returned at a time. Make sure that the `TotalCount` value does not exceed 400. The value is calculated by using the following formula: `TotalCount = (EndTime - StartTime)/Period`. If the TotalCount value is greater than 400, the `InvalidParameter.TooManyDataQueried` error is returned.
        You can query the monitoring data in the last 30 days. If the value of `StartTime` is more than 30 days earlier than the current time, an error is returned.
        ## [](#)Sample requests
        For example, you want to query the monitoring data of a cloud disk whose ID is `d-bp14emm68wx98vjk***` in the China (Hangzhou) region every 600 seconds from `2025-02-17T00:00:00Z` to `2025-02-18T10:00:00Z`. Request parameters:
        RegionId:"cn-hangzhou", // Set the region ID to cn-hangzhou, which specifies the China (Hangzhou) region.
        DiskId:"d-bp14emm68wx98vjk***", // Specify the disk ID.
        StartTime:"2025-02-15T00:00:00Z", // Specify the beginning of the time range to query.
        EndTime:"2025-02-17T00:00:00Z", // Specify the end of the time range to query.
        Period:"600", // Specify the interval at which to retrieve the monitoring data.
        
        @param request: DescribeDiskMonitorDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDiskMonitorDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDiskMonitorData',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDiskMonitorDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_disk_monitor_data(
        self,
        request: ecs_20140526_models.DescribeDiskMonitorDataRequest,
    ) -> ecs_20140526_models.DescribeDiskMonitorDataResponse:
        """
        @summary Queries the monitoring data of a cloud disk within a specific period of time, such as the read IOPS, write IOPS, read bandwidth (byte/s), write bandwidth (byte/s), read latency (microseconds), and write latency (microseconds).
        
        @description Take note of the following items:
        Monitoring data of only disks that are in the In Use (`In_use`) state can be queried. For more information, see [Disk states](https://help.aliyun.com/document_detail/25689.html).
        *\
        *Note** Some information may be missing from the monitoring data of a disk because the disk is not in the In Use `(In_use)` state and the system cannot obtain the relevant information.
        Up to 400 monitoring data entries can be returned at a time. Make sure that the `TotalCount` value does not exceed 400. The value is calculated by using the following formula: `TotalCount = (EndTime - StartTime)/Period`. If the TotalCount value is greater than 400, the `InvalidParameter.TooManyDataQueried` error is returned.
        You can query the monitoring data in the last 30 days. If the value of `StartTime` is more than 30 days earlier than the current time, an error is returned.
        ## [](#)Sample requests
        For example, you want to query the monitoring data of a cloud disk whose ID is `d-bp14emm68wx98vjk***` in the China (Hangzhou) region every 600 seconds from `2025-02-17T00:00:00Z` to `2025-02-18T10:00:00Z`. Request parameters:
        RegionId:"cn-hangzhou", // Set the region ID to cn-hangzhou, which specifies the China (Hangzhou) region.
        DiskId:"d-bp14emm68wx98vjk***", // Specify the disk ID.
        StartTime:"2025-02-15T00:00:00Z", // Specify the beginning of the time range to query.
        EndTime:"2025-02-17T00:00:00Z", // Specify the end of the time range to query.
        Period:"600", // Specify the interval at which to retrieve the monitoring data.
        
        @param request: DescribeDiskMonitorDataRequest
        @return: DescribeDiskMonitorDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_disk_monitor_data_with_options(request, runtime)

    async def describe_disk_monitor_data_async(
        self,
        request: ecs_20140526_models.DescribeDiskMonitorDataRequest,
    ) -> ecs_20140526_models.DescribeDiskMonitorDataResponse:
        """
        @summary Queries the monitoring data of a cloud disk within a specific period of time, such as the read IOPS, write IOPS, read bandwidth (byte/s), write bandwidth (byte/s), read latency (microseconds), and write latency (microseconds).
        
        @description Take note of the following items:
        Monitoring data of only disks that are in the In Use (`In_use`) state can be queried. For more information, see [Disk states](https://help.aliyun.com/document_detail/25689.html).
        *\
        *Note** Some information may be missing from the monitoring data of a disk because the disk is not in the In Use `(In_use)` state and the system cannot obtain the relevant information.
        Up to 400 monitoring data entries can be returned at a time. Make sure that the `TotalCount` value does not exceed 400. The value is calculated by using the following formula: `TotalCount = (EndTime - StartTime)/Period`. If the TotalCount value is greater than 400, the `InvalidParameter.TooManyDataQueried` error is returned.
        You can query the monitoring data in the last 30 days. If the value of `StartTime` is more than 30 days earlier than the current time, an error is returned.
        ## [](#)Sample requests
        For example, you want to query the monitoring data of a cloud disk whose ID is `d-bp14emm68wx98vjk***` in the China (Hangzhou) region every 600 seconds from `2025-02-17T00:00:00Z` to `2025-02-18T10:00:00Z`. Request parameters:
        RegionId:"cn-hangzhou", // Set the region ID to cn-hangzhou, which specifies the China (Hangzhou) region.
        DiskId:"d-bp14emm68wx98vjk***", // Specify the disk ID.
        StartTime:"2025-02-15T00:00:00Z", // Specify the beginning of the time range to query.
        EndTime:"2025-02-17T00:00:00Z", // Specify the end of the time range to query.
        Period:"600", // Specify the interval at which to retrieve the monitoring data.
        
        @param request: DescribeDiskMonitorDataRequest
        @return: DescribeDiskMonitorDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_disk_monitor_data_with_options_async(request, runtime)

    def describe_disks_with_options(
        self,
        request: ecs_20140526_models.DescribeDisksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDisksResponse:
        """
        @summary Queries block storage devices that you created, including cloud disks, local disks, and elastic ephemeral disks.
        
        @description    You can specify multiple request parameters such as `RegionId`, `ZoneId`, `DiskIds`, and `InstanceId` as filters. The specified parameters are evaluated by using the "AND" operator. If you specify more than one filter, the records that match all filters are returned.
        The value of `DiskIds` is a JSON array. If you do not specify DiskIds, the parameter is not used as a filter. If you set `DiskIds` to an empty JSON array, the parameter is regarded as a valid filter, and an empty result is returned.
        Token-based paged query: Use `NextToken` to configure the query token. Set the value to the `NextToken` value returned in the previous call to the DescribeDisks operation. Then, use `MaxResults` to specify the maximum number of entries to return on each page.
        You can attach a disk for which the multi-attach feature is enabled to multiple instances. You can query the attachment information of the disk based on the `Attachment` values in the response.
        When you call the API operation by using Alibaba Cloud CLI, you must specify request parameter values of different data types in the required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        
        @param request: DescribeDisksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDisksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.additional_attributes):
            query['AdditionalAttributes'] = request.additional_attributes
        if not UtilClient.is_unset(request.auto_snapshot_policy_id):
            query['AutoSnapshotPolicyId'] = request.auto_snapshot_policy_id
        if not UtilClient.is_unset(request.category):
            query['Category'] = request.category
        if not UtilClient.is_unset(request.delete_auto_snapshot):
            query['DeleteAutoSnapshot'] = request.delete_auto_snapshot
        if not UtilClient.is_unset(request.delete_with_instance):
            query['DeleteWithInstance'] = request.delete_with_instance
        if not UtilClient.is_unset(request.disk_charge_type):
            query['DiskChargeType'] = request.disk_charge_type
        if not UtilClient.is_unset(request.disk_ids):
            query['DiskIds'] = request.disk_ids
        if not UtilClient.is_unset(request.disk_name):
            query['DiskName'] = request.disk_name
        if not UtilClient.is_unset(request.disk_type):
            query['DiskType'] = request.disk_type
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.enable_auto_snapshot):
            query['EnableAutoSnapshot'] = request.enable_auto_snapshot
        if not UtilClient.is_unset(request.enable_automated_snapshot_policy):
            query['EnableAutomatedSnapshotPolicy'] = request.enable_automated_snapshot_policy
        if not UtilClient.is_unset(request.enable_shared):
            query['EnableShared'] = request.enable_shared
        if not UtilClient.is_unset(request.encrypted):
            query['Encrypted'] = request.encrypted
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.kmskey_id):
            query['KMSKeyId'] = request.kmskey_id
        if not UtilClient.is_unset(request.lock_reason):
            query['LockReason'] = request.lock_reason
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.multi_attach):
            query['MultiAttach'] = request.multi_attach
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.portable):
            query['Portable'] = request.portable
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDisks',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDisksResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_disks_with_options_async(
        self,
        request: ecs_20140526_models.DescribeDisksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDisksResponse:
        """
        @summary Queries block storage devices that you created, including cloud disks, local disks, and elastic ephemeral disks.
        
        @description    You can specify multiple request parameters such as `RegionId`, `ZoneId`, `DiskIds`, and `InstanceId` as filters. The specified parameters are evaluated by using the "AND" operator. If you specify more than one filter, the records that match all filters are returned.
        The value of `DiskIds` is a JSON array. If you do not specify DiskIds, the parameter is not used as a filter. If you set `DiskIds` to an empty JSON array, the parameter is regarded as a valid filter, and an empty result is returned.
        Token-based paged query: Use `NextToken` to configure the query token. Set the value to the `NextToken` value returned in the previous call to the DescribeDisks operation. Then, use `MaxResults` to specify the maximum number of entries to return on each page.
        You can attach a disk for which the multi-attach feature is enabled to multiple instances. You can query the attachment information of the disk based on the `Attachment` values in the response.
        When you call the API operation by using Alibaba Cloud CLI, you must specify request parameter values of different data types in the required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        
        @param request: DescribeDisksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDisksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.additional_attributes):
            query['AdditionalAttributes'] = request.additional_attributes
        if not UtilClient.is_unset(request.auto_snapshot_policy_id):
            query['AutoSnapshotPolicyId'] = request.auto_snapshot_policy_id
        if not UtilClient.is_unset(request.category):
            query['Category'] = request.category
        if not UtilClient.is_unset(request.delete_auto_snapshot):
            query['DeleteAutoSnapshot'] = request.delete_auto_snapshot
        if not UtilClient.is_unset(request.delete_with_instance):
            query['DeleteWithInstance'] = request.delete_with_instance
        if not UtilClient.is_unset(request.disk_charge_type):
            query['DiskChargeType'] = request.disk_charge_type
        if not UtilClient.is_unset(request.disk_ids):
            query['DiskIds'] = request.disk_ids
        if not UtilClient.is_unset(request.disk_name):
            query['DiskName'] = request.disk_name
        if not UtilClient.is_unset(request.disk_type):
            query['DiskType'] = request.disk_type
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.enable_auto_snapshot):
            query['EnableAutoSnapshot'] = request.enable_auto_snapshot
        if not UtilClient.is_unset(request.enable_automated_snapshot_policy):
            query['EnableAutomatedSnapshotPolicy'] = request.enable_automated_snapshot_policy
        if not UtilClient.is_unset(request.enable_shared):
            query['EnableShared'] = request.enable_shared
        if not UtilClient.is_unset(request.encrypted):
            query['Encrypted'] = request.encrypted
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.kmskey_id):
            query['KMSKeyId'] = request.kmskey_id
        if not UtilClient.is_unset(request.lock_reason):
            query['LockReason'] = request.lock_reason
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.multi_attach):
            query['MultiAttach'] = request.multi_attach
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.portable):
            query['Portable'] = request.portable
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDisks',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDisksResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_disks(
        self,
        request: ecs_20140526_models.DescribeDisksRequest,
    ) -> ecs_20140526_models.DescribeDisksResponse:
        """
        @summary Queries block storage devices that you created, including cloud disks, local disks, and elastic ephemeral disks.
        
        @description    You can specify multiple request parameters such as `RegionId`, `ZoneId`, `DiskIds`, and `InstanceId` as filters. The specified parameters are evaluated by using the "AND" operator. If you specify more than one filter, the records that match all filters are returned.
        The value of `DiskIds` is a JSON array. If you do not specify DiskIds, the parameter is not used as a filter. If you set `DiskIds` to an empty JSON array, the parameter is regarded as a valid filter, and an empty result is returned.
        Token-based paged query: Use `NextToken` to configure the query token. Set the value to the `NextToken` value returned in the previous call to the DescribeDisks operation. Then, use `MaxResults` to specify the maximum number of entries to return on each page.
        You can attach a disk for which the multi-attach feature is enabled to multiple instances. You can query the attachment information of the disk based on the `Attachment` values in the response.
        When you call the API operation by using Alibaba Cloud CLI, you must specify request parameter values of different data types in the required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        
        @param request: DescribeDisksRequest
        @return: DescribeDisksResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_disks_with_options(request, runtime)

    async def describe_disks_async(
        self,
        request: ecs_20140526_models.DescribeDisksRequest,
    ) -> ecs_20140526_models.DescribeDisksResponse:
        """
        @summary Queries block storage devices that you created, including cloud disks, local disks, and elastic ephemeral disks.
        
        @description    You can specify multiple request parameters such as `RegionId`, `ZoneId`, `DiskIds`, and `InstanceId` as filters. The specified parameters are evaluated by using the "AND" operator. If you specify more than one filter, the records that match all filters are returned.
        The value of `DiskIds` is a JSON array. If you do not specify DiskIds, the parameter is not used as a filter. If you set `DiskIds` to an empty JSON array, the parameter is regarded as a valid filter, and an empty result is returned.
        Token-based paged query: Use `NextToken` to configure the query token. Set the value to the `NextToken` value returned in the previous call to the DescribeDisks operation. Then, use `MaxResults` to specify the maximum number of entries to return on each page.
        You can attach a disk for which the multi-attach feature is enabled to multiple instances. You can query the attachment information of the disk based on the `Attachment` values in the response.
        When you call the API operation by using Alibaba Cloud CLI, you must specify request parameter values of different data types in the required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        
        @param request: DescribeDisksRequest
        @return: DescribeDisksResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_disks_with_options_async(request, runtime)

    def describe_disks_full_status_with_options(
        self,
        request: ecs_20140526_models.DescribeDisksFullStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDisksFullStatusResponse:
        """
        @summary Queries the full status information about one or more Elastic Block Storage (EBS) devices.
        
        @description    The full status information about an EBS device includes the lifecycle status specified by the `Status` parameter, health status specified by the `HealthStatus` parameter, and event type specified by the `EventType` parameter of the EBS device. You can filter the results based on these parameters.
        The release time, scheduled execution time, and actual execution time of each EBS device event are identical. If you specify a period of time by using the `EventTime.Start` and `EventTime.End` parameters, all events that occurred within this period are queried. You can query events that occurred within the last seven days.
        
        @param request: DescribeDisksFullStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDisksFullStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.event_id):
            query['EventId'] = request.event_id
        if not UtilClient.is_unset(request.event_type):
            query['EventType'] = request.event_type
        if not UtilClient.is_unset(request.health_status):
            query['HealthStatus'] = request.health_status
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.event_time):
            query['EventTime'] = request.event_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDisksFullStatus',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDisksFullStatusResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_disks_full_status_with_options_async(
        self,
        request: ecs_20140526_models.DescribeDisksFullStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeDisksFullStatusResponse:
        """
        @summary Queries the full status information about one or more Elastic Block Storage (EBS) devices.
        
        @description    The full status information about an EBS device includes the lifecycle status specified by the `Status` parameter, health status specified by the `HealthStatus` parameter, and event type specified by the `EventType` parameter of the EBS device. You can filter the results based on these parameters.
        The release time, scheduled execution time, and actual execution time of each EBS device event are identical. If you specify a period of time by using the `EventTime.Start` and `EventTime.End` parameters, all events that occurred within this period are queried. You can query events that occurred within the last seven days.
        
        @param request: DescribeDisksFullStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDisksFullStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.event_id):
            query['EventId'] = request.event_id
        if not UtilClient.is_unset(request.event_type):
            query['EventType'] = request.event_type
        if not UtilClient.is_unset(request.health_status):
            query['HealthStatus'] = request.health_status
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.event_time):
            query['EventTime'] = request.event_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDisksFullStatus',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeDisksFullStatusResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_disks_full_status(
        self,
        request: ecs_20140526_models.DescribeDisksFullStatusRequest,
    ) -> ecs_20140526_models.DescribeDisksFullStatusResponse:
        """
        @summary Queries the full status information about one or more Elastic Block Storage (EBS) devices.
        
        @description    The full status information about an EBS device includes the lifecycle status specified by the `Status` parameter, health status specified by the `HealthStatus` parameter, and event type specified by the `EventType` parameter of the EBS device. You can filter the results based on these parameters.
        The release time, scheduled execution time, and actual execution time of each EBS device event are identical. If you specify a period of time by using the `EventTime.Start` and `EventTime.End` parameters, all events that occurred within this period are queried. You can query events that occurred within the last seven days.
        
        @param request: DescribeDisksFullStatusRequest
        @return: DescribeDisksFullStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_disks_full_status_with_options(request, runtime)

    async def describe_disks_full_status_async(
        self,
        request: ecs_20140526_models.DescribeDisksFullStatusRequest,
    ) -> ecs_20140526_models.DescribeDisksFullStatusResponse:
        """
        @summary Queries the full status information about one or more Elastic Block Storage (EBS) devices.
        
        @description    The full status information about an EBS device includes the lifecycle status specified by the `Status` parameter, health status specified by the `HealthStatus` parameter, and event type specified by the `EventType` parameter of the EBS device. You can filter the results based on these parameters.
        The release time, scheduled execution time, and actual execution time of each EBS device event are identical. If you specify a period of time by using the `EventTime.Start` and `EventTime.End` parameters, all events that occurred within this period are queried. You can query events that occurred within the last seven days.
        
        @param request: DescribeDisksFullStatusRequest
        @return: DescribeDisksFullStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_disks_full_status_with_options_async(request, runtime)

    def describe_eip_addresses_with_options(
        self,
        request: ecs_20140526_models.DescribeEipAddressesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeEipAddressesResponse:
        """
        @deprecated OpenAPI DescribeEipAddresses is deprecated, please use Vpc::2016-04-28::DescribeEipAddresses instead.
        
        @summary DescribeEipAddresses
        
        @param request: DescribeEipAddressesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEipAddressesResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.associated_instance_id):
            query['AssociatedInstanceId'] = request.associated_instance_id
        if not UtilClient.is_unset(request.associated_instance_type):
            query['AssociatedInstanceType'] = request.associated_instance_type
        if not UtilClient.is_unset(request.charge_type):
            query['ChargeType'] = request.charge_type
        if not UtilClient.is_unset(request.eip_address):
            query['EipAddress'] = request.eip_address
        if not UtilClient.is_unset(request.isp):
            query['ISP'] = request.isp
        if not UtilClient.is_unset(request.lock_reason):
            query['LockReason'] = request.lock_reason
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEipAddresses',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeEipAddressesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_eip_addresses_with_options_async(
        self,
        request: ecs_20140526_models.DescribeEipAddressesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeEipAddressesResponse:
        """
        @deprecated OpenAPI DescribeEipAddresses is deprecated, please use Vpc::2016-04-28::DescribeEipAddresses instead.
        
        @summary DescribeEipAddresses
        
        @param request: DescribeEipAddressesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEipAddressesResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.associated_instance_id):
            query['AssociatedInstanceId'] = request.associated_instance_id
        if not UtilClient.is_unset(request.associated_instance_type):
            query['AssociatedInstanceType'] = request.associated_instance_type
        if not UtilClient.is_unset(request.charge_type):
            query['ChargeType'] = request.charge_type
        if not UtilClient.is_unset(request.eip_address):
            query['EipAddress'] = request.eip_address
        if not UtilClient.is_unset(request.isp):
            query['ISP'] = request.isp
        if not UtilClient.is_unset(request.lock_reason):
            query['LockReason'] = request.lock_reason
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEipAddresses',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeEipAddressesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_eip_addresses(
        self,
        request: ecs_20140526_models.DescribeEipAddressesRequest,
    ) -> ecs_20140526_models.DescribeEipAddressesResponse:
        """
        @deprecated OpenAPI DescribeEipAddresses is deprecated, please use Vpc::2016-04-28::DescribeEipAddresses instead.
        
        @summary DescribeEipAddresses
        
        @param request: DescribeEipAddressesRequest
        @return: DescribeEipAddressesResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_eip_addresses_with_options(request, runtime)

    async def describe_eip_addresses_async(
        self,
        request: ecs_20140526_models.DescribeEipAddressesRequest,
    ) -> ecs_20140526_models.DescribeEipAddressesResponse:
        """
        @deprecated OpenAPI DescribeEipAddresses is deprecated, please use Vpc::2016-04-28::DescribeEipAddresses instead.
        
        @summary DescribeEipAddresses
        
        @param request: DescribeEipAddressesRequest
        @return: DescribeEipAddressesResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_eip_addresses_with_options_async(request, runtime)

    def describe_eip_monitor_data_with_options(
        self,
        request: ecs_20140526_models.DescribeEipMonitorDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeEipMonitorDataResponse:
        """
        @deprecated OpenAPI DescribeEipMonitorData is deprecated, please use Vpc::2016-04-28::DescribeEipMonitorData instead.
        
        @summary DescribeEipMonitorData
        
        @param request: DescribeEipMonitorDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEipMonitorDataResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEipMonitorData',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeEipMonitorDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_eip_monitor_data_with_options_async(
        self,
        request: ecs_20140526_models.DescribeEipMonitorDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeEipMonitorDataResponse:
        """
        @deprecated OpenAPI DescribeEipMonitorData is deprecated, please use Vpc::2016-04-28::DescribeEipMonitorData instead.
        
        @summary DescribeEipMonitorData
        
        @param request: DescribeEipMonitorDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEipMonitorDataResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEipMonitorData',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeEipMonitorDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_eip_monitor_data(
        self,
        request: ecs_20140526_models.DescribeEipMonitorDataRequest,
    ) -> ecs_20140526_models.DescribeEipMonitorDataResponse:
        """
        @deprecated OpenAPI DescribeEipMonitorData is deprecated, please use Vpc::2016-04-28::DescribeEipMonitorData instead.
        
        @summary DescribeEipMonitorData
        
        @param request: DescribeEipMonitorDataRequest
        @return: DescribeEipMonitorDataResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_eip_monitor_data_with_options(request, runtime)

    async def describe_eip_monitor_data_async(
        self,
        request: ecs_20140526_models.DescribeEipMonitorDataRequest,
    ) -> ecs_20140526_models.DescribeEipMonitorDataResponse:
        """
        @deprecated OpenAPI DescribeEipMonitorData is deprecated, please use Vpc::2016-04-28::DescribeEipMonitorData instead.
        
        @summary DescribeEipMonitorData
        
        @param request: DescribeEipMonitorDataRequest
        @return: DescribeEipMonitorDataResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_eip_monitor_data_with_options_async(request, runtime)

    def describe_elasticity_assurance_auto_renew_attribute_with_options(
        self,
        request: ecs_20140526_models.DescribeElasticityAssuranceAutoRenewAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeElasticityAssuranceAutoRenewAttributeResponse:
        """
        @summary Queries the auto-renewal attribute of elasticity assurances.
        
        @param request: DescribeElasticityAssuranceAutoRenewAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeElasticityAssuranceAutoRenewAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeElasticityAssuranceAutoRenewAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeElasticityAssuranceAutoRenewAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_elasticity_assurance_auto_renew_attribute_with_options_async(
        self,
        request: ecs_20140526_models.DescribeElasticityAssuranceAutoRenewAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeElasticityAssuranceAutoRenewAttributeResponse:
        """
        @summary Queries the auto-renewal attribute of elasticity assurances.
        
        @param request: DescribeElasticityAssuranceAutoRenewAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeElasticityAssuranceAutoRenewAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeElasticityAssuranceAutoRenewAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeElasticityAssuranceAutoRenewAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_elasticity_assurance_auto_renew_attribute(
        self,
        request: ecs_20140526_models.DescribeElasticityAssuranceAutoRenewAttributeRequest,
    ) -> ecs_20140526_models.DescribeElasticityAssuranceAutoRenewAttributeResponse:
        """
        @summary Queries the auto-renewal attribute of elasticity assurances.
        
        @param request: DescribeElasticityAssuranceAutoRenewAttributeRequest
        @return: DescribeElasticityAssuranceAutoRenewAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_elasticity_assurance_auto_renew_attribute_with_options(request, runtime)

    async def describe_elasticity_assurance_auto_renew_attribute_async(
        self,
        request: ecs_20140526_models.DescribeElasticityAssuranceAutoRenewAttributeRequest,
    ) -> ecs_20140526_models.DescribeElasticityAssuranceAutoRenewAttributeResponse:
        """
        @summary Queries the auto-renewal attribute of elasticity assurances.
        
        @param request: DescribeElasticityAssuranceAutoRenewAttributeRequest
        @return: DescribeElasticityAssuranceAutoRenewAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_elasticity_assurance_auto_renew_attribute_with_options_async(request, runtime)

    def describe_elasticity_assurance_instances_with_options(
        self,
        request: ecs_20140526_models.DescribeElasticityAssuranceInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeElasticityAssuranceInstancesResponse:
        """
        @summary Queries the running Elastic Compute Service (ECS) instances that use an elasticity assurance.
        
        @description When an elasticity assurance expires, data about the association between the instances and the private pool generated by the elasticity assurance becomes invalid. When you call this operation to query the expired elasticity assurance, no value is returned.
        
        @param request: DescribeElasticityAssuranceInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeElasticityAssuranceInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeElasticityAssuranceInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeElasticityAssuranceInstancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_elasticity_assurance_instances_with_options_async(
        self,
        request: ecs_20140526_models.DescribeElasticityAssuranceInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeElasticityAssuranceInstancesResponse:
        """
        @summary Queries the running Elastic Compute Service (ECS) instances that use an elasticity assurance.
        
        @description When an elasticity assurance expires, data about the association between the instances and the private pool generated by the elasticity assurance becomes invalid. When you call this operation to query the expired elasticity assurance, no value is returned.
        
        @param request: DescribeElasticityAssuranceInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeElasticityAssuranceInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeElasticityAssuranceInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeElasticityAssuranceInstancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_elasticity_assurance_instances(
        self,
        request: ecs_20140526_models.DescribeElasticityAssuranceInstancesRequest,
    ) -> ecs_20140526_models.DescribeElasticityAssuranceInstancesResponse:
        """
        @summary Queries the running Elastic Compute Service (ECS) instances that use an elasticity assurance.
        
        @description When an elasticity assurance expires, data about the association between the instances and the private pool generated by the elasticity assurance becomes invalid. When you call this operation to query the expired elasticity assurance, no value is returned.
        
        @param request: DescribeElasticityAssuranceInstancesRequest
        @return: DescribeElasticityAssuranceInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_elasticity_assurance_instances_with_options(request, runtime)

    async def describe_elasticity_assurance_instances_async(
        self,
        request: ecs_20140526_models.DescribeElasticityAssuranceInstancesRequest,
    ) -> ecs_20140526_models.DescribeElasticityAssuranceInstancesResponse:
        """
        @summary Queries the running Elastic Compute Service (ECS) instances that use an elasticity assurance.
        
        @description When an elasticity assurance expires, data about the association between the instances and the private pool generated by the elasticity assurance becomes invalid. When you call this operation to query the expired elasticity assurance, no value is returned.
        
        @param request: DescribeElasticityAssuranceInstancesRequest
        @return: DescribeElasticityAssuranceInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_elasticity_assurance_instances_with_options_async(request, runtime)

    def describe_elasticity_assurances_with_options(
        self,
        request: ecs_20140526_models.DescribeElasticityAssurancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeElasticityAssurancesResponse:
        """
        @summary Queries the details of elasticity assurances.
        
        @param request: DescribeElasticityAssurancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeElasticityAssurancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.package_type):
            query['PackageType'] = request.package_type
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeElasticityAssurances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeElasticityAssurancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_elasticity_assurances_with_options_async(
        self,
        request: ecs_20140526_models.DescribeElasticityAssurancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeElasticityAssurancesResponse:
        """
        @summary Queries the details of elasticity assurances.
        
        @param request: DescribeElasticityAssurancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeElasticityAssurancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.package_type):
            query['PackageType'] = request.package_type
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeElasticityAssurances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeElasticityAssurancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_elasticity_assurances(
        self,
        request: ecs_20140526_models.DescribeElasticityAssurancesRequest,
    ) -> ecs_20140526_models.DescribeElasticityAssurancesResponse:
        """
        @summary Queries the details of elasticity assurances.
        
        @param request: DescribeElasticityAssurancesRequest
        @return: DescribeElasticityAssurancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_elasticity_assurances_with_options(request, runtime)

    async def describe_elasticity_assurances_async(
        self,
        request: ecs_20140526_models.DescribeElasticityAssurancesRequest,
    ) -> ecs_20140526_models.DescribeElasticityAssurancesResponse:
        """
        @summary Queries the details of elasticity assurances.
        
        @param request: DescribeElasticityAssurancesRequest
        @return: DescribeElasticityAssurancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_elasticity_assurances_with_options_async(request, runtime)

    def describe_eni_monitor_data_with_options(
        self,
        request: ecs_20140526_models.DescribeEniMonitorDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeEniMonitorDataResponse:
        """
        @summary Queries the monitoring data of a secondary elastic network interface (ENI) over a specific period of time.
        
        @description ## [](#)Usage notes
        The monitoring data of a secondary ENI includes the amount of traffic sent and received over the internal network, the number of packets sent and received by the secondary ENI, and the number of sent and received packets that are dropped by the secondary ENI. Specific information may be missing from the returned monitoring data. This may be because the system cannot obtain the relevant information. For example, if the instance to which the secondary ENI is attached is in the Stopped state or if the secondary ENI is not attached to an instance and is in the Available state, the monitoring data of the secondary ENI cannot be obtained. Take note of the following items:
        Up to 400 monitoring data entries can be returned at a time. Make sure that the `TotalCount` value does not exceed 400. The value is calculated by using the following formula: `TotalCount = (EndTime - StartTime)/Period`. If the TotalCount value is greater than 400, the `InvalidParameter.TooManyDataQueried` error is returned.
        You can query the monitoring data in the last 30 days. If the value of `StartTime` is more than 30 days earlier than the current time, an error is returned.
        
        @param request: DescribeEniMonitorDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEniMonitorDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.eni_id):
            query['EniId'] = request.eni_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEniMonitorData',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeEniMonitorDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_eni_monitor_data_with_options_async(
        self,
        request: ecs_20140526_models.DescribeEniMonitorDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeEniMonitorDataResponse:
        """
        @summary Queries the monitoring data of a secondary elastic network interface (ENI) over a specific period of time.
        
        @description ## [](#)Usage notes
        The monitoring data of a secondary ENI includes the amount of traffic sent and received over the internal network, the number of packets sent and received by the secondary ENI, and the number of sent and received packets that are dropped by the secondary ENI. Specific information may be missing from the returned monitoring data. This may be because the system cannot obtain the relevant information. For example, if the instance to which the secondary ENI is attached is in the Stopped state or if the secondary ENI is not attached to an instance and is in the Available state, the monitoring data of the secondary ENI cannot be obtained. Take note of the following items:
        Up to 400 monitoring data entries can be returned at a time. Make sure that the `TotalCount` value does not exceed 400. The value is calculated by using the following formula: `TotalCount = (EndTime - StartTime)/Period`. If the TotalCount value is greater than 400, the `InvalidParameter.TooManyDataQueried` error is returned.
        You can query the monitoring data in the last 30 days. If the value of `StartTime` is more than 30 days earlier than the current time, an error is returned.
        
        @param request: DescribeEniMonitorDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEniMonitorDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.eni_id):
            query['EniId'] = request.eni_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEniMonitorData',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeEniMonitorDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_eni_monitor_data(
        self,
        request: ecs_20140526_models.DescribeEniMonitorDataRequest,
    ) -> ecs_20140526_models.DescribeEniMonitorDataResponse:
        """
        @summary Queries the monitoring data of a secondary elastic network interface (ENI) over a specific period of time.
        
        @description ## [](#)Usage notes
        The monitoring data of a secondary ENI includes the amount of traffic sent and received over the internal network, the number of packets sent and received by the secondary ENI, and the number of sent and received packets that are dropped by the secondary ENI. Specific information may be missing from the returned monitoring data. This may be because the system cannot obtain the relevant information. For example, if the instance to which the secondary ENI is attached is in the Stopped state or if the secondary ENI is not attached to an instance and is in the Available state, the monitoring data of the secondary ENI cannot be obtained. Take note of the following items:
        Up to 400 monitoring data entries can be returned at a time. Make sure that the `TotalCount` value does not exceed 400. The value is calculated by using the following formula: `TotalCount = (EndTime - StartTime)/Period`. If the TotalCount value is greater than 400, the `InvalidParameter.TooManyDataQueried` error is returned.
        You can query the monitoring data in the last 30 days. If the value of `StartTime` is more than 30 days earlier than the current time, an error is returned.
        
        @param request: DescribeEniMonitorDataRequest
        @return: DescribeEniMonitorDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_eni_monitor_data_with_options(request, runtime)

    async def describe_eni_monitor_data_async(
        self,
        request: ecs_20140526_models.DescribeEniMonitorDataRequest,
    ) -> ecs_20140526_models.DescribeEniMonitorDataResponse:
        """
        @summary Queries the monitoring data of a secondary elastic network interface (ENI) over a specific period of time.
        
        @description ## [](#)Usage notes
        The monitoring data of a secondary ENI includes the amount of traffic sent and received over the internal network, the number of packets sent and received by the secondary ENI, and the number of sent and received packets that are dropped by the secondary ENI. Specific information may be missing from the returned monitoring data. This may be because the system cannot obtain the relevant information. For example, if the instance to which the secondary ENI is attached is in the Stopped state or if the secondary ENI is not attached to an instance and is in the Available state, the monitoring data of the secondary ENI cannot be obtained. Take note of the following items:
        Up to 400 monitoring data entries can be returned at a time. Make sure that the `TotalCount` value does not exceed 400. The value is calculated by using the following formula: `TotalCount = (EndTime - StartTime)/Period`. If the TotalCount value is greater than 400, the `InvalidParameter.TooManyDataQueried` error is returned.
        You can query the monitoring data in the last 30 days. If the value of `StartTime` is more than 30 days earlier than the current time, an error is returned.
        
        @param request: DescribeEniMonitorDataRequest
        @return: DescribeEniMonitorDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_eni_monitor_data_with_options_async(request, runtime)

    def describe_forward_table_entries_with_options(
        self,
        request: ecs_20140526_models.DescribeForwardTableEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeForwardTableEntriesResponse:
        """
        @deprecated OpenAPI DescribeForwardTableEntries is deprecated, please use Vpc::2016-04-28::DescribeForwardTableEntries instead.
        
        @summary DescribeForwardTableEntries
        
        @param request: DescribeForwardTableEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeForwardTableEntriesResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.forward_entry_id):
            query['ForwardEntryId'] = request.forward_entry_id
        if not UtilClient.is_unset(request.forward_table_id):
            query['ForwardTableId'] = request.forward_table_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeForwardTableEntries',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeForwardTableEntriesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_forward_table_entries_with_options_async(
        self,
        request: ecs_20140526_models.DescribeForwardTableEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeForwardTableEntriesResponse:
        """
        @deprecated OpenAPI DescribeForwardTableEntries is deprecated, please use Vpc::2016-04-28::DescribeForwardTableEntries instead.
        
        @summary DescribeForwardTableEntries
        
        @param request: DescribeForwardTableEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeForwardTableEntriesResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.forward_entry_id):
            query['ForwardEntryId'] = request.forward_entry_id
        if not UtilClient.is_unset(request.forward_table_id):
            query['ForwardTableId'] = request.forward_table_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeForwardTableEntries',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeForwardTableEntriesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_forward_table_entries(
        self,
        request: ecs_20140526_models.DescribeForwardTableEntriesRequest,
    ) -> ecs_20140526_models.DescribeForwardTableEntriesResponse:
        """
        @deprecated OpenAPI DescribeForwardTableEntries is deprecated, please use Vpc::2016-04-28::DescribeForwardTableEntries instead.
        
        @summary DescribeForwardTableEntries
        
        @param request: DescribeForwardTableEntriesRequest
        @return: DescribeForwardTableEntriesResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_forward_table_entries_with_options(request, runtime)

    async def describe_forward_table_entries_async(
        self,
        request: ecs_20140526_models.DescribeForwardTableEntriesRequest,
    ) -> ecs_20140526_models.DescribeForwardTableEntriesResponse:
        """
        @deprecated OpenAPI DescribeForwardTableEntries is deprecated, please use Vpc::2016-04-28::DescribeForwardTableEntries instead.
        
        @summary DescribeForwardTableEntries
        
        @param request: DescribeForwardTableEntriesRequest
        @return: DescribeForwardTableEntriesResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_forward_table_entries_with_options_async(request, runtime)

    def describe_ha_vips_with_options(
        self,
        request: ecs_20140526_models.DescribeHaVipsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeHaVipsResponse:
        """
        @deprecated OpenAPI DescribeHaVips is deprecated, please use Vpc::2016-04-28::DescribeHaVips instead.
        
        @summary DescribeHaVips
        
        @param request: DescribeHaVipsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeHaVipsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeHaVips',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeHaVipsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_ha_vips_with_options_async(
        self,
        request: ecs_20140526_models.DescribeHaVipsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeHaVipsResponse:
        """
        @deprecated OpenAPI DescribeHaVips is deprecated, please use Vpc::2016-04-28::DescribeHaVips instead.
        
        @summary DescribeHaVips
        
        @param request: DescribeHaVipsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeHaVipsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeHaVips',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeHaVipsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_ha_vips(
        self,
        request: ecs_20140526_models.DescribeHaVipsRequest,
    ) -> ecs_20140526_models.DescribeHaVipsResponse:
        """
        @deprecated OpenAPI DescribeHaVips is deprecated, please use Vpc::2016-04-28::DescribeHaVips instead.
        
        @summary DescribeHaVips
        
        @param request: DescribeHaVipsRequest
        @return: DescribeHaVipsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_ha_vips_with_options(request, runtime)

    async def describe_ha_vips_async(
        self,
        request: ecs_20140526_models.DescribeHaVipsRequest,
    ) -> ecs_20140526_models.DescribeHaVipsResponse:
        """
        @deprecated OpenAPI DescribeHaVips is deprecated, please use Vpc::2016-04-28::DescribeHaVips instead.
        
        @summary DescribeHaVips
        
        @param request: DescribeHaVipsRequest
        @return: DescribeHaVipsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_ha_vips_with_options_async(request, runtime)

    def describe_hpc_clusters_with_options(
        self,
        request: ecs_20140526_models.DescribeHpcClustersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeHpcClustersResponse:
        """
        @summary The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The \\\\*token\\*\\* can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence]\\(~~25693~~).
        
        @param request: DescribeHpcClustersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeHpcClustersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.hpc_cluster_ids):
            query['HpcClusterIds'] = request.hpc_cluster_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeHpcClusters',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeHpcClustersResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_hpc_clusters_with_options_async(
        self,
        request: ecs_20140526_models.DescribeHpcClustersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeHpcClustersResponse:
        """
        @summary The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The \\\\*token\\*\\* can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence]\\(~~25693~~).
        
        @param request: DescribeHpcClustersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeHpcClustersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.hpc_cluster_ids):
            query['HpcClusterIds'] = request.hpc_cluster_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeHpcClusters',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeHpcClustersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_hpc_clusters(
        self,
        request: ecs_20140526_models.DescribeHpcClustersRequest,
    ) -> ecs_20140526_models.DescribeHpcClustersResponse:
        """
        @summary The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The \\\\*token\\*\\* can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence]\\(~~25693~~).
        
        @param request: DescribeHpcClustersRequest
        @return: DescribeHpcClustersResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_hpc_clusters_with_options(request, runtime)

    async def describe_hpc_clusters_async(
        self,
        request: ecs_20140526_models.DescribeHpcClustersRequest,
    ) -> ecs_20140526_models.DescribeHpcClustersResponse:
        """
        @summary The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The \\\\*token\\*\\* can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence]\\(~~25693~~).
        
        @param request: DescribeHpcClustersRequest
        @return: DescribeHpcClustersResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_hpc_clusters_with_options_async(request, runtime)

    def describe_image_components_with_options(
        self,
        request: ecs_20140526_models.DescribeImageComponentsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeImageComponentsResponse:
        """
        @summary Queries the details of one or more image components.
        
        @description You can use `NextToken` to configure the query token. Set the value to the `NextToken` value that is returned in the previous call to the DescribeImageComponents operation. Then, use `MaxResults` to specify the maximum number of entries to return on each page.
        
        @param request: DescribeImageComponentsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeImageComponentsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.component_type):
            query['ComponentType'] = request.component_type
        if not UtilClient.is_unset(request.component_version):
            query['ComponentVersion'] = request.component_version
        if not UtilClient.is_unset(request.image_component_id):
            query['ImageComponentId'] = request.image_component_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner):
            query['Owner'] = request.owner
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.system_type):
            query['SystemType'] = request.system_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeImageComponents',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeImageComponentsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_image_components_with_options_async(
        self,
        request: ecs_20140526_models.DescribeImageComponentsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeImageComponentsResponse:
        """
        @summary Queries the details of one or more image components.
        
        @description You can use `NextToken` to configure the query token. Set the value to the `NextToken` value that is returned in the previous call to the DescribeImageComponents operation. Then, use `MaxResults` to specify the maximum number of entries to return on each page.
        
        @param request: DescribeImageComponentsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeImageComponentsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.component_type):
            query['ComponentType'] = request.component_type
        if not UtilClient.is_unset(request.component_version):
            query['ComponentVersion'] = request.component_version
        if not UtilClient.is_unset(request.image_component_id):
            query['ImageComponentId'] = request.image_component_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner):
            query['Owner'] = request.owner
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.system_type):
            query['SystemType'] = request.system_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeImageComponents',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeImageComponentsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_image_components(
        self,
        request: ecs_20140526_models.DescribeImageComponentsRequest,
    ) -> ecs_20140526_models.DescribeImageComponentsResponse:
        """
        @summary Queries the details of one or more image components.
        
        @description You can use `NextToken` to configure the query token. Set the value to the `NextToken` value that is returned in the previous call to the DescribeImageComponents operation. Then, use `MaxResults` to specify the maximum number of entries to return on each page.
        
        @param request: DescribeImageComponentsRequest
        @return: DescribeImageComponentsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_image_components_with_options(request, runtime)

    async def describe_image_components_async(
        self,
        request: ecs_20140526_models.DescribeImageComponentsRequest,
    ) -> ecs_20140526_models.DescribeImageComponentsResponse:
        """
        @summary Queries the details of one or more image components.
        
        @description You can use `NextToken` to configure the query token. Set the value to the `NextToken` value that is returned in the previous call to the DescribeImageComponents operation. Then, use `MaxResults` to specify the maximum number of entries to return on each page.
        
        @param request: DescribeImageComponentsRequest
        @return: DescribeImageComponentsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_image_components_with_options_async(request, runtime)

    def describe_image_from_family_with_options(
        self,
        request: ecs_20140526_models.DescribeImageFromFamilyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeImageFromFamilyResponse:
        """
        @summary Queries available custom images that are most recently created in a specific image family.
        
        @description ## [](#)Usage notes
        If no available image exists in a specific image family, the response is empty.
        
        @param request: DescribeImageFromFamilyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeImageFromFamilyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.image_family):
            query['ImageFamily'] = request.image_family
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeImageFromFamily',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeImageFromFamilyResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_image_from_family_with_options_async(
        self,
        request: ecs_20140526_models.DescribeImageFromFamilyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeImageFromFamilyResponse:
        """
        @summary Queries available custom images that are most recently created in a specific image family.
        
        @description ## [](#)Usage notes
        If no available image exists in a specific image family, the response is empty.
        
        @param request: DescribeImageFromFamilyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeImageFromFamilyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.image_family):
            query['ImageFamily'] = request.image_family
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeImageFromFamily',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeImageFromFamilyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_image_from_family(
        self,
        request: ecs_20140526_models.DescribeImageFromFamilyRequest,
    ) -> ecs_20140526_models.DescribeImageFromFamilyResponse:
        """
        @summary Queries available custom images that are most recently created in a specific image family.
        
        @description ## [](#)Usage notes
        If no available image exists in a specific image family, the response is empty.
        
        @param request: DescribeImageFromFamilyRequest
        @return: DescribeImageFromFamilyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_image_from_family_with_options(request, runtime)

    async def describe_image_from_family_async(
        self,
        request: ecs_20140526_models.DescribeImageFromFamilyRequest,
    ) -> ecs_20140526_models.DescribeImageFromFamilyResponse:
        """
        @summary Queries available custom images that are most recently created in a specific image family.
        
        @description ## [](#)Usage notes
        If no available image exists in a specific image family, the response is empty.
        
        @param request: DescribeImageFromFamilyRequest
        @return: DescribeImageFromFamilyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_image_from_family_with_options_async(request, runtime)

    def describe_image_pipeline_executions_with_options(
        self,
        request: ecs_20140526_models.DescribeImagePipelineExecutionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeImagePipelineExecutionsResponse:
        """
        @summary Queries the details of an image creation task.
        
        @description ## [](#)Usage notes
        The image template that is specified by the `ImagePipelineId` parameter cannot be a deleted image template. When an image template is deleted, the corresponding image creation task is deleted.
        You must specify `ImagePipelineId` or `ExecutionId`.
        You can configure the query token by using the `NextToken` parameter. Set NextToken to the value of `NextToken` that was returned the previous call to the `DescribeImagePipelineExecutions` operation. Then, use the `MaxResults` parameter to specify the maximum number of entries to return on each page.
        
        @param request: DescribeImagePipelineExecutionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeImagePipelineExecutionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.execution_id):
            query['ExecutionId'] = request.execution_id
        if not UtilClient.is_unset(request.image_pipeline_id):
            query['ImagePipelineId'] = request.image_pipeline_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeImagePipelineExecutions',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeImagePipelineExecutionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_image_pipeline_executions_with_options_async(
        self,
        request: ecs_20140526_models.DescribeImagePipelineExecutionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeImagePipelineExecutionsResponse:
        """
        @summary Queries the details of an image creation task.
        
        @description ## [](#)Usage notes
        The image template that is specified by the `ImagePipelineId` parameter cannot be a deleted image template. When an image template is deleted, the corresponding image creation task is deleted.
        You must specify `ImagePipelineId` or `ExecutionId`.
        You can configure the query token by using the `NextToken` parameter. Set NextToken to the value of `NextToken` that was returned the previous call to the `DescribeImagePipelineExecutions` operation. Then, use the `MaxResults` parameter to specify the maximum number of entries to return on each page.
        
        @param request: DescribeImagePipelineExecutionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeImagePipelineExecutionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.execution_id):
            query['ExecutionId'] = request.execution_id
        if not UtilClient.is_unset(request.image_pipeline_id):
            query['ImagePipelineId'] = request.image_pipeline_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeImagePipelineExecutions',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeImagePipelineExecutionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_image_pipeline_executions(
        self,
        request: ecs_20140526_models.DescribeImagePipelineExecutionsRequest,
    ) -> ecs_20140526_models.DescribeImagePipelineExecutionsResponse:
        """
        @summary Queries the details of an image creation task.
        
        @description ## [](#)Usage notes
        The image template that is specified by the `ImagePipelineId` parameter cannot be a deleted image template. When an image template is deleted, the corresponding image creation task is deleted.
        You must specify `ImagePipelineId` or `ExecutionId`.
        You can configure the query token by using the `NextToken` parameter. Set NextToken to the value of `NextToken` that was returned the previous call to the `DescribeImagePipelineExecutions` operation. Then, use the `MaxResults` parameter to specify the maximum number of entries to return on each page.
        
        @param request: DescribeImagePipelineExecutionsRequest
        @return: DescribeImagePipelineExecutionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_image_pipeline_executions_with_options(request, runtime)

    async def describe_image_pipeline_executions_async(
        self,
        request: ecs_20140526_models.DescribeImagePipelineExecutionsRequest,
    ) -> ecs_20140526_models.DescribeImagePipelineExecutionsResponse:
        """
        @summary Queries the details of an image creation task.
        
        @description ## [](#)Usage notes
        The image template that is specified by the `ImagePipelineId` parameter cannot be a deleted image template. When an image template is deleted, the corresponding image creation task is deleted.
        You must specify `ImagePipelineId` or `ExecutionId`.
        You can configure the query token by using the `NextToken` parameter. Set NextToken to the value of `NextToken` that was returned the previous call to the `DescribeImagePipelineExecutions` operation. Then, use the `MaxResults` parameter to specify the maximum number of entries to return on each page.
        
        @param request: DescribeImagePipelineExecutionsRequest
        @return: DescribeImagePipelineExecutionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_image_pipeline_executions_with_options_async(request, runtime)

    def describe_image_pipelines_with_options(
        self,
        request: ecs_20140526_models.DescribeImagePipelinesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeImagePipelinesResponse:
        """
        @summary Queries the details of one or more image templates.
        
        @description You can use `NextToken` to configure the query token. Set the value to the `NextToken` value that is returned in the previous call to the `DescribeImagePipelines` operation. Then, use `MaxResults` to specify the maximum number of entries to return on each page.
        
        @param request: DescribeImagePipelinesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeImagePipelinesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.image_pipeline_id):
            query['ImagePipelineId'] = request.image_pipeline_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeImagePipelines',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeImagePipelinesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_image_pipelines_with_options_async(
        self,
        request: ecs_20140526_models.DescribeImagePipelinesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeImagePipelinesResponse:
        """
        @summary Queries the details of one or more image templates.
        
        @description You can use `NextToken` to configure the query token. Set the value to the `NextToken` value that is returned in the previous call to the `DescribeImagePipelines` operation. Then, use `MaxResults` to specify the maximum number of entries to return on each page.
        
        @param request: DescribeImagePipelinesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeImagePipelinesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.image_pipeline_id):
            query['ImagePipelineId'] = request.image_pipeline_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeImagePipelines',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeImagePipelinesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_image_pipelines(
        self,
        request: ecs_20140526_models.DescribeImagePipelinesRequest,
    ) -> ecs_20140526_models.DescribeImagePipelinesResponse:
        """
        @summary Queries the details of one or more image templates.
        
        @description You can use `NextToken` to configure the query token. Set the value to the `NextToken` value that is returned in the previous call to the `DescribeImagePipelines` operation. Then, use `MaxResults` to specify the maximum number of entries to return on each page.
        
        @param request: DescribeImagePipelinesRequest
        @return: DescribeImagePipelinesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_image_pipelines_with_options(request, runtime)

    async def describe_image_pipelines_async(
        self,
        request: ecs_20140526_models.DescribeImagePipelinesRequest,
    ) -> ecs_20140526_models.DescribeImagePipelinesResponse:
        """
        @summary Queries the details of one or more image templates.
        
        @description You can use `NextToken` to configure the query token. Set the value to the `NextToken` value that is returned in the previous call to the `DescribeImagePipelines` operation. Then, use `MaxResults` to specify the maximum number of entries to return on each page.
        
        @param request: DescribeImagePipelinesRequest
        @return: DescribeImagePipelinesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_image_pipelines_with_options_async(request, runtime)

    def describe_image_share_permission_with_options(
        self,
        request: ecs_20140526_models.DescribeImageSharePermissionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeImageSharePermissionResponse:
        """
        @summary Queries the accounts with which a custom image is shared. When you call this operation, you can specify parameters, such as RegionId and ImageId, in the request. The response can be displayed by page. By default, 10 entries are displayed on each page.
        
        @param request: DescribeImageSharePermissionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeImageSharePermissionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeImageSharePermission',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeImageSharePermissionResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_image_share_permission_with_options_async(
        self,
        request: ecs_20140526_models.DescribeImageSharePermissionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeImageSharePermissionResponse:
        """
        @summary Queries the accounts with which a custom image is shared. When you call this operation, you can specify parameters, such as RegionId and ImageId, in the request. The response can be displayed by page. By default, 10 entries are displayed on each page.
        
        @param request: DescribeImageSharePermissionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeImageSharePermissionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeImageSharePermission',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeImageSharePermissionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_image_share_permission(
        self,
        request: ecs_20140526_models.DescribeImageSharePermissionRequest,
    ) -> ecs_20140526_models.DescribeImageSharePermissionResponse:
        """
        @summary Queries the accounts with which a custom image is shared. When you call this operation, you can specify parameters, such as RegionId and ImageId, in the request. The response can be displayed by page. By default, 10 entries are displayed on each page.
        
        @param request: DescribeImageSharePermissionRequest
        @return: DescribeImageSharePermissionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_image_share_permission_with_options(request, runtime)

    async def describe_image_share_permission_async(
        self,
        request: ecs_20140526_models.DescribeImageSharePermissionRequest,
    ) -> ecs_20140526_models.DescribeImageSharePermissionResponse:
        """
        @summary Queries the accounts with which a custom image is shared. When you call this operation, you can specify parameters, such as RegionId and ImageId, in the request. The response can be displayed by page. By default, 10 entries are displayed on each page.
        
        @param request: DescribeImageSharePermissionRequest
        @return: DescribeImageSharePermissionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_image_share_permission_with_options_async(request, runtime)

    def describe_image_support_instance_types_with_options(
        self,
        request: ecs_20140526_models.DescribeImageSupportInstanceTypesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeImageSupportInstanceTypesResponse:
        """
        @summary Queries the Elastic Compute Service (ECS) instance types supported by an image.
        
        @param request: DescribeImageSupportInstanceTypesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeImageSupportInstanceTypesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.action_type):
            query['ActionType'] = request.action_type
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeImageSupportInstanceTypes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeImageSupportInstanceTypesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_image_support_instance_types_with_options_async(
        self,
        request: ecs_20140526_models.DescribeImageSupportInstanceTypesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeImageSupportInstanceTypesResponse:
        """
        @summary Queries the Elastic Compute Service (ECS) instance types supported by an image.
        
        @param request: DescribeImageSupportInstanceTypesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeImageSupportInstanceTypesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.action_type):
            query['ActionType'] = request.action_type
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeImageSupportInstanceTypes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeImageSupportInstanceTypesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_image_support_instance_types(
        self,
        request: ecs_20140526_models.DescribeImageSupportInstanceTypesRequest,
    ) -> ecs_20140526_models.DescribeImageSupportInstanceTypesResponse:
        """
        @summary Queries the Elastic Compute Service (ECS) instance types supported by an image.
        
        @param request: DescribeImageSupportInstanceTypesRequest
        @return: DescribeImageSupportInstanceTypesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_image_support_instance_types_with_options(request, runtime)

    async def describe_image_support_instance_types_async(
        self,
        request: ecs_20140526_models.DescribeImageSupportInstanceTypesRequest,
    ) -> ecs_20140526_models.DescribeImageSupportInstanceTypesResponse:
        """
        @summary Queries the Elastic Compute Service (ECS) instance types supported by an image.
        
        @param request: DescribeImageSupportInstanceTypesRequest
        @return: DescribeImageSupportInstanceTypesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_image_support_instance_types_with_options_async(request, runtime)

    def describe_images_with_options(
        self,
        request: ecs_20140526_models.DescribeImagesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeImagesResponse:
        """
        @summary Queries image resources that you can use. You can specify parameters, such as ImageId, ActionType, and Filter, in the request.
        
        @description ## [](#)Usage notes
        You can query your custom images, public images provided by Alibaba Cloud, Alibaba Cloud Marketplace images, and shared images from other Alibaba Cloud accounts.
        This is a paginated query. The response contains the total number of available images and the images on the returned page. By default,10 entries are displayed on each page.
        When you call an API operation by using Alibaba Cloud CLI, you must specify request parameter values of different data types in the required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        If you set ImageOwnerAlias to system or others when you call the DescribeImages operation to query public images that are provided by Alibaba Cloud or shared images, Resource Access Management (RAM) policies are ignored in the request. For more information, see [RAM authorization](https://help.aliyun.com/document_detail/25497.html).
        
        @param request: DescribeImagesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeImagesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.action_type):
            query['ActionType'] = request.action_type
        if not UtilClient.is_unset(request.architecture):
            query['Architecture'] = request.architecture
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.image_family):
            query['ImageFamily'] = request.image_family
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.image_name):
            query['ImageName'] = request.image_name
        if not UtilClient.is_unset(request.image_owner_alias):
            query['ImageOwnerAlias'] = request.image_owner_alias
        if not UtilClient.is_unset(request.image_owner_id):
            query['ImageOwnerId'] = request.image_owner_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.is_public):
            query['IsPublic'] = request.is_public
        if not UtilClient.is_unset(request.is_support_cloudinit):
            query['IsSupportCloudinit'] = request.is_support_cloudinit
        if not UtilClient.is_unset(request.is_support_io_optimized):
            query['IsSupportIoOptimized'] = request.is_support_io_optimized
        if not UtilClient.is_unset(request.ostype):
            query['OSType'] = request.ostype
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.show_expired):
            query['ShowExpired'] = request.show_expired
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.usage):
            query['Usage'] = request.usage
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeImages',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeImagesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_images_with_options_async(
        self,
        request: ecs_20140526_models.DescribeImagesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeImagesResponse:
        """
        @summary Queries image resources that you can use. You can specify parameters, such as ImageId, ActionType, and Filter, in the request.
        
        @description ## [](#)Usage notes
        You can query your custom images, public images provided by Alibaba Cloud, Alibaba Cloud Marketplace images, and shared images from other Alibaba Cloud accounts.
        This is a paginated query. The response contains the total number of available images and the images on the returned page. By default,10 entries are displayed on each page.
        When you call an API operation by using Alibaba Cloud CLI, you must specify request parameter values of different data types in the required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        If you set ImageOwnerAlias to system or others when you call the DescribeImages operation to query public images that are provided by Alibaba Cloud or shared images, Resource Access Management (RAM) policies are ignored in the request. For more information, see [RAM authorization](https://help.aliyun.com/document_detail/25497.html).
        
        @param request: DescribeImagesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeImagesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.action_type):
            query['ActionType'] = request.action_type
        if not UtilClient.is_unset(request.architecture):
            query['Architecture'] = request.architecture
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.image_family):
            query['ImageFamily'] = request.image_family
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.image_name):
            query['ImageName'] = request.image_name
        if not UtilClient.is_unset(request.image_owner_alias):
            query['ImageOwnerAlias'] = request.image_owner_alias
        if not UtilClient.is_unset(request.image_owner_id):
            query['ImageOwnerId'] = request.image_owner_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.is_public):
            query['IsPublic'] = request.is_public
        if not UtilClient.is_unset(request.is_support_cloudinit):
            query['IsSupportCloudinit'] = request.is_support_cloudinit
        if not UtilClient.is_unset(request.is_support_io_optimized):
            query['IsSupportIoOptimized'] = request.is_support_io_optimized
        if not UtilClient.is_unset(request.ostype):
            query['OSType'] = request.ostype
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.show_expired):
            query['ShowExpired'] = request.show_expired
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.usage):
            query['Usage'] = request.usage
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeImages',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeImagesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_images(
        self,
        request: ecs_20140526_models.DescribeImagesRequest,
    ) -> ecs_20140526_models.DescribeImagesResponse:
        """
        @summary Queries image resources that you can use. You can specify parameters, such as ImageId, ActionType, and Filter, in the request.
        
        @description ## [](#)Usage notes
        You can query your custom images, public images provided by Alibaba Cloud, Alibaba Cloud Marketplace images, and shared images from other Alibaba Cloud accounts.
        This is a paginated query. The response contains the total number of available images and the images on the returned page. By default,10 entries are displayed on each page.
        When you call an API operation by using Alibaba Cloud CLI, you must specify request parameter values of different data types in the required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        If you set ImageOwnerAlias to system or others when you call the DescribeImages operation to query public images that are provided by Alibaba Cloud or shared images, Resource Access Management (RAM) policies are ignored in the request. For more information, see [RAM authorization](https://help.aliyun.com/document_detail/25497.html).
        
        @param request: DescribeImagesRequest
        @return: DescribeImagesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_images_with_options(request, runtime)

    async def describe_images_async(
        self,
        request: ecs_20140526_models.DescribeImagesRequest,
    ) -> ecs_20140526_models.DescribeImagesResponse:
        """
        @summary Queries image resources that you can use. You can specify parameters, such as ImageId, ActionType, and Filter, in the request.
        
        @description ## [](#)Usage notes
        You can query your custom images, public images provided by Alibaba Cloud, Alibaba Cloud Marketplace images, and shared images from other Alibaba Cloud accounts.
        This is a paginated query. The response contains the total number of available images and the images on the returned page. By default,10 entries are displayed on each page.
        When you call an API operation by using Alibaba Cloud CLI, you must specify request parameter values of different data types in the required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        If you set ImageOwnerAlias to system or others when you call the DescribeImages operation to query public images that are provided by Alibaba Cloud or shared images, Resource Access Management (RAM) policies are ignored in the request. For more information, see [RAM authorization](https://help.aliyun.com/document_detail/25497.html).
        
        @param request: DescribeImagesRequest
        @return: DescribeImagesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_images_with_options_async(request, runtime)

    def describe_instance_attachment_attributes_with_options(
        self,
        request: ecs_20140526_models.DescribeInstanceAttachmentAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceAttachmentAttributesResponse:
        """
        @summary Queries the information about the private pools that Elastic Compute Service (ECS) instances match.
        
        @description ## [](#)Usage notes
        After an elasticity assurance or a capacity reservation is created, a private pool is generated and associated with information about the instances that are created by using the private pool. You can specify a private pool when you create an instance. This way, the instance matches the elasticity assurance or capacity reservation that is associated with the private pool.
        When a private pool expires, data related to the association between instances and the private pool becomes invalid. If you call this operation to query information about the private pool, empty values are returned.
        
        @param request: DescribeInstanceAttachmentAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceAttachmentAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceAttachmentAttributes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceAttachmentAttributesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_instance_attachment_attributes_with_options_async(
        self,
        request: ecs_20140526_models.DescribeInstanceAttachmentAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceAttachmentAttributesResponse:
        """
        @summary Queries the information about the private pools that Elastic Compute Service (ECS) instances match.
        
        @description ## [](#)Usage notes
        After an elasticity assurance or a capacity reservation is created, a private pool is generated and associated with information about the instances that are created by using the private pool. You can specify a private pool when you create an instance. This way, the instance matches the elasticity assurance or capacity reservation that is associated with the private pool.
        When a private pool expires, data related to the association between instances and the private pool becomes invalid. If you call this operation to query information about the private pool, empty values are returned.
        
        @param request: DescribeInstanceAttachmentAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceAttachmentAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceAttachmentAttributes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceAttachmentAttributesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_instance_attachment_attributes(
        self,
        request: ecs_20140526_models.DescribeInstanceAttachmentAttributesRequest,
    ) -> ecs_20140526_models.DescribeInstanceAttachmentAttributesResponse:
        """
        @summary Queries the information about the private pools that Elastic Compute Service (ECS) instances match.
        
        @description ## [](#)Usage notes
        After an elasticity assurance or a capacity reservation is created, a private pool is generated and associated with information about the instances that are created by using the private pool. You can specify a private pool when you create an instance. This way, the instance matches the elasticity assurance or capacity reservation that is associated with the private pool.
        When a private pool expires, data related to the association between instances and the private pool becomes invalid. If you call this operation to query information about the private pool, empty values are returned.
        
        @param request: DescribeInstanceAttachmentAttributesRequest
        @return: DescribeInstanceAttachmentAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_instance_attachment_attributes_with_options(request, runtime)

    async def describe_instance_attachment_attributes_async(
        self,
        request: ecs_20140526_models.DescribeInstanceAttachmentAttributesRequest,
    ) -> ecs_20140526_models.DescribeInstanceAttachmentAttributesResponse:
        """
        @summary Queries the information about the private pools that Elastic Compute Service (ECS) instances match.
        
        @description ## [](#)Usage notes
        After an elasticity assurance or a capacity reservation is created, a private pool is generated and associated with information about the instances that are created by using the private pool. You can specify a private pool when you create an instance. This way, the instance matches the elasticity assurance or capacity reservation that is associated with the private pool.
        When a private pool expires, data related to the association between instances and the private pool becomes invalid. If you call this operation to query information about the private pool, empty values are returned.
        
        @param request: DescribeInstanceAttachmentAttributesRequest
        @return: DescribeInstanceAttachmentAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_instance_attachment_attributes_with_options_async(request, runtime)

    def describe_instance_attribute_with_options(
        self,
        request: ecs_20140526_models.DescribeInstanceAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceAttributeResponse:
        """
        @summary Queries the attributes of a specific Elastic Compute Service (ECS) instance.
        
        @param request: DescribeInstanceAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_instance_attribute_with_options_async(
        self,
        request: ecs_20140526_models.DescribeInstanceAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceAttributeResponse:
        """
        @summary Queries the attributes of a specific Elastic Compute Service (ECS) instance.
        
        @param request: DescribeInstanceAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_instance_attribute(
        self,
        request: ecs_20140526_models.DescribeInstanceAttributeRequest,
    ) -> ecs_20140526_models.DescribeInstanceAttributeResponse:
        """
        @summary Queries the attributes of a specific Elastic Compute Service (ECS) instance.
        
        @param request: DescribeInstanceAttributeRequest
        @return: DescribeInstanceAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_instance_attribute_with_options(request, runtime)

    async def describe_instance_attribute_async(
        self,
        request: ecs_20140526_models.DescribeInstanceAttributeRequest,
    ) -> ecs_20140526_models.DescribeInstanceAttributeResponse:
        """
        @summary Queries the attributes of a specific Elastic Compute Service (ECS) instance.
        
        @param request: DescribeInstanceAttributeRequest
        @return: DescribeInstanceAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_instance_attribute_with_options_async(request, runtime)

    def describe_instance_auto_renew_attribute_with_options(
        self,
        request: ecs_20140526_models.DescribeInstanceAutoRenewAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceAutoRenewAttributeResponse:
        """
        @summary Queries the auto-renewal attribute of subscription Elastic Compute Service (ECS) instances, including whether auto-renewal is enabled for the instances and the auto-renewal durations of the instances.
        
        @description    Only subscription instances are supported. If you call this operation for a pay-as-you-go instance, an error is returned.
        Before you configure auto-renewal or manual renewal for subscription instances, you can query the auto-renewal status of the instances.
        
        @param request: DescribeInstanceAutoRenewAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceAutoRenewAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.renewal_status):
            query['RenewalStatus'] = request.renewal_status
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceAutoRenewAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceAutoRenewAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_instance_auto_renew_attribute_with_options_async(
        self,
        request: ecs_20140526_models.DescribeInstanceAutoRenewAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceAutoRenewAttributeResponse:
        """
        @summary Queries the auto-renewal attribute of subscription Elastic Compute Service (ECS) instances, including whether auto-renewal is enabled for the instances and the auto-renewal durations of the instances.
        
        @description    Only subscription instances are supported. If you call this operation for a pay-as-you-go instance, an error is returned.
        Before you configure auto-renewal or manual renewal for subscription instances, you can query the auto-renewal status of the instances.
        
        @param request: DescribeInstanceAutoRenewAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceAutoRenewAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.renewal_status):
            query['RenewalStatus'] = request.renewal_status
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceAutoRenewAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceAutoRenewAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_instance_auto_renew_attribute(
        self,
        request: ecs_20140526_models.DescribeInstanceAutoRenewAttributeRequest,
    ) -> ecs_20140526_models.DescribeInstanceAutoRenewAttributeResponse:
        """
        @summary Queries the auto-renewal attribute of subscription Elastic Compute Service (ECS) instances, including whether auto-renewal is enabled for the instances and the auto-renewal durations of the instances.
        
        @description    Only subscription instances are supported. If you call this operation for a pay-as-you-go instance, an error is returned.
        Before you configure auto-renewal or manual renewal for subscription instances, you can query the auto-renewal status of the instances.
        
        @param request: DescribeInstanceAutoRenewAttributeRequest
        @return: DescribeInstanceAutoRenewAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_instance_auto_renew_attribute_with_options(request, runtime)

    async def describe_instance_auto_renew_attribute_async(
        self,
        request: ecs_20140526_models.DescribeInstanceAutoRenewAttributeRequest,
    ) -> ecs_20140526_models.DescribeInstanceAutoRenewAttributeResponse:
        """
        @summary Queries the auto-renewal attribute of subscription Elastic Compute Service (ECS) instances, including whether auto-renewal is enabled for the instances and the auto-renewal durations of the instances.
        
        @description    Only subscription instances are supported. If you call this operation for a pay-as-you-go instance, an error is returned.
        Before you configure auto-renewal or manual renewal for subscription instances, you can query the auto-renewal status of the instances.
        
        @param request: DescribeInstanceAutoRenewAttributeRequest
        @return: DescribeInstanceAutoRenewAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_instance_auto_renew_attribute_with_options_async(request, runtime)

    def describe_instance_history_events_with_options(
        self,
        request: ecs_20140526_models.DescribeInstanceHistoryEventsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceHistoryEventsResponse:
        """
        @summary Queries the system events of Elastic Compute Service (ECS) instances. When you call this operation, you can specify parameters, such as InstanceId and EventType, in the request. By default, non-active system events are queried.
        
        @description    You can query system events that were completed within the last 30 days. No limits apply to the time range for querying uncompleted system events.
        If you do not specify the EventCycleStatus or InstanceEventCycleStatus parameter, only system events in the Avoidated, Executed, Canceled, or Failed state are included in the query results by default.
        You can also specify the InstanceEventCycleStatus parameter in the request to query the system events that are in the Scheduled, Executing, or Inquiring state.
        
        @param request: DescribeInstanceHistoryEventsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceHistoryEventsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.event_cycle_status):
            query['EventCycleStatus'] = request.event_cycle_status
        if not UtilClient.is_unset(request.event_id):
            query['EventId'] = request.event_id
        if not UtilClient.is_unset(request.event_type):
            query['EventType'] = request.event_type
        if not UtilClient.is_unset(request.impact_level):
            query['ImpactLevel'] = request.impact_level
        if not UtilClient.is_unset(request.instance_event_cycle_status):
            query['InstanceEventCycleStatus'] = request.instance_event_cycle_status
        if not UtilClient.is_unset(request.instance_event_type):
            query['InstanceEventType'] = request.instance_event_type
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.event_publish_time):
            query['EventPublishTime'] = request.event_publish_time
        if not UtilClient.is_unset(request.not_before):
            query['NotBefore'] = request.not_before
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceHistoryEvents',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceHistoryEventsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_instance_history_events_with_options_async(
        self,
        request: ecs_20140526_models.DescribeInstanceHistoryEventsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceHistoryEventsResponse:
        """
        @summary Queries the system events of Elastic Compute Service (ECS) instances. When you call this operation, you can specify parameters, such as InstanceId and EventType, in the request. By default, non-active system events are queried.
        
        @description    You can query system events that were completed within the last 30 days. No limits apply to the time range for querying uncompleted system events.
        If you do not specify the EventCycleStatus or InstanceEventCycleStatus parameter, only system events in the Avoidated, Executed, Canceled, or Failed state are included in the query results by default.
        You can also specify the InstanceEventCycleStatus parameter in the request to query the system events that are in the Scheduled, Executing, or Inquiring state.
        
        @param request: DescribeInstanceHistoryEventsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceHistoryEventsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.event_cycle_status):
            query['EventCycleStatus'] = request.event_cycle_status
        if not UtilClient.is_unset(request.event_id):
            query['EventId'] = request.event_id
        if not UtilClient.is_unset(request.event_type):
            query['EventType'] = request.event_type
        if not UtilClient.is_unset(request.impact_level):
            query['ImpactLevel'] = request.impact_level
        if not UtilClient.is_unset(request.instance_event_cycle_status):
            query['InstanceEventCycleStatus'] = request.instance_event_cycle_status
        if not UtilClient.is_unset(request.instance_event_type):
            query['InstanceEventType'] = request.instance_event_type
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.event_publish_time):
            query['EventPublishTime'] = request.event_publish_time
        if not UtilClient.is_unset(request.not_before):
            query['NotBefore'] = request.not_before
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceHistoryEvents',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceHistoryEventsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_instance_history_events(
        self,
        request: ecs_20140526_models.DescribeInstanceHistoryEventsRequest,
    ) -> ecs_20140526_models.DescribeInstanceHistoryEventsResponse:
        """
        @summary Queries the system events of Elastic Compute Service (ECS) instances. When you call this operation, you can specify parameters, such as InstanceId and EventType, in the request. By default, non-active system events are queried.
        
        @description    You can query system events that were completed within the last 30 days. No limits apply to the time range for querying uncompleted system events.
        If you do not specify the EventCycleStatus or InstanceEventCycleStatus parameter, only system events in the Avoidated, Executed, Canceled, or Failed state are included in the query results by default.
        You can also specify the InstanceEventCycleStatus parameter in the request to query the system events that are in the Scheduled, Executing, or Inquiring state.
        
        @param request: DescribeInstanceHistoryEventsRequest
        @return: DescribeInstanceHistoryEventsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_instance_history_events_with_options(request, runtime)

    async def describe_instance_history_events_async(
        self,
        request: ecs_20140526_models.DescribeInstanceHistoryEventsRequest,
    ) -> ecs_20140526_models.DescribeInstanceHistoryEventsResponse:
        """
        @summary Queries the system events of Elastic Compute Service (ECS) instances. When you call this operation, you can specify parameters, such as InstanceId and EventType, in the request. By default, non-active system events are queried.
        
        @description    You can query system events that were completed within the last 30 days. No limits apply to the time range for querying uncompleted system events.
        If you do not specify the EventCycleStatus or InstanceEventCycleStatus parameter, only system events in the Avoidated, Executed, Canceled, or Failed state are included in the query results by default.
        You can also specify the InstanceEventCycleStatus parameter in the request to query the system events that are in the Scheduled, Executing, or Inquiring state.
        
        @param request: DescribeInstanceHistoryEventsRequest
        @return: DescribeInstanceHistoryEventsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_instance_history_events_with_options_async(request, runtime)

    def describe_instance_maintenance_attributes_with_options(
        self,
        request: ecs_20140526_models.DescribeInstanceMaintenanceAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceMaintenanceAttributesResponse:
        """
        @summary Queries the maintenance attributes of an instance.
        
        @description This operation is used to query the specified maintenance policy of an instance, which contains the following maintenance attributes:
        Maintenance window: the time period that you specify for maintenance.
        Maintenance action: the action that you specify in response to instance shutdown.
        
        @param request: DescribeInstanceMaintenanceAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceMaintenanceAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceMaintenanceAttributes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceMaintenanceAttributesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_instance_maintenance_attributes_with_options_async(
        self,
        request: ecs_20140526_models.DescribeInstanceMaintenanceAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceMaintenanceAttributesResponse:
        """
        @summary Queries the maintenance attributes of an instance.
        
        @description This operation is used to query the specified maintenance policy of an instance, which contains the following maintenance attributes:
        Maintenance window: the time period that you specify for maintenance.
        Maintenance action: the action that you specify in response to instance shutdown.
        
        @param request: DescribeInstanceMaintenanceAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceMaintenanceAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceMaintenanceAttributes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceMaintenanceAttributesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_instance_maintenance_attributes(
        self,
        request: ecs_20140526_models.DescribeInstanceMaintenanceAttributesRequest,
    ) -> ecs_20140526_models.DescribeInstanceMaintenanceAttributesResponse:
        """
        @summary Queries the maintenance attributes of an instance.
        
        @description This operation is used to query the specified maintenance policy of an instance, which contains the following maintenance attributes:
        Maintenance window: the time period that you specify for maintenance.
        Maintenance action: the action that you specify in response to instance shutdown.
        
        @param request: DescribeInstanceMaintenanceAttributesRequest
        @return: DescribeInstanceMaintenanceAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_instance_maintenance_attributes_with_options(request, runtime)

    async def describe_instance_maintenance_attributes_async(
        self,
        request: ecs_20140526_models.DescribeInstanceMaintenanceAttributesRequest,
    ) -> ecs_20140526_models.DescribeInstanceMaintenanceAttributesResponse:
        """
        @summary Queries the maintenance attributes of an instance.
        
        @description This operation is used to query the specified maintenance policy of an instance, which contains the following maintenance attributes:
        Maintenance window: the time period that you specify for maintenance.
        Maintenance action: the action that you specify in response to instance shutdown.
        
        @param request: DescribeInstanceMaintenanceAttributesRequest
        @return: DescribeInstanceMaintenanceAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_instance_maintenance_attributes_with_options_async(request, runtime)

    def describe_instance_modification_price_with_options(
        self,
        request: ecs_20140526_models.DescribeInstanceModificationPriceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceModificationPriceResponse:
        """
        @summary Queries the pricing information about newly attached subscription data disks or about the new instance types when you upgrade the configurations of unexpired subscription Elastic Compute Service (ECS) instances.
        
        @description    Pricing information can be queried for unexpired subscription ECS instances only when you upgrade their configurations. The pricing information cannot be queried when the instance configurations are downgraded.
        Pricing information cannot be queried for pay-as-you-go ECS instances when you change their configurations. Prices of existing pay-as-you-go ECS instances whose configurations are changed are the same as those of new pay-as-you-go instances. You can call the [DescribePrice](https://help.aliyun.com/document_detail/107829.html) operation to query the latest prices of ECS instances.
        Before you upgrade the configurations of an instance, we recommend that you call the [DescribeResourcesModification](https://help.aliyun.com/document_detail/66187.html) operation to query the instance types available for configuration upgrades in a specified zone.
        
        @param request: DescribeInstanceModificationPriceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceModificationPriceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.data_disk):
            query['DataDisk'] = request.data_disk
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.system_disk):
            query['SystemDisk'] = request.system_disk
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceModificationPrice',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceModificationPriceResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_instance_modification_price_with_options_async(
        self,
        request: ecs_20140526_models.DescribeInstanceModificationPriceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceModificationPriceResponse:
        """
        @summary Queries the pricing information about newly attached subscription data disks or about the new instance types when you upgrade the configurations of unexpired subscription Elastic Compute Service (ECS) instances.
        
        @description    Pricing information can be queried for unexpired subscription ECS instances only when you upgrade their configurations. The pricing information cannot be queried when the instance configurations are downgraded.
        Pricing information cannot be queried for pay-as-you-go ECS instances when you change their configurations. Prices of existing pay-as-you-go ECS instances whose configurations are changed are the same as those of new pay-as-you-go instances. You can call the [DescribePrice](https://help.aliyun.com/document_detail/107829.html) operation to query the latest prices of ECS instances.
        Before you upgrade the configurations of an instance, we recommend that you call the [DescribeResourcesModification](https://help.aliyun.com/document_detail/66187.html) operation to query the instance types available for configuration upgrades in a specified zone.
        
        @param request: DescribeInstanceModificationPriceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceModificationPriceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.data_disk):
            query['DataDisk'] = request.data_disk
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.system_disk):
            query['SystemDisk'] = request.system_disk
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceModificationPrice',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceModificationPriceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_instance_modification_price(
        self,
        request: ecs_20140526_models.DescribeInstanceModificationPriceRequest,
    ) -> ecs_20140526_models.DescribeInstanceModificationPriceResponse:
        """
        @summary Queries the pricing information about newly attached subscription data disks or about the new instance types when you upgrade the configurations of unexpired subscription Elastic Compute Service (ECS) instances.
        
        @description    Pricing information can be queried for unexpired subscription ECS instances only when you upgrade their configurations. The pricing information cannot be queried when the instance configurations are downgraded.
        Pricing information cannot be queried for pay-as-you-go ECS instances when you change their configurations. Prices of existing pay-as-you-go ECS instances whose configurations are changed are the same as those of new pay-as-you-go instances. You can call the [DescribePrice](https://help.aliyun.com/document_detail/107829.html) operation to query the latest prices of ECS instances.
        Before you upgrade the configurations of an instance, we recommend that you call the [DescribeResourcesModification](https://help.aliyun.com/document_detail/66187.html) operation to query the instance types available for configuration upgrades in a specified zone.
        
        @param request: DescribeInstanceModificationPriceRequest
        @return: DescribeInstanceModificationPriceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_instance_modification_price_with_options(request, runtime)

    async def describe_instance_modification_price_async(
        self,
        request: ecs_20140526_models.DescribeInstanceModificationPriceRequest,
    ) -> ecs_20140526_models.DescribeInstanceModificationPriceResponse:
        """
        @summary Queries the pricing information about newly attached subscription data disks or about the new instance types when you upgrade the configurations of unexpired subscription Elastic Compute Service (ECS) instances.
        
        @description    Pricing information can be queried for unexpired subscription ECS instances only when you upgrade their configurations. The pricing information cannot be queried when the instance configurations are downgraded.
        Pricing information cannot be queried for pay-as-you-go ECS instances when you change their configurations. Prices of existing pay-as-you-go ECS instances whose configurations are changed are the same as those of new pay-as-you-go instances. You can call the [DescribePrice](https://help.aliyun.com/document_detail/107829.html) operation to query the latest prices of ECS instances.
        Before you upgrade the configurations of an instance, we recommend that you call the [DescribeResourcesModification](https://help.aliyun.com/document_detail/66187.html) operation to query the instance types available for configuration upgrades in a specified zone.
        
        @param request: DescribeInstanceModificationPriceRequest
        @return: DescribeInstanceModificationPriceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_instance_modification_price_with_options_async(request, runtime)

    def describe_instance_monitor_data_with_options(
        self,
        request: ecs_20140526_models.DescribeInstanceMonitorDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceMonitorDataResponse:
        """
        @summary Queries the monitoring data of an Elastic Compute Service (ECS) instance. The monitoring data can include the vCPU utilization, CPU credits of the burstable instance, amount of received data traffic, amount of sent data traffic, and average bandwidth.
        
        @description ## [](#)Usage notes
        Take note of the following items:
        Up to 400 monitoring data entries can be returned at a time. Make sure that the `TotalCount` value does not exceed 400. The value is calculated by using the following formula: `TotalCount = (EndTime - StartTime)/Period`. If the TotalCount value is greater than 400, the `InvalidParameter.TooManyDataQueried` error is returned.
        You can query the monitoring data in the last 30 days. If the value of `StartTime` is more than 30 days earlier than the current time, an error is returned.
        In some scenarios, such as when the instance is in the Stopped state, the system cannot obtain the relevant information and specific information may be missing from the returned monitoring data.
        You cannot call this operation to obtain the CPU basic monitoring information of an ECS bare metal instance. To obtain the CPU monitoring information of an ECS bare metal instance, install the CloudMonitor agent on the instance. For more information, see [InstallCloudMonitor](https://help.aliyun.com/document_detail/183482.html).
        
        @param request: DescribeInstanceMonitorDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceMonitorDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceMonitorData',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceMonitorDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_instance_monitor_data_with_options_async(
        self,
        request: ecs_20140526_models.DescribeInstanceMonitorDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceMonitorDataResponse:
        """
        @summary Queries the monitoring data of an Elastic Compute Service (ECS) instance. The monitoring data can include the vCPU utilization, CPU credits of the burstable instance, amount of received data traffic, amount of sent data traffic, and average bandwidth.
        
        @description ## [](#)Usage notes
        Take note of the following items:
        Up to 400 monitoring data entries can be returned at a time. Make sure that the `TotalCount` value does not exceed 400. The value is calculated by using the following formula: `TotalCount = (EndTime - StartTime)/Period`. If the TotalCount value is greater than 400, the `InvalidParameter.TooManyDataQueried` error is returned.
        You can query the monitoring data in the last 30 days. If the value of `StartTime` is more than 30 days earlier than the current time, an error is returned.
        In some scenarios, such as when the instance is in the Stopped state, the system cannot obtain the relevant information and specific information may be missing from the returned monitoring data.
        You cannot call this operation to obtain the CPU basic monitoring information of an ECS bare metal instance. To obtain the CPU monitoring information of an ECS bare metal instance, install the CloudMonitor agent on the instance. For more information, see [InstallCloudMonitor](https://help.aliyun.com/document_detail/183482.html).
        
        @param request: DescribeInstanceMonitorDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceMonitorDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceMonitorData',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceMonitorDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_instance_monitor_data(
        self,
        request: ecs_20140526_models.DescribeInstanceMonitorDataRequest,
    ) -> ecs_20140526_models.DescribeInstanceMonitorDataResponse:
        """
        @summary Queries the monitoring data of an Elastic Compute Service (ECS) instance. The monitoring data can include the vCPU utilization, CPU credits of the burstable instance, amount of received data traffic, amount of sent data traffic, and average bandwidth.
        
        @description ## [](#)Usage notes
        Take note of the following items:
        Up to 400 monitoring data entries can be returned at a time. Make sure that the `TotalCount` value does not exceed 400. The value is calculated by using the following formula: `TotalCount = (EndTime - StartTime)/Period`. If the TotalCount value is greater than 400, the `InvalidParameter.TooManyDataQueried` error is returned.
        You can query the monitoring data in the last 30 days. If the value of `StartTime` is more than 30 days earlier than the current time, an error is returned.
        In some scenarios, such as when the instance is in the Stopped state, the system cannot obtain the relevant information and specific information may be missing from the returned monitoring data.
        You cannot call this operation to obtain the CPU basic monitoring information of an ECS bare metal instance. To obtain the CPU monitoring information of an ECS bare metal instance, install the CloudMonitor agent on the instance. For more information, see [InstallCloudMonitor](https://help.aliyun.com/document_detail/183482.html).
        
        @param request: DescribeInstanceMonitorDataRequest
        @return: DescribeInstanceMonitorDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_instance_monitor_data_with_options(request, runtime)

    async def describe_instance_monitor_data_async(
        self,
        request: ecs_20140526_models.DescribeInstanceMonitorDataRequest,
    ) -> ecs_20140526_models.DescribeInstanceMonitorDataResponse:
        """
        @summary Queries the monitoring data of an Elastic Compute Service (ECS) instance. The monitoring data can include the vCPU utilization, CPU credits of the burstable instance, amount of received data traffic, amount of sent data traffic, and average bandwidth.
        
        @description ## [](#)Usage notes
        Take note of the following items:
        Up to 400 monitoring data entries can be returned at a time. Make sure that the `TotalCount` value does not exceed 400. The value is calculated by using the following formula: `TotalCount = (EndTime - StartTime)/Period`. If the TotalCount value is greater than 400, the `InvalidParameter.TooManyDataQueried` error is returned.
        You can query the monitoring data in the last 30 days. If the value of `StartTime` is more than 30 days earlier than the current time, an error is returned.
        In some scenarios, such as when the instance is in the Stopped state, the system cannot obtain the relevant information and specific information may be missing from the returned monitoring data.
        You cannot call this operation to obtain the CPU basic monitoring information of an ECS bare metal instance. To obtain the CPU monitoring information of an ECS bare metal instance, install the CloudMonitor agent on the instance. For more information, see [InstallCloudMonitor](https://help.aliyun.com/document_detail/183482.html).
        
        @param request: DescribeInstanceMonitorDataRequest
        @return: DescribeInstanceMonitorDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_instance_monitor_data_with_options_async(request, runtime)

    def describe_instance_ram_role_with_options(
        self,
        request: ecs_20140526_models.DescribeInstanceRamRoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceRamRoleResponse:
        """
        @summary Queries the instance Resource Access Management (RAM) roles that are attached to Elastic Compute Service (ECS) instances based on the instance IDs, or queries the ECS instances to which a specific instance RAM role is attached based on the name of the instance RAM role.
        
        @description ## [](#)Usage notes
        When you call the API operation by using Alibaba Cloud CLI, you must specify request parameter values of different data types in the required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        
        @param request: DescribeInstanceRamRoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceRamRoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.ram_role_name):
            query['RamRoleName'] = request.ram_role_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceRamRole',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceRamRoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_instance_ram_role_with_options_async(
        self,
        request: ecs_20140526_models.DescribeInstanceRamRoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceRamRoleResponse:
        """
        @summary Queries the instance Resource Access Management (RAM) roles that are attached to Elastic Compute Service (ECS) instances based on the instance IDs, or queries the ECS instances to which a specific instance RAM role is attached based on the name of the instance RAM role.
        
        @description ## [](#)Usage notes
        When you call the API operation by using Alibaba Cloud CLI, you must specify request parameter values of different data types in the required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        
        @param request: DescribeInstanceRamRoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceRamRoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.ram_role_name):
            query['RamRoleName'] = request.ram_role_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceRamRole',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceRamRoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_instance_ram_role(
        self,
        request: ecs_20140526_models.DescribeInstanceRamRoleRequest,
    ) -> ecs_20140526_models.DescribeInstanceRamRoleResponse:
        """
        @summary Queries the instance Resource Access Management (RAM) roles that are attached to Elastic Compute Service (ECS) instances based on the instance IDs, or queries the ECS instances to which a specific instance RAM role is attached based on the name of the instance RAM role.
        
        @description ## [](#)Usage notes
        When you call the API operation by using Alibaba Cloud CLI, you must specify request parameter values of different data types in the required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        
        @param request: DescribeInstanceRamRoleRequest
        @return: DescribeInstanceRamRoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_instance_ram_role_with_options(request, runtime)

    async def describe_instance_ram_role_async(
        self,
        request: ecs_20140526_models.DescribeInstanceRamRoleRequest,
    ) -> ecs_20140526_models.DescribeInstanceRamRoleResponse:
        """
        @summary Queries the instance Resource Access Management (RAM) roles that are attached to Elastic Compute Service (ECS) instances based on the instance IDs, or queries the ECS instances to which a specific instance RAM role is attached based on the name of the instance RAM role.
        
        @description ## [](#)Usage notes
        When you call the API operation by using Alibaba Cloud CLI, you must specify request parameter values of different data types in the required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        
        @param request: DescribeInstanceRamRoleRequest
        @return: DescribeInstanceRamRoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_instance_ram_role_with_options_async(request, runtime)

    def describe_instance_status_with_options(
        self,
        request: ecs_20140526_models.DescribeInstanceStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceStatusResponse:
        """
        @summary Queries the status of one or more Elastic Compute Service (ECS) instances. You can also call this operation to query the list of ECS instances that match the specified filter conditions.
        
        @description For information about the lifecycle states of an ECS instance, see [Instance lifecycle](https://help.aliyun.com/document_detail/25687.html).
        ## [](#)Sample requests
        Query the ECS instances and the status of the instances in a **specific region**. Sample request:
        <!---->
        "RegionID": "cn-hangzhou"
        Query the ECS instances and the status of the instances in a **zone** of a **specific region**. Sample request:
        <!---->
        "RegionID": "cn-hangzhou",
        "ZoneID": "cn-hangzhou-a"
        Query the status of an ECS instance in a **specific region** based on the **instance ID**. Sample request:
        <!---->
        "RegionID": "cn-hangzhou",
        "InstancesID": ["i-bp1f7c1zqp999zvp***", "i-bp1dqjv36biueg61****"]
        
        @param request: DescribeInstanceStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceStatus',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceStatusResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_instance_status_with_options_async(
        self,
        request: ecs_20140526_models.DescribeInstanceStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceStatusResponse:
        """
        @summary Queries the status of one or more Elastic Compute Service (ECS) instances. You can also call this operation to query the list of ECS instances that match the specified filter conditions.
        
        @description For information about the lifecycle states of an ECS instance, see [Instance lifecycle](https://help.aliyun.com/document_detail/25687.html).
        ## [](#)Sample requests
        Query the ECS instances and the status of the instances in a **specific region**. Sample request:
        <!---->
        "RegionID": "cn-hangzhou"
        Query the ECS instances and the status of the instances in a **zone** of a **specific region**. Sample request:
        <!---->
        "RegionID": "cn-hangzhou",
        "ZoneID": "cn-hangzhou-a"
        Query the status of an ECS instance in a **specific region** based on the **instance ID**. Sample request:
        <!---->
        "RegionID": "cn-hangzhou",
        "InstancesID": ["i-bp1f7c1zqp999zvp***", "i-bp1dqjv36biueg61****"]
        
        @param request: DescribeInstanceStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceStatus',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceStatusResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_instance_status(
        self,
        request: ecs_20140526_models.DescribeInstanceStatusRequest,
    ) -> ecs_20140526_models.DescribeInstanceStatusResponse:
        """
        @summary Queries the status of one or more Elastic Compute Service (ECS) instances. You can also call this operation to query the list of ECS instances that match the specified filter conditions.
        
        @description For information about the lifecycle states of an ECS instance, see [Instance lifecycle](https://help.aliyun.com/document_detail/25687.html).
        ## [](#)Sample requests
        Query the ECS instances and the status of the instances in a **specific region**. Sample request:
        <!---->
        "RegionID": "cn-hangzhou"
        Query the ECS instances and the status of the instances in a **zone** of a **specific region**. Sample request:
        <!---->
        "RegionID": "cn-hangzhou",
        "ZoneID": "cn-hangzhou-a"
        Query the status of an ECS instance in a **specific region** based on the **instance ID**. Sample request:
        <!---->
        "RegionID": "cn-hangzhou",
        "InstancesID": ["i-bp1f7c1zqp999zvp***", "i-bp1dqjv36biueg61****"]
        
        @param request: DescribeInstanceStatusRequest
        @return: DescribeInstanceStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_instance_status_with_options(request, runtime)

    async def describe_instance_status_async(
        self,
        request: ecs_20140526_models.DescribeInstanceStatusRequest,
    ) -> ecs_20140526_models.DescribeInstanceStatusResponse:
        """
        @summary Queries the status of one or more Elastic Compute Service (ECS) instances. You can also call this operation to query the list of ECS instances that match the specified filter conditions.
        
        @description For information about the lifecycle states of an ECS instance, see [Instance lifecycle](https://help.aliyun.com/document_detail/25687.html).
        ## [](#)Sample requests
        Query the ECS instances and the status of the instances in a **specific region**. Sample request:
        <!---->
        "RegionID": "cn-hangzhou"
        Query the ECS instances and the status of the instances in a **zone** of a **specific region**. Sample request:
        <!---->
        "RegionID": "cn-hangzhou",
        "ZoneID": "cn-hangzhou-a"
        Query the status of an ECS instance in a **specific region** based on the **instance ID**. Sample request:
        <!---->
        "RegionID": "cn-hangzhou",
        "InstancesID": ["i-bp1f7c1zqp999zvp***", "i-bp1dqjv36biueg61****"]
        
        @param request: DescribeInstanceStatusRequest
        @return: DescribeInstanceStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_instance_status_with_options_async(request, runtime)

    def describe_instance_topology_with_options(
        self,
        request: ecs_20140526_models.DescribeInstanceTopologyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceTopologyResponse:
        """
        @summary Queries the topology of the host on which an Elastic Compute Service (ECS) instance resides.
        
        @param request: DescribeInstanceTopologyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceTopologyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceTopology',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceTopologyResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_instance_topology_with_options_async(
        self,
        request: ecs_20140526_models.DescribeInstanceTopologyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceTopologyResponse:
        """
        @summary Queries the topology of the host on which an Elastic Compute Service (ECS) instance resides.
        
        @param request: DescribeInstanceTopologyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceTopologyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceTopology',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceTopologyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_instance_topology(
        self,
        request: ecs_20140526_models.DescribeInstanceTopologyRequest,
    ) -> ecs_20140526_models.DescribeInstanceTopologyResponse:
        """
        @summary Queries the topology of the host on which an Elastic Compute Service (ECS) instance resides.
        
        @param request: DescribeInstanceTopologyRequest
        @return: DescribeInstanceTopologyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_instance_topology_with_options(request, runtime)

    async def describe_instance_topology_async(
        self,
        request: ecs_20140526_models.DescribeInstanceTopologyRequest,
    ) -> ecs_20140526_models.DescribeInstanceTopologyResponse:
        """
        @summary Queries the topology of the host on which an Elastic Compute Service (ECS) instance resides.
        
        @param request: DescribeInstanceTopologyRequest
        @return: DescribeInstanceTopologyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_instance_topology_with_options_async(request, runtime)

    def describe_instance_type_families_with_options(
        self,
        request: ecs_20140526_models.DescribeInstanceTypeFamiliesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceTypeFamiliesResponse:
        """
        @summary Queries the instance families provided by Elastic Compute Service (ECS). You can call the DescribeInstanceTypeFamilies operation to obtain information about different series of instance families. This helps you better understand the available instance types and choose appropriate instance types to create ECS instances.
        
        @param request: DescribeInstanceTypeFamiliesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceTypeFamiliesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.generation):
            query['Generation'] = request.generation
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceTypeFamilies',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceTypeFamiliesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_instance_type_families_with_options_async(
        self,
        request: ecs_20140526_models.DescribeInstanceTypeFamiliesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceTypeFamiliesResponse:
        """
        @summary Queries the instance families provided by Elastic Compute Service (ECS). You can call the DescribeInstanceTypeFamilies operation to obtain information about different series of instance families. This helps you better understand the available instance types and choose appropriate instance types to create ECS instances.
        
        @param request: DescribeInstanceTypeFamiliesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceTypeFamiliesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.generation):
            query['Generation'] = request.generation
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceTypeFamilies',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceTypeFamiliesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_instance_type_families(
        self,
        request: ecs_20140526_models.DescribeInstanceTypeFamiliesRequest,
    ) -> ecs_20140526_models.DescribeInstanceTypeFamiliesResponse:
        """
        @summary Queries the instance families provided by Elastic Compute Service (ECS). You can call the DescribeInstanceTypeFamilies operation to obtain information about different series of instance families. This helps you better understand the available instance types and choose appropriate instance types to create ECS instances.
        
        @param request: DescribeInstanceTypeFamiliesRequest
        @return: DescribeInstanceTypeFamiliesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_instance_type_families_with_options(request, runtime)

    async def describe_instance_type_families_async(
        self,
        request: ecs_20140526_models.DescribeInstanceTypeFamiliesRequest,
    ) -> ecs_20140526_models.DescribeInstanceTypeFamiliesResponse:
        """
        @summary Queries the instance families provided by Elastic Compute Service (ECS). You can call the DescribeInstanceTypeFamilies operation to obtain information about different series of instance families. This helps you better understand the available instance types and choose appropriate instance types to create ECS instances.
        
        @param request: DescribeInstanceTypeFamiliesRequest
        @return: DescribeInstanceTypeFamiliesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_instance_type_families_with_options_async(request, runtime)

    def describe_instance_types_with_options(
        self,
        request: ecs_20140526_models.DescribeInstanceTypesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceTypesResponse:
        """
        @summary Queries the details of all instance types or a specific instance type provided by Elastic Compute Service (ECS). You can understand the specifications and performance of instance types based on the response and select an instance type that meets your business requirements.
        
        @description    **Paged query**: You can set MaxResults to specify the maximum number of entries to return in a single call. If the number of entries to return exceeds the specified MaxResults value, the response includes a NextToken value. You can set NextToken to the return value and specify MaxResults in your next request to DescribeInstanceTypes to retrieve the next page of results.
        When you call this operation, if you do not set NextToken to paginate the results, only the first page of results is returned by default and includes a maximum of 100 entries. To retrieve further pages of results, set NextToken or pass filter conditions in your requests to DescribeInstanceTypes.
        >  MaxResults specifies the maximum number of entries per page. The maximum value of this parameter is changed from 1600 to 100 for all users as of November 15, 2023. If you called the DescribeInstanceTypes operation in 2022, you can use 1600 as the maximum value before November 15, 2023.
        The DescribeInstanceTypes operation is used to query only the specifications and performance information of instance types. To query instance types that are available in a specific region, call the [DescribeAvailableResource](https://help.aliyun.com/document_detail/66186.html) operation.
        To use special instance types such as instance types that are unavailable for purchase, [submit a ticket](https://smartservice.console.aliyun.com/service/create-ticket-intl).
        
        @param request: DescribeInstanceTypesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceTypesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cpu_architecture):
            query['CpuArchitecture'] = request.cpu_architecture
        if not UtilClient.is_unset(request.cpu_architectures):
            query['CpuArchitectures'] = request.cpu_architectures
        if not UtilClient.is_unset(request.gpuspec):
            query['GPUSpec'] = request.gpuspec
        if not UtilClient.is_unset(request.gpu_specs):
            query['GpuSpecs'] = request.gpu_specs
        if not UtilClient.is_unset(request.instance_categories):
            query['InstanceCategories'] = request.instance_categories
        if not UtilClient.is_unset(request.instance_category):
            query['InstanceCategory'] = request.instance_category
        if not UtilClient.is_unset(request.instance_family_level):
            query['InstanceFamilyLevel'] = request.instance_family_level
        if not UtilClient.is_unset(request.instance_type_families):
            query['InstanceTypeFamilies'] = request.instance_type_families
        if not UtilClient.is_unset(request.instance_type_family):
            query['InstanceTypeFamily'] = request.instance_type_family
        if not UtilClient.is_unset(request.instance_types):
            query['InstanceTypes'] = request.instance_types
        if not UtilClient.is_unset(request.local_storage_categories):
            query['LocalStorageCategories'] = request.local_storage_categories
        if not UtilClient.is_unset(request.local_storage_category):
            query['LocalStorageCategory'] = request.local_storage_category
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.maximum_cpu_core_count):
            query['MaximumCpuCoreCount'] = request.maximum_cpu_core_count
        if not UtilClient.is_unset(request.maximum_cpu_speed_frequency):
            query['MaximumCpuSpeedFrequency'] = request.maximum_cpu_speed_frequency
        if not UtilClient.is_unset(request.maximum_cpu_turbo_frequency):
            query['MaximumCpuTurboFrequency'] = request.maximum_cpu_turbo_frequency
        if not UtilClient.is_unset(request.maximum_gpuamount):
            query['MaximumGPUAmount'] = request.maximum_gpuamount
        if not UtilClient.is_unset(request.maximum_memory_size):
            query['MaximumMemorySize'] = request.maximum_memory_size
        if not UtilClient.is_unset(request.minimum_baseline_credit):
            query['MinimumBaselineCredit'] = request.minimum_baseline_credit
        if not UtilClient.is_unset(request.minimum_cpu_core_count):
            query['MinimumCpuCoreCount'] = request.minimum_cpu_core_count
        if not UtilClient.is_unset(request.minimum_cpu_speed_frequency):
            query['MinimumCpuSpeedFrequency'] = request.minimum_cpu_speed_frequency
        if not UtilClient.is_unset(request.minimum_cpu_turbo_frequency):
            query['MinimumCpuTurboFrequency'] = request.minimum_cpu_turbo_frequency
        if not UtilClient.is_unset(request.minimum_disk_quantity):
            query['MinimumDiskQuantity'] = request.minimum_disk_quantity
        if not UtilClient.is_unset(request.minimum_eni_ipv_6address_quantity):
            query['MinimumEniIpv6AddressQuantity'] = request.minimum_eni_ipv_6address_quantity
        if not UtilClient.is_unset(request.minimum_eni_private_ip_address_quantity):
            query['MinimumEniPrivateIpAddressQuantity'] = request.minimum_eni_private_ip_address_quantity
        if not UtilClient.is_unset(request.minimum_eni_quantity):
            query['MinimumEniQuantity'] = request.minimum_eni_quantity
        if not UtilClient.is_unset(request.minimum_eri_quantity):
            query['MinimumEriQuantity'] = request.minimum_eri_quantity
        if not UtilClient.is_unset(request.minimum_gpuamount):
            query['MinimumGPUAmount'] = request.minimum_gpuamount
        if not UtilClient.is_unset(request.minimum_initial_credit):
            query['MinimumInitialCredit'] = request.minimum_initial_credit
        if not UtilClient.is_unset(request.minimum_instance_bandwidth_rx):
            query['MinimumInstanceBandwidthRx'] = request.minimum_instance_bandwidth_rx
        if not UtilClient.is_unset(request.minimum_instance_bandwidth_tx):
            query['MinimumInstanceBandwidthTx'] = request.minimum_instance_bandwidth_tx
        if not UtilClient.is_unset(request.minimum_instance_pps_rx):
            query['MinimumInstancePpsRx'] = request.minimum_instance_pps_rx
        if not UtilClient.is_unset(request.minimum_instance_pps_tx):
            query['MinimumInstancePpsTx'] = request.minimum_instance_pps_tx
        if not UtilClient.is_unset(request.minimum_local_storage_amount):
            query['MinimumLocalStorageAmount'] = request.minimum_local_storage_amount
        if not UtilClient.is_unset(request.minimum_local_storage_capacity):
            query['MinimumLocalStorageCapacity'] = request.minimum_local_storage_capacity
        if not UtilClient.is_unset(request.minimum_memory_size):
            query['MinimumMemorySize'] = request.minimum_memory_size
        if not UtilClient.is_unset(request.minimum_primary_eni_queue_number):
            query['MinimumPrimaryEniQueueNumber'] = request.minimum_primary_eni_queue_number
        if not UtilClient.is_unset(request.minimum_queue_pair_number):
            query['MinimumQueuePairNumber'] = request.minimum_queue_pair_number
        if not UtilClient.is_unset(request.minimum_secondary_eni_queue_number):
            query['MinimumSecondaryEniQueueNumber'] = request.minimum_secondary_eni_queue_number
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.nvme_support):
            query['NvmeSupport'] = request.nvme_support
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_processor_model):
            query['PhysicalProcessorModel'] = request.physical_processor_model
        if not UtilClient.is_unset(request.physical_processor_models):
            query['PhysicalProcessorModels'] = request.physical_processor_models
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceTypes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceTypesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_instance_types_with_options_async(
        self,
        request: ecs_20140526_models.DescribeInstanceTypesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceTypesResponse:
        """
        @summary Queries the details of all instance types or a specific instance type provided by Elastic Compute Service (ECS). You can understand the specifications and performance of instance types based on the response and select an instance type that meets your business requirements.
        
        @description    **Paged query**: You can set MaxResults to specify the maximum number of entries to return in a single call. If the number of entries to return exceeds the specified MaxResults value, the response includes a NextToken value. You can set NextToken to the return value and specify MaxResults in your next request to DescribeInstanceTypes to retrieve the next page of results.
        When you call this operation, if you do not set NextToken to paginate the results, only the first page of results is returned by default and includes a maximum of 100 entries. To retrieve further pages of results, set NextToken or pass filter conditions in your requests to DescribeInstanceTypes.
        >  MaxResults specifies the maximum number of entries per page. The maximum value of this parameter is changed from 1600 to 100 for all users as of November 15, 2023. If you called the DescribeInstanceTypes operation in 2022, you can use 1600 as the maximum value before November 15, 2023.
        The DescribeInstanceTypes operation is used to query only the specifications and performance information of instance types. To query instance types that are available in a specific region, call the [DescribeAvailableResource](https://help.aliyun.com/document_detail/66186.html) operation.
        To use special instance types such as instance types that are unavailable for purchase, [submit a ticket](https://smartservice.console.aliyun.com/service/create-ticket-intl).
        
        @param request: DescribeInstanceTypesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceTypesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cpu_architecture):
            query['CpuArchitecture'] = request.cpu_architecture
        if not UtilClient.is_unset(request.cpu_architectures):
            query['CpuArchitectures'] = request.cpu_architectures
        if not UtilClient.is_unset(request.gpuspec):
            query['GPUSpec'] = request.gpuspec
        if not UtilClient.is_unset(request.gpu_specs):
            query['GpuSpecs'] = request.gpu_specs
        if not UtilClient.is_unset(request.instance_categories):
            query['InstanceCategories'] = request.instance_categories
        if not UtilClient.is_unset(request.instance_category):
            query['InstanceCategory'] = request.instance_category
        if not UtilClient.is_unset(request.instance_family_level):
            query['InstanceFamilyLevel'] = request.instance_family_level
        if not UtilClient.is_unset(request.instance_type_families):
            query['InstanceTypeFamilies'] = request.instance_type_families
        if not UtilClient.is_unset(request.instance_type_family):
            query['InstanceTypeFamily'] = request.instance_type_family
        if not UtilClient.is_unset(request.instance_types):
            query['InstanceTypes'] = request.instance_types
        if not UtilClient.is_unset(request.local_storage_categories):
            query['LocalStorageCategories'] = request.local_storage_categories
        if not UtilClient.is_unset(request.local_storage_category):
            query['LocalStorageCategory'] = request.local_storage_category
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.maximum_cpu_core_count):
            query['MaximumCpuCoreCount'] = request.maximum_cpu_core_count
        if not UtilClient.is_unset(request.maximum_cpu_speed_frequency):
            query['MaximumCpuSpeedFrequency'] = request.maximum_cpu_speed_frequency
        if not UtilClient.is_unset(request.maximum_cpu_turbo_frequency):
            query['MaximumCpuTurboFrequency'] = request.maximum_cpu_turbo_frequency
        if not UtilClient.is_unset(request.maximum_gpuamount):
            query['MaximumGPUAmount'] = request.maximum_gpuamount
        if not UtilClient.is_unset(request.maximum_memory_size):
            query['MaximumMemorySize'] = request.maximum_memory_size
        if not UtilClient.is_unset(request.minimum_baseline_credit):
            query['MinimumBaselineCredit'] = request.minimum_baseline_credit
        if not UtilClient.is_unset(request.minimum_cpu_core_count):
            query['MinimumCpuCoreCount'] = request.minimum_cpu_core_count
        if not UtilClient.is_unset(request.minimum_cpu_speed_frequency):
            query['MinimumCpuSpeedFrequency'] = request.minimum_cpu_speed_frequency
        if not UtilClient.is_unset(request.minimum_cpu_turbo_frequency):
            query['MinimumCpuTurboFrequency'] = request.minimum_cpu_turbo_frequency
        if not UtilClient.is_unset(request.minimum_disk_quantity):
            query['MinimumDiskQuantity'] = request.minimum_disk_quantity
        if not UtilClient.is_unset(request.minimum_eni_ipv_6address_quantity):
            query['MinimumEniIpv6AddressQuantity'] = request.minimum_eni_ipv_6address_quantity
        if not UtilClient.is_unset(request.minimum_eni_private_ip_address_quantity):
            query['MinimumEniPrivateIpAddressQuantity'] = request.minimum_eni_private_ip_address_quantity
        if not UtilClient.is_unset(request.minimum_eni_quantity):
            query['MinimumEniQuantity'] = request.minimum_eni_quantity
        if not UtilClient.is_unset(request.minimum_eri_quantity):
            query['MinimumEriQuantity'] = request.minimum_eri_quantity
        if not UtilClient.is_unset(request.minimum_gpuamount):
            query['MinimumGPUAmount'] = request.minimum_gpuamount
        if not UtilClient.is_unset(request.minimum_initial_credit):
            query['MinimumInitialCredit'] = request.minimum_initial_credit
        if not UtilClient.is_unset(request.minimum_instance_bandwidth_rx):
            query['MinimumInstanceBandwidthRx'] = request.minimum_instance_bandwidth_rx
        if not UtilClient.is_unset(request.minimum_instance_bandwidth_tx):
            query['MinimumInstanceBandwidthTx'] = request.minimum_instance_bandwidth_tx
        if not UtilClient.is_unset(request.minimum_instance_pps_rx):
            query['MinimumInstancePpsRx'] = request.minimum_instance_pps_rx
        if not UtilClient.is_unset(request.minimum_instance_pps_tx):
            query['MinimumInstancePpsTx'] = request.minimum_instance_pps_tx
        if not UtilClient.is_unset(request.minimum_local_storage_amount):
            query['MinimumLocalStorageAmount'] = request.minimum_local_storage_amount
        if not UtilClient.is_unset(request.minimum_local_storage_capacity):
            query['MinimumLocalStorageCapacity'] = request.minimum_local_storage_capacity
        if not UtilClient.is_unset(request.minimum_memory_size):
            query['MinimumMemorySize'] = request.minimum_memory_size
        if not UtilClient.is_unset(request.minimum_primary_eni_queue_number):
            query['MinimumPrimaryEniQueueNumber'] = request.minimum_primary_eni_queue_number
        if not UtilClient.is_unset(request.minimum_queue_pair_number):
            query['MinimumQueuePairNumber'] = request.minimum_queue_pair_number
        if not UtilClient.is_unset(request.minimum_secondary_eni_queue_number):
            query['MinimumSecondaryEniQueueNumber'] = request.minimum_secondary_eni_queue_number
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.nvme_support):
            query['NvmeSupport'] = request.nvme_support
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_processor_model):
            query['PhysicalProcessorModel'] = request.physical_processor_model
        if not UtilClient.is_unset(request.physical_processor_models):
            query['PhysicalProcessorModels'] = request.physical_processor_models
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceTypes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceTypesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_instance_types(
        self,
        request: ecs_20140526_models.DescribeInstanceTypesRequest,
    ) -> ecs_20140526_models.DescribeInstanceTypesResponse:
        """
        @summary Queries the details of all instance types or a specific instance type provided by Elastic Compute Service (ECS). You can understand the specifications and performance of instance types based on the response and select an instance type that meets your business requirements.
        
        @description    **Paged query**: You can set MaxResults to specify the maximum number of entries to return in a single call. If the number of entries to return exceeds the specified MaxResults value, the response includes a NextToken value. You can set NextToken to the return value and specify MaxResults in your next request to DescribeInstanceTypes to retrieve the next page of results.
        When you call this operation, if you do not set NextToken to paginate the results, only the first page of results is returned by default and includes a maximum of 100 entries. To retrieve further pages of results, set NextToken or pass filter conditions in your requests to DescribeInstanceTypes.
        >  MaxResults specifies the maximum number of entries per page. The maximum value of this parameter is changed from 1600 to 100 for all users as of November 15, 2023. If you called the DescribeInstanceTypes operation in 2022, you can use 1600 as the maximum value before November 15, 2023.
        The DescribeInstanceTypes operation is used to query only the specifications and performance information of instance types. To query instance types that are available in a specific region, call the [DescribeAvailableResource](https://help.aliyun.com/document_detail/66186.html) operation.
        To use special instance types such as instance types that are unavailable for purchase, [submit a ticket](https://smartservice.console.aliyun.com/service/create-ticket-intl).
        
        @param request: DescribeInstanceTypesRequest
        @return: DescribeInstanceTypesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_instance_types_with_options(request, runtime)

    async def describe_instance_types_async(
        self,
        request: ecs_20140526_models.DescribeInstanceTypesRequest,
    ) -> ecs_20140526_models.DescribeInstanceTypesResponse:
        """
        @summary Queries the details of all instance types or a specific instance type provided by Elastic Compute Service (ECS). You can understand the specifications and performance of instance types based on the response and select an instance type that meets your business requirements.
        
        @description    **Paged query**: You can set MaxResults to specify the maximum number of entries to return in a single call. If the number of entries to return exceeds the specified MaxResults value, the response includes a NextToken value. You can set NextToken to the return value and specify MaxResults in your next request to DescribeInstanceTypes to retrieve the next page of results.
        When you call this operation, if you do not set NextToken to paginate the results, only the first page of results is returned by default and includes a maximum of 100 entries. To retrieve further pages of results, set NextToken or pass filter conditions in your requests to DescribeInstanceTypes.
        >  MaxResults specifies the maximum number of entries per page. The maximum value of this parameter is changed from 1600 to 100 for all users as of November 15, 2023. If you called the DescribeInstanceTypes operation in 2022, you can use 1600 as the maximum value before November 15, 2023.
        The DescribeInstanceTypes operation is used to query only the specifications and performance information of instance types. To query instance types that are available in a specific region, call the [DescribeAvailableResource](https://help.aliyun.com/document_detail/66186.html) operation.
        To use special instance types such as instance types that are unavailable for purchase, [submit a ticket](https://smartservice.console.aliyun.com/service/create-ticket-intl).
        
        @param request: DescribeInstanceTypesRequest
        @return: DescribeInstanceTypesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_instance_types_with_options_async(request, runtime)

    def describe_instance_vnc_url_with_options(
        self,
        request: ecs_20140526_models.DescribeInstanceVncUrlRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceVncUrlResponse:
        """
        @summary Queries the Virtual Network Computing (VNC) logon address of an Elastic Compute Service (ECS) instance.
        
        @description    You cannot directly use the VNC logon address (VncUrl) in the response to log on to an ECS instance. To log on to the ECS instance, you can use the **web management terminal URL** that contains the VNC logon address.
        >  To construct a web management terminal URL, add the `vncUrl=\\\\*\\*\\*`, `instanceId=****`, and `isWindows=true/false` parameters at the end of `https://g.alicdn.com/aliyun/ecs-console-vnc2/0.0.8/index.html?`. Separate each parameter with an ampersand (`&`). Parameter description:
        `vncUrl`: the VNC logon address.
        `instanceId`: the instance ID.
        `isWindows`: specifies whether the operating system of your ECS instance is Windows. A value of `true` specifies that the operating system is Windows. A value of `false` specifies that the operating system is not Windows.
        You can connect to an ECS instance without using a VNC logon password. Therefore, you do not need to specify the `password` parameter.
        The keepalive time of a connection to a VNC management terminal is 300 seconds. If you do not interact with the VNC management terminal within 300 seconds, the VNC management terminal is automatically disconnected.
        If the connection is interrupted, you must call the DescribeInstanceVncUrl operation to obtain a new VNC logon address (`VncUrl`) and use the new logon address to construct a new web management terminal URL that you can use to reconnect to the VNC management terminal. You can reconnect to a VNC management terminal up to 30 times per minute.
        Sample web management terminal URL:
        https://g.alicdn.com/aliyun/ecs-console-vnc2/0.0.8/index.html?vncUrl=ws%3A%2F%***&instanceId=i-wz9hhwq5a6tm****&isWindows=true
        
        @param request: DescribeInstanceVncUrlRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceVncUrlResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceVncUrl',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceVncUrlResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_instance_vnc_url_with_options_async(
        self,
        request: ecs_20140526_models.DescribeInstanceVncUrlRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstanceVncUrlResponse:
        """
        @summary Queries the Virtual Network Computing (VNC) logon address of an Elastic Compute Service (ECS) instance.
        
        @description    You cannot directly use the VNC logon address (VncUrl) in the response to log on to an ECS instance. To log on to the ECS instance, you can use the **web management terminal URL** that contains the VNC logon address.
        >  To construct a web management terminal URL, add the `vncUrl=\\\\*\\*\\*`, `instanceId=****`, and `isWindows=true/false` parameters at the end of `https://g.alicdn.com/aliyun/ecs-console-vnc2/0.0.8/index.html?`. Separate each parameter with an ampersand (`&`). Parameter description:
        `vncUrl`: the VNC logon address.
        `instanceId`: the instance ID.
        `isWindows`: specifies whether the operating system of your ECS instance is Windows. A value of `true` specifies that the operating system is Windows. A value of `false` specifies that the operating system is not Windows.
        You can connect to an ECS instance without using a VNC logon password. Therefore, you do not need to specify the `password` parameter.
        The keepalive time of a connection to a VNC management terminal is 300 seconds. If you do not interact with the VNC management terminal within 300 seconds, the VNC management terminal is automatically disconnected.
        If the connection is interrupted, you must call the DescribeInstanceVncUrl operation to obtain a new VNC logon address (`VncUrl`) and use the new logon address to construct a new web management terminal URL that you can use to reconnect to the VNC management terminal. You can reconnect to a VNC management terminal up to 30 times per minute.
        Sample web management terminal URL:
        https://g.alicdn.com/aliyun/ecs-console-vnc2/0.0.8/index.html?vncUrl=ws%3A%2F%***&instanceId=i-wz9hhwq5a6tm****&isWindows=true
        
        @param request: DescribeInstanceVncUrlRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstanceVncUrlResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstanceVncUrl',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstanceVncUrlResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_instance_vnc_url(
        self,
        request: ecs_20140526_models.DescribeInstanceVncUrlRequest,
    ) -> ecs_20140526_models.DescribeInstanceVncUrlResponse:
        """
        @summary Queries the Virtual Network Computing (VNC) logon address of an Elastic Compute Service (ECS) instance.
        
        @description    You cannot directly use the VNC logon address (VncUrl) in the response to log on to an ECS instance. To log on to the ECS instance, you can use the **web management terminal URL** that contains the VNC logon address.
        >  To construct a web management terminal URL, add the `vncUrl=\\\\*\\*\\*`, `instanceId=****`, and `isWindows=true/false` parameters at the end of `https://g.alicdn.com/aliyun/ecs-console-vnc2/0.0.8/index.html?`. Separate each parameter with an ampersand (`&`). Parameter description:
        `vncUrl`: the VNC logon address.
        `instanceId`: the instance ID.
        `isWindows`: specifies whether the operating system of your ECS instance is Windows. A value of `true` specifies that the operating system is Windows. A value of `false` specifies that the operating system is not Windows.
        You can connect to an ECS instance without using a VNC logon password. Therefore, you do not need to specify the `password` parameter.
        The keepalive time of a connection to a VNC management terminal is 300 seconds. If you do not interact with the VNC management terminal within 300 seconds, the VNC management terminal is automatically disconnected.
        If the connection is interrupted, you must call the DescribeInstanceVncUrl operation to obtain a new VNC logon address (`VncUrl`) and use the new logon address to construct a new web management terminal URL that you can use to reconnect to the VNC management terminal. You can reconnect to a VNC management terminal up to 30 times per minute.
        Sample web management terminal URL:
        https://g.alicdn.com/aliyun/ecs-console-vnc2/0.0.8/index.html?vncUrl=ws%3A%2F%***&instanceId=i-wz9hhwq5a6tm****&isWindows=true
        
        @param request: DescribeInstanceVncUrlRequest
        @return: DescribeInstanceVncUrlResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_instance_vnc_url_with_options(request, runtime)

    async def describe_instance_vnc_url_async(
        self,
        request: ecs_20140526_models.DescribeInstanceVncUrlRequest,
    ) -> ecs_20140526_models.DescribeInstanceVncUrlResponse:
        """
        @summary Queries the Virtual Network Computing (VNC) logon address of an Elastic Compute Service (ECS) instance.
        
        @description    You cannot directly use the VNC logon address (VncUrl) in the response to log on to an ECS instance. To log on to the ECS instance, you can use the **web management terminal URL** that contains the VNC logon address.
        >  To construct a web management terminal URL, add the `vncUrl=\\\\*\\*\\*`, `instanceId=****`, and `isWindows=true/false` parameters at the end of `https://g.alicdn.com/aliyun/ecs-console-vnc2/0.0.8/index.html?`. Separate each parameter with an ampersand (`&`). Parameter description:
        `vncUrl`: the VNC logon address.
        `instanceId`: the instance ID.
        `isWindows`: specifies whether the operating system of your ECS instance is Windows. A value of `true` specifies that the operating system is Windows. A value of `false` specifies that the operating system is not Windows.
        You can connect to an ECS instance without using a VNC logon password. Therefore, you do not need to specify the `password` parameter.
        The keepalive time of a connection to a VNC management terminal is 300 seconds. If you do not interact with the VNC management terminal within 300 seconds, the VNC management terminal is automatically disconnected.
        If the connection is interrupted, you must call the DescribeInstanceVncUrl operation to obtain a new VNC logon address (`VncUrl`) and use the new logon address to construct a new web management terminal URL that you can use to reconnect to the VNC management terminal. You can reconnect to a VNC management terminal up to 30 times per minute.
        Sample web management terminal URL:
        https://g.alicdn.com/aliyun/ecs-console-vnc2/0.0.8/index.html?vncUrl=ws%3A%2F%***&instanceId=i-wz9hhwq5a6tm****&isWindows=true
        
        @param request: DescribeInstanceVncUrlRequest
        @return: DescribeInstanceVncUrlResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_instance_vnc_url_with_options_async(request, runtime)

    def describe_instances_with_options(
        self,
        request: ecs_20140526_models.DescribeInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstancesResponse:
        """
        @summary Queries Elastic Compute Service (ECS) instances by various filter conditions. The details of the queried ECS instances are returned in the response.
        
        @description ### [](#)Limits
        When you call the API operation by using Alibaba Cloud CLI, you must specify request parameter values of different data types in the required formats. For more information, see [Parameter format overview](https://help.aliyun.com/document_detail/110340.html).
        If you use a Resource Access Management (RAM) user or RAM role that does not have the permissions to call this operation, an empty list is returned.
        ### [](#)Suggestions
        Specify DryRun in the request to perform a dry run. In the dry run, the system checks the validity and authorization status of the parameters.
        During a paged query, when you call the DescribeInstances operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeInstances operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.additional_attributes):
            query['AdditionalAttributes'] = request.additional_attributes
        if not UtilClient.is_unset(request.device_available):
            query['DeviceAvailable'] = request.device_available
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.eip_addresses):
            query['EipAddresses'] = request.eip_addresses
        if not UtilClient.is_unset(request.hpc_cluster_id):
            query['HpcClusterId'] = request.hpc_cluster_id
        if not UtilClient.is_unset(request.http_endpoint):
            query['HttpEndpoint'] = request.http_endpoint
        if not UtilClient.is_unset(request.http_put_response_hop_limit):
            query['HttpPutResponseHopLimit'] = request.http_put_response_hop_limit
        if not UtilClient.is_unset(request.http_tokens):
            query['HttpTokens'] = request.http_tokens
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.inner_ip_addresses):
            query['InnerIpAddresses'] = request.inner_ip_addresses
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.instance_network_type):
            query['InstanceNetworkType'] = request.instance_network_type
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.instance_type_family):
            query['InstanceTypeFamily'] = request.instance_type_family
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.io_optimized):
            query['IoOptimized'] = request.io_optimized
        if not UtilClient.is_unset(request.ipv_6address):
            query['Ipv6Address'] = request.ipv_6address
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.lock_reason):
            query['LockReason'] = request.lock_reason
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.need_sale_cycle):
            query['NeedSaleCycle'] = request.need_sale_cycle
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.private_ip_addresses):
            query['PrivateIpAddresses'] = request.private_ip_addresses
        if not UtilClient.is_unset(request.public_ip_addresses):
            query['PublicIpAddresses'] = request.public_ip_addresses
        if not UtilClient.is_unset(request.rdma_ip_addresses):
            query['RdmaIpAddresses'] = request.rdma_ip_addresses
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_instances_with_options_async(
        self,
        request: ecs_20140526_models.DescribeInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstancesResponse:
        """
        @summary Queries Elastic Compute Service (ECS) instances by various filter conditions. The details of the queried ECS instances are returned in the response.
        
        @description ### [](#)Limits
        When you call the API operation by using Alibaba Cloud CLI, you must specify request parameter values of different data types in the required formats. For more information, see [Parameter format overview](https://help.aliyun.com/document_detail/110340.html).
        If you use a Resource Access Management (RAM) user or RAM role that does not have the permissions to call this operation, an empty list is returned.
        ### [](#)Suggestions
        Specify DryRun in the request to perform a dry run. In the dry run, the system checks the validity and authorization status of the parameters.
        During a paged query, when you call the DescribeInstances operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeInstances operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.additional_attributes):
            query['AdditionalAttributes'] = request.additional_attributes
        if not UtilClient.is_unset(request.device_available):
            query['DeviceAvailable'] = request.device_available
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.eip_addresses):
            query['EipAddresses'] = request.eip_addresses
        if not UtilClient.is_unset(request.hpc_cluster_id):
            query['HpcClusterId'] = request.hpc_cluster_id
        if not UtilClient.is_unset(request.http_endpoint):
            query['HttpEndpoint'] = request.http_endpoint
        if not UtilClient.is_unset(request.http_put_response_hop_limit):
            query['HttpPutResponseHopLimit'] = request.http_put_response_hop_limit
        if not UtilClient.is_unset(request.http_tokens):
            query['HttpTokens'] = request.http_tokens
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.inner_ip_addresses):
            query['InnerIpAddresses'] = request.inner_ip_addresses
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.instance_network_type):
            query['InstanceNetworkType'] = request.instance_network_type
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.instance_type_family):
            query['InstanceTypeFamily'] = request.instance_type_family
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.io_optimized):
            query['IoOptimized'] = request.io_optimized
        if not UtilClient.is_unset(request.ipv_6address):
            query['Ipv6Address'] = request.ipv_6address
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.lock_reason):
            query['LockReason'] = request.lock_reason
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.need_sale_cycle):
            query['NeedSaleCycle'] = request.need_sale_cycle
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.private_ip_addresses):
            query['PrivateIpAddresses'] = request.private_ip_addresses
        if not UtilClient.is_unset(request.public_ip_addresses):
            query['PublicIpAddresses'] = request.public_ip_addresses
        if not UtilClient.is_unset(request.rdma_ip_addresses):
            query['RdmaIpAddresses'] = request.rdma_ip_addresses
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_instances(
        self,
        request: ecs_20140526_models.DescribeInstancesRequest,
    ) -> ecs_20140526_models.DescribeInstancesResponse:
        """
        @summary Queries Elastic Compute Service (ECS) instances by various filter conditions. The details of the queried ECS instances are returned in the response.
        
        @description ### [](#)Limits
        When you call the API operation by using Alibaba Cloud CLI, you must specify request parameter values of different data types in the required formats. For more information, see [Parameter format overview](https://help.aliyun.com/document_detail/110340.html).
        If you use a Resource Access Management (RAM) user or RAM role that does not have the permissions to call this operation, an empty list is returned.
        ### [](#)Suggestions
        Specify DryRun in the request to perform a dry run. In the dry run, the system checks the validity and authorization status of the parameters.
        During a paged query, when you call the DescribeInstances operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeInstances operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeInstancesRequest
        @return: DescribeInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_instances_with_options(request, runtime)

    async def describe_instances_async(
        self,
        request: ecs_20140526_models.DescribeInstancesRequest,
    ) -> ecs_20140526_models.DescribeInstancesResponse:
        """
        @summary Queries Elastic Compute Service (ECS) instances by various filter conditions. The details of the queried ECS instances are returned in the response.
        
        @description ### [](#)Limits
        When you call the API operation by using Alibaba Cloud CLI, you must specify request parameter values of different data types in the required formats. For more information, see [Parameter format overview](https://help.aliyun.com/document_detail/110340.html).
        If you use a Resource Access Management (RAM) user or RAM role that does not have the permissions to call this operation, an empty list is returned.
        ### [](#)Suggestions
        Specify DryRun in the request to perform a dry run. In the dry run, the system checks the validity and authorization status of the parameters.
        During a paged query, when you call the DescribeInstances operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeInstances operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeInstancesRequest
        @return: DescribeInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_instances_with_options_async(request, runtime)

    def describe_instances_full_status_with_options(
        self,
        request: ecs_20140526_models.DescribeInstancesFullStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstancesFullStatusResponse:
        """
        @summary Queries the full status information of one or more Elastic Compute Service (ECS) instances. The full status information includes the instance status and the status of instance system events. The instance status is the lifecycle status of instances. The status of instance system events is the health status of maintenance events.
        
        @description ## [](#)Usage notes
        The response includes the instance status and the instance system events that are in the Scheduled state.
        You can specify a period of time to query events that occurred within the period of time.
        
        @param request: DescribeInstancesFullStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstancesFullStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.event_id):
            query['EventId'] = request.event_id
        if not UtilClient.is_unset(request.event_type):
            query['EventType'] = request.event_type
        if not UtilClient.is_unset(request.health_status):
            query['HealthStatus'] = request.health_status
        if not UtilClient.is_unset(request.instance_event_type):
            query['InstanceEventType'] = request.instance_event_type
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.event_publish_time):
            query['EventPublishTime'] = request.event_publish_time
        if not UtilClient.is_unset(request.not_before):
            query['NotBefore'] = request.not_before
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstancesFullStatus',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstancesFullStatusResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_instances_full_status_with_options_async(
        self,
        request: ecs_20140526_models.DescribeInstancesFullStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInstancesFullStatusResponse:
        """
        @summary Queries the full status information of one or more Elastic Compute Service (ECS) instances. The full status information includes the instance status and the status of instance system events. The instance status is the lifecycle status of instances. The status of instance system events is the health status of maintenance events.
        
        @description ## [](#)Usage notes
        The response includes the instance status and the instance system events that are in the Scheduled state.
        You can specify a period of time to query events that occurred within the period of time.
        
        @param request: DescribeInstancesFullStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInstancesFullStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.event_id):
            query['EventId'] = request.event_id
        if not UtilClient.is_unset(request.event_type):
            query['EventType'] = request.event_type
        if not UtilClient.is_unset(request.health_status):
            query['HealthStatus'] = request.health_status
        if not UtilClient.is_unset(request.instance_event_type):
            query['InstanceEventType'] = request.instance_event_type
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.event_publish_time):
            query['EventPublishTime'] = request.event_publish_time
        if not UtilClient.is_unset(request.not_before):
            query['NotBefore'] = request.not_before
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInstancesFullStatus',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInstancesFullStatusResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_instances_full_status(
        self,
        request: ecs_20140526_models.DescribeInstancesFullStatusRequest,
    ) -> ecs_20140526_models.DescribeInstancesFullStatusResponse:
        """
        @summary Queries the full status information of one or more Elastic Compute Service (ECS) instances. The full status information includes the instance status and the status of instance system events. The instance status is the lifecycle status of instances. The status of instance system events is the health status of maintenance events.
        
        @description ## [](#)Usage notes
        The response includes the instance status and the instance system events that are in the Scheduled state.
        You can specify a period of time to query events that occurred within the period of time.
        
        @param request: DescribeInstancesFullStatusRequest
        @return: DescribeInstancesFullStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_instances_full_status_with_options(request, runtime)

    async def describe_instances_full_status_async(
        self,
        request: ecs_20140526_models.DescribeInstancesFullStatusRequest,
    ) -> ecs_20140526_models.DescribeInstancesFullStatusResponse:
        """
        @summary Queries the full status information of one or more Elastic Compute Service (ECS) instances. The full status information includes the instance status and the status of instance system events. The instance status is the lifecycle status of instances. The status of instance system events is the health status of maintenance events.
        
        @description ## [](#)Usage notes
        The response includes the instance status and the instance system events that are in the Scheduled state.
        You can specify a period of time to query events that occurred within the period of time.
        
        @param request: DescribeInstancesFullStatusRequest
        @return: DescribeInstancesFullStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_instances_full_status_with_options_async(request, runtime)

    def describe_invocation_results_with_options(
        self,
        request: ecs_20140526_models.DescribeInvocationResultsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInvocationResultsResponse:
        """
        @summary Queries the execution results of one or more Cloud Assistant commands on Elastic Compute Service (ECS) instances.
        
        @description ## [](#)Usage notes
        After you run a command, the command may fail to run or may return unexpected results. You can call this operation to query the execution results.
        You can query information about command executions within the last four weeks. Up to 100,000 pieces of execution information can be retained.
        You can [subscribe to Cloud Assistant task status events](https://help.aliyun.com/document_detail/2669130.html) to obtain command execution results from the events. This helps you reduce the number of times to poll API operations and improve efficiency.
        During a paged query, when you call the DescribeInvocationResults operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeInvocationResults operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        Comparison between the `DescribeInvocations` and `DescribeInvocationResults` operations:
        Scenario in which the `RunCommand` or `InvokeCommand` operation is called to run a Cloud Assistant command on multiple instances:
        The `DescribeInvocations` operation queries the execution status of the command on each instance and the overall execution status of the command on all instances.
        The `DescribeInvocationResults` operation queries only the execution status of the command on each instance.
        Scenario in which the `RunCommand` or `InvokeCommand` operation is called to run a Cloud Assistant command on a single instance:
        The `DescribeInvocations` operation is equivalent to the `DescribeInvocationResults` operation.
        If you want to query the status of each execution for a scheduled (recurring) task or a task that is automatically executed on instance startup (`RepeatMode is set to Period or EveryReboot`), you can call only the `DescribeInvocationResults` operation and must set `IncludeHistory` to true. The `DescribeInvocations` operation queries only the most recent execution status of the command.
        If you want to view the command content and parameters, you can call only the `DescribeInvocations` operation and check the `CommandContent` value in the response.
        
        @param request: DescribeInvocationResultsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInvocationResultsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.command_id):
            query['CommandId'] = request.command_id
        if not UtilClient.is_unset(request.content_encoding):
            query['ContentEncoding'] = request.content_encoding
        if not UtilClient.is_unset(request.include_history):
            query['IncludeHistory'] = request.include_history
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.invoke_id):
            query['InvokeId'] = request.invoke_id
        if not UtilClient.is_unset(request.invoke_record_status):
            query['InvokeRecordStatus'] = request.invoke_record_status
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInvocationResults',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInvocationResultsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_invocation_results_with_options_async(
        self,
        request: ecs_20140526_models.DescribeInvocationResultsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInvocationResultsResponse:
        """
        @summary Queries the execution results of one or more Cloud Assistant commands on Elastic Compute Service (ECS) instances.
        
        @description ## [](#)Usage notes
        After you run a command, the command may fail to run or may return unexpected results. You can call this operation to query the execution results.
        You can query information about command executions within the last four weeks. Up to 100,000 pieces of execution information can be retained.
        You can [subscribe to Cloud Assistant task status events](https://help.aliyun.com/document_detail/2669130.html) to obtain command execution results from the events. This helps you reduce the number of times to poll API operations and improve efficiency.
        During a paged query, when you call the DescribeInvocationResults operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeInvocationResults operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        Comparison between the `DescribeInvocations` and `DescribeInvocationResults` operations:
        Scenario in which the `RunCommand` or `InvokeCommand` operation is called to run a Cloud Assistant command on multiple instances:
        The `DescribeInvocations` operation queries the execution status of the command on each instance and the overall execution status of the command on all instances.
        The `DescribeInvocationResults` operation queries only the execution status of the command on each instance.
        Scenario in which the `RunCommand` or `InvokeCommand` operation is called to run a Cloud Assistant command on a single instance:
        The `DescribeInvocations` operation is equivalent to the `DescribeInvocationResults` operation.
        If you want to query the status of each execution for a scheduled (recurring) task or a task that is automatically executed on instance startup (`RepeatMode is set to Period or EveryReboot`), you can call only the `DescribeInvocationResults` operation and must set `IncludeHistory` to true. The `DescribeInvocations` operation queries only the most recent execution status of the command.
        If you want to view the command content and parameters, you can call only the `DescribeInvocations` operation and check the `CommandContent` value in the response.
        
        @param request: DescribeInvocationResultsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInvocationResultsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.command_id):
            query['CommandId'] = request.command_id
        if not UtilClient.is_unset(request.content_encoding):
            query['ContentEncoding'] = request.content_encoding
        if not UtilClient.is_unset(request.include_history):
            query['IncludeHistory'] = request.include_history
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.invoke_id):
            query['InvokeId'] = request.invoke_id
        if not UtilClient.is_unset(request.invoke_record_status):
            query['InvokeRecordStatus'] = request.invoke_record_status
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInvocationResults',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInvocationResultsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_invocation_results(
        self,
        request: ecs_20140526_models.DescribeInvocationResultsRequest,
    ) -> ecs_20140526_models.DescribeInvocationResultsResponse:
        """
        @summary Queries the execution results of one or more Cloud Assistant commands on Elastic Compute Service (ECS) instances.
        
        @description ## [](#)Usage notes
        After you run a command, the command may fail to run or may return unexpected results. You can call this operation to query the execution results.
        You can query information about command executions within the last four weeks. Up to 100,000 pieces of execution information can be retained.
        You can [subscribe to Cloud Assistant task status events](https://help.aliyun.com/document_detail/2669130.html) to obtain command execution results from the events. This helps you reduce the number of times to poll API operations and improve efficiency.
        During a paged query, when you call the DescribeInvocationResults operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeInvocationResults operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        Comparison between the `DescribeInvocations` and `DescribeInvocationResults` operations:
        Scenario in which the `RunCommand` or `InvokeCommand` operation is called to run a Cloud Assistant command on multiple instances:
        The `DescribeInvocations` operation queries the execution status of the command on each instance and the overall execution status of the command on all instances.
        The `DescribeInvocationResults` operation queries only the execution status of the command on each instance.
        Scenario in which the `RunCommand` or `InvokeCommand` operation is called to run a Cloud Assistant command on a single instance:
        The `DescribeInvocations` operation is equivalent to the `DescribeInvocationResults` operation.
        If you want to query the status of each execution for a scheduled (recurring) task or a task that is automatically executed on instance startup (`RepeatMode is set to Period or EveryReboot`), you can call only the `DescribeInvocationResults` operation and must set `IncludeHistory` to true. The `DescribeInvocations` operation queries only the most recent execution status of the command.
        If you want to view the command content and parameters, you can call only the `DescribeInvocations` operation and check the `CommandContent` value in the response.
        
        @param request: DescribeInvocationResultsRequest
        @return: DescribeInvocationResultsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_invocation_results_with_options(request, runtime)

    async def describe_invocation_results_async(
        self,
        request: ecs_20140526_models.DescribeInvocationResultsRequest,
    ) -> ecs_20140526_models.DescribeInvocationResultsResponse:
        """
        @summary Queries the execution results of one or more Cloud Assistant commands on Elastic Compute Service (ECS) instances.
        
        @description ## [](#)Usage notes
        After you run a command, the command may fail to run or may return unexpected results. You can call this operation to query the execution results.
        You can query information about command executions within the last four weeks. Up to 100,000 pieces of execution information can be retained.
        You can [subscribe to Cloud Assistant task status events](https://help.aliyun.com/document_detail/2669130.html) to obtain command execution results from the events. This helps you reduce the number of times to poll API operations and improve efficiency.
        During a paged query, when you call the DescribeInvocationResults operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeInvocationResults operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        Comparison between the `DescribeInvocations` and `DescribeInvocationResults` operations:
        Scenario in which the `RunCommand` or `InvokeCommand` operation is called to run a Cloud Assistant command on multiple instances:
        The `DescribeInvocations` operation queries the execution status of the command on each instance and the overall execution status of the command on all instances.
        The `DescribeInvocationResults` operation queries only the execution status of the command on each instance.
        Scenario in which the `RunCommand` or `InvokeCommand` operation is called to run a Cloud Assistant command on a single instance:
        The `DescribeInvocations` operation is equivalent to the `DescribeInvocationResults` operation.
        If you want to query the status of each execution for a scheduled (recurring) task or a task that is automatically executed on instance startup (`RepeatMode is set to Period or EveryReboot`), you can call only the `DescribeInvocationResults` operation and must set `IncludeHistory` to true. The `DescribeInvocations` operation queries only the most recent execution status of the command.
        If you want to view the command content and parameters, you can call only the `DescribeInvocations` operation and check the `CommandContent` value in the response.
        
        @param request: DescribeInvocationResultsRequest
        @return: DescribeInvocationResultsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_invocation_results_with_options_async(request, runtime)

    def describe_invocations_with_options(
        self,
        request: ecs_20140526_models.DescribeInvocationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInvocationsResponse:
        """
        @summary Queries the execution list and states of Cloud Assistant commands.
        
        @description    After you run a command, the command may fail to run or may return unexpected results. You can call this operation to query the execution results.
        You can query information about command executions within the last four weeks. Up to 100,000 pieces of execution information can be retained.
        You can [subscribe to Cloud Assistant task status events](https://help.aliyun.com/document_detail/2669130.html) to obtain command execution results from the events. This helps you reduce the number of times to poll API operations and improve efficiency.
        During a paged query, when you call the DescribeInvocations operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeInvocations operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        Differences between the `DescribeInvocations` and `DescribeInvocationResults` operations:
        Scenario in which the `RunCommand` or `InvokeCommand` operation is called to run a Cloud Assistant command on multiple instances:
        The `DescribeInvocations` operation queries the execution status of the command on each instance and the overall execution status of the command on all instances.
        The `DescribeInvocationResults` operation queries only the execution status of the command on each instance.
        Scenario in which the `RunCommand` or `InvokeCommand` operation is called to run a Cloud Assistant command on a single instance:
        The `DescribeInvocations` operation is equivalent to the `DescribeInvocationResults` operation.
        If you want to query the status of each execution for a scheduled (recurring) task or a task that is automatically executed on instance startup (`RepeatMode is set to Period or EveryReboot`), you can call only the `DescribeInvocationResults` operation and must set `IncludeHistory` to true. The `DescribeInvocations` operation queries only the most recent execution status of the command.
        If you want to view the command content and parameters, you can call only the `DescribeInvocations` operation and check the `CommandContent` value in the response.
        
        @param request: DescribeInvocationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInvocationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.command_id):
            query['CommandId'] = request.command_id
        if not UtilClient.is_unset(request.command_name):
            query['CommandName'] = request.command_name
        if not UtilClient.is_unset(request.command_type):
            query['CommandType'] = request.command_type
        if not UtilClient.is_unset(request.content_encoding):
            query['ContentEncoding'] = request.content_encoding
        if not UtilClient.is_unset(request.include_output):
            query['IncludeOutput'] = request.include_output
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.invoke_id):
            query['InvokeId'] = request.invoke_id
        if not UtilClient.is_unset(request.invoke_status):
            query['InvokeStatus'] = request.invoke_status
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_mode):
            query['RepeatMode'] = request.repeat_mode
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.timed):
            query['Timed'] = request.timed
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInvocations',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInvocationsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_invocations_with_options_async(
        self,
        request: ecs_20140526_models.DescribeInvocationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeInvocationsResponse:
        """
        @summary Queries the execution list and states of Cloud Assistant commands.
        
        @description    After you run a command, the command may fail to run or may return unexpected results. You can call this operation to query the execution results.
        You can query information about command executions within the last four weeks. Up to 100,000 pieces of execution information can be retained.
        You can [subscribe to Cloud Assistant task status events](https://help.aliyun.com/document_detail/2669130.html) to obtain command execution results from the events. This helps you reduce the number of times to poll API operations and improve efficiency.
        During a paged query, when you call the DescribeInvocations operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeInvocations operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        Differences between the `DescribeInvocations` and `DescribeInvocationResults` operations:
        Scenario in which the `RunCommand` or `InvokeCommand` operation is called to run a Cloud Assistant command on multiple instances:
        The `DescribeInvocations` operation queries the execution status of the command on each instance and the overall execution status of the command on all instances.
        The `DescribeInvocationResults` operation queries only the execution status of the command on each instance.
        Scenario in which the `RunCommand` or `InvokeCommand` operation is called to run a Cloud Assistant command on a single instance:
        The `DescribeInvocations` operation is equivalent to the `DescribeInvocationResults` operation.
        If you want to query the status of each execution for a scheduled (recurring) task or a task that is automatically executed on instance startup (`RepeatMode is set to Period or EveryReboot`), you can call only the `DescribeInvocationResults` operation and must set `IncludeHistory` to true. The `DescribeInvocations` operation queries only the most recent execution status of the command.
        If you want to view the command content and parameters, you can call only the `DescribeInvocations` operation and check the `CommandContent` value in the response.
        
        @param request: DescribeInvocationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeInvocationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.command_id):
            query['CommandId'] = request.command_id
        if not UtilClient.is_unset(request.command_name):
            query['CommandName'] = request.command_name
        if not UtilClient.is_unset(request.command_type):
            query['CommandType'] = request.command_type
        if not UtilClient.is_unset(request.content_encoding):
            query['ContentEncoding'] = request.content_encoding
        if not UtilClient.is_unset(request.include_output):
            query['IncludeOutput'] = request.include_output
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.invoke_id):
            query['InvokeId'] = request.invoke_id
        if not UtilClient.is_unset(request.invoke_status):
            query['InvokeStatus'] = request.invoke_status
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_mode):
            query['RepeatMode'] = request.repeat_mode
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.timed):
            query['Timed'] = request.timed
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeInvocations',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeInvocationsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_invocations(
        self,
        request: ecs_20140526_models.DescribeInvocationsRequest,
    ) -> ecs_20140526_models.DescribeInvocationsResponse:
        """
        @summary Queries the execution list and states of Cloud Assistant commands.
        
        @description    After you run a command, the command may fail to run or may return unexpected results. You can call this operation to query the execution results.
        You can query information about command executions within the last four weeks. Up to 100,000 pieces of execution information can be retained.
        You can [subscribe to Cloud Assistant task status events](https://help.aliyun.com/document_detail/2669130.html) to obtain command execution results from the events. This helps you reduce the number of times to poll API operations and improve efficiency.
        During a paged query, when you call the DescribeInvocations operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeInvocations operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        Differences between the `DescribeInvocations` and `DescribeInvocationResults` operations:
        Scenario in which the `RunCommand` or `InvokeCommand` operation is called to run a Cloud Assistant command on multiple instances:
        The `DescribeInvocations` operation queries the execution status of the command on each instance and the overall execution status of the command on all instances.
        The `DescribeInvocationResults` operation queries only the execution status of the command on each instance.
        Scenario in which the `RunCommand` or `InvokeCommand` operation is called to run a Cloud Assistant command on a single instance:
        The `DescribeInvocations` operation is equivalent to the `DescribeInvocationResults` operation.
        If you want to query the status of each execution for a scheduled (recurring) task or a task that is automatically executed on instance startup (`RepeatMode is set to Period or EveryReboot`), you can call only the `DescribeInvocationResults` operation and must set `IncludeHistory` to true. The `DescribeInvocations` operation queries only the most recent execution status of the command.
        If you want to view the command content and parameters, you can call only the `DescribeInvocations` operation and check the `CommandContent` value in the response.
        
        @param request: DescribeInvocationsRequest
        @return: DescribeInvocationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_invocations_with_options(request, runtime)

    async def describe_invocations_async(
        self,
        request: ecs_20140526_models.DescribeInvocationsRequest,
    ) -> ecs_20140526_models.DescribeInvocationsResponse:
        """
        @summary Queries the execution list and states of Cloud Assistant commands.
        
        @description    After you run a command, the command may fail to run or may return unexpected results. You can call this operation to query the execution results.
        You can query information about command executions within the last four weeks. Up to 100,000 pieces of execution information can be retained.
        You can [subscribe to Cloud Assistant task status events](https://help.aliyun.com/document_detail/2669130.html) to obtain command execution results from the events. This helps you reduce the number of times to poll API operations and improve efficiency.
        During a paged query, when you call the DescribeInvocations operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeInvocations operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        Differences between the `DescribeInvocations` and `DescribeInvocationResults` operations:
        Scenario in which the `RunCommand` or `InvokeCommand` operation is called to run a Cloud Assistant command on multiple instances:
        The `DescribeInvocations` operation queries the execution status of the command on each instance and the overall execution status of the command on all instances.
        The `DescribeInvocationResults` operation queries only the execution status of the command on each instance.
        Scenario in which the `RunCommand` or `InvokeCommand` operation is called to run a Cloud Assistant command on a single instance:
        The `DescribeInvocations` operation is equivalent to the `DescribeInvocationResults` operation.
        If you want to query the status of each execution for a scheduled (recurring) task or a task that is automatically executed on instance startup (`RepeatMode is set to Period or EveryReboot`), you can call only the `DescribeInvocationResults` operation and must set `IncludeHistory` to true. The `DescribeInvocations` operation queries only the most recent execution status of the command.
        If you want to view the command content and parameters, you can call only the `DescribeInvocations` operation and check the `CommandContent` value in the response.
        
        @param request: DescribeInvocationsRequest
        @return: DescribeInvocationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_invocations_with_options_async(request, runtime)

    def describe_key_pairs_with_options(
        self,
        request: ecs_20140526_models.DescribeKeyPairsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeKeyPairsResponse:
        """
        @summary Queries one or more key pairs.
        
        @param request: DescribeKeyPairsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeKeyPairsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.include_public_key):
            query['IncludePublicKey'] = request.include_public_key
        if not UtilClient.is_unset(request.key_pair_finger_print):
            query['KeyPairFingerPrint'] = request.key_pair_finger_print
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeKeyPairs',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeKeyPairsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_key_pairs_with_options_async(
        self,
        request: ecs_20140526_models.DescribeKeyPairsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeKeyPairsResponse:
        """
        @summary Queries one or more key pairs.
        
        @param request: DescribeKeyPairsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeKeyPairsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.include_public_key):
            query['IncludePublicKey'] = request.include_public_key
        if not UtilClient.is_unset(request.key_pair_finger_print):
            query['KeyPairFingerPrint'] = request.key_pair_finger_print
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeKeyPairs',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeKeyPairsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_key_pairs(
        self,
        request: ecs_20140526_models.DescribeKeyPairsRequest,
    ) -> ecs_20140526_models.DescribeKeyPairsResponse:
        """
        @summary Queries one or more key pairs.
        
        @param request: DescribeKeyPairsRequest
        @return: DescribeKeyPairsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_key_pairs_with_options(request, runtime)

    async def describe_key_pairs_async(
        self,
        request: ecs_20140526_models.DescribeKeyPairsRequest,
    ) -> ecs_20140526_models.DescribeKeyPairsResponse:
        """
        @summary Queries one or more key pairs.
        
        @param request: DescribeKeyPairsRequest
        @return: DescribeKeyPairsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_key_pairs_with_options_async(request, runtime)

    def describe_launch_template_versions_with_options(
        self,
        request: ecs_20140526_models.DescribeLaunchTemplateVersionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeLaunchTemplateVersionsResponse:
        """
        @summary Queries the information of launch template versions, such as the total number of launch templates, launch template names, and launch template version numbers.
        
        @param request: DescribeLaunchTemplateVersionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLaunchTemplateVersionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.default_version):
            query['DefaultVersion'] = request.default_version
        if not UtilClient.is_unset(request.detail_flag):
            query['DetailFlag'] = request.detail_flag
        if not UtilClient.is_unset(request.launch_template_id):
            query['LaunchTemplateId'] = request.launch_template_id
        if not UtilClient.is_unset(request.launch_template_name):
            query['LaunchTemplateName'] = request.launch_template_name
        if not UtilClient.is_unset(request.launch_template_version):
            query['LaunchTemplateVersion'] = request.launch_template_version
        if not UtilClient.is_unset(request.max_version):
            query['MaxVersion'] = request.max_version
        if not UtilClient.is_unset(request.min_version):
            query['MinVersion'] = request.min_version
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLaunchTemplateVersions',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeLaunchTemplateVersionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_launch_template_versions_with_options_async(
        self,
        request: ecs_20140526_models.DescribeLaunchTemplateVersionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeLaunchTemplateVersionsResponse:
        """
        @summary Queries the information of launch template versions, such as the total number of launch templates, launch template names, and launch template version numbers.
        
        @param request: DescribeLaunchTemplateVersionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLaunchTemplateVersionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.default_version):
            query['DefaultVersion'] = request.default_version
        if not UtilClient.is_unset(request.detail_flag):
            query['DetailFlag'] = request.detail_flag
        if not UtilClient.is_unset(request.launch_template_id):
            query['LaunchTemplateId'] = request.launch_template_id
        if not UtilClient.is_unset(request.launch_template_name):
            query['LaunchTemplateName'] = request.launch_template_name
        if not UtilClient.is_unset(request.launch_template_version):
            query['LaunchTemplateVersion'] = request.launch_template_version
        if not UtilClient.is_unset(request.max_version):
            query['MaxVersion'] = request.max_version
        if not UtilClient.is_unset(request.min_version):
            query['MinVersion'] = request.min_version
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLaunchTemplateVersions',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeLaunchTemplateVersionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_launch_template_versions(
        self,
        request: ecs_20140526_models.DescribeLaunchTemplateVersionsRequest,
    ) -> ecs_20140526_models.DescribeLaunchTemplateVersionsResponse:
        """
        @summary Queries the information of launch template versions, such as the total number of launch templates, launch template names, and launch template version numbers.
        
        @param request: DescribeLaunchTemplateVersionsRequest
        @return: DescribeLaunchTemplateVersionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_launch_template_versions_with_options(request, runtime)

    async def describe_launch_template_versions_async(
        self,
        request: ecs_20140526_models.DescribeLaunchTemplateVersionsRequest,
    ) -> ecs_20140526_models.DescribeLaunchTemplateVersionsResponse:
        """
        @summary Queries the information of launch template versions, such as the total number of launch templates, launch template names, and launch template version numbers.
        
        @param request: DescribeLaunchTemplateVersionsRequest
        @return: DescribeLaunchTemplateVersionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_launch_template_versions_with_options_async(request, runtime)

    def describe_launch_templates_with_options(
        self,
        request: ecs_20140526_models.DescribeLaunchTemplatesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeLaunchTemplatesResponse:
        """
        @summary Queries the information of one or more launch templates, such as the total number of launch templates, the creation time of each launch template, and the latest version number of each launch template. When you can this operation, you can specify parameters, such as TemplateTag, TemplateResourceGroupId, and LaunchTemplateId, in the request.
        
        @param request: DescribeLaunchTemplatesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLaunchTemplatesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.launch_template_id):
            query['LaunchTemplateId'] = request.launch_template_id
        if not UtilClient.is_unset(request.launch_template_name):
            query['LaunchTemplateName'] = request.launch_template_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.template_resource_group_id):
            query['TemplateResourceGroupId'] = request.template_resource_group_id
        if not UtilClient.is_unset(request.template_tag):
            query['TemplateTag'] = request.template_tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLaunchTemplates',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeLaunchTemplatesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_launch_templates_with_options_async(
        self,
        request: ecs_20140526_models.DescribeLaunchTemplatesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeLaunchTemplatesResponse:
        """
        @summary Queries the information of one or more launch templates, such as the total number of launch templates, the creation time of each launch template, and the latest version number of each launch template. When you can this operation, you can specify parameters, such as TemplateTag, TemplateResourceGroupId, and LaunchTemplateId, in the request.
        
        @param request: DescribeLaunchTemplatesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLaunchTemplatesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.launch_template_id):
            query['LaunchTemplateId'] = request.launch_template_id
        if not UtilClient.is_unset(request.launch_template_name):
            query['LaunchTemplateName'] = request.launch_template_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.template_resource_group_id):
            query['TemplateResourceGroupId'] = request.template_resource_group_id
        if not UtilClient.is_unset(request.template_tag):
            query['TemplateTag'] = request.template_tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLaunchTemplates',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeLaunchTemplatesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_launch_templates(
        self,
        request: ecs_20140526_models.DescribeLaunchTemplatesRequest,
    ) -> ecs_20140526_models.DescribeLaunchTemplatesResponse:
        """
        @summary Queries the information of one or more launch templates, such as the total number of launch templates, the creation time of each launch template, and the latest version number of each launch template. When you can this operation, you can specify parameters, such as TemplateTag, TemplateResourceGroupId, and LaunchTemplateId, in the request.
        
        @param request: DescribeLaunchTemplatesRequest
        @return: DescribeLaunchTemplatesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_launch_templates_with_options(request, runtime)

    async def describe_launch_templates_async(
        self,
        request: ecs_20140526_models.DescribeLaunchTemplatesRequest,
    ) -> ecs_20140526_models.DescribeLaunchTemplatesResponse:
        """
        @summary Queries the information of one or more launch templates, such as the total number of launch templates, the creation time of each launch template, and the latest version number of each launch template. When you can this operation, you can specify parameters, such as TemplateTag, TemplateResourceGroupId, and LaunchTemplateId, in the request.
        
        @param request: DescribeLaunchTemplatesRequest
        @return: DescribeLaunchTemplatesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_launch_templates_with_options_async(request, runtime)

    def describe_limitation_with_options(
        self,
        request: ecs_20140526_models.DescribeLimitationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeLimitationResponse:
        """
        @deprecated OpenAPI DescribeLimitation is deprecated
        
        @summary 查询账号限制
        
        @param request: DescribeLimitationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLimitationResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.limitation):
            query['Limitation'] = request.limitation
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLimitation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeLimitationResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_limitation_with_options_async(
        self,
        request: ecs_20140526_models.DescribeLimitationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeLimitationResponse:
        """
        @deprecated OpenAPI DescribeLimitation is deprecated
        
        @summary 查询账号限制
        
        @param request: DescribeLimitationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLimitationResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.limitation):
            query['Limitation'] = request.limitation
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLimitation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeLimitationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_limitation(
        self,
        request: ecs_20140526_models.DescribeLimitationRequest,
    ) -> ecs_20140526_models.DescribeLimitationResponse:
        """
        @deprecated OpenAPI DescribeLimitation is deprecated
        
        @summary 查询账号限制
        
        @param request: DescribeLimitationRequest
        @return: DescribeLimitationResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_limitation_with_options(request, runtime)

    async def describe_limitation_async(
        self,
        request: ecs_20140526_models.DescribeLimitationRequest,
    ) -> ecs_20140526_models.DescribeLimitationResponse:
        """
        @deprecated OpenAPI DescribeLimitation is deprecated
        
        @summary 查询账号限制
        
        @param request: DescribeLimitationRequest
        @return: DescribeLimitationResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_limitation_with_options_async(request, runtime)

    def describe_managed_instances_with_options(
        self,
        request: ecs_20140526_models.DescribeManagedInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeManagedInstancesResponse:
        """
        @summary Queries managed instances.
        
        @description During a paged query, when you call the DescribeManagedInstances operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeManagedInstances operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeManagedInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeManagedInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.activation_id):
            query['ActivationId'] = request.activation_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_ip):
            query['InstanceIp'] = request.instance_ip
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.os_type):
            query['OsType'] = request.os_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeManagedInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeManagedInstancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_managed_instances_with_options_async(
        self,
        request: ecs_20140526_models.DescribeManagedInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeManagedInstancesResponse:
        """
        @summary Queries managed instances.
        
        @description During a paged query, when you call the DescribeManagedInstances operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeManagedInstances operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeManagedInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeManagedInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.activation_id):
            query['ActivationId'] = request.activation_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_ip):
            query['InstanceIp'] = request.instance_ip
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.os_type):
            query['OsType'] = request.os_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeManagedInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeManagedInstancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_managed_instances(
        self,
        request: ecs_20140526_models.DescribeManagedInstancesRequest,
    ) -> ecs_20140526_models.DescribeManagedInstancesResponse:
        """
        @summary Queries managed instances.
        
        @description During a paged query, when you call the DescribeManagedInstances operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeManagedInstances operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeManagedInstancesRequest
        @return: DescribeManagedInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_managed_instances_with_options(request, runtime)

    async def describe_managed_instances_async(
        self,
        request: ecs_20140526_models.DescribeManagedInstancesRequest,
    ) -> ecs_20140526_models.DescribeManagedInstancesResponse:
        """
        @summary Queries managed instances.
        
        @description During a paged query, when you call the DescribeManagedInstances operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeManagedInstances operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeManagedInstancesRequest
        @return: DescribeManagedInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_managed_instances_with_options_async(request, runtime)

    def describe_nat_gateways_with_options(
        self,
        request: ecs_20140526_models.DescribeNatGatewaysRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeNatGatewaysResponse:
        """
        @deprecated OpenAPI DescribeNatGateways is deprecated, please use Vpc::2016-04-28::DescribeNatGateways instead.
        
        @summary DescribeNatGateways
        
        @param request: DescribeNatGatewaysRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeNatGatewaysResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeNatGateways',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeNatGatewaysResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_nat_gateways_with_options_async(
        self,
        request: ecs_20140526_models.DescribeNatGatewaysRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeNatGatewaysResponse:
        """
        @deprecated OpenAPI DescribeNatGateways is deprecated, please use Vpc::2016-04-28::DescribeNatGateways instead.
        
        @summary DescribeNatGateways
        
        @param request: DescribeNatGatewaysRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeNatGatewaysResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeNatGateways',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeNatGatewaysResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_nat_gateways(
        self,
        request: ecs_20140526_models.DescribeNatGatewaysRequest,
    ) -> ecs_20140526_models.DescribeNatGatewaysResponse:
        """
        @deprecated OpenAPI DescribeNatGateways is deprecated, please use Vpc::2016-04-28::DescribeNatGateways instead.
        
        @summary DescribeNatGateways
        
        @param request: DescribeNatGatewaysRequest
        @return: DescribeNatGatewaysResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_nat_gateways_with_options(request, runtime)

    async def describe_nat_gateways_async(
        self,
        request: ecs_20140526_models.DescribeNatGatewaysRequest,
    ) -> ecs_20140526_models.DescribeNatGatewaysResponse:
        """
        @deprecated OpenAPI DescribeNatGateways is deprecated, please use Vpc::2016-04-28::DescribeNatGateways instead.
        
        @summary DescribeNatGateways
        
        @param request: DescribeNatGatewaysRequest
        @return: DescribeNatGatewaysResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_nat_gateways_with_options_async(request, runtime)

    def describe_network_interface_attribute_with_options(
        self,
        request: ecs_20140526_models.DescribeNetworkInterfaceAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeNetworkInterfaceAttributeResponse:
        """
        @summary Queries the details of an elastic network interface (ENI). When you call this operation, you can set the NetworkInterfaceId parameter to specify an ENI.
        
        @description ## Debugging
        [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Ecs\\&api=DescribeNetworkInterfaceAttribute\\&type=RPC\\&version=2014-05-26)
        
        @param request: DescribeNetworkInterfaceAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeNetworkInterfaceAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.attribute):
            query['Attribute'] = request.attribute
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeNetworkInterfaceAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeNetworkInterfaceAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_network_interface_attribute_with_options_async(
        self,
        request: ecs_20140526_models.DescribeNetworkInterfaceAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeNetworkInterfaceAttributeResponse:
        """
        @summary Queries the details of an elastic network interface (ENI). When you call this operation, you can set the NetworkInterfaceId parameter to specify an ENI.
        
        @description ## Debugging
        [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Ecs\\&api=DescribeNetworkInterfaceAttribute\\&type=RPC\\&version=2014-05-26)
        
        @param request: DescribeNetworkInterfaceAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeNetworkInterfaceAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.attribute):
            query['Attribute'] = request.attribute
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeNetworkInterfaceAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeNetworkInterfaceAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_network_interface_attribute(
        self,
        request: ecs_20140526_models.DescribeNetworkInterfaceAttributeRequest,
    ) -> ecs_20140526_models.DescribeNetworkInterfaceAttributeResponse:
        """
        @summary Queries the details of an elastic network interface (ENI). When you call this operation, you can set the NetworkInterfaceId parameter to specify an ENI.
        
        @description ## Debugging
        [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Ecs\\&api=DescribeNetworkInterfaceAttribute\\&type=RPC\\&version=2014-05-26)
        
        @param request: DescribeNetworkInterfaceAttributeRequest
        @return: DescribeNetworkInterfaceAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_network_interface_attribute_with_options(request, runtime)

    async def describe_network_interface_attribute_async(
        self,
        request: ecs_20140526_models.DescribeNetworkInterfaceAttributeRequest,
    ) -> ecs_20140526_models.DescribeNetworkInterfaceAttributeResponse:
        """
        @summary Queries the details of an elastic network interface (ENI). When you call this operation, you can set the NetworkInterfaceId parameter to specify an ENI.
        
        @description ## Debugging
        [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Ecs\\&api=DescribeNetworkInterfaceAttribute\\&type=RPC\\&version=2014-05-26)
        
        @param request: DescribeNetworkInterfaceAttributeRequest
        @return: DescribeNetworkInterfaceAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_network_interface_attribute_with_options_async(request, runtime)

    def describe_network_interface_permissions_with_options(
        self,
        request: ecs_20140526_models.DescribeNetworkInterfacePermissionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeNetworkInterfacePermissionsResponse:
        """
        @summary Queries the permissions on elastic network interfaces (ENIs) that are granted to an Alibaba Cloud partner (certified ISV) or an individual user.
        
        @param request: DescribeNetworkInterfacePermissionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeNetworkInterfacePermissionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.network_interface_permission_id):
            query['NetworkInterfacePermissionId'] = request.network_interface_permission_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeNetworkInterfacePermissions',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeNetworkInterfacePermissionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_network_interface_permissions_with_options_async(
        self,
        request: ecs_20140526_models.DescribeNetworkInterfacePermissionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeNetworkInterfacePermissionsResponse:
        """
        @summary Queries the permissions on elastic network interfaces (ENIs) that are granted to an Alibaba Cloud partner (certified ISV) or an individual user.
        
        @param request: DescribeNetworkInterfacePermissionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeNetworkInterfacePermissionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.network_interface_permission_id):
            query['NetworkInterfacePermissionId'] = request.network_interface_permission_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeNetworkInterfacePermissions',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeNetworkInterfacePermissionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_network_interface_permissions(
        self,
        request: ecs_20140526_models.DescribeNetworkInterfacePermissionsRequest,
    ) -> ecs_20140526_models.DescribeNetworkInterfacePermissionsResponse:
        """
        @summary Queries the permissions on elastic network interfaces (ENIs) that are granted to an Alibaba Cloud partner (certified ISV) or an individual user.
        
        @param request: DescribeNetworkInterfacePermissionsRequest
        @return: DescribeNetworkInterfacePermissionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_network_interface_permissions_with_options(request, runtime)

    async def describe_network_interface_permissions_async(
        self,
        request: ecs_20140526_models.DescribeNetworkInterfacePermissionsRequest,
    ) -> ecs_20140526_models.DescribeNetworkInterfacePermissionsResponse:
        """
        @summary Queries the permissions on elastic network interfaces (ENIs) that are granted to an Alibaba Cloud partner (certified ISV) or an individual user.
        
        @param request: DescribeNetworkInterfacePermissionsRequest
        @return: DescribeNetworkInterfacePermissionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_network_interface_permissions_with_options_async(request, runtime)

    def describe_network_interfaces_with_options(
        self,
        request: ecs_20140526_models.DescribeNetworkInterfacesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeNetworkInterfacesResponse:
        """
        @summary Queries the details of one or more Elastic Network Interface (ENIs).
        
        @description ## [](#)Usage notes
        You can call the `DescribeNetworkInterfaces` operation for paged query by specifying the `MaxResults` or `NextToken` parameter. Take note of the following items:
        During a paged query, when you call the DescribeNetworkInterfaces operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results.
        When you call the DescribeNetworkInterfaces operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeNetworkInterfacesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeNetworkInterfacesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.ipv_6address):
            query['Ipv6Address'] = request.ipv_6address
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.network_interface_name):
            query['NetworkInterfaceName'] = request.network_interface_name
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.primary_ip_address):
            query['PrimaryIpAddress'] = request.primary_ip_address
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.service_managed):
            query['ServiceManaged'] = request.service_managed
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeNetworkInterfaces',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeNetworkInterfacesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_network_interfaces_with_options_async(
        self,
        request: ecs_20140526_models.DescribeNetworkInterfacesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeNetworkInterfacesResponse:
        """
        @summary Queries the details of one or more Elastic Network Interface (ENIs).
        
        @description ## [](#)Usage notes
        You can call the `DescribeNetworkInterfaces` operation for paged query by specifying the `MaxResults` or `NextToken` parameter. Take note of the following items:
        During a paged query, when you call the DescribeNetworkInterfaces operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results.
        When you call the DescribeNetworkInterfaces operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeNetworkInterfacesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeNetworkInterfacesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.ipv_6address):
            query['Ipv6Address'] = request.ipv_6address
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.network_interface_name):
            query['NetworkInterfaceName'] = request.network_interface_name
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.primary_ip_address):
            query['PrimaryIpAddress'] = request.primary_ip_address
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.service_managed):
            query['ServiceManaged'] = request.service_managed
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeNetworkInterfaces',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeNetworkInterfacesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_network_interfaces(
        self,
        request: ecs_20140526_models.DescribeNetworkInterfacesRequest,
    ) -> ecs_20140526_models.DescribeNetworkInterfacesResponse:
        """
        @summary Queries the details of one or more Elastic Network Interface (ENIs).
        
        @description ## [](#)Usage notes
        You can call the `DescribeNetworkInterfaces` operation for paged query by specifying the `MaxResults` or `NextToken` parameter. Take note of the following items:
        During a paged query, when you call the DescribeNetworkInterfaces operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results.
        When you call the DescribeNetworkInterfaces operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeNetworkInterfacesRequest
        @return: DescribeNetworkInterfacesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_network_interfaces_with_options(request, runtime)

    async def describe_network_interfaces_async(
        self,
        request: ecs_20140526_models.DescribeNetworkInterfacesRequest,
    ) -> ecs_20140526_models.DescribeNetworkInterfacesResponse:
        """
        @summary Queries the details of one or more Elastic Network Interface (ENIs).
        
        @description ## [](#)Usage notes
        You can call the `DescribeNetworkInterfaces` operation for paged query by specifying the `MaxResults` or `NextToken` parameter. Take note of the following items:
        During a paged query, when you call the DescribeNetworkInterfaces operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results.
        When you call the DescribeNetworkInterfaces operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeNetworkInterfacesRequest
        @return: DescribeNetworkInterfacesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_network_interfaces_with_options_async(request, runtime)

    def describe_new_project_eip_monitor_data_with_options(
        self,
        request: ecs_20140526_models.DescribeNewProjectEipMonitorDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeNewProjectEipMonitorDataResponse:
        """
        @deprecated OpenAPI DescribeNewProjectEipMonitorData is deprecated, please use Vpc::2016-04-28::DescribeEipMonitorData instead.
        
        @summary DescribeNewProjectEipMonitorData
        
        @param request: DescribeNewProjectEipMonitorDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeNewProjectEipMonitorDataResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeNewProjectEipMonitorData',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeNewProjectEipMonitorDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_new_project_eip_monitor_data_with_options_async(
        self,
        request: ecs_20140526_models.DescribeNewProjectEipMonitorDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeNewProjectEipMonitorDataResponse:
        """
        @deprecated OpenAPI DescribeNewProjectEipMonitorData is deprecated, please use Vpc::2016-04-28::DescribeEipMonitorData instead.
        
        @summary DescribeNewProjectEipMonitorData
        
        @param request: DescribeNewProjectEipMonitorDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeNewProjectEipMonitorDataResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeNewProjectEipMonitorData',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeNewProjectEipMonitorDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_new_project_eip_monitor_data(
        self,
        request: ecs_20140526_models.DescribeNewProjectEipMonitorDataRequest,
    ) -> ecs_20140526_models.DescribeNewProjectEipMonitorDataResponse:
        """
        @deprecated OpenAPI DescribeNewProjectEipMonitorData is deprecated, please use Vpc::2016-04-28::DescribeEipMonitorData instead.
        
        @summary DescribeNewProjectEipMonitorData
        
        @param request: DescribeNewProjectEipMonitorDataRequest
        @return: DescribeNewProjectEipMonitorDataResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_new_project_eip_monitor_data_with_options(request, runtime)

    async def describe_new_project_eip_monitor_data_async(
        self,
        request: ecs_20140526_models.DescribeNewProjectEipMonitorDataRequest,
    ) -> ecs_20140526_models.DescribeNewProjectEipMonitorDataResponse:
        """
        @deprecated OpenAPI DescribeNewProjectEipMonitorData is deprecated, please use Vpc::2016-04-28::DescribeEipMonitorData instead.
        
        @summary DescribeNewProjectEipMonitorData
        
        @param request: DescribeNewProjectEipMonitorDataRequest
        @return: DescribeNewProjectEipMonitorDataResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_new_project_eip_monitor_data_with_options_async(request, runtime)

    def describe_physical_connections_with_options(
        self,
        request: ecs_20140526_models.DescribePhysicalConnectionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribePhysicalConnectionsResponse:
        """
        @deprecated OpenAPI DescribePhysicalConnections is deprecated, please use Vpc::2016-04-28::DescribePhysicalConnections instead.
        
        @summary DescribePhysicalConnections
        
        @param request: DescribePhysicalConnectionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePhysicalConnectionsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePhysicalConnections',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribePhysicalConnectionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_physical_connections_with_options_async(
        self,
        request: ecs_20140526_models.DescribePhysicalConnectionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribePhysicalConnectionsResponse:
        """
        @deprecated OpenAPI DescribePhysicalConnections is deprecated, please use Vpc::2016-04-28::DescribePhysicalConnections instead.
        
        @summary DescribePhysicalConnections
        
        @param request: DescribePhysicalConnectionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePhysicalConnectionsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePhysicalConnections',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribePhysicalConnectionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_physical_connections(
        self,
        request: ecs_20140526_models.DescribePhysicalConnectionsRequest,
    ) -> ecs_20140526_models.DescribePhysicalConnectionsResponse:
        """
        @deprecated OpenAPI DescribePhysicalConnections is deprecated, please use Vpc::2016-04-28::DescribePhysicalConnections instead.
        
        @summary DescribePhysicalConnections
        
        @param request: DescribePhysicalConnectionsRequest
        @return: DescribePhysicalConnectionsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_physical_connections_with_options(request, runtime)

    async def describe_physical_connections_async(
        self,
        request: ecs_20140526_models.DescribePhysicalConnectionsRequest,
    ) -> ecs_20140526_models.DescribePhysicalConnectionsResponse:
        """
        @deprecated OpenAPI DescribePhysicalConnections is deprecated, please use Vpc::2016-04-28::DescribePhysicalConnections instead.
        
        @summary DescribePhysicalConnections
        
        @param request: DescribePhysicalConnectionsRequest
        @return: DescribePhysicalConnectionsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_physical_connections_with_options_async(request, runtime)

    def describe_port_range_list_associations_with_options(
        self,
        request: ecs_20140526_models.DescribePortRangeListAssociationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribePortRangeListAssociationsResponse:
        """
        @summary Queries the resources that are associated with a port list, such as security groups.
        
        @param request: DescribePortRangeListAssociationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePortRangeListAssociationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_range_list_id):
            query['PortRangeListId'] = request.port_range_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePortRangeListAssociations',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribePortRangeListAssociationsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_port_range_list_associations_with_options_async(
        self,
        request: ecs_20140526_models.DescribePortRangeListAssociationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribePortRangeListAssociationsResponse:
        """
        @summary Queries the resources that are associated with a port list, such as security groups.
        
        @param request: DescribePortRangeListAssociationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePortRangeListAssociationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_range_list_id):
            query['PortRangeListId'] = request.port_range_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePortRangeListAssociations',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribePortRangeListAssociationsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_port_range_list_associations(
        self,
        request: ecs_20140526_models.DescribePortRangeListAssociationsRequest,
    ) -> ecs_20140526_models.DescribePortRangeListAssociationsResponse:
        """
        @summary Queries the resources that are associated with a port list, such as security groups.
        
        @param request: DescribePortRangeListAssociationsRequest
        @return: DescribePortRangeListAssociationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_port_range_list_associations_with_options(request, runtime)

    async def describe_port_range_list_associations_async(
        self,
        request: ecs_20140526_models.DescribePortRangeListAssociationsRequest,
    ) -> ecs_20140526_models.DescribePortRangeListAssociationsResponse:
        """
        @summary Queries the resources that are associated with a port list, such as security groups.
        
        @param request: DescribePortRangeListAssociationsRequest
        @return: DescribePortRangeListAssociationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_port_range_list_associations_with_options_async(request, runtime)

    def describe_port_range_list_entries_with_options(
        self,
        request: ecs_20140526_models.DescribePortRangeListEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribePortRangeListEntriesResponse:
        """
        @summary Queries the entries of a specified port list.
        
        @param request: DescribePortRangeListEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePortRangeListEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_range_list_id):
            query['PortRangeListId'] = request.port_range_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePortRangeListEntries',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribePortRangeListEntriesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_port_range_list_entries_with_options_async(
        self,
        request: ecs_20140526_models.DescribePortRangeListEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribePortRangeListEntriesResponse:
        """
        @summary Queries the entries of a specified port list.
        
        @param request: DescribePortRangeListEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePortRangeListEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_range_list_id):
            query['PortRangeListId'] = request.port_range_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePortRangeListEntries',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribePortRangeListEntriesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_port_range_list_entries(
        self,
        request: ecs_20140526_models.DescribePortRangeListEntriesRequest,
    ) -> ecs_20140526_models.DescribePortRangeListEntriesResponse:
        """
        @summary Queries the entries of a specified port list.
        
        @param request: DescribePortRangeListEntriesRequest
        @return: DescribePortRangeListEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_port_range_list_entries_with_options(request, runtime)

    async def describe_port_range_list_entries_async(
        self,
        request: ecs_20140526_models.DescribePortRangeListEntriesRequest,
    ) -> ecs_20140526_models.DescribePortRangeListEntriesResponse:
        """
        @summary Queries the entries of a specified port list.
        
        @param request: DescribePortRangeListEntriesRequest
        @return: DescribePortRangeListEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_port_range_list_entries_with_options_async(request, runtime)

    def describe_port_range_lists_with_options(
        self,
        request: ecs_20140526_models.DescribePortRangeListsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribePortRangeListsResponse:
        """
        @summary Queries the port lists.
        
        @param request: DescribePortRangeListsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePortRangeListsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_range_list_id):
            query['PortRangeListId'] = request.port_range_list_id
        if not UtilClient.is_unset(request.port_range_list_name):
            query['PortRangeListName'] = request.port_range_list_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePortRangeLists',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribePortRangeListsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_port_range_lists_with_options_async(
        self,
        request: ecs_20140526_models.DescribePortRangeListsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribePortRangeListsResponse:
        """
        @summary Queries the port lists.
        
        @param request: DescribePortRangeListsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePortRangeListsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_range_list_id):
            query['PortRangeListId'] = request.port_range_list_id
        if not UtilClient.is_unset(request.port_range_list_name):
            query['PortRangeListName'] = request.port_range_list_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePortRangeLists',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribePortRangeListsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_port_range_lists(
        self,
        request: ecs_20140526_models.DescribePortRangeListsRequest,
    ) -> ecs_20140526_models.DescribePortRangeListsResponse:
        """
        @summary Queries the port lists.
        
        @param request: DescribePortRangeListsRequest
        @return: DescribePortRangeListsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_port_range_lists_with_options(request, runtime)

    async def describe_port_range_lists_async(
        self,
        request: ecs_20140526_models.DescribePortRangeListsRequest,
    ) -> ecs_20140526_models.DescribePortRangeListsResponse:
        """
        @summary Queries the port lists.
        
        @param request: DescribePortRangeListsRequest
        @return: DescribePortRangeListsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_port_range_lists_with_options_async(request, runtime)

    def describe_prefix_list_associations_with_options(
        self,
        request: ecs_20140526_models.DescribePrefixListAssociationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribePrefixListAssociationsResponse:
        """
        @summary Queries information about resources that are associated with a prefix list, such as the resource IDs and types.
        
        @param request: DescribePrefixListAssociationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePrefixListAssociationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePrefixListAssociations',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribePrefixListAssociationsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_prefix_list_associations_with_options_async(
        self,
        request: ecs_20140526_models.DescribePrefixListAssociationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribePrefixListAssociationsResponse:
        """
        @summary Queries information about resources that are associated with a prefix list, such as the resource IDs and types.
        
        @param request: DescribePrefixListAssociationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePrefixListAssociationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePrefixListAssociations',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribePrefixListAssociationsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_prefix_list_associations(
        self,
        request: ecs_20140526_models.DescribePrefixListAssociationsRequest,
    ) -> ecs_20140526_models.DescribePrefixListAssociationsResponse:
        """
        @summary Queries information about resources that are associated with a prefix list, such as the resource IDs and types.
        
        @param request: DescribePrefixListAssociationsRequest
        @return: DescribePrefixListAssociationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_prefix_list_associations_with_options(request, runtime)

    async def describe_prefix_list_associations_async(
        self,
        request: ecs_20140526_models.DescribePrefixListAssociationsRequest,
    ) -> ecs_20140526_models.DescribePrefixListAssociationsResponse:
        """
        @summary Queries information about resources that are associated with a prefix list, such as the resource IDs and types.
        
        @param request: DescribePrefixListAssociationsRequest
        @return: DescribePrefixListAssociationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_prefix_list_associations_with_options_async(request, runtime)

    def describe_prefix_list_attributes_with_options(
        self,
        request: ecs_20140526_models.DescribePrefixListAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribePrefixListAttributesResponse:
        """
        @summary Queries the details of a prefix list, including the name, address family, maximum number of entries, and details of the entries.
        
        @param request: DescribePrefixListAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePrefixListAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePrefixListAttributes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribePrefixListAttributesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_prefix_list_attributes_with_options_async(
        self,
        request: ecs_20140526_models.DescribePrefixListAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribePrefixListAttributesResponse:
        """
        @summary Queries the details of a prefix list, including the name, address family, maximum number of entries, and details of the entries.
        
        @param request: DescribePrefixListAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePrefixListAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePrefixListAttributes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribePrefixListAttributesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_prefix_list_attributes(
        self,
        request: ecs_20140526_models.DescribePrefixListAttributesRequest,
    ) -> ecs_20140526_models.DescribePrefixListAttributesResponse:
        """
        @summary Queries the details of a prefix list, including the name, address family, maximum number of entries, and details of the entries.
        
        @param request: DescribePrefixListAttributesRequest
        @return: DescribePrefixListAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_prefix_list_attributes_with_options(request, runtime)

    async def describe_prefix_list_attributes_async(
        self,
        request: ecs_20140526_models.DescribePrefixListAttributesRequest,
    ) -> ecs_20140526_models.DescribePrefixListAttributesResponse:
        """
        @summary Queries the details of a prefix list, including the name, address family, maximum number of entries, and details of the entries.
        
        @param request: DescribePrefixListAttributesRequest
        @return: DescribePrefixListAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_prefix_list_attributes_with_options_async(request, runtime)

    def describe_prefix_lists_with_options(
        self,
        request: ecs_20140526_models.DescribePrefixListsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribePrefixListsResponse:
        """
        @summary Queries the information of prefix lists.
        
        @description You can specify the `AddressFamily`, `PrefixListId.N`, and `PrefixListName` request parameters in the request. Specified parameters have logical AND relations. Only the parameters that you set are included in the filter conditions.
        
        @param request: DescribePrefixListsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePrefixListsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.address_family):
            query['AddressFamily'] = request.address_family
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.prefix_list_name):
            query['PrefixListName'] = request.prefix_list_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePrefixLists',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribePrefixListsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_prefix_lists_with_options_async(
        self,
        request: ecs_20140526_models.DescribePrefixListsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribePrefixListsResponse:
        """
        @summary Queries the information of prefix lists.
        
        @description You can specify the `AddressFamily`, `PrefixListId.N`, and `PrefixListName` request parameters in the request. Specified parameters have logical AND relations. Only the parameters that you set are included in the filter conditions.
        
        @param request: DescribePrefixListsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePrefixListsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.address_family):
            query['AddressFamily'] = request.address_family
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.prefix_list_name):
            query['PrefixListName'] = request.prefix_list_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePrefixLists',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribePrefixListsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_prefix_lists(
        self,
        request: ecs_20140526_models.DescribePrefixListsRequest,
    ) -> ecs_20140526_models.DescribePrefixListsResponse:
        """
        @summary Queries the information of prefix lists.
        
        @description You can specify the `AddressFamily`, `PrefixListId.N`, and `PrefixListName` request parameters in the request. Specified parameters have logical AND relations. Only the parameters that you set are included in the filter conditions.
        
        @param request: DescribePrefixListsRequest
        @return: DescribePrefixListsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_prefix_lists_with_options(request, runtime)

    async def describe_prefix_lists_async(
        self,
        request: ecs_20140526_models.DescribePrefixListsRequest,
    ) -> ecs_20140526_models.DescribePrefixListsResponse:
        """
        @summary Queries the information of prefix lists.
        
        @description You can specify the `AddressFamily`, `PrefixListId.N`, and `PrefixListName` request parameters in the request. Specified parameters have logical AND relations. Only the parameters that you set are included in the filter conditions.
        
        @param request: DescribePrefixListsRequest
        @return: DescribePrefixListsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_prefix_lists_with_options_async(request, runtime)

    def describe_price_with_options(
        self,
        request: ecs_20140526_models.DescribePriceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribePriceResponse:
        """
        @summary Queries the most recent prices of specified resources. You can specify a resource type in the request, such as the Elastic Compute Service (ECS) instance, cloud disk, dedicated host, elasticity assurance, and capacity reservation. You can also query the activity rules, prices, and discounts of resources.
        
        @description The required parameters vary based on the type of resource whose prices you want to query.
        When `ResourceType` is set to instance, you must specify `InstanceType`. By default, `ChargeType` is set to `PostPaid`. You can specify `PriceUnit` to query the ECS resource prices in different billing cycles.
        When `ResourceType` is set to disk, you must specify `DataDisk.1.Category` and `DataDisk.1.Size` in the same request. When `ResourceType` is set to disk, only pay-as-you-go prices of cloud disks are returned. In this scenario, `PriceUnit` can be set only to `Hour`.
        When `ResourceType` is set to diskperformance, you must specify `DataDisk.1.Category` and `DataDisk.1.ProvisionedIops`.
        When `ResourceType` is set to ddh, you must specify `DedicatedHostType`.
        When `ResourceType` is set to ElasticityAssurance, you must specify `InstanceType`.
        When `ResourceType` is set to CapacityReservation, you must specify `InstanceType`.
        When `ResourceType` is set to bandwidth, only the pay-by-traffic (`PayByTraffic`) prices for network usage are returned.
        
        @param request: DescribePriceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePriceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.amount):
            query['Amount'] = request.amount
        if not UtilClient.is_unset(request.assurance_times):
            query['AssuranceTimes'] = request.assurance_times
        if not UtilClient.is_unset(request.capacity):
            query['Capacity'] = request.capacity
        if not UtilClient.is_unset(request.dedicated_host_type):
            query['DedicatedHostType'] = request.dedicated_host_type
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.instance_amount):
            query['InstanceAmount'] = request.instance_amount
        if not UtilClient.is_unset(request.instance_cpu_core_count):
            query['InstanceCpuCoreCount'] = request.instance_cpu_core_count
        if not UtilClient.is_unset(request.instance_network_type):
            query['InstanceNetworkType'] = request.instance_network_type
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.instance_type_list):
            query['InstanceTypeList'] = request.instance_type_list
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.internet_max_bandwidth_out):
            query['InternetMaxBandwidthOut'] = request.internet_max_bandwidth_out
        if not UtilClient.is_unset(request.io_optimized):
            query['IoOptimized'] = request.io_optimized
        if not UtilClient.is_unset(request.isp):
            query['Isp'] = request.isp
        if not UtilClient.is_unset(request.offering_type):
            query['OfferingType'] = request.offering_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.price_unit):
            query['PriceUnit'] = request.price_unit
        if not UtilClient.is_unset(request.recurrence_rules):
            query['RecurrenceRules'] = request.recurrence_rules
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.scope):
            query['Scope'] = request.scope
        if not UtilClient.is_unset(request.spot_duration):
            query['SpotDuration'] = request.spot_duration
        if not UtilClient.is_unset(request.spot_strategy):
            query['SpotStrategy'] = request.spot_strategy
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.data_disk):
            query['DataDisk'] = request.data_disk
        if not UtilClient.is_unset(request.scheduler_options):
            query['SchedulerOptions'] = request.scheduler_options
        if not UtilClient.is_unset(request.system_disk):
            query['SystemDisk'] = request.system_disk
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePrice',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribePriceResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_price_with_options_async(
        self,
        request: ecs_20140526_models.DescribePriceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribePriceResponse:
        """
        @summary Queries the most recent prices of specified resources. You can specify a resource type in the request, such as the Elastic Compute Service (ECS) instance, cloud disk, dedicated host, elasticity assurance, and capacity reservation. You can also query the activity rules, prices, and discounts of resources.
        
        @description The required parameters vary based on the type of resource whose prices you want to query.
        When `ResourceType` is set to instance, you must specify `InstanceType`. By default, `ChargeType` is set to `PostPaid`. You can specify `PriceUnit` to query the ECS resource prices in different billing cycles.
        When `ResourceType` is set to disk, you must specify `DataDisk.1.Category` and `DataDisk.1.Size` in the same request. When `ResourceType` is set to disk, only pay-as-you-go prices of cloud disks are returned. In this scenario, `PriceUnit` can be set only to `Hour`.
        When `ResourceType` is set to diskperformance, you must specify `DataDisk.1.Category` and `DataDisk.1.ProvisionedIops`.
        When `ResourceType` is set to ddh, you must specify `DedicatedHostType`.
        When `ResourceType` is set to ElasticityAssurance, you must specify `InstanceType`.
        When `ResourceType` is set to CapacityReservation, you must specify `InstanceType`.
        When `ResourceType` is set to bandwidth, only the pay-by-traffic (`PayByTraffic`) prices for network usage are returned.
        
        @param request: DescribePriceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePriceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.amount):
            query['Amount'] = request.amount
        if not UtilClient.is_unset(request.assurance_times):
            query['AssuranceTimes'] = request.assurance_times
        if not UtilClient.is_unset(request.capacity):
            query['Capacity'] = request.capacity
        if not UtilClient.is_unset(request.dedicated_host_type):
            query['DedicatedHostType'] = request.dedicated_host_type
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.instance_amount):
            query['InstanceAmount'] = request.instance_amount
        if not UtilClient.is_unset(request.instance_cpu_core_count):
            query['InstanceCpuCoreCount'] = request.instance_cpu_core_count
        if not UtilClient.is_unset(request.instance_network_type):
            query['InstanceNetworkType'] = request.instance_network_type
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.instance_type_list):
            query['InstanceTypeList'] = request.instance_type_list
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.internet_max_bandwidth_out):
            query['InternetMaxBandwidthOut'] = request.internet_max_bandwidth_out
        if not UtilClient.is_unset(request.io_optimized):
            query['IoOptimized'] = request.io_optimized
        if not UtilClient.is_unset(request.isp):
            query['Isp'] = request.isp
        if not UtilClient.is_unset(request.offering_type):
            query['OfferingType'] = request.offering_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.price_unit):
            query['PriceUnit'] = request.price_unit
        if not UtilClient.is_unset(request.recurrence_rules):
            query['RecurrenceRules'] = request.recurrence_rules
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.scope):
            query['Scope'] = request.scope
        if not UtilClient.is_unset(request.spot_duration):
            query['SpotDuration'] = request.spot_duration
        if not UtilClient.is_unset(request.spot_strategy):
            query['SpotStrategy'] = request.spot_strategy
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.data_disk):
            query['DataDisk'] = request.data_disk
        if not UtilClient.is_unset(request.scheduler_options):
            query['SchedulerOptions'] = request.scheduler_options
        if not UtilClient.is_unset(request.system_disk):
            query['SystemDisk'] = request.system_disk
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePrice',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribePriceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_price(
        self,
        request: ecs_20140526_models.DescribePriceRequest,
    ) -> ecs_20140526_models.DescribePriceResponse:
        """
        @summary Queries the most recent prices of specified resources. You can specify a resource type in the request, such as the Elastic Compute Service (ECS) instance, cloud disk, dedicated host, elasticity assurance, and capacity reservation. You can also query the activity rules, prices, and discounts of resources.
        
        @description The required parameters vary based on the type of resource whose prices you want to query.
        When `ResourceType` is set to instance, you must specify `InstanceType`. By default, `ChargeType` is set to `PostPaid`. You can specify `PriceUnit` to query the ECS resource prices in different billing cycles.
        When `ResourceType` is set to disk, you must specify `DataDisk.1.Category` and `DataDisk.1.Size` in the same request. When `ResourceType` is set to disk, only pay-as-you-go prices of cloud disks are returned. In this scenario, `PriceUnit` can be set only to `Hour`.
        When `ResourceType` is set to diskperformance, you must specify `DataDisk.1.Category` and `DataDisk.1.ProvisionedIops`.
        When `ResourceType` is set to ddh, you must specify `DedicatedHostType`.
        When `ResourceType` is set to ElasticityAssurance, you must specify `InstanceType`.
        When `ResourceType` is set to CapacityReservation, you must specify `InstanceType`.
        When `ResourceType` is set to bandwidth, only the pay-by-traffic (`PayByTraffic`) prices for network usage are returned.
        
        @param request: DescribePriceRequest
        @return: DescribePriceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_price_with_options(request, runtime)

    async def describe_price_async(
        self,
        request: ecs_20140526_models.DescribePriceRequest,
    ) -> ecs_20140526_models.DescribePriceResponse:
        """
        @summary Queries the most recent prices of specified resources. You can specify a resource type in the request, such as the Elastic Compute Service (ECS) instance, cloud disk, dedicated host, elasticity assurance, and capacity reservation. You can also query the activity rules, prices, and discounts of resources.
        
        @description The required parameters vary based on the type of resource whose prices you want to query.
        When `ResourceType` is set to instance, you must specify `InstanceType`. By default, `ChargeType` is set to `PostPaid`. You can specify `PriceUnit` to query the ECS resource prices in different billing cycles.
        When `ResourceType` is set to disk, you must specify `DataDisk.1.Category` and `DataDisk.1.Size` in the same request. When `ResourceType` is set to disk, only pay-as-you-go prices of cloud disks are returned. In this scenario, `PriceUnit` can be set only to `Hour`.
        When `ResourceType` is set to diskperformance, you must specify `DataDisk.1.Category` and `DataDisk.1.ProvisionedIops`.
        When `ResourceType` is set to ddh, you must specify `DedicatedHostType`.
        When `ResourceType` is set to ElasticityAssurance, you must specify `InstanceType`.
        When `ResourceType` is set to CapacityReservation, you must specify `InstanceType`.
        When `ResourceType` is set to bandwidth, only the pay-by-traffic (`PayByTraffic`) prices for network usage are returned.
        
        @param request: DescribePriceRequest
        @return: DescribePriceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_price_with_options_async(request, runtime)

    def describe_recommend_instance_type_with_options(
        self,
        request: ecs_20140526_models.DescribeRecommendInstanceTypeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeRecommendInstanceTypeResponse:
        """
        @summary Queries alternative instance types of an instance type. This operation is in internal preview. This operation lists all alternative instance types of an instance type that has been or is planed to be retired.
        
        @param request: DescribeRecommendInstanceTypeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRecommendInstanceTypeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cores):
            query['Cores'] = request.cores
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_family_level):
            query['InstanceFamilyLevel'] = request.instance_family_level
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.instance_type_family):
            query['InstanceTypeFamily'] = request.instance_type_family
        if not UtilClient.is_unset(request.io_optimized):
            query['IoOptimized'] = request.io_optimized
        if not UtilClient.is_unset(request.max_price):
            query['MaxPrice'] = request.max_price
        if not UtilClient.is_unset(request.memory):
            query['Memory'] = request.memory
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority_strategy):
            query['PriorityStrategy'] = request.priority_strategy
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.scene):
            query['Scene'] = request.scene
        if not UtilClient.is_unset(request.spot_strategy):
            query['SpotStrategy'] = request.spot_strategy
        if not UtilClient.is_unset(request.system_disk_category):
            query['SystemDiskCategory'] = request.system_disk_category
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.zone_match_mode):
            query['ZoneMatchMode'] = request.zone_match_mode
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRecommendInstanceType',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeRecommendInstanceTypeResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_recommend_instance_type_with_options_async(
        self,
        request: ecs_20140526_models.DescribeRecommendInstanceTypeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeRecommendInstanceTypeResponse:
        """
        @summary Queries alternative instance types of an instance type. This operation is in internal preview. This operation lists all alternative instance types of an instance type that has been or is planed to be retired.
        
        @param request: DescribeRecommendInstanceTypeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRecommendInstanceTypeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cores):
            query['Cores'] = request.cores
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_family_level):
            query['InstanceFamilyLevel'] = request.instance_family_level
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.instance_type_family):
            query['InstanceTypeFamily'] = request.instance_type_family
        if not UtilClient.is_unset(request.io_optimized):
            query['IoOptimized'] = request.io_optimized
        if not UtilClient.is_unset(request.max_price):
            query['MaxPrice'] = request.max_price
        if not UtilClient.is_unset(request.memory):
            query['Memory'] = request.memory
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority_strategy):
            query['PriorityStrategy'] = request.priority_strategy
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.scene):
            query['Scene'] = request.scene
        if not UtilClient.is_unset(request.spot_strategy):
            query['SpotStrategy'] = request.spot_strategy
        if not UtilClient.is_unset(request.system_disk_category):
            query['SystemDiskCategory'] = request.system_disk_category
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.zone_match_mode):
            query['ZoneMatchMode'] = request.zone_match_mode
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRecommendInstanceType',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeRecommendInstanceTypeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_recommend_instance_type(
        self,
        request: ecs_20140526_models.DescribeRecommendInstanceTypeRequest,
    ) -> ecs_20140526_models.DescribeRecommendInstanceTypeResponse:
        """
        @summary Queries alternative instance types of an instance type. This operation is in internal preview. This operation lists all alternative instance types of an instance type that has been or is planed to be retired.
        
        @param request: DescribeRecommendInstanceTypeRequest
        @return: DescribeRecommendInstanceTypeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_recommend_instance_type_with_options(request, runtime)

    async def describe_recommend_instance_type_async(
        self,
        request: ecs_20140526_models.DescribeRecommendInstanceTypeRequest,
    ) -> ecs_20140526_models.DescribeRecommendInstanceTypeResponse:
        """
        @summary Queries alternative instance types of an instance type. This operation is in internal preview. This operation lists all alternative instance types of an instance type that has been or is planed to be retired.
        
        @param request: DescribeRecommendInstanceTypeRequest
        @return: DescribeRecommendInstanceTypeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_recommend_instance_type_with_options_async(request, runtime)

    def describe_regions_with_options(
        self,
        request: ecs_20140526_models.DescribeRegionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeRegionsResponse:
        """
        @summary Queries Alibaba Cloud regions. When you call this operation, you can specify parameters, such as InstanceChargeType and ResourceType, in the request.
        
        @param request: DescribeRegionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRegionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.accept_language):
            query['AcceptLanguage'] = request.accept_language
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRegions',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeRegionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_regions_with_options_async(
        self,
        request: ecs_20140526_models.DescribeRegionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeRegionsResponse:
        """
        @summary Queries Alibaba Cloud regions. When you call this operation, you can specify parameters, such as InstanceChargeType and ResourceType, in the request.
        
        @param request: DescribeRegionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRegionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.accept_language):
            query['AcceptLanguage'] = request.accept_language
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRegions',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeRegionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_regions(
        self,
        request: ecs_20140526_models.DescribeRegionsRequest,
    ) -> ecs_20140526_models.DescribeRegionsResponse:
        """
        @summary Queries Alibaba Cloud regions. When you call this operation, you can specify parameters, such as InstanceChargeType and ResourceType, in the request.
        
        @param request: DescribeRegionsRequest
        @return: DescribeRegionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_regions_with_options(request, runtime)

    async def describe_regions_async(
        self,
        request: ecs_20140526_models.DescribeRegionsRequest,
    ) -> ecs_20140526_models.DescribeRegionsResponse:
        """
        @summary Queries Alibaba Cloud regions. When you call this operation, you can specify parameters, such as InstanceChargeType and ResourceType, in the request.
        
        @param request: DescribeRegionsRequest
        @return: DescribeRegionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_regions_with_options_async(request, runtime)

    def describe_renewal_price_with_options(
        self,
        request: ecs_20140526_models.DescribeRenewalPriceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeRenewalPriceResponse:
        """
        @summary Queries the renewal prices of Elastic Compute Service (ECS) resources. Renewal prices of only subscription resources can be queried.
        
        @description    You can call this operation to query the price for renewing a subscription instance for a specific period of time or to a synchronized expiration date.
        Take note of the following items:
        If you specify only the required parameters, the price for renewing an instance for one month is queried by default.
        The renewal period-related parameter pair (`Period` and `PeriodUnit`) and the synchronized expiration date-related parameter (`ExpectedRenewDay`) are mutually exclusive. You cannot set these parameters together to query the prices for renewing a specified instance for a period of time and to a synchronized expiration date at the same time.
        
        @param request: DescribeRenewalPriceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRenewalPriceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.expected_renew_day):
            query['ExpectedRenewDay'] = request.expected_renew_day
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.price_unit):
            query['PriceUnit'] = request.price_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRenewalPrice',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeRenewalPriceResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_renewal_price_with_options_async(
        self,
        request: ecs_20140526_models.DescribeRenewalPriceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeRenewalPriceResponse:
        """
        @summary Queries the renewal prices of Elastic Compute Service (ECS) resources. Renewal prices of only subscription resources can be queried.
        
        @description    You can call this operation to query the price for renewing a subscription instance for a specific period of time or to a synchronized expiration date.
        Take note of the following items:
        If you specify only the required parameters, the price for renewing an instance for one month is queried by default.
        The renewal period-related parameter pair (`Period` and `PeriodUnit`) and the synchronized expiration date-related parameter (`ExpectedRenewDay`) are mutually exclusive. You cannot set these parameters together to query the prices for renewing a specified instance for a period of time and to a synchronized expiration date at the same time.
        
        @param request: DescribeRenewalPriceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRenewalPriceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.expected_renew_day):
            query['ExpectedRenewDay'] = request.expected_renew_day
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.price_unit):
            query['PriceUnit'] = request.price_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRenewalPrice',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeRenewalPriceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_renewal_price(
        self,
        request: ecs_20140526_models.DescribeRenewalPriceRequest,
    ) -> ecs_20140526_models.DescribeRenewalPriceResponse:
        """
        @summary Queries the renewal prices of Elastic Compute Service (ECS) resources. Renewal prices of only subscription resources can be queried.
        
        @description    You can call this operation to query the price for renewing a subscription instance for a specific period of time or to a synchronized expiration date.
        Take note of the following items:
        If you specify only the required parameters, the price for renewing an instance for one month is queried by default.
        The renewal period-related parameter pair (`Period` and `PeriodUnit`) and the synchronized expiration date-related parameter (`ExpectedRenewDay`) are mutually exclusive. You cannot set these parameters together to query the prices for renewing a specified instance for a period of time and to a synchronized expiration date at the same time.
        
        @param request: DescribeRenewalPriceRequest
        @return: DescribeRenewalPriceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_renewal_price_with_options(request, runtime)

    async def describe_renewal_price_async(
        self,
        request: ecs_20140526_models.DescribeRenewalPriceRequest,
    ) -> ecs_20140526_models.DescribeRenewalPriceResponse:
        """
        @summary Queries the renewal prices of Elastic Compute Service (ECS) resources. Renewal prices of only subscription resources can be queried.
        
        @description    You can call this operation to query the price for renewing a subscription instance for a specific period of time or to a synchronized expiration date.
        Take note of the following items:
        If you specify only the required parameters, the price for renewing an instance for one month is queried by default.
        The renewal period-related parameter pair (`Period` and `PeriodUnit`) and the synchronized expiration date-related parameter (`ExpectedRenewDay`) are mutually exclusive. You cannot set these parameters together to query the prices for renewing a specified instance for a period of time and to a synchronized expiration date at the same time.
        
        @param request: DescribeRenewalPriceRequest
        @return: DescribeRenewalPriceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_renewal_price_with_options_async(request, runtime)

    def describe_reserved_instance_auto_renew_attribute_with_options(
        self,
        request: ecs_20140526_models.DescribeReservedInstanceAutoRenewAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeReservedInstanceAutoRenewAttributeResponse:
        """
        @summary Queries the auto-renewal attributes of one or more reserved instances, including the auto-renewal duration and auto-renewal status.
        
        @param request: DescribeReservedInstanceAutoRenewAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeReservedInstanceAutoRenewAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.reserved_instance_id):
            query['ReservedInstanceId'] = request.reserved_instance_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeReservedInstanceAutoRenewAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeReservedInstanceAutoRenewAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_reserved_instance_auto_renew_attribute_with_options_async(
        self,
        request: ecs_20140526_models.DescribeReservedInstanceAutoRenewAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeReservedInstanceAutoRenewAttributeResponse:
        """
        @summary Queries the auto-renewal attributes of one or more reserved instances, including the auto-renewal duration and auto-renewal status.
        
        @param request: DescribeReservedInstanceAutoRenewAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeReservedInstanceAutoRenewAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.reserved_instance_id):
            query['ReservedInstanceId'] = request.reserved_instance_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeReservedInstanceAutoRenewAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeReservedInstanceAutoRenewAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_reserved_instance_auto_renew_attribute(
        self,
        request: ecs_20140526_models.DescribeReservedInstanceAutoRenewAttributeRequest,
    ) -> ecs_20140526_models.DescribeReservedInstanceAutoRenewAttributeResponse:
        """
        @summary Queries the auto-renewal attributes of one or more reserved instances, including the auto-renewal duration and auto-renewal status.
        
        @param request: DescribeReservedInstanceAutoRenewAttributeRequest
        @return: DescribeReservedInstanceAutoRenewAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_reserved_instance_auto_renew_attribute_with_options(request, runtime)

    async def describe_reserved_instance_auto_renew_attribute_async(
        self,
        request: ecs_20140526_models.DescribeReservedInstanceAutoRenewAttributeRequest,
    ) -> ecs_20140526_models.DescribeReservedInstanceAutoRenewAttributeResponse:
        """
        @summary Queries the auto-renewal attributes of one or more reserved instances, including the auto-renewal duration and auto-renewal status.
        
        @param request: DescribeReservedInstanceAutoRenewAttributeRequest
        @return: DescribeReservedInstanceAutoRenewAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_reserved_instance_auto_renew_attribute_with_options_async(request, runtime)

    def describe_reserved_instances_with_options(
        self,
        request: ecs_20140526_models.DescribeReservedInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeReservedInstancesResponse:
        """
        @summary Queries the details of reserved instances that you have purchased in a specific region. You can query the details of reserved instances based on parameters, such as tags and reserved instance attributes.
        
        @description ### [](#)Scenarios
        Query all reserved instances in a specific region.
        Query the details of a reserved instance based on the ID or name.
        Query your purchased reserved instances based on the instance type or instance family.
        Query your purchased reserved instances based on the scope or status of reserved instances.
        ### [](#)Sample requests
        *Example: Query all purchased reserved instances in the China (Hangzhou) region**\
        "RegionId":"cn-hangzhou", //The ID of the region.
        *Example: Query the details of the reserved instance whose ID is ecsri-bp129enntoynwwj5\\*\\*\\*\\* in the China (Hangzhou) region**\
        "RegionId":"cn-hangzhou", //The ID of the region."ReservedInstanceId":"ecsri-bp129enntoynwwj5***" //The ID of the reserved instance.
        *Example: Query the reserved instances that can be used to offset the bills of ecs.c5.2xlarge instances in the China (Hangzhou) region**\
        "RegionId":"cn-hangzhou", //The ID of the region."InstanceType":"ecs.c5.2xlarge", //The instance type.
        *Example: Query the regional reserved instances that are within the validity period in the China (Hangzhou) region**\
        "RegionId":"cn-hangzhou", //The ID of the region."Scope":"Region", //Set the scope of the reserved instance to regional."Status":["Active"] //Set the status to Active, which indicates that the reserved instance is within the validity period.
        
        @param request: DescribeReservedInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeReservedInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_type):
            query['AllocationType'] = request.allocation_type
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.instance_type_family):
            query['InstanceTypeFamily'] = request.instance_type_family
        if not UtilClient.is_unset(request.lock_reason):
            query['LockReason'] = request.lock_reason
        if not UtilClient.is_unset(request.offering_type):
            query['OfferingType'] = request.offering_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.reserved_instance_id):
            query['ReservedInstanceId'] = request.reserved_instance_id
        if not UtilClient.is_unset(request.reserved_instance_name):
            query['ReservedInstanceName'] = request.reserved_instance_name
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.scope):
            query['Scope'] = request.scope
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeReservedInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeReservedInstancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_reserved_instances_with_options_async(
        self,
        request: ecs_20140526_models.DescribeReservedInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeReservedInstancesResponse:
        """
        @summary Queries the details of reserved instances that you have purchased in a specific region. You can query the details of reserved instances based on parameters, such as tags and reserved instance attributes.
        
        @description ### [](#)Scenarios
        Query all reserved instances in a specific region.
        Query the details of a reserved instance based on the ID or name.
        Query your purchased reserved instances based on the instance type or instance family.
        Query your purchased reserved instances based on the scope or status of reserved instances.
        ### [](#)Sample requests
        *Example: Query all purchased reserved instances in the China (Hangzhou) region**\
        "RegionId":"cn-hangzhou", //The ID of the region.
        *Example: Query the details of the reserved instance whose ID is ecsri-bp129enntoynwwj5\\*\\*\\*\\* in the China (Hangzhou) region**\
        "RegionId":"cn-hangzhou", //The ID of the region."ReservedInstanceId":"ecsri-bp129enntoynwwj5***" //The ID of the reserved instance.
        *Example: Query the reserved instances that can be used to offset the bills of ecs.c5.2xlarge instances in the China (Hangzhou) region**\
        "RegionId":"cn-hangzhou", //The ID of the region."InstanceType":"ecs.c5.2xlarge", //The instance type.
        *Example: Query the regional reserved instances that are within the validity period in the China (Hangzhou) region**\
        "RegionId":"cn-hangzhou", //The ID of the region."Scope":"Region", //Set the scope of the reserved instance to regional."Status":["Active"] //Set the status to Active, which indicates that the reserved instance is within the validity period.
        
        @param request: DescribeReservedInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeReservedInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_type):
            query['AllocationType'] = request.allocation_type
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.instance_type_family):
            query['InstanceTypeFamily'] = request.instance_type_family
        if not UtilClient.is_unset(request.lock_reason):
            query['LockReason'] = request.lock_reason
        if not UtilClient.is_unset(request.offering_type):
            query['OfferingType'] = request.offering_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.reserved_instance_id):
            query['ReservedInstanceId'] = request.reserved_instance_id
        if not UtilClient.is_unset(request.reserved_instance_name):
            query['ReservedInstanceName'] = request.reserved_instance_name
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.scope):
            query['Scope'] = request.scope
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeReservedInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeReservedInstancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_reserved_instances(
        self,
        request: ecs_20140526_models.DescribeReservedInstancesRequest,
    ) -> ecs_20140526_models.DescribeReservedInstancesResponse:
        """
        @summary Queries the details of reserved instances that you have purchased in a specific region. You can query the details of reserved instances based on parameters, such as tags and reserved instance attributes.
        
        @description ### [](#)Scenarios
        Query all reserved instances in a specific region.
        Query the details of a reserved instance based on the ID or name.
        Query your purchased reserved instances based on the instance type or instance family.
        Query your purchased reserved instances based on the scope or status of reserved instances.
        ### [](#)Sample requests
        *Example: Query all purchased reserved instances in the China (Hangzhou) region**\
        "RegionId":"cn-hangzhou", //The ID of the region.
        *Example: Query the details of the reserved instance whose ID is ecsri-bp129enntoynwwj5\\*\\*\\*\\* in the China (Hangzhou) region**\
        "RegionId":"cn-hangzhou", //The ID of the region."ReservedInstanceId":"ecsri-bp129enntoynwwj5***" //The ID of the reserved instance.
        *Example: Query the reserved instances that can be used to offset the bills of ecs.c5.2xlarge instances in the China (Hangzhou) region**\
        "RegionId":"cn-hangzhou", //The ID of the region."InstanceType":"ecs.c5.2xlarge", //The instance type.
        *Example: Query the regional reserved instances that are within the validity period in the China (Hangzhou) region**\
        "RegionId":"cn-hangzhou", //The ID of the region."Scope":"Region", //Set the scope of the reserved instance to regional."Status":["Active"] //Set the status to Active, which indicates that the reserved instance is within the validity period.
        
        @param request: DescribeReservedInstancesRequest
        @return: DescribeReservedInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_reserved_instances_with_options(request, runtime)

    async def describe_reserved_instances_async(
        self,
        request: ecs_20140526_models.DescribeReservedInstancesRequest,
    ) -> ecs_20140526_models.DescribeReservedInstancesResponse:
        """
        @summary Queries the details of reserved instances that you have purchased in a specific region. You can query the details of reserved instances based on parameters, such as tags and reserved instance attributes.
        
        @description ### [](#)Scenarios
        Query all reserved instances in a specific region.
        Query the details of a reserved instance based on the ID or name.
        Query your purchased reserved instances based on the instance type or instance family.
        Query your purchased reserved instances based on the scope or status of reserved instances.
        ### [](#)Sample requests
        *Example: Query all purchased reserved instances in the China (Hangzhou) region**\
        "RegionId":"cn-hangzhou", //The ID of the region.
        *Example: Query the details of the reserved instance whose ID is ecsri-bp129enntoynwwj5\\*\\*\\*\\* in the China (Hangzhou) region**\
        "RegionId":"cn-hangzhou", //The ID of the region."ReservedInstanceId":"ecsri-bp129enntoynwwj5***" //The ID of the reserved instance.
        *Example: Query the reserved instances that can be used to offset the bills of ecs.c5.2xlarge instances in the China (Hangzhou) region**\
        "RegionId":"cn-hangzhou", //The ID of the region."InstanceType":"ecs.c5.2xlarge", //The instance type.
        *Example: Query the regional reserved instances that are within the validity period in the China (Hangzhou) region**\
        "RegionId":"cn-hangzhou", //The ID of the region."Scope":"Region", //Set the scope of the reserved instance to regional."Status":["Active"] //Set the status to Active, which indicates that the reserved instance is within the validity period.
        
        @param request: DescribeReservedInstancesRequest
        @return: DescribeReservedInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_reserved_instances_with_options_async(request, runtime)

    def describe_resource_by_tags_with_options(
        self,
        request: ecs_20140526_models.DescribeResourceByTagsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeResourceByTagsResponse:
        """
        @deprecated OpenAPI DescribeResourceByTags is deprecated, please use Tag::2018-08-28::ListResourcesByTag instead.
        
        @summary Queries resources by tag or resource type.
        
        @param request: DescribeResourceByTagsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeResourceByTagsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeResourceByTags',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeResourceByTagsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_resource_by_tags_with_options_async(
        self,
        request: ecs_20140526_models.DescribeResourceByTagsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeResourceByTagsResponse:
        """
        @deprecated OpenAPI DescribeResourceByTags is deprecated, please use Tag::2018-08-28::ListResourcesByTag instead.
        
        @summary Queries resources by tag or resource type.
        
        @param request: DescribeResourceByTagsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeResourceByTagsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeResourceByTags',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeResourceByTagsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_resource_by_tags(
        self,
        request: ecs_20140526_models.DescribeResourceByTagsRequest,
    ) -> ecs_20140526_models.DescribeResourceByTagsResponse:
        """
        @deprecated OpenAPI DescribeResourceByTags is deprecated, please use Tag::2018-08-28::ListResourcesByTag instead.
        
        @summary Queries resources by tag or resource type.
        
        @param request: DescribeResourceByTagsRequest
        @return: DescribeResourceByTagsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_resource_by_tags_with_options(request, runtime)

    async def describe_resource_by_tags_async(
        self,
        request: ecs_20140526_models.DescribeResourceByTagsRequest,
    ) -> ecs_20140526_models.DescribeResourceByTagsResponse:
        """
        @deprecated OpenAPI DescribeResourceByTags is deprecated, please use Tag::2018-08-28::ListResourcesByTag instead.
        
        @summary Queries resources by tag or resource type.
        
        @param request: DescribeResourceByTagsRequest
        @return: DescribeResourceByTagsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_resource_by_tags_with_options_async(request, runtime)

    def describe_resources_modification_with_options(
        self,
        request: ecs_20140526_models.DescribeResourcesModificationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeResourcesModificationResponse:
        """
        @summary Queries available instance types or system disk categories in a specific zone before you change the instance type or system disk category of an Elastic Compute Service (ECS) instance.
        
        @description Examples of common scenarios in which this operation is used:
        ### [](#-1)Example 1: Query the instance types to which you can change the instance type of an instance.
        Query the instance types to which you can change the instance type of the i-bp67acfmxazb4p\\\\*\\*\\* instance and the inventory of the queried instance types in the zone in which the instance resides.
        http(s)://ecs.aliyuncs.com/?Action=DescribeResourcesModification
        &RegionId=cn-hangzhou
        &ResourceId=i-bp67acfmxazb4p***\
        &DestinationResource=InstanceType
        &OperationType=Upgrade
        &<Common request parameters>
        ### [](#-2)Example 2: Query the instance types to which you can change the instance type of an instance after a system disk category change.
        Query the instance types to which you can change the instance type of the i-bp67acfmxazb4p\\\\*\\*\\* instance after a system disk category change and the inventory of the queried instance types in the zone in which the instance resides.
        http(s)://ecs.aliyuncs.com/?Action=DescribeResourcesModification
        &RegionId=cn-hangzhou
        &ResourceId=i-bp67acfmxazb4p***\
        &DestinationResource=InstanceType
        &OperationType=Upgrade
        &Conditions.0=DiskCategory
        &<Common request parameters>
        ### [](#-3)Example 3: Query the system disk categories supported by the instance type to which you want to change the instance type of an instance.
        Query the system disk categories supported by the instance type to which you want to change the instance type of the i-bp67acfmxazb4p\\\\*\\*\\* instance and the inventory of the disk categories in the zone in which the instance resides. In this example, the ecs.g7.large instance type is used. To change to the instance type, you must change the system disk category of the instance to a category supported by the instance type.
        >  You can call this operation as described in Example 2 to query the instance types to which you can change the instance type of an instance.
        http(s)://ecs.aliyuncs.com/?Action=DescribeResourcesModification
        &RegionId=cn-hangzhou
        &ResourceId=i-bp67acfmxazb4p***\
        &DestinationResource=SystemDisk
        &OperationType=Upgrade
        &InstanceType=ecs.g7.large
        &<Common request parameters>
        
        @param request: DescribeResourcesModificationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeResourcesModificationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.conditions):
            query['Conditions'] = request.conditions
        if not UtilClient.is_unset(request.cores):
            query['Cores'] = request.cores
        if not UtilClient.is_unset(request.destination_resource):
            query['DestinationResource'] = request.destination_resource
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.memory):
            query['Memory'] = request.memory
        if not UtilClient.is_unset(request.migrate_across_zone):
            query['MigrateAcrossZone'] = request.migrate_across_zone
        if not UtilClient.is_unset(request.operation_type):
            query['OperationType'] = request.operation_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeResourcesModification',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeResourcesModificationResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_resources_modification_with_options_async(
        self,
        request: ecs_20140526_models.DescribeResourcesModificationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeResourcesModificationResponse:
        """
        @summary Queries available instance types or system disk categories in a specific zone before you change the instance type or system disk category of an Elastic Compute Service (ECS) instance.
        
        @description Examples of common scenarios in which this operation is used:
        ### [](#-1)Example 1: Query the instance types to which you can change the instance type of an instance.
        Query the instance types to which you can change the instance type of the i-bp67acfmxazb4p\\\\*\\*\\* instance and the inventory of the queried instance types in the zone in which the instance resides.
        http(s)://ecs.aliyuncs.com/?Action=DescribeResourcesModification
        &RegionId=cn-hangzhou
        &ResourceId=i-bp67acfmxazb4p***\
        &DestinationResource=InstanceType
        &OperationType=Upgrade
        &<Common request parameters>
        ### [](#-2)Example 2: Query the instance types to which you can change the instance type of an instance after a system disk category change.
        Query the instance types to which you can change the instance type of the i-bp67acfmxazb4p\\\\*\\*\\* instance after a system disk category change and the inventory of the queried instance types in the zone in which the instance resides.
        http(s)://ecs.aliyuncs.com/?Action=DescribeResourcesModification
        &RegionId=cn-hangzhou
        &ResourceId=i-bp67acfmxazb4p***\
        &DestinationResource=InstanceType
        &OperationType=Upgrade
        &Conditions.0=DiskCategory
        &<Common request parameters>
        ### [](#-3)Example 3: Query the system disk categories supported by the instance type to which you want to change the instance type of an instance.
        Query the system disk categories supported by the instance type to which you want to change the instance type of the i-bp67acfmxazb4p\\\\*\\*\\* instance and the inventory of the disk categories in the zone in which the instance resides. In this example, the ecs.g7.large instance type is used. To change to the instance type, you must change the system disk category of the instance to a category supported by the instance type.
        >  You can call this operation as described in Example 2 to query the instance types to which you can change the instance type of an instance.
        http(s)://ecs.aliyuncs.com/?Action=DescribeResourcesModification
        &RegionId=cn-hangzhou
        &ResourceId=i-bp67acfmxazb4p***\
        &DestinationResource=SystemDisk
        &OperationType=Upgrade
        &InstanceType=ecs.g7.large
        &<Common request parameters>
        
        @param request: DescribeResourcesModificationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeResourcesModificationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.conditions):
            query['Conditions'] = request.conditions
        if not UtilClient.is_unset(request.cores):
            query['Cores'] = request.cores
        if not UtilClient.is_unset(request.destination_resource):
            query['DestinationResource'] = request.destination_resource
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.memory):
            query['Memory'] = request.memory
        if not UtilClient.is_unset(request.migrate_across_zone):
            query['MigrateAcrossZone'] = request.migrate_across_zone
        if not UtilClient.is_unset(request.operation_type):
            query['OperationType'] = request.operation_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeResourcesModification',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeResourcesModificationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_resources_modification(
        self,
        request: ecs_20140526_models.DescribeResourcesModificationRequest,
    ) -> ecs_20140526_models.DescribeResourcesModificationResponse:
        """
        @summary Queries available instance types or system disk categories in a specific zone before you change the instance type or system disk category of an Elastic Compute Service (ECS) instance.
        
        @description Examples of common scenarios in which this operation is used:
        ### [](#-1)Example 1: Query the instance types to which you can change the instance type of an instance.
        Query the instance types to which you can change the instance type of the i-bp67acfmxazb4p\\\\*\\*\\* instance and the inventory of the queried instance types in the zone in which the instance resides.
        http(s)://ecs.aliyuncs.com/?Action=DescribeResourcesModification
        &RegionId=cn-hangzhou
        &ResourceId=i-bp67acfmxazb4p***\
        &DestinationResource=InstanceType
        &OperationType=Upgrade
        &<Common request parameters>
        ### [](#-2)Example 2: Query the instance types to which you can change the instance type of an instance after a system disk category change.
        Query the instance types to which you can change the instance type of the i-bp67acfmxazb4p\\\\*\\*\\* instance after a system disk category change and the inventory of the queried instance types in the zone in which the instance resides.
        http(s)://ecs.aliyuncs.com/?Action=DescribeResourcesModification
        &RegionId=cn-hangzhou
        &ResourceId=i-bp67acfmxazb4p***\
        &DestinationResource=InstanceType
        &OperationType=Upgrade
        &Conditions.0=DiskCategory
        &<Common request parameters>
        ### [](#-3)Example 3: Query the system disk categories supported by the instance type to which you want to change the instance type of an instance.
        Query the system disk categories supported by the instance type to which you want to change the instance type of the i-bp67acfmxazb4p\\\\*\\*\\* instance and the inventory of the disk categories in the zone in which the instance resides. In this example, the ecs.g7.large instance type is used. To change to the instance type, you must change the system disk category of the instance to a category supported by the instance type.
        >  You can call this operation as described in Example 2 to query the instance types to which you can change the instance type of an instance.
        http(s)://ecs.aliyuncs.com/?Action=DescribeResourcesModification
        &RegionId=cn-hangzhou
        &ResourceId=i-bp67acfmxazb4p***\
        &DestinationResource=SystemDisk
        &OperationType=Upgrade
        &InstanceType=ecs.g7.large
        &<Common request parameters>
        
        @param request: DescribeResourcesModificationRequest
        @return: DescribeResourcesModificationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_resources_modification_with_options(request, runtime)

    async def describe_resources_modification_async(
        self,
        request: ecs_20140526_models.DescribeResourcesModificationRequest,
    ) -> ecs_20140526_models.DescribeResourcesModificationResponse:
        """
        @summary Queries available instance types or system disk categories in a specific zone before you change the instance type or system disk category of an Elastic Compute Service (ECS) instance.
        
        @description Examples of common scenarios in which this operation is used:
        ### [](#-1)Example 1: Query the instance types to which you can change the instance type of an instance.
        Query the instance types to which you can change the instance type of the i-bp67acfmxazb4p\\\\*\\*\\* instance and the inventory of the queried instance types in the zone in which the instance resides.
        http(s)://ecs.aliyuncs.com/?Action=DescribeResourcesModification
        &RegionId=cn-hangzhou
        &ResourceId=i-bp67acfmxazb4p***\
        &DestinationResource=InstanceType
        &OperationType=Upgrade
        &<Common request parameters>
        ### [](#-2)Example 2: Query the instance types to which you can change the instance type of an instance after a system disk category change.
        Query the instance types to which you can change the instance type of the i-bp67acfmxazb4p\\\\*\\*\\* instance after a system disk category change and the inventory of the queried instance types in the zone in which the instance resides.
        http(s)://ecs.aliyuncs.com/?Action=DescribeResourcesModification
        &RegionId=cn-hangzhou
        &ResourceId=i-bp67acfmxazb4p***\
        &DestinationResource=InstanceType
        &OperationType=Upgrade
        &Conditions.0=DiskCategory
        &<Common request parameters>
        ### [](#-3)Example 3: Query the system disk categories supported by the instance type to which you want to change the instance type of an instance.
        Query the system disk categories supported by the instance type to which you want to change the instance type of the i-bp67acfmxazb4p\\\\*\\*\\* instance and the inventory of the disk categories in the zone in which the instance resides. In this example, the ecs.g7.large instance type is used. To change to the instance type, you must change the system disk category of the instance to a category supported by the instance type.
        >  You can call this operation as described in Example 2 to query the instance types to which you can change the instance type of an instance.
        http(s)://ecs.aliyuncs.com/?Action=DescribeResourcesModification
        &RegionId=cn-hangzhou
        &ResourceId=i-bp67acfmxazb4p***\
        &DestinationResource=SystemDisk
        &OperationType=Upgrade
        &InstanceType=ecs.g7.large
        &<Common request parameters>
        
        @param request: DescribeResourcesModificationRequest
        @return: DescribeResourcesModificationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_resources_modification_with_options_async(request, runtime)

    def describe_route_tables_with_options(
        self,
        request: ecs_20140526_models.DescribeRouteTablesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeRouteTablesResponse:
        """
        @deprecated OpenAPI DescribeRouteTables is deprecated, please use Vpc::2016-04-28::DescribeRouteTableList instead.
        
        @summary 查询路由表信息列表
        
        @param request: DescribeRouteTablesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRouteTablesResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        if not UtilClient.is_unset(request.route_table_name):
            query['RouteTableName'] = request.route_table_name
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        if not UtilClient.is_unset(request.router_type):
            query['RouterType'] = request.router_type
        if not UtilClient.is_unset(request.vrouter_id):
            query['VRouterId'] = request.vrouter_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRouteTables',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeRouteTablesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_route_tables_with_options_async(
        self,
        request: ecs_20140526_models.DescribeRouteTablesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeRouteTablesResponse:
        """
        @deprecated OpenAPI DescribeRouteTables is deprecated, please use Vpc::2016-04-28::DescribeRouteTableList instead.
        
        @summary 查询路由表信息列表
        
        @param request: DescribeRouteTablesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRouteTablesResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        if not UtilClient.is_unset(request.route_table_name):
            query['RouteTableName'] = request.route_table_name
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        if not UtilClient.is_unset(request.router_type):
            query['RouterType'] = request.router_type
        if not UtilClient.is_unset(request.vrouter_id):
            query['VRouterId'] = request.vrouter_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRouteTables',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeRouteTablesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_route_tables(
        self,
        request: ecs_20140526_models.DescribeRouteTablesRequest,
    ) -> ecs_20140526_models.DescribeRouteTablesResponse:
        """
        @deprecated OpenAPI DescribeRouteTables is deprecated, please use Vpc::2016-04-28::DescribeRouteTableList instead.
        
        @summary 查询路由表信息列表
        
        @param request: DescribeRouteTablesRequest
        @return: DescribeRouteTablesResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_route_tables_with_options(request, runtime)

    async def describe_route_tables_async(
        self,
        request: ecs_20140526_models.DescribeRouteTablesRequest,
    ) -> ecs_20140526_models.DescribeRouteTablesResponse:
        """
        @deprecated OpenAPI DescribeRouteTables is deprecated, please use Vpc::2016-04-28::DescribeRouteTableList instead.
        
        @summary 查询路由表信息列表
        
        @param request: DescribeRouteTablesRequest
        @return: DescribeRouteTablesResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_route_tables_with_options_async(request, runtime)

    def describe_router_interfaces_with_options(
        self,
        request: ecs_20140526_models.DescribeRouterInterfacesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeRouterInterfacesResponse:
        """
        @deprecated OpenAPI DescribeRouterInterfaces is deprecated, please use Vpc::2016-04-28::DescribeRouterInterfaces instead.
        
        @summary DescribeRouterInterfaces
        
        @param request: DescribeRouterInterfacesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRouterInterfacesResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRouterInterfaces',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeRouterInterfacesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_router_interfaces_with_options_async(
        self,
        request: ecs_20140526_models.DescribeRouterInterfacesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeRouterInterfacesResponse:
        """
        @deprecated OpenAPI DescribeRouterInterfaces is deprecated, please use Vpc::2016-04-28::DescribeRouterInterfaces instead.
        
        @summary DescribeRouterInterfaces
        
        @param request: DescribeRouterInterfacesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRouterInterfacesResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRouterInterfaces',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeRouterInterfacesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_router_interfaces(
        self,
        request: ecs_20140526_models.DescribeRouterInterfacesRequest,
    ) -> ecs_20140526_models.DescribeRouterInterfacesResponse:
        """
        @deprecated OpenAPI DescribeRouterInterfaces is deprecated, please use Vpc::2016-04-28::DescribeRouterInterfaces instead.
        
        @summary DescribeRouterInterfaces
        
        @param request: DescribeRouterInterfacesRequest
        @return: DescribeRouterInterfacesResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_router_interfaces_with_options(request, runtime)

    async def describe_router_interfaces_async(
        self,
        request: ecs_20140526_models.DescribeRouterInterfacesRequest,
    ) -> ecs_20140526_models.DescribeRouterInterfacesResponse:
        """
        @deprecated OpenAPI DescribeRouterInterfaces is deprecated, please use Vpc::2016-04-28::DescribeRouterInterfaces instead.
        
        @summary DescribeRouterInterfaces
        
        @param request: DescribeRouterInterfacesRequest
        @return: DescribeRouterInterfacesResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_router_interfaces_with_options_async(request, runtime)

    def describe_savings_plan_estimation_with_options(
        self,
        request: ecs_20140526_models.DescribeSavingsPlanEstimationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSavingsPlanEstimationResponse:
        """
        @summary 节省计划测算
        
        @param request: DescribeSavingsPlanEstimationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSavingsPlanEstimationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.estimation_resource):
            query['EstimationResource'] = request.estimation_resource
        if not UtilClient.is_unset(request.instance_type_scope):
            query['InstanceTypeScope'] = request.instance_type_scope
        if not UtilClient.is_unset(request.offering_type):
            query['OfferingType'] = request.offering_type
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.plan_type):
            query['PlanType'] = request.plan_type
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSavingsPlanEstimation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSavingsPlanEstimationResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_savings_plan_estimation_with_options_async(
        self,
        request: ecs_20140526_models.DescribeSavingsPlanEstimationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSavingsPlanEstimationResponse:
        """
        @summary 节省计划测算
        
        @param request: DescribeSavingsPlanEstimationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSavingsPlanEstimationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.estimation_resource):
            query['EstimationResource'] = request.estimation_resource
        if not UtilClient.is_unset(request.instance_type_scope):
            query['InstanceTypeScope'] = request.instance_type_scope
        if not UtilClient.is_unset(request.offering_type):
            query['OfferingType'] = request.offering_type
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.plan_type):
            query['PlanType'] = request.plan_type
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSavingsPlanEstimation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSavingsPlanEstimationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_savings_plan_estimation(
        self,
        request: ecs_20140526_models.DescribeSavingsPlanEstimationRequest,
    ) -> ecs_20140526_models.DescribeSavingsPlanEstimationResponse:
        """
        @summary 节省计划测算
        
        @param request: DescribeSavingsPlanEstimationRequest
        @return: DescribeSavingsPlanEstimationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_savings_plan_estimation_with_options(request, runtime)

    async def describe_savings_plan_estimation_async(
        self,
        request: ecs_20140526_models.DescribeSavingsPlanEstimationRequest,
    ) -> ecs_20140526_models.DescribeSavingsPlanEstimationResponse:
        """
        @summary 节省计划测算
        
        @param request: DescribeSavingsPlanEstimationRequest
        @return: DescribeSavingsPlanEstimationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_savings_plan_estimation_with_options_async(request, runtime)

    def describe_savings_plan_price_with_options(
        self,
        request: ecs_20140526_models.DescribeSavingsPlanPriceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSavingsPlanPriceResponse:
        """
        @summary 询价购买节省计划并预付费换购按量付费
        
        @param request: DescribeSavingsPlanPriceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSavingsPlanPriceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.committed_amount):
            query['CommittedAmount'] = request.committed_amount
        if not UtilClient.is_unset(request.instance_type_family):
            query['InstanceTypeFamily'] = request.instance_type_family
        if not UtilClient.is_unset(request.instance_type_family_group):
            query['InstanceTypeFamilyGroup'] = request.instance_type_family_group
        if not UtilClient.is_unset(request.offering_type):
            query['OfferingType'] = request.offering_type
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.plan_type):
            query['PlanType'] = request.plan_type
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSavingsPlanPrice',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSavingsPlanPriceResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_savings_plan_price_with_options_async(
        self,
        request: ecs_20140526_models.DescribeSavingsPlanPriceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSavingsPlanPriceResponse:
        """
        @summary 询价购买节省计划并预付费换购按量付费
        
        @param request: DescribeSavingsPlanPriceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSavingsPlanPriceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.committed_amount):
            query['CommittedAmount'] = request.committed_amount
        if not UtilClient.is_unset(request.instance_type_family):
            query['InstanceTypeFamily'] = request.instance_type_family
        if not UtilClient.is_unset(request.instance_type_family_group):
            query['InstanceTypeFamilyGroup'] = request.instance_type_family_group
        if not UtilClient.is_unset(request.offering_type):
            query['OfferingType'] = request.offering_type
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.plan_type):
            query['PlanType'] = request.plan_type
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSavingsPlanPrice',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSavingsPlanPriceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_savings_plan_price(
        self,
        request: ecs_20140526_models.DescribeSavingsPlanPriceRequest,
    ) -> ecs_20140526_models.DescribeSavingsPlanPriceResponse:
        """
        @summary 询价购买节省计划并预付费换购按量付费
        
        @param request: DescribeSavingsPlanPriceRequest
        @return: DescribeSavingsPlanPriceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_savings_plan_price_with_options(request, runtime)

    async def describe_savings_plan_price_async(
        self,
        request: ecs_20140526_models.DescribeSavingsPlanPriceRequest,
    ) -> ecs_20140526_models.DescribeSavingsPlanPriceResponse:
        """
        @summary 询价购买节省计划并预付费换购按量付费
        
        @param request: DescribeSavingsPlanPriceRequest
        @return: DescribeSavingsPlanPriceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_savings_plan_price_with_options_async(request, runtime)

    def describe_security_group_attribute_with_options(
        self,
        request: ecs_20140526_models.DescribeSecurityGroupAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSecurityGroupAttributeResponse:
        """
        @summary Queries the details of a specified security group and the security group rules of the security group.
        
        @param request: DescribeSecurityGroupAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSecurityGroupAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.direction):
            query['Direction'] = request.direction
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.nic_type):
            query['NicType'] = request.nic_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSecurityGroupAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSecurityGroupAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_security_group_attribute_with_options_async(
        self,
        request: ecs_20140526_models.DescribeSecurityGroupAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSecurityGroupAttributeResponse:
        """
        @summary Queries the details of a specified security group and the security group rules of the security group.
        
        @param request: DescribeSecurityGroupAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSecurityGroupAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.direction):
            query['Direction'] = request.direction
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.nic_type):
            query['NicType'] = request.nic_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSecurityGroupAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSecurityGroupAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_security_group_attribute(
        self,
        request: ecs_20140526_models.DescribeSecurityGroupAttributeRequest,
    ) -> ecs_20140526_models.DescribeSecurityGroupAttributeResponse:
        """
        @summary Queries the details of a specified security group and the security group rules of the security group.
        
        @param request: DescribeSecurityGroupAttributeRequest
        @return: DescribeSecurityGroupAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_security_group_attribute_with_options(request, runtime)

    async def describe_security_group_attribute_async(
        self,
        request: ecs_20140526_models.DescribeSecurityGroupAttributeRequest,
    ) -> ecs_20140526_models.DescribeSecurityGroupAttributeResponse:
        """
        @summary Queries the details of a specified security group and the security group rules of the security group.
        
        @param request: DescribeSecurityGroupAttributeRequest
        @return: DescribeSecurityGroupAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_security_group_attribute_with_options_async(request, runtime)

    def describe_security_group_references_with_options(
        self,
        request: ecs_20140526_models.DescribeSecurityGroupReferencesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSecurityGroupReferencesResponse:
        """
        @summary Queries the security groups whose rules reference security groups as authorization objects.
        
        @description    If you cannot delete a security group by calling the [DeleteSecurityGroup](https://help.aliyun.com/document_detail/25558.html) operation, call the DescribeSecurityGroupReferences operation to check whether the security group is referenced by the rules of other security groups. If the security group is referenced by the rules of other security groups, you must call the [RevokeSecurityGroup](https://help.aliyun.com/document_detail/2679855.html) and [RevokeSecurityGroupEgress](https://help.aliyun.com/document_detail/2679856.html) operations to remove the references before you can delete the security group.
        
        @param request: DescribeSecurityGroupReferencesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSecurityGroupReferencesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSecurityGroupReferences',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSecurityGroupReferencesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_security_group_references_with_options_async(
        self,
        request: ecs_20140526_models.DescribeSecurityGroupReferencesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSecurityGroupReferencesResponse:
        """
        @summary Queries the security groups whose rules reference security groups as authorization objects.
        
        @description    If you cannot delete a security group by calling the [DeleteSecurityGroup](https://help.aliyun.com/document_detail/25558.html) operation, call the DescribeSecurityGroupReferences operation to check whether the security group is referenced by the rules of other security groups. If the security group is referenced by the rules of other security groups, you must call the [RevokeSecurityGroup](https://help.aliyun.com/document_detail/2679855.html) and [RevokeSecurityGroupEgress](https://help.aliyun.com/document_detail/2679856.html) operations to remove the references before you can delete the security group.
        
        @param request: DescribeSecurityGroupReferencesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSecurityGroupReferencesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSecurityGroupReferences',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSecurityGroupReferencesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_security_group_references(
        self,
        request: ecs_20140526_models.DescribeSecurityGroupReferencesRequest,
    ) -> ecs_20140526_models.DescribeSecurityGroupReferencesResponse:
        """
        @summary Queries the security groups whose rules reference security groups as authorization objects.
        
        @description    If you cannot delete a security group by calling the [DeleteSecurityGroup](https://help.aliyun.com/document_detail/25558.html) operation, call the DescribeSecurityGroupReferences operation to check whether the security group is referenced by the rules of other security groups. If the security group is referenced by the rules of other security groups, you must call the [RevokeSecurityGroup](https://help.aliyun.com/document_detail/2679855.html) and [RevokeSecurityGroupEgress](https://help.aliyun.com/document_detail/2679856.html) operations to remove the references before you can delete the security group.
        
        @param request: DescribeSecurityGroupReferencesRequest
        @return: DescribeSecurityGroupReferencesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_security_group_references_with_options(request, runtime)

    async def describe_security_group_references_async(
        self,
        request: ecs_20140526_models.DescribeSecurityGroupReferencesRequest,
    ) -> ecs_20140526_models.DescribeSecurityGroupReferencesResponse:
        """
        @summary Queries the security groups whose rules reference security groups as authorization objects.
        
        @description    If you cannot delete a security group by calling the [DeleteSecurityGroup](https://help.aliyun.com/document_detail/25558.html) operation, call the DescribeSecurityGroupReferences operation to check whether the security group is referenced by the rules of other security groups. If the security group is referenced by the rules of other security groups, you must call the [RevokeSecurityGroup](https://help.aliyun.com/document_detail/2679855.html) and [RevokeSecurityGroupEgress](https://help.aliyun.com/document_detail/2679856.html) operations to remove the references before you can delete the security group.
        
        @param request: DescribeSecurityGroupReferencesRequest
        @return: DescribeSecurityGroupReferencesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_security_group_references_with_options_async(request, runtime)

    def describe_security_groups_with_options(
        self,
        request: ecs_20140526_models.DescribeSecurityGroupsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSecurityGroupsResponse:
        """
        @summary Queries the basic information of security groups. You can query the information by various filter conditions, such as the region ID, security group ID, and security group type.
        
        @description    **Paged query**: We recommend that you specify `MaxResults` and `NextToken`.
        If the response does not include `NextToken`, the current page of results is the last page and no more results are to be returned.
        During a paged query, when you call the DescribeSecurityGroups operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results.
        When you call the DescribeSecurityGroups operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        When you use Alibaba Cloud CLI to call an API operation, you must specify request parameter values of different data types in required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        
        @param request: DescribeSecurityGroupsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSecurityGroupsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.fuzzy_query):
            query['FuzzyQuery'] = request.fuzzy_query
        if not UtilClient.is_unset(request.is_query_ecs_count):
            query['IsQueryEcsCount'] = request.is_query_ecs_count
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_ids):
            query['SecurityGroupIds'] = request.security_group_ids
        if not UtilClient.is_unset(request.security_group_name):
            query['SecurityGroupName'] = request.security_group_name
        if not UtilClient.is_unset(request.security_group_type):
            query['SecurityGroupType'] = request.security_group_type
        if not UtilClient.is_unset(request.service_managed):
            query['ServiceManaged'] = request.service_managed
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSecurityGroups',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSecurityGroupsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_security_groups_with_options_async(
        self,
        request: ecs_20140526_models.DescribeSecurityGroupsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSecurityGroupsResponse:
        """
        @summary Queries the basic information of security groups. You can query the information by various filter conditions, such as the region ID, security group ID, and security group type.
        
        @description    **Paged query**: We recommend that you specify `MaxResults` and `NextToken`.
        If the response does not include `NextToken`, the current page of results is the last page and no more results are to be returned.
        During a paged query, when you call the DescribeSecurityGroups operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results.
        When you call the DescribeSecurityGroups operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        When you use Alibaba Cloud CLI to call an API operation, you must specify request parameter values of different data types in required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        
        @param request: DescribeSecurityGroupsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSecurityGroupsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.fuzzy_query):
            query['FuzzyQuery'] = request.fuzzy_query
        if not UtilClient.is_unset(request.is_query_ecs_count):
            query['IsQueryEcsCount'] = request.is_query_ecs_count
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_ids):
            query['SecurityGroupIds'] = request.security_group_ids
        if not UtilClient.is_unset(request.security_group_name):
            query['SecurityGroupName'] = request.security_group_name
        if not UtilClient.is_unset(request.security_group_type):
            query['SecurityGroupType'] = request.security_group_type
        if not UtilClient.is_unset(request.service_managed):
            query['ServiceManaged'] = request.service_managed
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSecurityGroups',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSecurityGroupsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_security_groups(
        self,
        request: ecs_20140526_models.DescribeSecurityGroupsRequest,
    ) -> ecs_20140526_models.DescribeSecurityGroupsResponse:
        """
        @summary Queries the basic information of security groups. You can query the information by various filter conditions, such as the region ID, security group ID, and security group type.
        
        @description    **Paged query**: We recommend that you specify `MaxResults` and `NextToken`.
        If the response does not include `NextToken`, the current page of results is the last page and no more results are to be returned.
        During a paged query, when you call the DescribeSecurityGroups operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results.
        When you call the DescribeSecurityGroups operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        When you use Alibaba Cloud CLI to call an API operation, you must specify request parameter values of different data types in required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        
        @param request: DescribeSecurityGroupsRequest
        @return: DescribeSecurityGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_security_groups_with_options(request, runtime)

    async def describe_security_groups_async(
        self,
        request: ecs_20140526_models.DescribeSecurityGroupsRequest,
    ) -> ecs_20140526_models.DescribeSecurityGroupsResponse:
        """
        @summary Queries the basic information of security groups. You can query the information by various filter conditions, such as the region ID, security group ID, and security group type.
        
        @description    **Paged query**: We recommend that you specify `MaxResults` and `NextToken`.
        If the response does not include `NextToken`, the current page of results is the last page and no more results are to be returned.
        During a paged query, when you call the DescribeSecurityGroups operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results.
        When you call the DescribeSecurityGroups operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        When you use Alibaba Cloud CLI to call an API operation, you must specify request parameter values of different data types in required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        
        @param request: DescribeSecurityGroupsRequest
        @return: DescribeSecurityGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_security_groups_with_options_async(request, runtime)

    def describe_send_file_results_with_options(
        self,
        request: ecs_20140526_models.DescribeSendFileResultsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSendFileResultsResponse:
        """
        @summary Queries the files sent by Cloud Assistant and their status.
        
        @description ## [](#)Usage notes
        When you send a file, the file may fail to be sent to specific Elastic Compute Service (ECS) instances. You can call this operation to check the file sending results.
        You can call this operation to query the file sending records within the last six weeks.
        During a paged query, when you call the DescribeSendFileResults operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeSendFileResults operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeSendFileResultsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSendFileResultsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.invocation_status):
            query['InvocationStatus'] = request.invocation_status
        if not UtilClient.is_unset(request.invoke_id):
            query['InvokeId'] = request.invoke_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSendFileResults',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSendFileResultsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_send_file_results_with_options_async(
        self,
        request: ecs_20140526_models.DescribeSendFileResultsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSendFileResultsResponse:
        """
        @summary Queries the files sent by Cloud Assistant and their status.
        
        @description ## [](#)Usage notes
        When you send a file, the file may fail to be sent to specific Elastic Compute Service (ECS) instances. You can call this operation to check the file sending results.
        You can call this operation to query the file sending records within the last six weeks.
        During a paged query, when you call the DescribeSendFileResults operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeSendFileResults operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeSendFileResultsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSendFileResultsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.invocation_status):
            query['InvocationStatus'] = request.invocation_status
        if not UtilClient.is_unset(request.invoke_id):
            query['InvokeId'] = request.invoke_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSendFileResults',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSendFileResultsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_send_file_results(
        self,
        request: ecs_20140526_models.DescribeSendFileResultsRequest,
    ) -> ecs_20140526_models.DescribeSendFileResultsResponse:
        """
        @summary Queries the files sent by Cloud Assistant and their status.
        
        @description ## [](#)Usage notes
        When you send a file, the file may fail to be sent to specific Elastic Compute Service (ECS) instances. You can call this operation to check the file sending results.
        You can call this operation to query the file sending records within the last six weeks.
        During a paged query, when you call the DescribeSendFileResults operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeSendFileResults operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeSendFileResultsRequest
        @return: DescribeSendFileResultsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_send_file_results_with_options(request, runtime)

    async def describe_send_file_results_async(
        self,
        request: ecs_20140526_models.DescribeSendFileResultsRequest,
    ) -> ecs_20140526_models.DescribeSendFileResultsResponse:
        """
        @summary Queries the files sent by Cloud Assistant and their status.
        
        @description ## [](#)Usage notes
        When you send a file, the file may fail to be sent to specific Elastic Compute Service (ECS) instances. You can call this operation to check the file sending results.
        You can call this operation to query the file sending records within the last six weeks.
        During a paged query, when you call the DescribeSendFileResults operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the DescribeSendFileResults operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: DescribeSendFileResultsRequest
        @return: DescribeSendFileResultsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_send_file_results_with_options_async(request, runtime)

    def describe_snapshot_groups_with_options(
        self,
        request: ecs_20140526_models.DescribeSnapshotGroupsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSnapshotGroupsResponse:
        """
        @summary Queries the information of one or more snapshot-consistent groups, such as the status of the groups, IDs of the instances associated with the groups, and snapshot creation progress.
        
        @description You can specify multiple request parameters to be queried, such as `InstanceId`, `SnapshotGroupId.N`, and `Status.N`. Specified parameters have logical AND relations. Only the specified parameters are included in the filter conditions.
        
        @param request: DescribeSnapshotGroupsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSnapshotGroupsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.additional_attributes):
            query['AdditionalAttributes'] = request.additional_attributes
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snapshot_group_id):
            query['SnapshotGroupId'] = request.snapshot_group_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSnapshotGroups',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSnapshotGroupsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_snapshot_groups_with_options_async(
        self,
        request: ecs_20140526_models.DescribeSnapshotGroupsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSnapshotGroupsResponse:
        """
        @summary Queries the information of one or more snapshot-consistent groups, such as the status of the groups, IDs of the instances associated with the groups, and snapshot creation progress.
        
        @description You can specify multiple request parameters to be queried, such as `InstanceId`, `SnapshotGroupId.N`, and `Status.N`. Specified parameters have logical AND relations. Only the specified parameters are included in the filter conditions.
        
        @param request: DescribeSnapshotGroupsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSnapshotGroupsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.additional_attributes):
            query['AdditionalAttributes'] = request.additional_attributes
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snapshot_group_id):
            query['SnapshotGroupId'] = request.snapshot_group_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSnapshotGroups',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSnapshotGroupsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_snapshot_groups(
        self,
        request: ecs_20140526_models.DescribeSnapshotGroupsRequest,
    ) -> ecs_20140526_models.DescribeSnapshotGroupsResponse:
        """
        @summary Queries the information of one or more snapshot-consistent groups, such as the status of the groups, IDs of the instances associated with the groups, and snapshot creation progress.
        
        @description You can specify multiple request parameters to be queried, such as `InstanceId`, `SnapshotGroupId.N`, and `Status.N`. Specified parameters have logical AND relations. Only the specified parameters are included in the filter conditions.
        
        @param request: DescribeSnapshotGroupsRequest
        @return: DescribeSnapshotGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_snapshot_groups_with_options(request, runtime)

    async def describe_snapshot_groups_async(
        self,
        request: ecs_20140526_models.DescribeSnapshotGroupsRequest,
    ) -> ecs_20140526_models.DescribeSnapshotGroupsResponse:
        """
        @summary Queries the information of one or more snapshot-consistent groups, such as the status of the groups, IDs of the instances associated with the groups, and snapshot creation progress.
        
        @description You can specify multiple request parameters to be queried, such as `InstanceId`, `SnapshotGroupId.N`, and `Status.N`. Specified parameters have logical AND relations. Only the specified parameters are included in the filter conditions.
        
        @param request: DescribeSnapshotGroupsRequest
        @return: DescribeSnapshotGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_snapshot_groups_with_options_async(request, runtime)

    def describe_snapshot_links_with_options(
        self,
        request: ecs_20140526_models.DescribeSnapshotLinksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSnapshotLinksResponse:
        """
        @summary Queries the snapshot chains of cloud disks. A snapshot chain is a chain of all the snapshots created for a disk. A disk corresponds to a chain of snapshots.
        
        @description ## [](#)Usage notes
        Take note of the following items:
        You can specify multiple request parameters, such as `RegionId`, `DiskIds`, and `InstanceId`, to query snapshot chains. Specified parameters have logical AND relations.
        Only the specified parameters are used as filter conditions. If the `DiskIds` and `SnapshotLinkIds` parameters are set to empty JSON arrays, the values are considered as valid filter conditions. In this case, an empty result is returned.
        
        @param request: DescribeSnapshotLinksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSnapshotLinksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.disk_ids):
            query['DiskIds'] = request.disk_ids
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snapshot_link_ids):
            query['SnapshotLinkIds'] = request.snapshot_link_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSnapshotLinks',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSnapshotLinksResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_snapshot_links_with_options_async(
        self,
        request: ecs_20140526_models.DescribeSnapshotLinksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSnapshotLinksResponse:
        """
        @summary Queries the snapshot chains of cloud disks. A snapshot chain is a chain of all the snapshots created for a disk. A disk corresponds to a chain of snapshots.
        
        @description ## [](#)Usage notes
        Take note of the following items:
        You can specify multiple request parameters, such as `RegionId`, `DiskIds`, and `InstanceId`, to query snapshot chains. Specified parameters have logical AND relations.
        Only the specified parameters are used as filter conditions. If the `DiskIds` and `SnapshotLinkIds` parameters are set to empty JSON arrays, the values are considered as valid filter conditions. In this case, an empty result is returned.
        
        @param request: DescribeSnapshotLinksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSnapshotLinksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.disk_ids):
            query['DiskIds'] = request.disk_ids
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snapshot_link_ids):
            query['SnapshotLinkIds'] = request.snapshot_link_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSnapshotLinks',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSnapshotLinksResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_snapshot_links(
        self,
        request: ecs_20140526_models.DescribeSnapshotLinksRequest,
    ) -> ecs_20140526_models.DescribeSnapshotLinksResponse:
        """
        @summary Queries the snapshot chains of cloud disks. A snapshot chain is a chain of all the snapshots created for a disk. A disk corresponds to a chain of snapshots.
        
        @description ## [](#)Usage notes
        Take note of the following items:
        You can specify multiple request parameters, such as `RegionId`, `DiskIds`, and `InstanceId`, to query snapshot chains. Specified parameters have logical AND relations.
        Only the specified parameters are used as filter conditions. If the `DiskIds` and `SnapshotLinkIds` parameters are set to empty JSON arrays, the values are considered as valid filter conditions. In this case, an empty result is returned.
        
        @param request: DescribeSnapshotLinksRequest
        @return: DescribeSnapshotLinksResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_snapshot_links_with_options(request, runtime)

    async def describe_snapshot_links_async(
        self,
        request: ecs_20140526_models.DescribeSnapshotLinksRequest,
    ) -> ecs_20140526_models.DescribeSnapshotLinksResponse:
        """
        @summary Queries the snapshot chains of cloud disks. A snapshot chain is a chain of all the snapshots created for a disk. A disk corresponds to a chain of snapshots.
        
        @description ## [](#)Usage notes
        Take note of the following items:
        You can specify multiple request parameters, such as `RegionId`, `DiskIds`, and `InstanceId`, to query snapshot chains. Specified parameters have logical AND relations.
        Only the specified parameters are used as filter conditions. If the `DiskIds` and `SnapshotLinkIds` parameters are set to empty JSON arrays, the values are considered as valid filter conditions. In this case, an empty result is returned.
        
        @param request: DescribeSnapshotLinksRequest
        @return: DescribeSnapshotLinksResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_snapshot_links_with_options_async(request, runtime)

    def describe_snapshot_monitor_data_with_options(
        self,
        request: ecs_20140526_models.DescribeSnapshotMonitorDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSnapshotMonitorDataResponse:
        """
        @summary Queries the monitoring data of snapshot sizes in a region within the last 30 days.
        
        @description ## [](#)Usage notes
        Take note of the following items:
        Up to 400 monitoring data entries can be returned at a time. Make sure that the `TotalCount` value does not exceed 400. The value is calculated by using the following formula: `TotalCount = (EndTime - StartTime)/Period`. If the TotalCount value is greater than 400, the `InvalidParameter.TooManyDataQueried` error is returned.
        You can query the monitoring data of snapshot sizes in the last 30 days. If the value of `StartTime` is more than 30 days earlier than the current time, an error is returned.
        
        @param request: DescribeSnapshotMonitorDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSnapshotMonitorDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category):
            query['Category'] = request.category
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSnapshotMonitorData',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSnapshotMonitorDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_snapshot_monitor_data_with_options_async(
        self,
        request: ecs_20140526_models.DescribeSnapshotMonitorDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSnapshotMonitorDataResponse:
        """
        @summary Queries the monitoring data of snapshot sizes in a region within the last 30 days.
        
        @description ## [](#)Usage notes
        Take note of the following items:
        Up to 400 monitoring data entries can be returned at a time. Make sure that the `TotalCount` value does not exceed 400. The value is calculated by using the following formula: `TotalCount = (EndTime - StartTime)/Period`. If the TotalCount value is greater than 400, the `InvalidParameter.TooManyDataQueried` error is returned.
        You can query the monitoring data of snapshot sizes in the last 30 days. If the value of `StartTime` is more than 30 days earlier than the current time, an error is returned.
        
        @param request: DescribeSnapshotMonitorDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSnapshotMonitorDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category):
            query['Category'] = request.category
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSnapshotMonitorData',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSnapshotMonitorDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_snapshot_monitor_data(
        self,
        request: ecs_20140526_models.DescribeSnapshotMonitorDataRequest,
    ) -> ecs_20140526_models.DescribeSnapshotMonitorDataResponse:
        """
        @summary Queries the monitoring data of snapshot sizes in a region within the last 30 days.
        
        @description ## [](#)Usage notes
        Take note of the following items:
        Up to 400 monitoring data entries can be returned at a time. Make sure that the `TotalCount` value does not exceed 400. The value is calculated by using the following formula: `TotalCount = (EndTime - StartTime)/Period`. If the TotalCount value is greater than 400, the `InvalidParameter.TooManyDataQueried` error is returned.
        You can query the monitoring data of snapshot sizes in the last 30 days. If the value of `StartTime` is more than 30 days earlier than the current time, an error is returned.
        
        @param request: DescribeSnapshotMonitorDataRequest
        @return: DescribeSnapshotMonitorDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_snapshot_monitor_data_with_options(request, runtime)

    async def describe_snapshot_monitor_data_async(
        self,
        request: ecs_20140526_models.DescribeSnapshotMonitorDataRequest,
    ) -> ecs_20140526_models.DescribeSnapshotMonitorDataResponse:
        """
        @summary Queries the monitoring data of snapshot sizes in a region within the last 30 days.
        
        @description ## [](#)Usage notes
        Take note of the following items:
        Up to 400 monitoring data entries can be returned at a time. Make sure that the `TotalCount` value does not exceed 400. The value is calculated by using the following formula: `TotalCount = (EndTime - StartTime)/Period`. If the TotalCount value is greater than 400, the `InvalidParameter.TooManyDataQueried` error is returned.
        You can query the monitoring data of snapshot sizes in the last 30 days. If the value of `StartTime` is more than 30 days earlier than the current time, an error is returned.
        
        @param request: DescribeSnapshotMonitorDataRequest
        @return: DescribeSnapshotMonitorDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_snapshot_monitor_data_with_options_async(request, runtime)

    def describe_snapshot_package_with_options(
        self,
        request: ecs_20140526_models.DescribeSnapshotPackageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSnapshotPackageResponse:
        """
        @summary Queries the Object Storage Service (OSS) storage plans that you purchased in an Alibaba Cloud region. OSS storage plans can be used to offset the storage fees for standard snapshots instead of local snapshots.
        
        @param request: DescribeSnapshotPackageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSnapshotPackageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSnapshotPackage',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSnapshotPackageResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_snapshot_package_with_options_async(
        self,
        request: ecs_20140526_models.DescribeSnapshotPackageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSnapshotPackageResponse:
        """
        @summary Queries the Object Storage Service (OSS) storage plans that you purchased in an Alibaba Cloud region. OSS storage plans can be used to offset the storage fees for standard snapshots instead of local snapshots.
        
        @param request: DescribeSnapshotPackageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSnapshotPackageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSnapshotPackage',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSnapshotPackageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_snapshot_package(
        self,
        request: ecs_20140526_models.DescribeSnapshotPackageRequest,
    ) -> ecs_20140526_models.DescribeSnapshotPackageResponse:
        """
        @summary Queries the Object Storage Service (OSS) storage plans that you purchased in an Alibaba Cloud region. OSS storage plans can be used to offset the storage fees for standard snapshots instead of local snapshots.
        
        @param request: DescribeSnapshotPackageRequest
        @return: DescribeSnapshotPackageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_snapshot_package_with_options(request, runtime)

    async def describe_snapshot_package_async(
        self,
        request: ecs_20140526_models.DescribeSnapshotPackageRequest,
    ) -> ecs_20140526_models.DescribeSnapshotPackageResponse:
        """
        @summary Queries the Object Storage Service (OSS) storage plans that you purchased in an Alibaba Cloud region. OSS storage plans can be used to offset the storage fees for standard snapshots instead of local snapshots.
        
        @param request: DescribeSnapshotPackageRequest
        @return: DescribeSnapshotPackageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_snapshot_package_with_options_async(request, runtime)

    def describe_snapshots_with_options(
        self,
        request: ecs_20140526_models.DescribeSnapshotsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSnapshotsResponse:
        """
        @summary Queries the details of cloud disk snapshots. The details include the status of the snapshots, the amount of remaining time required to create the snapshots, and the retention period of the automatic snapshots in days.
        
        @description You can specify multiple request parameters, such as `InstanceId`, `DiskId`, and `SnapshotIds`, to query snapshots. The specified parameters have logical AND relations. Only the specified parameters are included in the filter conditions.
        When you use Alibaba Cloud CLI to call an API operation, you must specify request parameter values of different data types in required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        Sample requests:
        *Query the snapshots of all cloud disks attached to an Elastic Compute Service (ECS) instance in the China (Hangzhou) region**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.InstanceId:  i-bp1fh7by6d9mw7zr***   // Specify the ID of the instance that you want to query.
        *Query the snapshots of a specific cloud disk in the China (Hangzhou) region**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.DiskId:   d-bp10e7ej8z743dmu***   // Specify the ID of the cloud disk that you want to query.
        *Query information about two snapshots in the China (Hangzhou) region by snapshot ID**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.SnapshotIds:   ["d-bp10e7ej8z743dmu***", "s-bp19vd1lorzgzt2s****"]   // Specify the IDs of the snapshots that you want to query.
        *Query snapshots created after a specific point in time in the China (Hangzhou) region**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.Filter.1.Key:   CreationStartTime,   // Specify a point in time to query snapshots that were created after the specified point in time.Filter.1.Value:   2024-11-27T00:00Z
        
        @param request: DescribeSnapshotsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSnapshotsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category):
            query['Category'] = request.category
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.encrypted):
            query['Encrypted'] = request.encrypted
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.kmskey_id):
            query['KMSKeyId'] = request.kmskey_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snapshot_ids):
            query['SnapshotIds'] = request.snapshot_ids
        if not UtilClient.is_unset(request.snapshot_link_id):
            query['SnapshotLinkId'] = request.snapshot_link_id
        if not UtilClient.is_unset(request.snapshot_name):
            query['SnapshotName'] = request.snapshot_name
        if not UtilClient.is_unset(request.snapshot_type):
            query['SnapshotType'] = request.snapshot_type
        if not UtilClient.is_unset(request.source_disk_type):
            query['SourceDiskType'] = request.source_disk_type
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.usage):
            query['Usage'] = request.usage
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSnapshots',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSnapshotsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_snapshots_with_options_async(
        self,
        request: ecs_20140526_models.DescribeSnapshotsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSnapshotsResponse:
        """
        @summary Queries the details of cloud disk snapshots. The details include the status of the snapshots, the amount of remaining time required to create the snapshots, and the retention period of the automatic snapshots in days.
        
        @description You can specify multiple request parameters, such as `InstanceId`, `DiskId`, and `SnapshotIds`, to query snapshots. The specified parameters have logical AND relations. Only the specified parameters are included in the filter conditions.
        When you use Alibaba Cloud CLI to call an API operation, you must specify request parameter values of different data types in required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        Sample requests:
        *Query the snapshots of all cloud disks attached to an Elastic Compute Service (ECS) instance in the China (Hangzhou) region**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.InstanceId:  i-bp1fh7by6d9mw7zr***   // Specify the ID of the instance that you want to query.
        *Query the snapshots of a specific cloud disk in the China (Hangzhou) region**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.DiskId:   d-bp10e7ej8z743dmu***   // Specify the ID of the cloud disk that you want to query.
        *Query information about two snapshots in the China (Hangzhou) region by snapshot ID**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.SnapshotIds:   ["d-bp10e7ej8z743dmu***", "s-bp19vd1lorzgzt2s****"]   // Specify the IDs of the snapshots that you want to query.
        *Query snapshots created after a specific point in time in the China (Hangzhou) region**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.Filter.1.Key:   CreationStartTime,   // Specify a point in time to query snapshots that were created after the specified point in time.Filter.1.Value:   2024-11-27T00:00Z
        
        @param request: DescribeSnapshotsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSnapshotsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category):
            query['Category'] = request.category
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.encrypted):
            query['Encrypted'] = request.encrypted
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.kmskey_id):
            query['KMSKeyId'] = request.kmskey_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snapshot_ids):
            query['SnapshotIds'] = request.snapshot_ids
        if not UtilClient.is_unset(request.snapshot_link_id):
            query['SnapshotLinkId'] = request.snapshot_link_id
        if not UtilClient.is_unset(request.snapshot_name):
            query['SnapshotName'] = request.snapshot_name
        if not UtilClient.is_unset(request.snapshot_type):
            query['SnapshotType'] = request.snapshot_type
        if not UtilClient.is_unset(request.source_disk_type):
            query['SourceDiskType'] = request.source_disk_type
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.usage):
            query['Usage'] = request.usage
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSnapshots',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSnapshotsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_snapshots(
        self,
        request: ecs_20140526_models.DescribeSnapshotsRequest,
    ) -> ecs_20140526_models.DescribeSnapshotsResponse:
        """
        @summary Queries the details of cloud disk snapshots. The details include the status of the snapshots, the amount of remaining time required to create the snapshots, and the retention period of the automatic snapshots in days.
        
        @description You can specify multiple request parameters, such as `InstanceId`, `DiskId`, and `SnapshotIds`, to query snapshots. The specified parameters have logical AND relations. Only the specified parameters are included in the filter conditions.
        When you use Alibaba Cloud CLI to call an API operation, you must specify request parameter values of different data types in required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        Sample requests:
        *Query the snapshots of all cloud disks attached to an Elastic Compute Service (ECS) instance in the China (Hangzhou) region**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.InstanceId:  i-bp1fh7by6d9mw7zr***   // Specify the ID of the instance that you want to query.
        *Query the snapshots of a specific cloud disk in the China (Hangzhou) region**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.DiskId:   d-bp10e7ej8z743dmu***   // Specify the ID of the cloud disk that you want to query.
        *Query information about two snapshots in the China (Hangzhou) region by snapshot ID**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.SnapshotIds:   ["d-bp10e7ej8z743dmu***", "s-bp19vd1lorzgzt2s****"]   // Specify the IDs of the snapshots that you want to query.
        *Query snapshots created after a specific point in time in the China (Hangzhou) region**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.Filter.1.Key:   CreationStartTime,   // Specify a point in time to query snapshots that were created after the specified point in time.Filter.1.Value:   2024-11-27T00:00Z
        
        @param request: DescribeSnapshotsRequest
        @return: DescribeSnapshotsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_snapshots_with_options(request, runtime)

    async def describe_snapshots_async(
        self,
        request: ecs_20140526_models.DescribeSnapshotsRequest,
    ) -> ecs_20140526_models.DescribeSnapshotsResponse:
        """
        @summary Queries the details of cloud disk snapshots. The details include the status of the snapshots, the amount of remaining time required to create the snapshots, and the retention period of the automatic snapshots in days.
        
        @description You can specify multiple request parameters, such as `InstanceId`, `DiskId`, and `SnapshotIds`, to query snapshots. The specified parameters have logical AND relations. Only the specified parameters are included in the filter conditions.
        When you use Alibaba Cloud CLI to call an API operation, you must specify request parameter values of different data types in required formats. For more information, see [Parameter formats](https://help.aliyun.com/document_detail/110340.html).
        Sample requests:
        *Query the snapshots of all cloud disks attached to an Elastic Compute Service (ECS) instance in the China (Hangzhou) region**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.InstanceId:  i-bp1fh7by6d9mw7zr***   // Specify the ID of the instance that you want to query.
        *Query the snapshots of a specific cloud disk in the China (Hangzhou) region**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.DiskId:   d-bp10e7ej8z743dmu***   // Specify the ID of the cloud disk that you want to query.
        *Query information about two snapshots in the China (Hangzhou) region by snapshot ID**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.SnapshotIds:   ["d-bp10e7ej8z743dmu***", "s-bp19vd1lorzgzt2s****"]   // Specify the IDs of the snapshots that you want to query.
        *Query snapshots created after a specific point in time in the China (Hangzhou) region**\
        RegionId:  cn-hangzhou,   // Specify the China (Hangzhou) region.Filter.1.Key:   CreationStartTime,   // Specify a point in time to query snapshots that were created after the specified point in time.Filter.1.Value:   2024-11-27T00:00Z
        
        @param request: DescribeSnapshotsRequest
        @return: DescribeSnapshotsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_snapshots_with_options_async(request, runtime)

    def describe_snapshots_usage_with_options(
        self,
        request: ecs_20140526_models.DescribeSnapshotsUsageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSnapshotsUsageResponse:
        """
        @summary Queries the number of snapshots that are stored in a region and the total size of the snapshots.
        
        @description ## [](#)Usage notes
        If you want to view the snapshot usage of each disk in the current region, we recommend that you call the [DescribeSnapshotLinks](https://help.aliyun.com/document_detail/55837.html) operation to query snapshot chain information.
        
        @param request: DescribeSnapshotsUsageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSnapshotsUsageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSnapshotsUsage',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSnapshotsUsageResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_snapshots_usage_with_options_async(
        self,
        request: ecs_20140526_models.DescribeSnapshotsUsageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSnapshotsUsageResponse:
        """
        @summary Queries the number of snapshots that are stored in a region and the total size of the snapshots.
        
        @description ## [](#)Usage notes
        If you want to view the snapshot usage of each disk in the current region, we recommend that you call the [DescribeSnapshotLinks](https://help.aliyun.com/document_detail/55837.html) operation to query snapshot chain information.
        
        @param request: DescribeSnapshotsUsageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSnapshotsUsageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSnapshotsUsage',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSnapshotsUsageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_snapshots_usage(
        self,
        request: ecs_20140526_models.DescribeSnapshotsUsageRequest,
    ) -> ecs_20140526_models.DescribeSnapshotsUsageResponse:
        """
        @summary Queries the number of snapshots that are stored in a region and the total size of the snapshots.
        
        @description ## [](#)Usage notes
        If you want to view the snapshot usage of each disk in the current region, we recommend that you call the [DescribeSnapshotLinks](https://help.aliyun.com/document_detail/55837.html) operation to query snapshot chain information.
        
        @param request: DescribeSnapshotsUsageRequest
        @return: DescribeSnapshotsUsageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_snapshots_usage_with_options(request, runtime)

    async def describe_snapshots_usage_async(
        self,
        request: ecs_20140526_models.DescribeSnapshotsUsageRequest,
    ) -> ecs_20140526_models.DescribeSnapshotsUsageResponse:
        """
        @summary Queries the number of snapshots that are stored in a region and the total size of the snapshots.
        
        @description ## [](#)Usage notes
        If you want to view the snapshot usage of each disk in the current region, we recommend that you call the [DescribeSnapshotLinks](https://help.aliyun.com/document_detail/55837.html) operation to query snapshot chain information.
        
        @param request: DescribeSnapshotsUsageRequest
        @return: DescribeSnapshotsUsageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_snapshots_usage_with_options_async(request, runtime)

    def describe_spot_advice_with_options(
        self,
        request: ecs_20140526_models.DescribeSpotAdviceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSpotAdviceResponse:
        """
        @summary Queries information about spot instances in a region in the previous 30 days. The information includes the average release rate of spot instances and the percentage of the average spot instance price relative to the pay-as-you-go instance price.
        
        @description    This operation is applicable only to I/O optimized spot instances that reside in virtual private clouds (VPCs).
        You can use one of the following methods to call this operation:
        Specify `Cores` and `Memory` or `MinCores` and `MinMemory` to query information about the instance types that meet the specified vCPU and memory requirements.
        Specify `InstanceTypes.N` to query information about the specified instance types.
        Specify `Cores` and `Memory` or `MinCores` and `MinMemory`, and then specify `InstanceTypeFamily` or `InstanceFamilyLevel` to query information about the instance types that meet the specified vCPU and memory requirements within the specified instance family or at a specified instance family level.
        You can calculate the average price of spot instances based on the percentage of the average spot instance price relative to the pay-as-you-go instance price and the pay-as-you-go instance price.
        
        @param request: DescribeSpotAdviceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSpotAdviceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cores):
            query['Cores'] = request.cores
        if not UtilClient.is_unset(request.gpu_amount):
            query['GpuAmount'] = request.gpu_amount
        if not UtilClient.is_unset(request.gpu_spec):
            query['GpuSpec'] = request.gpu_spec
        if not UtilClient.is_unset(request.instance_family_level):
            query['InstanceFamilyLevel'] = request.instance_family_level
        if not UtilClient.is_unset(request.instance_type_family):
            query['InstanceTypeFamily'] = request.instance_type_family
        if not UtilClient.is_unset(request.instance_types):
            query['InstanceTypes'] = request.instance_types
        if not UtilClient.is_unset(request.memory):
            query['Memory'] = request.memory
        if not UtilClient.is_unset(request.min_cores):
            query['MinCores'] = request.min_cores
        if not UtilClient.is_unset(request.min_memory):
            query['MinMemory'] = request.min_memory
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSpotAdvice',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSpotAdviceResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_spot_advice_with_options_async(
        self,
        request: ecs_20140526_models.DescribeSpotAdviceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSpotAdviceResponse:
        """
        @summary Queries information about spot instances in a region in the previous 30 days. The information includes the average release rate of spot instances and the percentage of the average spot instance price relative to the pay-as-you-go instance price.
        
        @description    This operation is applicable only to I/O optimized spot instances that reside in virtual private clouds (VPCs).
        You can use one of the following methods to call this operation:
        Specify `Cores` and `Memory` or `MinCores` and `MinMemory` to query information about the instance types that meet the specified vCPU and memory requirements.
        Specify `InstanceTypes.N` to query information about the specified instance types.
        Specify `Cores` and `Memory` or `MinCores` and `MinMemory`, and then specify `InstanceTypeFamily` or `InstanceFamilyLevel` to query information about the instance types that meet the specified vCPU and memory requirements within the specified instance family or at a specified instance family level.
        You can calculate the average price of spot instances based on the percentage of the average spot instance price relative to the pay-as-you-go instance price and the pay-as-you-go instance price.
        
        @param request: DescribeSpotAdviceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSpotAdviceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cores):
            query['Cores'] = request.cores
        if not UtilClient.is_unset(request.gpu_amount):
            query['GpuAmount'] = request.gpu_amount
        if not UtilClient.is_unset(request.gpu_spec):
            query['GpuSpec'] = request.gpu_spec
        if not UtilClient.is_unset(request.instance_family_level):
            query['InstanceFamilyLevel'] = request.instance_family_level
        if not UtilClient.is_unset(request.instance_type_family):
            query['InstanceTypeFamily'] = request.instance_type_family
        if not UtilClient.is_unset(request.instance_types):
            query['InstanceTypes'] = request.instance_types
        if not UtilClient.is_unset(request.memory):
            query['Memory'] = request.memory
        if not UtilClient.is_unset(request.min_cores):
            query['MinCores'] = request.min_cores
        if not UtilClient.is_unset(request.min_memory):
            query['MinMemory'] = request.min_memory
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSpotAdvice',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSpotAdviceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_spot_advice(
        self,
        request: ecs_20140526_models.DescribeSpotAdviceRequest,
    ) -> ecs_20140526_models.DescribeSpotAdviceResponse:
        """
        @summary Queries information about spot instances in a region in the previous 30 days. The information includes the average release rate of spot instances and the percentage of the average spot instance price relative to the pay-as-you-go instance price.
        
        @description    This operation is applicable only to I/O optimized spot instances that reside in virtual private clouds (VPCs).
        You can use one of the following methods to call this operation:
        Specify `Cores` and `Memory` or `MinCores` and `MinMemory` to query information about the instance types that meet the specified vCPU and memory requirements.
        Specify `InstanceTypes.N` to query information about the specified instance types.
        Specify `Cores` and `Memory` or `MinCores` and `MinMemory`, and then specify `InstanceTypeFamily` or `InstanceFamilyLevel` to query information about the instance types that meet the specified vCPU and memory requirements within the specified instance family or at a specified instance family level.
        You can calculate the average price of spot instances based on the percentage of the average spot instance price relative to the pay-as-you-go instance price and the pay-as-you-go instance price.
        
        @param request: DescribeSpotAdviceRequest
        @return: DescribeSpotAdviceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_spot_advice_with_options(request, runtime)

    async def describe_spot_advice_async(
        self,
        request: ecs_20140526_models.DescribeSpotAdviceRequest,
    ) -> ecs_20140526_models.DescribeSpotAdviceResponse:
        """
        @summary Queries information about spot instances in a region in the previous 30 days. The information includes the average release rate of spot instances and the percentage of the average spot instance price relative to the pay-as-you-go instance price.
        
        @description    This operation is applicable only to I/O optimized spot instances that reside in virtual private clouds (VPCs).
        You can use one of the following methods to call this operation:
        Specify `Cores` and `Memory` or `MinCores` and `MinMemory` to query information about the instance types that meet the specified vCPU and memory requirements.
        Specify `InstanceTypes.N` to query information about the specified instance types.
        Specify `Cores` and `Memory` or `MinCores` and `MinMemory`, and then specify `InstanceTypeFamily` or `InstanceFamilyLevel` to query information about the instance types that meet the specified vCPU and memory requirements within the specified instance family or at a specified instance family level.
        You can calculate the average price of spot instances based on the percentage of the average spot instance price relative to the pay-as-you-go instance price and the pay-as-you-go instance price.
        
        @param request: DescribeSpotAdviceRequest
        @return: DescribeSpotAdviceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_spot_advice_with_options_async(request, runtime)

    def describe_spot_price_history_with_options(
        self,
        request: ecs_20140526_models.DescribeSpotPriceHistoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSpotPriceHistoryResponse:
        """
        @summary Queries the historical prices of spot instances within up to the previous 30 days. You can set the maximum price of a spot instance based on the historical prices.
        
        @description    This operation is applicable only to I/O optimized spot instances.
        The data returned by the interface may be paginated. If the returned data contains the `NextOffset` parameter, you can set the `Offset` parameter in the request to the value of the `NextOffset` parameter for subsequent data query.
        
        @param request: DescribeSpotPriceHistoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSpotPriceHistoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.io_optimized):
            query['IoOptimized'] = request.io_optimized
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.ostype):
            query['OSType'] = request.ostype
        if not UtilClient.is_unset(request.offset):
            query['Offset'] = request.offset
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.spot_duration):
            query['SpotDuration'] = request.spot_duration
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSpotPriceHistory',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSpotPriceHistoryResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_spot_price_history_with_options_async(
        self,
        request: ecs_20140526_models.DescribeSpotPriceHistoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeSpotPriceHistoryResponse:
        """
        @summary Queries the historical prices of spot instances within up to the previous 30 days. You can set the maximum price of a spot instance based on the historical prices.
        
        @description    This operation is applicable only to I/O optimized spot instances.
        The data returned by the interface may be paginated. If the returned data contains the `NextOffset` parameter, you can set the `Offset` parameter in the request to the value of the `NextOffset` parameter for subsequent data query.
        
        @param request: DescribeSpotPriceHistoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSpotPriceHistoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.io_optimized):
            query['IoOptimized'] = request.io_optimized
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.ostype):
            query['OSType'] = request.ostype
        if not UtilClient.is_unset(request.offset):
            query['Offset'] = request.offset
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.spot_duration):
            query['SpotDuration'] = request.spot_duration
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSpotPriceHistory',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeSpotPriceHistoryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_spot_price_history(
        self,
        request: ecs_20140526_models.DescribeSpotPriceHistoryRequest,
    ) -> ecs_20140526_models.DescribeSpotPriceHistoryResponse:
        """
        @summary Queries the historical prices of spot instances within up to the previous 30 days. You can set the maximum price of a spot instance based on the historical prices.
        
        @description    This operation is applicable only to I/O optimized spot instances.
        The data returned by the interface may be paginated. If the returned data contains the `NextOffset` parameter, you can set the `Offset` parameter in the request to the value of the `NextOffset` parameter for subsequent data query.
        
        @param request: DescribeSpotPriceHistoryRequest
        @return: DescribeSpotPriceHistoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_spot_price_history_with_options(request, runtime)

    async def describe_spot_price_history_async(
        self,
        request: ecs_20140526_models.DescribeSpotPriceHistoryRequest,
    ) -> ecs_20140526_models.DescribeSpotPriceHistoryResponse:
        """
        @summary Queries the historical prices of spot instances within up to the previous 30 days. You can set the maximum price of a spot instance based on the historical prices.
        
        @description    This operation is applicable only to I/O optimized spot instances.
        The data returned by the interface may be paginated. If the returned data contains the `NextOffset` parameter, you can set the `Offset` parameter in the request to the value of the `NextOffset` parameter for subsequent data query.
        
        @param request: DescribeSpotPriceHistoryRequest
        @return: DescribeSpotPriceHistoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_spot_price_history_with_options_async(request, runtime)

    def describe_storage_capacity_units_with_options(
        self,
        request: ecs_20140526_models.DescribeStorageCapacityUnitsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeStorageCapacityUnitsResponse:
        """
        @summary Queries the details of storage capacity units (SCUs). In the request, you can specify the name, status, or capacity of each SCU.
        
        @param request: DescribeStorageCapacityUnitsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeStorageCapacityUnitsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_type):
            query['AllocationType'] = request.allocation_type
        if not UtilClient.is_unset(request.capacity):
            query['Capacity'] = request.capacity
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.storage_capacity_unit_id):
            query['StorageCapacityUnitId'] = request.storage_capacity_unit_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeStorageCapacityUnits',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeStorageCapacityUnitsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_storage_capacity_units_with_options_async(
        self,
        request: ecs_20140526_models.DescribeStorageCapacityUnitsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeStorageCapacityUnitsResponse:
        """
        @summary Queries the details of storage capacity units (SCUs). In the request, you can specify the name, status, or capacity of each SCU.
        
        @param request: DescribeStorageCapacityUnitsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeStorageCapacityUnitsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_type):
            query['AllocationType'] = request.allocation_type
        if not UtilClient.is_unset(request.capacity):
            query['Capacity'] = request.capacity
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.storage_capacity_unit_id):
            query['StorageCapacityUnitId'] = request.storage_capacity_unit_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeStorageCapacityUnits',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeStorageCapacityUnitsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_storage_capacity_units(
        self,
        request: ecs_20140526_models.DescribeStorageCapacityUnitsRequest,
    ) -> ecs_20140526_models.DescribeStorageCapacityUnitsResponse:
        """
        @summary Queries the details of storage capacity units (SCUs). In the request, you can specify the name, status, or capacity of each SCU.
        
        @param request: DescribeStorageCapacityUnitsRequest
        @return: DescribeStorageCapacityUnitsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_storage_capacity_units_with_options(request, runtime)

    async def describe_storage_capacity_units_async(
        self,
        request: ecs_20140526_models.DescribeStorageCapacityUnitsRequest,
    ) -> ecs_20140526_models.DescribeStorageCapacityUnitsResponse:
        """
        @summary Queries the details of storage capacity units (SCUs). In the request, you can specify the name, status, or capacity of each SCU.
        
        @param request: DescribeStorageCapacityUnitsRequest
        @return: DescribeStorageCapacityUnitsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_storage_capacity_units_with_options_async(request, runtime)

    def describe_storage_set_details_with_options(
        self,
        request: ecs_20140526_models.DescribeStorageSetDetailsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeStorageSetDetailsResponse:
        """
        @summary Queries the details of the disks or Shared Block Storage devices in a storage set.
        
        @param request: DescribeStorageSetDetailsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeStorageSetDetailsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.disk_ids):
            query['DiskIds'] = request.disk_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_set_id):
            query['StorageSetId'] = request.storage_set_id
        if not UtilClient.is_unset(request.storage_set_partition_number):
            query['StorageSetPartitionNumber'] = request.storage_set_partition_number
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeStorageSetDetails',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeStorageSetDetailsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_storage_set_details_with_options_async(
        self,
        request: ecs_20140526_models.DescribeStorageSetDetailsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeStorageSetDetailsResponse:
        """
        @summary Queries the details of the disks or Shared Block Storage devices in a storage set.
        
        @param request: DescribeStorageSetDetailsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeStorageSetDetailsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.disk_ids):
            query['DiskIds'] = request.disk_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_set_id):
            query['StorageSetId'] = request.storage_set_id
        if not UtilClient.is_unset(request.storage_set_partition_number):
            query['StorageSetPartitionNumber'] = request.storage_set_partition_number
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeStorageSetDetails',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeStorageSetDetailsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_storage_set_details(
        self,
        request: ecs_20140526_models.DescribeStorageSetDetailsRequest,
    ) -> ecs_20140526_models.DescribeStorageSetDetailsResponse:
        """
        @summary Queries the details of the disks or Shared Block Storage devices in a storage set.
        
        @param request: DescribeStorageSetDetailsRequest
        @return: DescribeStorageSetDetailsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_storage_set_details_with_options(request, runtime)

    async def describe_storage_set_details_async(
        self,
        request: ecs_20140526_models.DescribeStorageSetDetailsRequest,
    ) -> ecs_20140526_models.DescribeStorageSetDetailsResponse:
        """
        @summary Queries the details of the disks or Shared Block Storage devices in a storage set.
        
        @param request: DescribeStorageSetDetailsRequest
        @return: DescribeStorageSetDetailsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_storage_set_details_with_options_async(request, runtime)

    def describe_storage_sets_with_options(
        self,
        request: ecs_20140526_models.DescribeStorageSetsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeStorageSetsResponse:
        """
        @summary Describes the details of storage sets in a specific region. The details of a storage set include its region, zone, creation time, and maximum number of partitions.
        
        @param request: DescribeStorageSetsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeStorageSetsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_set_ids):
            query['StorageSetIds'] = request.storage_set_ids
        if not UtilClient.is_unset(request.storage_set_name):
            query['StorageSetName'] = request.storage_set_name
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeStorageSets',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeStorageSetsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_storage_sets_with_options_async(
        self,
        request: ecs_20140526_models.DescribeStorageSetsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeStorageSetsResponse:
        """
        @summary Describes the details of storage sets in a specific region. The details of a storage set include its region, zone, creation time, and maximum number of partitions.
        
        @param request: DescribeStorageSetsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeStorageSetsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_set_ids):
            query['StorageSetIds'] = request.storage_set_ids
        if not UtilClient.is_unset(request.storage_set_name):
            query['StorageSetName'] = request.storage_set_name
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeStorageSets',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeStorageSetsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_storage_sets(
        self,
        request: ecs_20140526_models.DescribeStorageSetsRequest,
    ) -> ecs_20140526_models.DescribeStorageSetsResponse:
        """
        @summary Describes the details of storage sets in a specific region. The details of a storage set include its region, zone, creation time, and maximum number of partitions.
        
        @param request: DescribeStorageSetsRequest
        @return: DescribeStorageSetsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_storage_sets_with_options(request, runtime)

    async def describe_storage_sets_async(
        self,
        request: ecs_20140526_models.DescribeStorageSetsRequest,
    ) -> ecs_20140526_models.DescribeStorageSetsResponse:
        """
        @summary Describes the details of storage sets in a specific region. The details of a storage set include its region, zone, creation time, and maximum number of partitions.
        
        @param request: DescribeStorageSetsRequest
        @return: DescribeStorageSetsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_storage_sets_with_options_async(request, runtime)

    def describe_tags_with_options(
        self,
        request: ecs_20140526_models.DescribeTagsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeTagsResponse:
        """
        @deprecated OpenAPI DescribeTags is deprecated, please use Tag::2018-08-28::CountResourcesByTags instead.
        
        @summary Queries the available tags. You can specify multiple filter conditions, such as a resource type, a resource ID, a tag key, and a tag value, to query tags. The specified filter conditions have logical AND relations.
        
        @description If a tag key that has no tag value is specified, all tags that contain the tag key are returned. If a tag key-value pair is specified, only tags that exactly match the key-value pair are returned.
        
        @param request: DescribeTagsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeTagsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category):
            query['Category'] = request.category
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeTags',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeTagsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_tags_with_options_async(
        self,
        request: ecs_20140526_models.DescribeTagsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeTagsResponse:
        """
        @deprecated OpenAPI DescribeTags is deprecated, please use Tag::2018-08-28::CountResourcesByTags instead.
        
        @summary Queries the available tags. You can specify multiple filter conditions, such as a resource type, a resource ID, a tag key, and a tag value, to query tags. The specified filter conditions have logical AND relations.
        
        @description If a tag key that has no tag value is specified, all tags that contain the tag key are returned. If a tag key-value pair is specified, only tags that exactly match the key-value pair are returned.
        
        @param request: DescribeTagsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeTagsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category):
            query['Category'] = request.category
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeTags',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeTagsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_tags(
        self,
        request: ecs_20140526_models.DescribeTagsRequest,
    ) -> ecs_20140526_models.DescribeTagsResponse:
        """
        @deprecated OpenAPI DescribeTags is deprecated, please use Tag::2018-08-28::CountResourcesByTags instead.
        
        @summary Queries the available tags. You can specify multiple filter conditions, such as a resource type, a resource ID, a tag key, and a tag value, to query tags. The specified filter conditions have logical AND relations.
        
        @description If a tag key that has no tag value is specified, all tags that contain the tag key are returned. If a tag key-value pair is specified, only tags that exactly match the key-value pair are returned.
        
        @param request: DescribeTagsRequest
        @return: DescribeTagsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_tags_with_options(request, runtime)

    async def describe_tags_async(
        self,
        request: ecs_20140526_models.DescribeTagsRequest,
    ) -> ecs_20140526_models.DescribeTagsResponse:
        """
        @deprecated OpenAPI DescribeTags is deprecated, please use Tag::2018-08-28::CountResourcesByTags instead.
        
        @summary Queries the available tags. You can specify multiple filter conditions, such as a resource type, a resource ID, a tag key, and a tag value, to query tags. The specified filter conditions have logical AND relations.
        
        @description If a tag key that has no tag value is specified, all tags that contain the tag key are returned. If a tag key-value pair is specified, only tags that exactly match the key-value pair are returned.
        
        @param request: DescribeTagsRequest
        @return: DescribeTagsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_tags_with_options_async(request, runtime)

    def describe_task_attribute_with_options(
        self,
        request: ecs_20140526_models.DescribeTaskAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeTaskAttributeResponse:
        """
        @summary Queries the details of an asynchronous task. The asynchronous tasks that you can query by calling this operation are the tasks generated by the ImportImage, ExportImage, and ModifyDiskSpec operations.
        
        @param request: DescribeTaskAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeTaskAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeTaskAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeTaskAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_task_attribute_with_options_async(
        self,
        request: ecs_20140526_models.DescribeTaskAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeTaskAttributeResponse:
        """
        @summary Queries the details of an asynchronous task. The asynchronous tasks that you can query by calling this operation are the tasks generated by the ImportImage, ExportImage, and ModifyDiskSpec operations.
        
        @param request: DescribeTaskAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeTaskAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeTaskAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeTaskAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_task_attribute(
        self,
        request: ecs_20140526_models.DescribeTaskAttributeRequest,
    ) -> ecs_20140526_models.DescribeTaskAttributeResponse:
        """
        @summary Queries the details of an asynchronous task. The asynchronous tasks that you can query by calling this operation are the tasks generated by the ImportImage, ExportImage, and ModifyDiskSpec operations.
        
        @param request: DescribeTaskAttributeRequest
        @return: DescribeTaskAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_task_attribute_with_options(request, runtime)

    async def describe_task_attribute_async(
        self,
        request: ecs_20140526_models.DescribeTaskAttributeRequest,
    ) -> ecs_20140526_models.DescribeTaskAttributeResponse:
        """
        @summary Queries the details of an asynchronous task. The asynchronous tasks that you can query by calling this operation are the tasks generated by the ImportImage, ExportImage, and ModifyDiskSpec operations.
        
        @param request: DescribeTaskAttributeRequest
        @return: DescribeTaskAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_task_attribute_with_options_async(request, runtime)

    def describe_tasks_with_options(
        self,
        request: ecs_20140526_models.DescribeTasksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeTasksResponse:
        """
        @summary Queries the progress of one or more asynchronous tasks.
        
        @description ## Debugging
        [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Ecs\\&api=DescribeTasks\\&type=RPC\\&version=2014-05-26)
        
        @param request: DescribeTasksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeTasksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_ids):
            query['ResourceIds'] = request.resource_ids
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.task_action):
            query['TaskAction'] = request.task_action
        if not UtilClient.is_unset(request.task_ids):
            query['TaskIds'] = request.task_ids
        if not UtilClient.is_unset(request.task_status):
            query['TaskStatus'] = request.task_status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeTasks',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeTasksResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_tasks_with_options_async(
        self,
        request: ecs_20140526_models.DescribeTasksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeTasksResponse:
        """
        @summary Queries the progress of one or more asynchronous tasks.
        
        @description ## Debugging
        [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Ecs\\&api=DescribeTasks\\&type=RPC\\&version=2014-05-26)
        
        @param request: DescribeTasksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeTasksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_ids):
            query['ResourceIds'] = request.resource_ids
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.task_action):
            query['TaskAction'] = request.task_action
        if not UtilClient.is_unset(request.task_ids):
            query['TaskIds'] = request.task_ids
        if not UtilClient.is_unset(request.task_status):
            query['TaskStatus'] = request.task_status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeTasks',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeTasksResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_tasks(
        self,
        request: ecs_20140526_models.DescribeTasksRequest,
    ) -> ecs_20140526_models.DescribeTasksResponse:
        """
        @summary Queries the progress of one or more asynchronous tasks.
        
        @description ## Debugging
        [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Ecs\\&api=DescribeTasks\\&type=RPC\\&version=2014-05-26)
        
        @param request: DescribeTasksRequest
        @return: DescribeTasksResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_tasks_with_options(request, runtime)

    async def describe_tasks_async(
        self,
        request: ecs_20140526_models.DescribeTasksRequest,
    ) -> ecs_20140526_models.DescribeTasksResponse:
        """
        @summary Queries the progress of one or more asynchronous tasks.
        
        @description ## Debugging
        [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Ecs\\&api=DescribeTasks\\&type=RPC\\&version=2014-05-26)
        
        @param request: DescribeTasksRequest
        @return: DescribeTasksResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_tasks_with_options_async(request, runtime)

    def describe_terminal_sessions_with_options(
        self,
        request: ecs_20140526_models.DescribeTerminalSessionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeTerminalSessionsResponse:
        """
        @summary Queries the session records of Elastic Compute Service (ECS) Session Manager.
        
        @description You can query the session records of Session Manager that were generated in the last four weeks.
        
        @param request: DescribeTerminalSessionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeTerminalSessionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.session_id):
            query['SessionId'] = request.session_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeTerminalSessions',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeTerminalSessionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_terminal_sessions_with_options_async(
        self,
        request: ecs_20140526_models.DescribeTerminalSessionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeTerminalSessionsResponse:
        """
        @summary Queries the session records of Elastic Compute Service (ECS) Session Manager.
        
        @description You can query the session records of Session Manager that were generated in the last four weeks.
        
        @param request: DescribeTerminalSessionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeTerminalSessionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.session_id):
            query['SessionId'] = request.session_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeTerminalSessions',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeTerminalSessionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_terminal_sessions(
        self,
        request: ecs_20140526_models.DescribeTerminalSessionsRequest,
    ) -> ecs_20140526_models.DescribeTerminalSessionsResponse:
        """
        @summary Queries the session records of Elastic Compute Service (ECS) Session Manager.
        
        @description You can query the session records of Session Manager that were generated in the last four weeks.
        
        @param request: DescribeTerminalSessionsRequest
        @return: DescribeTerminalSessionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_terminal_sessions_with_options(request, runtime)

    async def describe_terminal_sessions_async(
        self,
        request: ecs_20140526_models.DescribeTerminalSessionsRequest,
    ) -> ecs_20140526_models.DescribeTerminalSessionsResponse:
        """
        @summary Queries the session records of Elastic Compute Service (ECS) Session Manager.
        
        @description You can query the session records of Session Manager that were generated in the last four weeks.
        
        @param request: DescribeTerminalSessionsRequest
        @return: DescribeTerminalSessionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_terminal_sessions_with_options_async(request, runtime)

    def describe_user_business_behavior_with_options(
        self,
        request: ecs_20140526_models.DescribeUserBusinessBehaviorRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeUserBusinessBehaviorResponse:
        """
        @deprecated OpenAPI DescribeUserBusinessBehavior is deprecated
        
        @summary 获取用户级别默认属性
        
        @param request: DescribeUserBusinessBehaviorRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeUserBusinessBehaviorResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status_key):
            query['statusKey'] = request.status_key
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeUserBusinessBehavior',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeUserBusinessBehaviorResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_user_business_behavior_with_options_async(
        self,
        request: ecs_20140526_models.DescribeUserBusinessBehaviorRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeUserBusinessBehaviorResponse:
        """
        @deprecated OpenAPI DescribeUserBusinessBehavior is deprecated
        
        @summary 获取用户级别默认属性
        
        @param request: DescribeUserBusinessBehaviorRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeUserBusinessBehaviorResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status_key):
            query['statusKey'] = request.status_key
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeUserBusinessBehavior',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeUserBusinessBehaviorResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_user_business_behavior(
        self,
        request: ecs_20140526_models.DescribeUserBusinessBehaviorRequest,
    ) -> ecs_20140526_models.DescribeUserBusinessBehaviorResponse:
        """
        @deprecated OpenAPI DescribeUserBusinessBehavior is deprecated
        
        @summary 获取用户级别默认属性
        
        @param request: DescribeUserBusinessBehaviorRequest
        @return: DescribeUserBusinessBehaviorResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_user_business_behavior_with_options(request, runtime)

    async def describe_user_business_behavior_async(
        self,
        request: ecs_20140526_models.DescribeUserBusinessBehaviorRequest,
    ) -> ecs_20140526_models.DescribeUserBusinessBehaviorResponse:
        """
        @deprecated OpenAPI DescribeUserBusinessBehavior is deprecated
        
        @summary 获取用户级别默认属性
        
        @param request: DescribeUserBusinessBehaviorRequest
        @return: DescribeUserBusinessBehaviorResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_user_business_behavior_with_options_async(request, runtime)

    def describe_user_data_with_options(
        self,
        request: ecs_20140526_models.DescribeUserDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeUserDataResponse:
        """
        @summary Queries the user data of an Elastic Compute Service (ECS) instance.
        
        @description    If no user data is configured for the ECS instance, an empty string is returned.
        
        @param request: DescribeUserDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeUserDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeUserData',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeUserDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_user_data_with_options_async(
        self,
        request: ecs_20140526_models.DescribeUserDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeUserDataResponse:
        """
        @summary Queries the user data of an Elastic Compute Service (ECS) instance.
        
        @description    If no user data is configured for the ECS instance, an empty string is returned.
        
        @param request: DescribeUserDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeUserDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeUserData',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeUserDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_user_data(
        self,
        request: ecs_20140526_models.DescribeUserDataRequest,
    ) -> ecs_20140526_models.DescribeUserDataResponse:
        """
        @summary Queries the user data of an Elastic Compute Service (ECS) instance.
        
        @description    If no user data is configured for the ECS instance, an empty string is returned.
        
        @param request: DescribeUserDataRequest
        @return: DescribeUserDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_user_data_with_options(request, runtime)

    async def describe_user_data_async(
        self,
        request: ecs_20140526_models.DescribeUserDataRequest,
    ) -> ecs_20140526_models.DescribeUserDataResponse:
        """
        @summary Queries the user data of an Elastic Compute Service (ECS) instance.
        
        @description    If no user data is configured for the ECS instance, an empty string is returned.
        
        @param request: DescribeUserDataRequest
        @return: DescribeUserDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_user_data_with_options_async(request, runtime)

    def describe_vrouters_with_options(
        self,
        request: ecs_20140526_models.DescribeVRoutersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeVRoutersResponse:
        """
        @deprecated OpenAPI DescribeVRouters is deprecated, please use Vpc::2016-04-28::DescribeVRouters instead.
        
        @summary 查询路由器列表
        
        @param request: DescribeVRoutersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVRoutersResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vrouter_id):
            query['VRouterId'] = request.vrouter_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVRouters',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeVRoutersResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vrouters_with_options_async(
        self,
        request: ecs_20140526_models.DescribeVRoutersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeVRoutersResponse:
        """
        @deprecated OpenAPI DescribeVRouters is deprecated, please use Vpc::2016-04-28::DescribeVRouters instead.
        
        @summary 查询路由器列表
        
        @param request: DescribeVRoutersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVRoutersResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vrouter_id):
            query['VRouterId'] = request.vrouter_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVRouters',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeVRoutersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vrouters(
        self,
        request: ecs_20140526_models.DescribeVRoutersRequest,
    ) -> ecs_20140526_models.DescribeVRoutersResponse:
        """
        @deprecated OpenAPI DescribeVRouters is deprecated, please use Vpc::2016-04-28::DescribeVRouters instead.
        
        @summary 查询路由器列表
        
        @param request: DescribeVRoutersRequest
        @return: DescribeVRoutersResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vrouters_with_options(request, runtime)

    async def describe_vrouters_async(
        self,
        request: ecs_20140526_models.DescribeVRoutersRequest,
    ) -> ecs_20140526_models.DescribeVRoutersResponse:
        """
        @deprecated OpenAPI DescribeVRouters is deprecated, please use Vpc::2016-04-28::DescribeVRouters instead.
        
        @summary 查询路由器列表
        
        @param request: DescribeVRoutersRequest
        @return: DescribeVRoutersResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vrouters_with_options_async(request, runtime)

    def describe_vswitches_with_options(
        self,
        request: ecs_20140526_models.DescribeVSwitchesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeVSwitchesResponse:
        """
        @deprecated OpenAPI DescribeVSwitches is deprecated, please use Vpc::2016-04-28::DescribeVSwitches instead.
        
        @summary DescribeVSwitches
        
        @param request: DescribeVSwitchesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVSwitchesResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.is_default):
            query['IsDefault'] = request.is_default
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVSwitches',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeVSwitchesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vswitches_with_options_async(
        self,
        request: ecs_20140526_models.DescribeVSwitchesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeVSwitchesResponse:
        """
        @deprecated OpenAPI DescribeVSwitches is deprecated, please use Vpc::2016-04-28::DescribeVSwitches instead.
        
        @summary DescribeVSwitches
        
        @param request: DescribeVSwitchesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVSwitchesResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.is_default):
            query['IsDefault'] = request.is_default
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVSwitches',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeVSwitchesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vswitches(
        self,
        request: ecs_20140526_models.DescribeVSwitchesRequest,
    ) -> ecs_20140526_models.DescribeVSwitchesResponse:
        """
        @deprecated OpenAPI DescribeVSwitches is deprecated, please use Vpc::2016-04-28::DescribeVSwitches instead.
        
        @summary DescribeVSwitches
        
        @param request: DescribeVSwitchesRequest
        @return: DescribeVSwitchesResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vswitches_with_options(request, runtime)

    async def describe_vswitches_async(
        self,
        request: ecs_20140526_models.DescribeVSwitchesRequest,
    ) -> ecs_20140526_models.DescribeVSwitchesResponse:
        """
        @deprecated OpenAPI DescribeVSwitches is deprecated, please use Vpc::2016-04-28::DescribeVSwitches instead.
        
        @summary DescribeVSwitches
        
        @param request: DescribeVSwitchesRequest
        @return: DescribeVSwitchesResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vswitches_with_options_async(request, runtime)

    def describe_virtual_border_routers_with_options(
        self,
        request: ecs_20140526_models.DescribeVirtualBorderRoutersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeVirtualBorderRoutersResponse:
        """
        @deprecated OpenAPI DescribeVirtualBorderRouters is deprecated, please use Vpc::2016-04-28::DescribeVirtualBorderRouters instead.
        
        @summary DescribeVirtualBorderRouters
        
        @param request: DescribeVirtualBorderRoutersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVirtualBorderRoutersResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVirtualBorderRouters',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeVirtualBorderRoutersResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_virtual_border_routers_with_options_async(
        self,
        request: ecs_20140526_models.DescribeVirtualBorderRoutersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeVirtualBorderRoutersResponse:
        """
        @deprecated OpenAPI DescribeVirtualBorderRouters is deprecated, please use Vpc::2016-04-28::DescribeVirtualBorderRouters instead.
        
        @summary DescribeVirtualBorderRouters
        
        @param request: DescribeVirtualBorderRoutersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVirtualBorderRoutersResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVirtualBorderRouters',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeVirtualBorderRoutersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_virtual_border_routers(
        self,
        request: ecs_20140526_models.DescribeVirtualBorderRoutersRequest,
    ) -> ecs_20140526_models.DescribeVirtualBorderRoutersResponse:
        """
        @deprecated OpenAPI DescribeVirtualBorderRouters is deprecated, please use Vpc::2016-04-28::DescribeVirtualBorderRouters instead.
        
        @summary DescribeVirtualBorderRouters
        
        @param request: DescribeVirtualBorderRoutersRequest
        @return: DescribeVirtualBorderRoutersResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_virtual_border_routers_with_options(request, runtime)

    async def describe_virtual_border_routers_async(
        self,
        request: ecs_20140526_models.DescribeVirtualBorderRoutersRequest,
    ) -> ecs_20140526_models.DescribeVirtualBorderRoutersResponse:
        """
        @deprecated OpenAPI DescribeVirtualBorderRouters is deprecated, please use Vpc::2016-04-28::DescribeVirtualBorderRouters instead.
        
        @summary DescribeVirtualBorderRouters
        
        @param request: DescribeVirtualBorderRoutersRequest
        @return: DescribeVirtualBorderRoutersResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_virtual_border_routers_with_options_async(request, runtime)

    def describe_virtual_border_routers_for_physical_connection_with_options(
        self,
        request: ecs_20140526_models.DescribeVirtualBorderRoutersForPhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeVirtualBorderRoutersForPhysicalConnectionResponse:
        """
        @deprecated OpenAPI DescribeVirtualBorderRoutersForPhysicalConnection is deprecated, please use Vpc::2016-04-28::DescribeVirtualBorderRoutersForPhysicalConnection instead.
        
        @summary DescribeVirtualBorderRoutersForPhysicalConnection
        
        @param request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVirtualBorderRoutersForPhysicalConnectionResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVirtualBorderRoutersForPhysicalConnection',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeVirtualBorderRoutersForPhysicalConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_virtual_border_routers_for_physical_connection_with_options_async(
        self,
        request: ecs_20140526_models.DescribeVirtualBorderRoutersForPhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeVirtualBorderRoutersForPhysicalConnectionResponse:
        """
        @deprecated OpenAPI DescribeVirtualBorderRoutersForPhysicalConnection is deprecated, please use Vpc::2016-04-28::DescribeVirtualBorderRoutersForPhysicalConnection instead.
        
        @summary DescribeVirtualBorderRoutersForPhysicalConnection
        
        @param request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVirtualBorderRoutersForPhysicalConnectionResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVirtualBorderRoutersForPhysicalConnection',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeVirtualBorderRoutersForPhysicalConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_virtual_border_routers_for_physical_connection(
        self,
        request: ecs_20140526_models.DescribeVirtualBorderRoutersForPhysicalConnectionRequest,
    ) -> ecs_20140526_models.DescribeVirtualBorderRoutersForPhysicalConnectionResponse:
        """
        @deprecated OpenAPI DescribeVirtualBorderRoutersForPhysicalConnection is deprecated, please use Vpc::2016-04-28::DescribeVirtualBorderRoutersForPhysicalConnection instead.
        
        @summary DescribeVirtualBorderRoutersForPhysicalConnection
        
        @param request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest
        @return: DescribeVirtualBorderRoutersForPhysicalConnectionResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_virtual_border_routers_for_physical_connection_with_options(request, runtime)

    async def describe_virtual_border_routers_for_physical_connection_async(
        self,
        request: ecs_20140526_models.DescribeVirtualBorderRoutersForPhysicalConnectionRequest,
    ) -> ecs_20140526_models.DescribeVirtualBorderRoutersForPhysicalConnectionResponse:
        """
        @deprecated OpenAPI DescribeVirtualBorderRoutersForPhysicalConnection is deprecated, please use Vpc::2016-04-28::DescribeVirtualBorderRoutersForPhysicalConnection instead.
        
        @summary DescribeVirtualBorderRoutersForPhysicalConnection
        
        @param request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest
        @return: DescribeVirtualBorderRoutersForPhysicalConnectionResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_virtual_border_routers_for_physical_connection_with_options_async(request, runtime)

    def describe_vpcs_with_options(
        self,
        request: ecs_20140526_models.DescribeVpcsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeVpcsResponse:
        """
        @deprecated OpenAPI DescribeVpcs is deprecated, please use Vpc::2016-04-28::DescribeVpcs instead.
        
        @summary 查询VPC
        
        @param request: DescribeVpcsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpcsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.is_default):
            query['IsDefault'] = request.is_default
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpcs',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeVpcsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vpcs_with_options_async(
        self,
        request: ecs_20140526_models.DescribeVpcsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeVpcsResponse:
        """
        @deprecated OpenAPI DescribeVpcs is deprecated, please use Vpc::2016-04-28::DescribeVpcs instead.
        
        @summary 查询VPC
        
        @param request: DescribeVpcsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpcsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.is_default):
            query['IsDefault'] = request.is_default
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpcs',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeVpcsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vpcs(
        self,
        request: ecs_20140526_models.DescribeVpcsRequest,
    ) -> ecs_20140526_models.DescribeVpcsResponse:
        """
        @deprecated OpenAPI DescribeVpcs is deprecated, please use Vpc::2016-04-28::DescribeVpcs instead.
        
        @summary 查询VPC
        
        @param request: DescribeVpcsRequest
        @return: DescribeVpcsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vpcs_with_options(request, runtime)

    async def describe_vpcs_async(
        self,
        request: ecs_20140526_models.DescribeVpcsRequest,
    ) -> ecs_20140526_models.DescribeVpcsResponse:
        """
        @deprecated OpenAPI DescribeVpcs is deprecated, please use Vpc::2016-04-28::DescribeVpcs instead.
        
        @summary 查询VPC
        
        @param request: DescribeVpcsRequest
        @return: DescribeVpcsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vpcs_with_options_async(request, runtime)

    def describe_zones_with_options(
        self,
        request: ecs_20140526_models.DescribeZonesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeZonesResponse:
        """
        @summary Queries Alibaba Cloud regions. You can specify parameters, such as InstanceChargeType and ResourceType, in the request.
        
        @description ## [](#)Usage notes
        When you call this operation, only a list of zones and some resource information of each zone are returned. If you want to query instance types and disk categories that are available for purchase in a specific zone, we recommend that you call the [DescribeAvailableResource](https://help.aliyun.com/document_detail/66186.html) operation.
        
        @param request: DescribeZonesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeZonesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.accept_language):
            query['AcceptLanguage'] = request.accept_language
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.spot_strategy):
            query['SpotStrategy'] = request.spot_strategy
        if not UtilClient.is_unset(request.verbose):
            query['Verbose'] = request.verbose
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeZones',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeZonesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_zones_with_options_async(
        self,
        request: ecs_20140526_models.DescribeZonesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DescribeZonesResponse:
        """
        @summary Queries Alibaba Cloud regions. You can specify parameters, such as InstanceChargeType and ResourceType, in the request.
        
        @description ## [](#)Usage notes
        When you call this operation, only a list of zones and some resource information of each zone are returned. If you want to query instance types and disk categories that are available for purchase in a specific zone, we recommend that you call the [DescribeAvailableResource](https://help.aliyun.com/document_detail/66186.html) operation.
        
        @param request: DescribeZonesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeZonesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.accept_language):
            query['AcceptLanguage'] = request.accept_language
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.spot_strategy):
            query['SpotStrategy'] = request.spot_strategy
        if not UtilClient.is_unset(request.verbose):
            query['Verbose'] = request.verbose
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeZones',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DescribeZonesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_zones(
        self,
        request: ecs_20140526_models.DescribeZonesRequest,
    ) -> ecs_20140526_models.DescribeZonesResponse:
        """
        @summary Queries Alibaba Cloud regions. You can specify parameters, such as InstanceChargeType and ResourceType, in the request.
        
        @description ## [](#)Usage notes
        When you call this operation, only a list of zones and some resource information of each zone are returned. If you want to query instance types and disk categories that are available for purchase in a specific zone, we recommend that you call the [DescribeAvailableResource](https://help.aliyun.com/document_detail/66186.html) operation.
        
        @param request: DescribeZonesRequest
        @return: DescribeZonesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_zones_with_options(request, runtime)

    async def describe_zones_async(
        self,
        request: ecs_20140526_models.DescribeZonesRequest,
    ) -> ecs_20140526_models.DescribeZonesResponse:
        """
        @summary Queries Alibaba Cloud regions. You can specify parameters, such as InstanceChargeType and ResourceType, in the request.
        
        @description ## [](#)Usage notes
        When you call this operation, only a list of zones and some resource information of each zone are returned. If you want to query instance types and disk categories that are available for purchase in a specific zone, we recommend that you call the [DescribeAvailableResource](https://help.aliyun.com/document_detail/66186.html) operation.
        
        @param request: DescribeZonesRequest
        @return: DescribeZonesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_zones_with_options_async(request, runtime)

    def detach_classic_link_vpc_with_options(
        self,
        request: ecs_20140526_models.DetachClassicLinkVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DetachClassicLinkVpcResponse:
        """
        @summary Unlinks an Elastic Compute Service (ECS) instance that resides in the classic network from a virtual private cloud (VPC) by closing the ClassicLink connection between the instance and the VPC. After the instance is unlinked from the VPC, the instance can no longer communicate with instances in the VPC.
        
        @param request: DetachClassicLinkVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DetachClassicLinkVpcResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DetachClassicLinkVpc',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DetachClassicLinkVpcResponse(),
            self.call_api(params, req, runtime)
        )

    async def detach_classic_link_vpc_with_options_async(
        self,
        request: ecs_20140526_models.DetachClassicLinkVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DetachClassicLinkVpcResponse:
        """
        @summary Unlinks an Elastic Compute Service (ECS) instance that resides in the classic network from a virtual private cloud (VPC) by closing the ClassicLink connection between the instance and the VPC. After the instance is unlinked from the VPC, the instance can no longer communicate with instances in the VPC.
        
        @param request: DetachClassicLinkVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DetachClassicLinkVpcResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DetachClassicLinkVpc',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DetachClassicLinkVpcResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def detach_classic_link_vpc(
        self,
        request: ecs_20140526_models.DetachClassicLinkVpcRequest,
    ) -> ecs_20140526_models.DetachClassicLinkVpcResponse:
        """
        @summary Unlinks an Elastic Compute Service (ECS) instance that resides in the classic network from a virtual private cloud (VPC) by closing the ClassicLink connection between the instance and the VPC. After the instance is unlinked from the VPC, the instance can no longer communicate with instances in the VPC.
        
        @param request: DetachClassicLinkVpcRequest
        @return: DetachClassicLinkVpcResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.detach_classic_link_vpc_with_options(request, runtime)

    async def detach_classic_link_vpc_async(
        self,
        request: ecs_20140526_models.DetachClassicLinkVpcRequest,
    ) -> ecs_20140526_models.DetachClassicLinkVpcResponse:
        """
        @summary Unlinks an Elastic Compute Service (ECS) instance that resides in the classic network from a virtual private cloud (VPC) by closing the ClassicLink connection between the instance and the VPC. After the instance is unlinked from the VPC, the instance can no longer communicate with instances in the VPC.
        
        @param request: DetachClassicLinkVpcRequest
        @return: DetachClassicLinkVpcResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.detach_classic_link_vpc_with_options_async(request, runtime)

    def detach_disk_with_options(
        self,
        request: ecs_20140526_models.DetachDiskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DetachDiskResponse:
        """
        @summary Detaches a pay-as-you-go data disk or a system disk from an Elastic Compute Service (ECS) instance.
        
        @description Take note of the following items:
        This operation is an asynchronous operation. After you call the operation to detach a disk from an ECS instance, the disk is detached in approximately 1 minute.
        If `OperationLocks` in the response contains `"LockReason" : "security"` when you query information about an instance, the instance is locked for security reasons and all operations are prohibited on the instance.
        If you want to attach an elastic ephemeral disk that you detached from an instance, you can attach the disk only to the instance.
        
        @param request: DetachDiskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DetachDiskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.delete_with_instance):
            query['DeleteWithInstance'] = request.delete_with_instance
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DetachDisk',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DetachDiskResponse(),
            self.call_api(params, req, runtime)
        )

    async def detach_disk_with_options_async(
        self,
        request: ecs_20140526_models.DetachDiskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DetachDiskResponse:
        """
        @summary Detaches a pay-as-you-go data disk or a system disk from an Elastic Compute Service (ECS) instance.
        
        @description Take note of the following items:
        This operation is an asynchronous operation. After you call the operation to detach a disk from an ECS instance, the disk is detached in approximately 1 minute.
        If `OperationLocks` in the response contains `"LockReason" : "security"` when you query information about an instance, the instance is locked for security reasons and all operations are prohibited on the instance.
        If you want to attach an elastic ephemeral disk that you detached from an instance, you can attach the disk only to the instance.
        
        @param request: DetachDiskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DetachDiskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.delete_with_instance):
            query['DeleteWithInstance'] = request.delete_with_instance
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DetachDisk',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DetachDiskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def detach_disk(
        self,
        request: ecs_20140526_models.DetachDiskRequest,
    ) -> ecs_20140526_models.DetachDiskResponse:
        """
        @summary Detaches a pay-as-you-go data disk or a system disk from an Elastic Compute Service (ECS) instance.
        
        @description Take note of the following items:
        This operation is an asynchronous operation. After you call the operation to detach a disk from an ECS instance, the disk is detached in approximately 1 minute.
        If `OperationLocks` in the response contains `"LockReason" : "security"` when you query information about an instance, the instance is locked for security reasons and all operations are prohibited on the instance.
        If you want to attach an elastic ephemeral disk that you detached from an instance, you can attach the disk only to the instance.
        
        @param request: DetachDiskRequest
        @return: DetachDiskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.detach_disk_with_options(request, runtime)

    async def detach_disk_async(
        self,
        request: ecs_20140526_models.DetachDiskRequest,
    ) -> ecs_20140526_models.DetachDiskResponse:
        """
        @summary Detaches a pay-as-you-go data disk or a system disk from an Elastic Compute Service (ECS) instance.
        
        @description Take note of the following items:
        This operation is an asynchronous operation. After you call the operation to detach a disk from an ECS instance, the disk is detached in approximately 1 minute.
        If `OperationLocks` in the response contains `"LockReason" : "security"` when you query information about an instance, the instance is locked for security reasons and all operations are prohibited on the instance.
        If you want to attach an elastic ephemeral disk that you detached from an instance, you can attach the disk only to the instance.
        
        @param request: DetachDiskRequest
        @return: DetachDiskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.detach_disk_with_options_async(request, runtime)

    def detach_instance_ram_role_with_options(
        self,
        request: ecs_20140526_models.DetachInstanceRamRoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DetachInstanceRamRoleResponse:
        """
        @summary Detaches instance Resource Access Management (RAM) roles from Elastic Compute Service (ECS) instances.
        
        @param request: DetachInstanceRamRoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DetachInstanceRamRoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.ram_role_name):
            query['RamRoleName'] = request.ram_role_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DetachInstanceRamRole',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DetachInstanceRamRoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def detach_instance_ram_role_with_options_async(
        self,
        request: ecs_20140526_models.DetachInstanceRamRoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DetachInstanceRamRoleResponse:
        """
        @summary Detaches instance Resource Access Management (RAM) roles from Elastic Compute Service (ECS) instances.
        
        @param request: DetachInstanceRamRoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DetachInstanceRamRoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.ram_role_name):
            query['RamRoleName'] = request.ram_role_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DetachInstanceRamRole',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DetachInstanceRamRoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def detach_instance_ram_role(
        self,
        request: ecs_20140526_models.DetachInstanceRamRoleRequest,
    ) -> ecs_20140526_models.DetachInstanceRamRoleResponse:
        """
        @summary Detaches instance Resource Access Management (RAM) roles from Elastic Compute Service (ECS) instances.
        
        @param request: DetachInstanceRamRoleRequest
        @return: DetachInstanceRamRoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.detach_instance_ram_role_with_options(request, runtime)

    async def detach_instance_ram_role_async(
        self,
        request: ecs_20140526_models.DetachInstanceRamRoleRequest,
    ) -> ecs_20140526_models.DetachInstanceRamRoleResponse:
        """
        @summary Detaches instance Resource Access Management (RAM) roles from Elastic Compute Service (ECS) instances.
        
        @param request: DetachInstanceRamRoleRequest
        @return: DetachInstanceRamRoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.detach_instance_ram_role_with_options_async(request, runtime)

    def detach_key_pair_with_options(
        self,
        request: ecs_20140526_models.DetachKeyPairRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DetachKeyPairResponse:
        """
        @summary Unbinds an SSH key pair from Linux Elastic Compute Service (ECS) instances.
        
        @description When you call this operation, take note of the following items:
        After you unbind an SSH key pair from an instance, you must call the [RebootInstance](https://help.aliyun.com/document_detail/25502.html) operation to restart the instance to allow the unbind operation to take effect.
        After you unbind an SSH key pair from an instance, the username and password authentication method is selected for the instance.
        
        @param request: DetachKeyPairRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DetachKeyPairResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DetachKeyPair',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DetachKeyPairResponse(),
            self.call_api(params, req, runtime)
        )

    async def detach_key_pair_with_options_async(
        self,
        request: ecs_20140526_models.DetachKeyPairRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DetachKeyPairResponse:
        """
        @summary Unbinds an SSH key pair from Linux Elastic Compute Service (ECS) instances.
        
        @description When you call this operation, take note of the following items:
        After you unbind an SSH key pair from an instance, you must call the [RebootInstance](https://help.aliyun.com/document_detail/25502.html) operation to restart the instance to allow the unbind operation to take effect.
        After you unbind an SSH key pair from an instance, the username and password authentication method is selected for the instance.
        
        @param request: DetachKeyPairRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DetachKeyPairResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DetachKeyPair',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DetachKeyPairResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def detach_key_pair(
        self,
        request: ecs_20140526_models.DetachKeyPairRequest,
    ) -> ecs_20140526_models.DetachKeyPairResponse:
        """
        @summary Unbinds an SSH key pair from Linux Elastic Compute Service (ECS) instances.
        
        @description When you call this operation, take note of the following items:
        After you unbind an SSH key pair from an instance, you must call the [RebootInstance](https://help.aliyun.com/document_detail/25502.html) operation to restart the instance to allow the unbind operation to take effect.
        After you unbind an SSH key pair from an instance, the username and password authentication method is selected for the instance.
        
        @param request: DetachKeyPairRequest
        @return: DetachKeyPairResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.detach_key_pair_with_options(request, runtime)

    async def detach_key_pair_async(
        self,
        request: ecs_20140526_models.DetachKeyPairRequest,
    ) -> ecs_20140526_models.DetachKeyPairResponse:
        """
        @summary Unbinds an SSH key pair from Linux Elastic Compute Service (ECS) instances.
        
        @description When you call this operation, take note of the following items:
        After you unbind an SSH key pair from an instance, you must call the [RebootInstance](https://help.aliyun.com/document_detail/25502.html) operation to restart the instance to allow the unbind operation to take effect.
        After you unbind an SSH key pair from an instance, the username and password authentication method is selected for the instance.
        
        @param request: DetachKeyPairRequest
        @return: DetachKeyPairResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.detach_key_pair_with_options_async(request, runtime)

    def detach_network_interface_with_options(
        self,
        request: ecs_20140526_models.DetachNetworkInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DetachNetworkInterfaceResponse:
        """
        @summary Detach an elastic network interface (ENI) from an Elastic Compute Service (ECS) instance.
        
        @description Take note of the following items:
        You cannot detach the primary ENI of an instance.
        Make sure that the ENI to be detached is in the Detaching (Unbinding) or InUse (Bound) state.
        Make sure that the instance from which you want to detach an ENI is in the Running (Running) or Stopped (Stopped) state.
        The DetachNetworkInterface operation is an asynchronous operation. After this operation is called to detach an ENI, you can check the status or events of the ENI to determine whether the ENI is detached. The following figure shows the transitions between the states of the ENI.![](https://help-static-aliyun-doc.aliyuncs.com/file-manage-files/en-US/20230223/uemr/DetachNetworkInterface.png)
        If the ENI is in the Detaching state, the ENI detachment request is sent and the ENI is being detached from the associated instance.
        If the ENI is in the Available state, the ENI is detached from the associated instance.
        If the ENI is stuck in the Detaching state, the ENI may fail to be detached from the associated instance due to specific reasons. For example, the ENI may fail to be detached because the operating system of the instance did not respond to the ENI detachment request. If this issue occurs, you can re-initiate the request to detach the ENI. If the issue persists, restart the instance.
        For information about examples on how to call the DetachNetworkInterface operation, see [Detach an ENI from an ECS instance](https://help.aliyun.com/document_detail/471551.html).
        
        @param request: DetachNetworkInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DetachNetworkInterfaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.trunk_network_instance_id):
            query['TrunkNetworkInstanceId'] = request.trunk_network_instance_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DetachNetworkInterface',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DetachNetworkInterfaceResponse(),
            self.call_api(params, req, runtime)
        )

    async def detach_network_interface_with_options_async(
        self,
        request: ecs_20140526_models.DetachNetworkInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DetachNetworkInterfaceResponse:
        """
        @summary Detach an elastic network interface (ENI) from an Elastic Compute Service (ECS) instance.
        
        @description Take note of the following items:
        You cannot detach the primary ENI of an instance.
        Make sure that the ENI to be detached is in the Detaching (Unbinding) or InUse (Bound) state.
        Make sure that the instance from which you want to detach an ENI is in the Running (Running) or Stopped (Stopped) state.
        The DetachNetworkInterface operation is an asynchronous operation. After this operation is called to detach an ENI, you can check the status or events of the ENI to determine whether the ENI is detached. The following figure shows the transitions between the states of the ENI.![](https://help-static-aliyun-doc.aliyuncs.com/file-manage-files/en-US/20230223/uemr/DetachNetworkInterface.png)
        If the ENI is in the Detaching state, the ENI detachment request is sent and the ENI is being detached from the associated instance.
        If the ENI is in the Available state, the ENI is detached from the associated instance.
        If the ENI is stuck in the Detaching state, the ENI may fail to be detached from the associated instance due to specific reasons. For example, the ENI may fail to be detached because the operating system of the instance did not respond to the ENI detachment request. If this issue occurs, you can re-initiate the request to detach the ENI. If the issue persists, restart the instance.
        For information about examples on how to call the DetachNetworkInterface operation, see [Detach an ENI from an ECS instance](https://help.aliyun.com/document_detail/471551.html).
        
        @param request: DetachNetworkInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DetachNetworkInterfaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.trunk_network_instance_id):
            query['TrunkNetworkInstanceId'] = request.trunk_network_instance_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DetachNetworkInterface',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DetachNetworkInterfaceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def detach_network_interface(
        self,
        request: ecs_20140526_models.DetachNetworkInterfaceRequest,
    ) -> ecs_20140526_models.DetachNetworkInterfaceResponse:
        """
        @summary Detach an elastic network interface (ENI) from an Elastic Compute Service (ECS) instance.
        
        @description Take note of the following items:
        You cannot detach the primary ENI of an instance.
        Make sure that the ENI to be detached is in the Detaching (Unbinding) or InUse (Bound) state.
        Make sure that the instance from which you want to detach an ENI is in the Running (Running) or Stopped (Stopped) state.
        The DetachNetworkInterface operation is an asynchronous operation. After this operation is called to detach an ENI, you can check the status or events of the ENI to determine whether the ENI is detached. The following figure shows the transitions between the states of the ENI.![](https://help-static-aliyun-doc.aliyuncs.com/file-manage-files/en-US/20230223/uemr/DetachNetworkInterface.png)
        If the ENI is in the Detaching state, the ENI detachment request is sent and the ENI is being detached from the associated instance.
        If the ENI is in the Available state, the ENI is detached from the associated instance.
        If the ENI is stuck in the Detaching state, the ENI may fail to be detached from the associated instance due to specific reasons. For example, the ENI may fail to be detached because the operating system of the instance did not respond to the ENI detachment request. If this issue occurs, you can re-initiate the request to detach the ENI. If the issue persists, restart the instance.
        For information about examples on how to call the DetachNetworkInterface operation, see [Detach an ENI from an ECS instance](https://help.aliyun.com/document_detail/471551.html).
        
        @param request: DetachNetworkInterfaceRequest
        @return: DetachNetworkInterfaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.detach_network_interface_with_options(request, runtime)

    async def detach_network_interface_async(
        self,
        request: ecs_20140526_models.DetachNetworkInterfaceRequest,
    ) -> ecs_20140526_models.DetachNetworkInterfaceResponse:
        """
        @summary Detach an elastic network interface (ENI) from an Elastic Compute Service (ECS) instance.
        
        @description Take note of the following items:
        You cannot detach the primary ENI of an instance.
        Make sure that the ENI to be detached is in the Detaching (Unbinding) or InUse (Bound) state.
        Make sure that the instance from which you want to detach an ENI is in the Running (Running) or Stopped (Stopped) state.
        The DetachNetworkInterface operation is an asynchronous operation. After this operation is called to detach an ENI, you can check the status or events of the ENI to determine whether the ENI is detached. The following figure shows the transitions between the states of the ENI.![](https://help-static-aliyun-doc.aliyuncs.com/file-manage-files/en-US/20230223/uemr/DetachNetworkInterface.png)
        If the ENI is in the Detaching state, the ENI detachment request is sent and the ENI is being detached from the associated instance.
        If the ENI is in the Available state, the ENI is detached from the associated instance.
        If the ENI is stuck in the Detaching state, the ENI may fail to be detached from the associated instance due to specific reasons. For example, the ENI may fail to be detached because the operating system of the instance did not respond to the ENI detachment request. If this issue occurs, you can re-initiate the request to detach the ENI. If the issue persists, restart the instance.
        For information about examples on how to call the DetachNetworkInterface operation, see [Detach an ENI from an ECS instance](https://help.aliyun.com/document_detail/471551.html).
        
        @param request: DetachNetworkInterfaceRequest
        @return: DetachNetworkInterfaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.detach_network_interface_with_options_async(request, runtime)

    def disable_activation_with_options(
        self,
        request: ecs_20140526_models.DisableActivationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DisableActivationResponse:
        """
        @summary To prevent an activation code from being leaked, you can call the DisableActivation operation to disable the activation code. Disabled activation codes cannot be used to register new managed instances. However, managed instances that are already registered are not affected.
        
        @description ## [](#)Usage notes
        To prevent an activation code from being leaked, you can call the DisableActivation operation to disable the activation code. Disabled activation codes cannot be used to register new managed instances. However, managed instances that are already registered are not affected.
        
        @param request: DisableActivationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableActivationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.activation_id):
            query['ActivationId'] = request.activation_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableActivation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DisableActivationResponse(),
            self.call_api(params, req, runtime)
        )

    async def disable_activation_with_options_async(
        self,
        request: ecs_20140526_models.DisableActivationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DisableActivationResponse:
        """
        @summary To prevent an activation code from being leaked, you can call the DisableActivation operation to disable the activation code. Disabled activation codes cannot be used to register new managed instances. However, managed instances that are already registered are not affected.
        
        @description ## [](#)Usage notes
        To prevent an activation code from being leaked, you can call the DisableActivation operation to disable the activation code. Disabled activation codes cannot be used to register new managed instances. However, managed instances that are already registered are not affected.
        
        @param request: DisableActivationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableActivationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.activation_id):
            query['ActivationId'] = request.activation_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableActivation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DisableActivationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def disable_activation(
        self,
        request: ecs_20140526_models.DisableActivationRequest,
    ) -> ecs_20140526_models.DisableActivationResponse:
        """
        @summary To prevent an activation code from being leaked, you can call the DisableActivation operation to disable the activation code. Disabled activation codes cannot be used to register new managed instances. However, managed instances that are already registered are not affected.
        
        @description ## [](#)Usage notes
        To prevent an activation code from being leaked, you can call the DisableActivation operation to disable the activation code. Disabled activation codes cannot be used to register new managed instances. However, managed instances that are already registered are not affected.
        
        @param request: DisableActivationRequest
        @return: DisableActivationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.disable_activation_with_options(request, runtime)

    async def disable_activation_async(
        self,
        request: ecs_20140526_models.DisableActivationRequest,
    ) -> ecs_20140526_models.DisableActivationResponse:
        """
        @summary To prevent an activation code from being leaked, you can call the DisableActivation operation to disable the activation code. Disabled activation codes cannot be used to register new managed instances. However, managed instances that are already registered are not affected.
        
        @description ## [](#)Usage notes
        To prevent an activation code from being leaked, you can call the DisableActivation operation to disable the activation code. Disabled activation codes cannot be used to register new managed instances. However, managed instances that are already registered are not affected.
        
        @param request: DisableActivationRequest
        @return: DisableActivationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.disable_activation_with_options_async(request, runtime)

    def disable_disk_encryption_by_default_with_options(
        self,
        request: ecs_20140526_models.DisableDiskEncryptionByDefaultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DisableDiskEncryptionByDefaultResponse:
        """
        @summary Disables account-level default encryption of Elastic Block Storage (EBS) resources in a region. After you disable account-level default encryption of EBS resources in a region, the encryption status of existing disks in the region does not change. When you create a disk, you can still choose to encrypt the disk.
        
        @description    **Instructions**\
        You must grant the RAM user the `AliyunECSFullAccess` permissions. For information about how to grant permissions to a RAM user, see [Grant permissions to a RAM user](https://help.aliyun.com/document_detail/116146.html).
        **Considerations**\
        After Account-level EBS Default Encryption is disabled, the encryption status of existing cloud disks is not affected.
        After Account-level EBS Default Encryption is disabled, you can still choose to encrypt new cloud disks when you purchase the disks.
        
        @param request: DisableDiskEncryptionByDefaultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableDiskEncryptionByDefaultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableDiskEncryptionByDefault',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DisableDiskEncryptionByDefaultResponse(),
            self.call_api(params, req, runtime)
        )

    async def disable_disk_encryption_by_default_with_options_async(
        self,
        request: ecs_20140526_models.DisableDiskEncryptionByDefaultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.DisableDiskEncryptionByDefaultResponse:
        """
        @summary Disables account-level default encryption of Elastic Block Storage (EBS) resources in a region. After you disable account-level default encryption of EBS resources in a region, the encryption status of existing disks in the region does not change. When you create a disk, you can still choose to encrypt the disk.
        
        @description    **Instructions**\
        You must grant the RAM user the `AliyunECSFullAccess` permissions. For information about how to grant permissions to a RAM user, see [Grant permissions to a RAM user](https://help.aliyun.com/document_detail/116146.html).
        **Considerations**\
        After Account-level EBS Default Encryption is disabled, the encryption status of existing cloud disks is not affected.
        After Account-level EBS Default Encryption is disabled, you can still choose to encrypt new cloud disks when you purchase the disks.
        
        @param request: DisableDiskEncryptionByDefaultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableDiskEncryptionByDefaultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableDiskEncryptionByDefault',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.DisableDiskEncryptionByDefaultResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def disable_disk_encryption_by_default(
        self,
        request: ecs_20140526_models.DisableDiskEncryptionByDefaultRequest,
    ) -> ecs_20140526_models.DisableDiskEncryptionByDefaultResponse:
        """
        @summary Disables account-level default encryption of Elastic Block Storage (EBS) resources in a region. After you disable account-level default encryption of EBS resources in a region, the encryption status of existing disks in the region does not change. When you create a disk, you can still choose to encrypt the disk.
        
        @description    **Instructions**\
        You must grant the RAM user the `AliyunECSFullAccess` permissions. For information about how to grant permissions to a RAM user, see [Grant permissions to a RAM user](https://help.aliyun.com/document_detail/116146.html).
        **Considerations**\
        After Account-level EBS Default Encryption is disabled, the encryption status of existing cloud disks is not affected.
        After Account-level EBS Default Encryption is disabled, you can still choose to encrypt new cloud disks when you purchase the disks.
        
        @param request: DisableDiskEncryptionByDefaultRequest
        @return: DisableDiskEncryptionByDefaultResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.disable_disk_encryption_by_default_with_options(request, runtime)

    async def disable_disk_encryption_by_default_async(
        self,
        request: ecs_20140526_models.DisableDiskEncryptionByDefaultRequest,
    ) -> ecs_20140526_models.DisableDiskEncryptionByDefaultResponse:
        """
        @summary Disables account-level default encryption of Elastic Block Storage (EBS) resources in a region. After you disable account-level default encryption of EBS resources in a region, the encryption status of existing disks in the region does not change. When you create a disk, you can still choose to encrypt the disk.
        
        @description    **Instructions**\
        You must grant the RAM user the `AliyunECSFullAccess` permissions. For information about how to grant permissions to a RAM user, see [Grant permissions to a RAM user](https://help.aliyun.com/document_detail/116146.html).
        **Considerations**\
        After Account-level EBS Default Encryption is disabled, the encryption status of existing cloud disks is not affected.
        After Account-level EBS Default Encryption is disabled, you can still choose to encrypt new cloud disks when you purchase the disks.
        
        @param request: DisableDiskEncryptionByDefaultRequest
        @return: DisableDiskEncryptionByDefaultResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.disable_disk_encryption_by_default_with_options_async(request, runtime)

    def enable_disk_encryption_by_default_with_options(
        self,
        request: ecs_20140526_models.EnableDiskEncryptionByDefaultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.EnableDiskEncryptionByDefaultResponse:
        """
        @summary Enables the Account-level Elastic Block Storage (EBS) Default Encryption feature in a region.
        
        @description >  The Account-level EBS Default Encryption feature is available only in specific regions and to specific users. To use the feature, [submit a ticket](https://smartservice.console.aliyun.com/service/create-ticket-intl).
        **Precautions**\
        To enable the Account-level EBS Default Encryption feature as a Resource Access Management (RAM) user, grant the `AliyunECSFullAccess` permission to the RAM user. For more information, see [Grant permissions to a RAM user](https://help.aliyun.com/document_detail/116146.html).
        Before you can enable the Account-level EBS Default Encryption feature in a region, you must [activate Key Management Service (KMS)](https://help.aliyun.com/document_detail/480156.html) in the region.
        After you enable the Account-level EBS Default Encryption feature in a region, you can purchase only encrypted cloud disks in the region. For more information, see the [Limits](~~59643#50de175230erj~~) section of the "Encrypt cloud disks" topic.
        **Considerations**\
        After you enable the Account-level EBS Default Encryption feature in a region, new pay-as-you-go and subscription cloud disks in the region must be encrypted. You can use the KMS key configured for the feature or specify other KMS keys to encrypt the cloud disks.
        The first time you enable the Account-level EBS Default Encryption feature in a region, the service key in the region is automatically used to encrypt EBS resources.
        **Suggestions**\
        You can call the [DescribeDiskEncryptionByDefaultStatus](https://help.aliyun.com/document_detail/2851493.html) operation to query whether the Account-level EBS Default Encryption feature is enabled in a region and the [DescribeDiskDefaultKMSKeyId](https://help.aliyun.com/document_detail/2851490.html) operation to query the ID of the KMS key used by the feature in a region.
        You can call the [ModifyDiskDefaultKMSKeyId](https://help.aliyun.com/document_detail/2851492.html) or [ResetDiskDefaultKMSKeyId](https://help.aliyun.com/document_detail/2851539.html) operation to change or reset the KMS key used by the Account-level EBS Default Encryption feature in a region.
        You can call the [DisableDiskEncryptionByDefault](https://help.aliyun.com/document_detail/2851491.html) operation to disable the Account-level EBS Default Encryption feature in a region.
        
        @param request: EnableDiskEncryptionByDefaultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableDiskEncryptionByDefaultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableDiskEncryptionByDefault',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.EnableDiskEncryptionByDefaultResponse(),
            self.call_api(params, req, runtime)
        )

    async def enable_disk_encryption_by_default_with_options_async(
        self,
        request: ecs_20140526_models.EnableDiskEncryptionByDefaultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.EnableDiskEncryptionByDefaultResponse:
        """
        @summary Enables the Account-level Elastic Block Storage (EBS) Default Encryption feature in a region.
        
        @description >  The Account-level EBS Default Encryption feature is available only in specific regions and to specific users. To use the feature, [submit a ticket](https://smartservice.console.aliyun.com/service/create-ticket-intl).
        **Precautions**\
        To enable the Account-level EBS Default Encryption feature as a Resource Access Management (RAM) user, grant the `AliyunECSFullAccess` permission to the RAM user. For more information, see [Grant permissions to a RAM user](https://help.aliyun.com/document_detail/116146.html).
        Before you can enable the Account-level EBS Default Encryption feature in a region, you must [activate Key Management Service (KMS)](https://help.aliyun.com/document_detail/480156.html) in the region.
        After you enable the Account-level EBS Default Encryption feature in a region, you can purchase only encrypted cloud disks in the region. For more information, see the [Limits](~~59643#50de175230erj~~) section of the "Encrypt cloud disks" topic.
        **Considerations**\
        After you enable the Account-level EBS Default Encryption feature in a region, new pay-as-you-go and subscription cloud disks in the region must be encrypted. You can use the KMS key configured for the feature or specify other KMS keys to encrypt the cloud disks.
        The first time you enable the Account-level EBS Default Encryption feature in a region, the service key in the region is automatically used to encrypt EBS resources.
        **Suggestions**\
        You can call the [DescribeDiskEncryptionByDefaultStatus](https://help.aliyun.com/document_detail/2851493.html) operation to query whether the Account-level EBS Default Encryption feature is enabled in a region and the [DescribeDiskDefaultKMSKeyId](https://help.aliyun.com/document_detail/2851490.html) operation to query the ID of the KMS key used by the feature in a region.
        You can call the [ModifyDiskDefaultKMSKeyId](https://help.aliyun.com/document_detail/2851492.html) or [ResetDiskDefaultKMSKeyId](https://help.aliyun.com/document_detail/2851539.html) operation to change or reset the KMS key used by the Account-level EBS Default Encryption feature in a region.
        You can call the [DisableDiskEncryptionByDefault](https://help.aliyun.com/document_detail/2851491.html) operation to disable the Account-level EBS Default Encryption feature in a region.
        
        @param request: EnableDiskEncryptionByDefaultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableDiskEncryptionByDefaultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableDiskEncryptionByDefault',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.EnableDiskEncryptionByDefaultResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def enable_disk_encryption_by_default(
        self,
        request: ecs_20140526_models.EnableDiskEncryptionByDefaultRequest,
    ) -> ecs_20140526_models.EnableDiskEncryptionByDefaultResponse:
        """
        @summary Enables the Account-level Elastic Block Storage (EBS) Default Encryption feature in a region.
        
        @description >  The Account-level EBS Default Encryption feature is available only in specific regions and to specific users. To use the feature, [submit a ticket](https://smartservice.console.aliyun.com/service/create-ticket-intl).
        **Precautions**\
        To enable the Account-level EBS Default Encryption feature as a Resource Access Management (RAM) user, grant the `AliyunECSFullAccess` permission to the RAM user. For more information, see [Grant permissions to a RAM user](https://help.aliyun.com/document_detail/116146.html).
        Before you can enable the Account-level EBS Default Encryption feature in a region, you must [activate Key Management Service (KMS)](https://help.aliyun.com/document_detail/480156.html) in the region.
        After you enable the Account-level EBS Default Encryption feature in a region, you can purchase only encrypted cloud disks in the region. For more information, see the [Limits](~~59643#50de175230erj~~) section of the "Encrypt cloud disks" topic.
        **Considerations**\
        After you enable the Account-level EBS Default Encryption feature in a region, new pay-as-you-go and subscription cloud disks in the region must be encrypted. You can use the KMS key configured for the feature or specify other KMS keys to encrypt the cloud disks.
        The first time you enable the Account-level EBS Default Encryption feature in a region, the service key in the region is automatically used to encrypt EBS resources.
        **Suggestions**\
        You can call the [DescribeDiskEncryptionByDefaultStatus](https://help.aliyun.com/document_detail/2851493.html) operation to query whether the Account-level EBS Default Encryption feature is enabled in a region and the [DescribeDiskDefaultKMSKeyId](https://help.aliyun.com/document_detail/2851490.html) operation to query the ID of the KMS key used by the feature in a region.
        You can call the [ModifyDiskDefaultKMSKeyId](https://help.aliyun.com/document_detail/2851492.html) or [ResetDiskDefaultKMSKeyId](https://help.aliyun.com/document_detail/2851539.html) operation to change or reset the KMS key used by the Account-level EBS Default Encryption feature in a region.
        You can call the [DisableDiskEncryptionByDefault](https://help.aliyun.com/document_detail/2851491.html) operation to disable the Account-level EBS Default Encryption feature in a region.
        
        @param request: EnableDiskEncryptionByDefaultRequest
        @return: EnableDiskEncryptionByDefaultResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.enable_disk_encryption_by_default_with_options(request, runtime)

    async def enable_disk_encryption_by_default_async(
        self,
        request: ecs_20140526_models.EnableDiskEncryptionByDefaultRequest,
    ) -> ecs_20140526_models.EnableDiskEncryptionByDefaultResponse:
        """
        @summary Enables the Account-level Elastic Block Storage (EBS) Default Encryption feature in a region.
        
        @description >  The Account-level EBS Default Encryption feature is available only in specific regions and to specific users. To use the feature, [submit a ticket](https://smartservice.console.aliyun.com/service/create-ticket-intl).
        **Precautions**\
        To enable the Account-level EBS Default Encryption feature as a Resource Access Management (RAM) user, grant the `AliyunECSFullAccess` permission to the RAM user. For more information, see [Grant permissions to a RAM user](https://help.aliyun.com/document_detail/116146.html).
        Before you can enable the Account-level EBS Default Encryption feature in a region, you must [activate Key Management Service (KMS)](https://help.aliyun.com/document_detail/480156.html) in the region.
        After you enable the Account-level EBS Default Encryption feature in a region, you can purchase only encrypted cloud disks in the region. For more information, see the [Limits](~~59643#50de175230erj~~) section of the "Encrypt cloud disks" topic.
        **Considerations**\
        After you enable the Account-level EBS Default Encryption feature in a region, new pay-as-you-go and subscription cloud disks in the region must be encrypted. You can use the KMS key configured for the feature or specify other KMS keys to encrypt the cloud disks.
        The first time you enable the Account-level EBS Default Encryption feature in a region, the service key in the region is automatically used to encrypt EBS resources.
        **Suggestions**\
        You can call the [DescribeDiskEncryptionByDefaultStatus](https://help.aliyun.com/document_detail/2851493.html) operation to query whether the Account-level EBS Default Encryption feature is enabled in a region and the [DescribeDiskDefaultKMSKeyId](https://help.aliyun.com/document_detail/2851490.html) operation to query the ID of the KMS key used by the feature in a region.
        You can call the [ModifyDiskDefaultKMSKeyId](https://help.aliyun.com/document_detail/2851492.html) or [ResetDiskDefaultKMSKeyId](https://help.aliyun.com/document_detail/2851539.html) operation to change or reset the KMS key used by the Account-level EBS Default Encryption feature in a region.
        You can call the [DisableDiskEncryptionByDefault](https://help.aliyun.com/document_detail/2851491.html) operation to disable the Account-level EBS Default Encryption feature in a region.
        
        @param request: EnableDiskEncryptionByDefaultRequest
        @return: EnableDiskEncryptionByDefaultResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.enable_disk_encryption_by_default_with_options_async(request, runtime)

    def enable_physical_connection_with_options(
        self,
        request: ecs_20140526_models.EnablePhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.EnablePhysicalConnectionResponse:
        """
        @deprecated OpenAPI EnablePhysicalConnection is deprecated, please use Vpc::2016-04-28::EnablePhysicalConnection instead.
        
        @summary EnablePhysicalConnection
        
        @param request: EnablePhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnablePhysicalConnectionResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnablePhysicalConnection',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.EnablePhysicalConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def enable_physical_connection_with_options_async(
        self,
        request: ecs_20140526_models.EnablePhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.EnablePhysicalConnectionResponse:
        """
        @deprecated OpenAPI EnablePhysicalConnection is deprecated, please use Vpc::2016-04-28::EnablePhysicalConnection instead.
        
        @summary EnablePhysicalConnection
        
        @param request: EnablePhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnablePhysicalConnectionResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnablePhysicalConnection',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.EnablePhysicalConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def enable_physical_connection(
        self,
        request: ecs_20140526_models.EnablePhysicalConnectionRequest,
    ) -> ecs_20140526_models.EnablePhysicalConnectionResponse:
        """
        @deprecated OpenAPI EnablePhysicalConnection is deprecated, please use Vpc::2016-04-28::EnablePhysicalConnection instead.
        
        @summary EnablePhysicalConnection
        
        @param request: EnablePhysicalConnectionRequest
        @return: EnablePhysicalConnectionResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.enable_physical_connection_with_options(request, runtime)

    async def enable_physical_connection_async(
        self,
        request: ecs_20140526_models.EnablePhysicalConnectionRequest,
    ) -> ecs_20140526_models.EnablePhysicalConnectionResponse:
        """
        @deprecated OpenAPI EnablePhysicalConnection is deprecated, please use Vpc::2016-04-28::EnablePhysicalConnection instead.
        
        @summary EnablePhysicalConnection
        
        @param request: EnablePhysicalConnectionRequest
        @return: EnablePhysicalConnectionResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.enable_physical_connection_with_options_async(request, runtime)

    def end_terminal_session_with_options(
        self,
        request: ecs_20140526_models.EndTerminalSessionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.EndTerminalSessionResponse:
        """
        @summary Permanently closes a session.
        
        @description    After you closes a session, the session is no longer available.
        The WebSocket URL that is associated with a closed session is invalid and no longer available.
        
        @param request: EndTerminalSessionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EndTerminalSessionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.session_id):
            query['SessionId'] = request.session_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EndTerminalSession',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.EndTerminalSessionResponse(),
            self.call_api(params, req, runtime)
        )

    async def end_terminal_session_with_options_async(
        self,
        request: ecs_20140526_models.EndTerminalSessionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.EndTerminalSessionResponse:
        """
        @summary Permanently closes a session.
        
        @description    After you closes a session, the session is no longer available.
        The WebSocket URL that is associated with a closed session is invalid and no longer available.
        
        @param request: EndTerminalSessionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EndTerminalSessionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.session_id):
            query['SessionId'] = request.session_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EndTerminalSession',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.EndTerminalSessionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def end_terminal_session(
        self,
        request: ecs_20140526_models.EndTerminalSessionRequest,
    ) -> ecs_20140526_models.EndTerminalSessionResponse:
        """
        @summary Permanently closes a session.
        
        @description    After you closes a session, the session is no longer available.
        The WebSocket URL that is associated with a closed session is invalid and no longer available.
        
        @param request: EndTerminalSessionRequest
        @return: EndTerminalSessionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.end_terminal_session_with_options(request, runtime)

    async def end_terminal_session_async(
        self,
        request: ecs_20140526_models.EndTerminalSessionRequest,
    ) -> ecs_20140526_models.EndTerminalSessionResponse:
        """
        @summary Permanently closes a session.
        
        @description    After you closes a session, the session is no longer available.
        The WebSocket URL that is associated with a closed session is invalid and no longer available.
        
        @param request: EndTerminalSessionRequest
        @return: EndTerminalSessionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.end_terminal_session_with_options_async(request, runtime)

    def export_image_with_options(
        self,
        request: ecs_20140526_models.ExportImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ExportImageResponse:
        """
        @summary Exports a custom image to an Object Storage Service (OSS) bucket in the same region.
        
        @description Take note of the following items:
        Make sure that you are familiar with the prerequisites and considerations. For more information, see [Export a custom image](https://help.aliyun.com/document_detail/58181.html).
        The `ImageFormat` parameter is available only for the following regions: Japan (Tokyo), Indonesia (Jakarta), Germany (Frankfurt), UAE (Dubai), US (Virginia), UK (London), Singapore, Malaysia (Kuala Lumpur), and US (Silicon Valley). By default, custom images are exported in the RAW format in regions where the ImageFormat parameter is unsupported.
        Use Resource Access Management (RAM) to authorize Elastic Compute Service (ECS) to write data to OSS. To complete the authorization, perform the following operations:
        Create a role named `AliyunECSImageExportDefaultRole` and attach the following policy to the role:
        {
        "Statement": [
        {
        "Action": "sts:AssumeRole",
        "Effect": "Allow",
        "Principal": {
        "Service": [
        "ecs.aliyuncs.com"
        ]
        }
        }
        ],
        "Version": "1"
        }
        Attach the `AliyunECSImageExportRolePolicy` system policy, which is the default policy that grants ECS the permissions to export images, to the `AliyunECSImageExportDefaultRole` role. For more information, go to the [Cloud Resource Access Authorization](https://ram.console.aliyun.com/?spm=5176.2020520101.0.0.64c64df5dfpmdY#/role/authorize?request=%7B%22Requests%22:%20%7B%22request1%22:%20%7B%22RoleName%22:%20%22AliyunECSImageImportDefaultRole%22,%20%22TemplateId%22:%20%22ECSImportRole%22%7D,%20%22request2%22:%20%7B%22RoleName%22:%20%22AliyunECSImageExportDefaultRole%22,%20%22TemplateId%22:%20%22ECSExportRole%22%7D%7D,%20%22ReturnUrl%22:%20%22https:%2F%2Fecs.console.aliyun.com%2F%22,%20%22Service%22:%20%22ECS%22%7D) page. You can also create a custom policy that contains the following content and attach the policy to the role:
        {
        "Version": "1",
        "Statement": [
        {
        "Action": [
        "oss:GetObject",
        "oss:PutObject",
        "oss:DeleteObject",
        "oss:GetBucketLocation",
        "oss:GetBucketInfo",
        "oss:AbortMultipartUpload",
        "oss:ListMultipartUploads",
        "oss:ListParts"
        ],
        "Resource": "",
        "Effect": "Allow"
        }
        ]
        }
        After you export the images, take note of the following items:
        Each exported custom image is stored in the specified OSS bucket. You can download the custom image. For more information, see [Download OSS objects by using simple download](https://help.aliyun.com/document_detail/31912.html).
        
        @param request: ExportImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ExportImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.image_format):
            query['ImageFormat'] = request.image_format
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.ossbucket):
            query['OSSBucket'] = request.ossbucket
        if not UtilClient.is_unset(request.ossprefix):
            query['OSSPrefix'] = request.ossprefix
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.role_name):
            query['RoleName'] = request.role_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ExportImage',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ExportImageResponse(),
            self.call_api(params, req, runtime)
        )

    async def export_image_with_options_async(
        self,
        request: ecs_20140526_models.ExportImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ExportImageResponse:
        """
        @summary Exports a custom image to an Object Storage Service (OSS) bucket in the same region.
        
        @description Take note of the following items:
        Make sure that you are familiar with the prerequisites and considerations. For more information, see [Export a custom image](https://help.aliyun.com/document_detail/58181.html).
        The `ImageFormat` parameter is available only for the following regions: Japan (Tokyo), Indonesia (Jakarta), Germany (Frankfurt), UAE (Dubai), US (Virginia), UK (London), Singapore, Malaysia (Kuala Lumpur), and US (Silicon Valley). By default, custom images are exported in the RAW format in regions where the ImageFormat parameter is unsupported.
        Use Resource Access Management (RAM) to authorize Elastic Compute Service (ECS) to write data to OSS. To complete the authorization, perform the following operations:
        Create a role named `AliyunECSImageExportDefaultRole` and attach the following policy to the role:
        {
        "Statement": [
        {
        "Action": "sts:AssumeRole",
        "Effect": "Allow",
        "Principal": {
        "Service": [
        "ecs.aliyuncs.com"
        ]
        }
        }
        ],
        "Version": "1"
        }
        Attach the `AliyunECSImageExportRolePolicy` system policy, which is the default policy that grants ECS the permissions to export images, to the `AliyunECSImageExportDefaultRole` role. For more information, go to the [Cloud Resource Access Authorization](https://ram.console.aliyun.com/?spm=5176.2020520101.0.0.64c64df5dfpmdY#/role/authorize?request=%7B%22Requests%22:%20%7B%22request1%22:%20%7B%22RoleName%22:%20%22AliyunECSImageImportDefaultRole%22,%20%22TemplateId%22:%20%22ECSImportRole%22%7D,%20%22request2%22:%20%7B%22RoleName%22:%20%22AliyunECSImageExportDefaultRole%22,%20%22TemplateId%22:%20%22ECSExportRole%22%7D%7D,%20%22ReturnUrl%22:%20%22https:%2F%2Fecs.console.aliyun.com%2F%22,%20%22Service%22:%20%22ECS%22%7D) page. You can also create a custom policy that contains the following content and attach the policy to the role:
        {
        "Version": "1",
        "Statement": [
        {
        "Action": [
        "oss:GetObject",
        "oss:PutObject",
        "oss:DeleteObject",
        "oss:GetBucketLocation",
        "oss:GetBucketInfo",
        "oss:AbortMultipartUpload",
        "oss:ListMultipartUploads",
        "oss:ListParts"
        ],
        "Resource": "",
        "Effect": "Allow"
        }
        ]
        }
        After you export the images, take note of the following items:
        Each exported custom image is stored in the specified OSS bucket. You can download the custom image. For more information, see [Download OSS objects by using simple download](https://help.aliyun.com/document_detail/31912.html).
        
        @param request: ExportImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ExportImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.image_format):
            query['ImageFormat'] = request.image_format
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.ossbucket):
            query['OSSBucket'] = request.ossbucket
        if not UtilClient.is_unset(request.ossprefix):
            query['OSSPrefix'] = request.ossprefix
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.role_name):
            query['RoleName'] = request.role_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ExportImage',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ExportImageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def export_image(
        self,
        request: ecs_20140526_models.ExportImageRequest,
    ) -> ecs_20140526_models.ExportImageResponse:
        """
        @summary Exports a custom image to an Object Storage Service (OSS) bucket in the same region.
        
        @description Take note of the following items:
        Make sure that you are familiar with the prerequisites and considerations. For more information, see [Export a custom image](https://help.aliyun.com/document_detail/58181.html).
        The `ImageFormat` parameter is available only for the following regions: Japan (Tokyo), Indonesia (Jakarta), Germany (Frankfurt), UAE (Dubai), US (Virginia), UK (London), Singapore, Malaysia (Kuala Lumpur), and US (Silicon Valley). By default, custom images are exported in the RAW format in regions where the ImageFormat parameter is unsupported.
        Use Resource Access Management (RAM) to authorize Elastic Compute Service (ECS) to write data to OSS. To complete the authorization, perform the following operations:
        Create a role named `AliyunECSImageExportDefaultRole` and attach the following policy to the role:
        {
        "Statement": [
        {
        "Action": "sts:AssumeRole",
        "Effect": "Allow",
        "Principal": {
        "Service": [
        "ecs.aliyuncs.com"
        ]
        }
        }
        ],
        "Version": "1"
        }
        Attach the `AliyunECSImageExportRolePolicy` system policy, which is the default policy that grants ECS the permissions to export images, to the `AliyunECSImageExportDefaultRole` role. For more information, go to the [Cloud Resource Access Authorization](https://ram.console.aliyun.com/?spm=5176.2020520101.0.0.64c64df5dfpmdY#/role/authorize?request=%7B%22Requests%22:%20%7B%22request1%22:%20%7B%22RoleName%22:%20%22AliyunECSImageImportDefaultRole%22,%20%22TemplateId%22:%20%22ECSImportRole%22%7D,%20%22request2%22:%20%7B%22RoleName%22:%20%22AliyunECSImageExportDefaultRole%22,%20%22TemplateId%22:%20%22ECSExportRole%22%7D%7D,%20%22ReturnUrl%22:%20%22https:%2F%2Fecs.console.aliyun.com%2F%22,%20%22Service%22:%20%22ECS%22%7D) page. You can also create a custom policy that contains the following content and attach the policy to the role:
        {
        "Version": "1",
        "Statement": [
        {
        "Action": [
        "oss:GetObject",
        "oss:PutObject",
        "oss:DeleteObject",
        "oss:GetBucketLocation",
        "oss:GetBucketInfo",
        "oss:AbortMultipartUpload",
        "oss:ListMultipartUploads",
        "oss:ListParts"
        ],
        "Resource": "",
        "Effect": "Allow"
        }
        ]
        }
        After you export the images, take note of the following items:
        Each exported custom image is stored in the specified OSS bucket. You can download the custom image. For more information, see [Download OSS objects by using simple download](https://help.aliyun.com/document_detail/31912.html).
        
        @param request: ExportImageRequest
        @return: ExportImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.export_image_with_options(request, runtime)

    async def export_image_async(
        self,
        request: ecs_20140526_models.ExportImageRequest,
    ) -> ecs_20140526_models.ExportImageResponse:
        """
        @summary Exports a custom image to an Object Storage Service (OSS) bucket in the same region.
        
        @description Take note of the following items:
        Make sure that you are familiar with the prerequisites and considerations. For more information, see [Export a custom image](https://help.aliyun.com/document_detail/58181.html).
        The `ImageFormat` parameter is available only for the following regions: Japan (Tokyo), Indonesia (Jakarta), Germany (Frankfurt), UAE (Dubai), US (Virginia), UK (London), Singapore, Malaysia (Kuala Lumpur), and US (Silicon Valley). By default, custom images are exported in the RAW format in regions where the ImageFormat parameter is unsupported.
        Use Resource Access Management (RAM) to authorize Elastic Compute Service (ECS) to write data to OSS. To complete the authorization, perform the following operations:
        Create a role named `AliyunECSImageExportDefaultRole` and attach the following policy to the role:
        {
        "Statement": [
        {
        "Action": "sts:AssumeRole",
        "Effect": "Allow",
        "Principal": {
        "Service": [
        "ecs.aliyuncs.com"
        ]
        }
        }
        ],
        "Version": "1"
        }
        Attach the `AliyunECSImageExportRolePolicy` system policy, which is the default policy that grants ECS the permissions to export images, to the `AliyunECSImageExportDefaultRole` role. For more information, go to the [Cloud Resource Access Authorization](https://ram.console.aliyun.com/?spm=5176.2020520101.0.0.64c64df5dfpmdY#/role/authorize?request=%7B%22Requests%22:%20%7B%22request1%22:%20%7B%22RoleName%22:%20%22AliyunECSImageImportDefaultRole%22,%20%22TemplateId%22:%20%22ECSImportRole%22%7D,%20%22request2%22:%20%7B%22RoleName%22:%20%22AliyunECSImageExportDefaultRole%22,%20%22TemplateId%22:%20%22ECSExportRole%22%7D%7D,%20%22ReturnUrl%22:%20%22https:%2F%2Fecs.console.aliyun.com%2F%22,%20%22Service%22:%20%22ECS%22%7D) page. You can also create a custom policy that contains the following content and attach the policy to the role:
        {
        "Version": "1",
        "Statement": [
        {
        "Action": [
        "oss:GetObject",
        "oss:PutObject",
        "oss:DeleteObject",
        "oss:GetBucketLocation",
        "oss:GetBucketInfo",
        "oss:AbortMultipartUpload",
        "oss:ListMultipartUploads",
        "oss:ListParts"
        ],
        "Resource": "",
        "Effect": "Allow"
        }
        ]
        }
        After you export the images, take note of the following items:
        Each exported custom image is stored in the specified OSS bucket. You can download the custom image. For more information, see [Download OSS objects by using simple download](https://help.aliyun.com/document_detail/31912.html).
        
        @param request: ExportImageRequest
        @return: ExportImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.export_image_with_options_async(request, runtime)

    def export_snapshot_with_options(
        self,
        request: ecs_20140526_models.ExportSnapshotRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ExportSnapshotResponse:
        """
        @deprecated OpenAPI ExportSnapshot is deprecated
        
        @summary 将快照导出到指定的对象存储
        
        @param request: ExportSnapshotRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ExportSnapshotResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.oss_bucket):
            query['OssBucket'] = request.oss_bucket
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.role_name):
            query['RoleName'] = request.role_name
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ExportSnapshot',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ExportSnapshotResponse(),
            self.call_api(params, req, runtime)
        )

    async def export_snapshot_with_options_async(
        self,
        request: ecs_20140526_models.ExportSnapshotRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ExportSnapshotResponse:
        """
        @deprecated OpenAPI ExportSnapshot is deprecated
        
        @summary 将快照导出到指定的对象存储
        
        @param request: ExportSnapshotRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ExportSnapshotResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.oss_bucket):
            query['OssBucket'] = request.oss_bucket
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.role_name):
            query['RoleName'] = request.role_name
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ExportSnapshot',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ExportSnapshotResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def export_snapshot(
        self,
        request: ecs_20140526_models.ExportSnapshotRequest,
    ) -> ecs_20140526_models.ExportSnapshotResponse:
        """
        @deprecated OpenAPI ExportSnapshot is deprecated
        
        @summary 将快照导出到指定的对象存储
        
        @param request: ExportSnapshotRequest
        @return: ExportSnapshotResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.export_snapshot_with_options(request, runtime)

    async def export_snapshot_async(
        self,
        request: ecs_20140526_models.ExportSnapshotRequest,
    ) -> ecs_20140526_models.ExportSnapshotResponse:
        """
        @deprecated OpenAPI ExportSnapshot is deprecated
        
        @summary 将快照导出到指定的对象存储
        
        @param request: ExportSnapshotRequest
        @return: ExportSnapshotResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.export_snapshot_with_options_async(request, runtime)

    def get_instance_console_output_with_options(
        self,
        request: ecs_20140526_models.GetInstanceConsoleOutputRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.GetInstanceConsoleOutputResponse:
        """
        @summary Queries the command output of an Elastic Compute Service (ECS) instance. The returned command output is encoded in Base64.
        
        @description    ECS is a virtualized cloud-based service and cannot be connected to display devices. Alibaba Cloud caches system command outputs for the last start, restart, or shutdown of ECS instances. You can call the GetInstanceConsoleOutput operation to query the command outputs.
        For instances of the retired instance types, you cannot obtain command outputs. For more information, see [Retired instance types](https://help.aliyun.com/document_detail/55263.html).
        You cannot obtain the command outputs of Windows instances.
        
        @param request: GetInstanceConsoleOutputRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetInstanceConsoleOutputResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remove_symbols):
            query['RemoveSymbols'] = request.remove_symbols
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetInstanceConsoleOutput',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.GetInstanceConsoleOutputResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_instance_console_output_with_options_async(
        self,
        request: ecs_20140526_models.GetInstanceConsoleOutputRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.GetInstanceConsoleOutputResponse:
        """
        @summary Queries the command output of an Elastic Compute Service (ECS) instance. The returned command output is encoded in Base64.
        
        @description    ECS is a virtualized cloud-based service and cannot be connected to display devices. Alibaba Cloud caches system command outputs for the last start, restart, or shutdown of ECS instances. You can call the GetInstanceConsoleOutput operation to query the command outputs.
        For instances of the retired instance types, you cannot obtain command outputs. For more information, see [Retired instance types](https://help.aliyun.com/document_detail/55263.html).
        You cannot obtain the command outputs of Windows instances.
        
        @param request: GetInstanceConsoleOutputRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetInstanceConsoleOutputResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remove_symbols):
            query['RemoveSymbols'] = request.remove_symbols
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetInstanceConsoleOutput',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.GetInstanceConsoleOutputResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_instance_console_output(
        self,
        request: ecs_20140526_models.GetInstanceConsoleOutputRequest,
    ) -> ecs_20140526_models.GetInstanceConsoleOutputResponse:
        """
        @summary Queries the command output of an Elastic Compute Service (ECS) instance. The returned command output is encoded in Base64.
        
        @description    ECS is a virtualized cloud-based service and cannot be connected to display devices. Alibaba Cloud caches system command outputs for the last start, restart, or shutdown of ECS instances. You can call the GetInstanceConsoleOutput operation to query the command outputs.
        For instances of the retired instance types, you cannot obtain command outputs. For more information, see [Retired instance types](https://help.aliyun.com/document_detail/55263.html).
        You cannot obtain the command outputs of Windows instances.
        
        @param request: GetInstanceConsoleOutputRequest
        @return: GetInstanceConsoleOutputResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_instance_console_output_with_options(request, runtime)

    async def get_instance_console_output_async(
        self,
        request: ecs_20140526_models.GetInstanceConsoleOutputRequest,
    ) -> ecs_20140526_models.GetInstanceConsoleOutputResponse:
        """
        @summary Queries the command output of an Elastic Compute Service (ECS) instance. The returned command output is encoded in Base64.
        
        @description    ECS is a virtualized cloud-based service and cannot be connected to display devices. Alibaba Cloud caches system command outputs for the last start, restart, or shutdown of ECS instances. You can call the GetInstanceConsoleOutput operation to query the command outputs.
        For instances of the retired instance types, you cannot obtain command outputs. For more information, see [Retired instance types](https://help.aliyun.com/document_detail/55263.html).
        You cannot obtain the command outputs of Windows instances.
        
        @param request: GetInstanceConsoleOutputRequest
        @return: GetInstanceConsoleOutputResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_instance_console_output_with_options_async(request, runtime)

    def get_instance_screenshot_with_options(
        self,
        request: ecs_20140526_models.GetInstanceScreenshotRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.GetInstanceScreenshotResponse:
        """
        @summary Obtains the screenshots of an Elastic Compute Service (ECS) instance.
        
        @description After ECS returns a Base64-encoded instance screenshot in the JPG format, you must decode the screenshot. We recommend that you call this operation for troubleshooting and diagnosis. When you call this operation, take note of the following items:
        The instance must be in the Running state.
        For instances of the retired instance types, you cannot obtain screenshots. For more information, see [Retired instance types](https://help.aliyun.com/document_detail/55263.html).
        If you call this operation on an instance for multiple times, the call interval must be at least 10 seconds. Otherwise, the `Throttling` error is returned.
        
        @param request: GetInstanceScreenshotRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetInstanceScreenshotResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.wake_up):
            query['WakeUp'] = request.wake_up
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetInstanceScreenshot',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.GetInstanceScreenshotResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_instance_screenshot_with_options_async(
        self,
        request: ecs_20140526_models.GetInstanceScreenshotRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.GetInstanceScreenshotResponse:
        """
        @summary Obtains the screenshots of an Elastic Compute Service (ECS) instance.
        
        @description After ECS returns a Base64-encoded instance screenshot in the JPG format, you must decode the screenshot. We recommend that you call this operation for troubleshooting and diagnosis. When you call this operation, take note of the following items:
        The instance must be in the Running state.
        For instances of the retired instance types, you cannot obtain screenshots. For more information, see [Retired instance types](https://help.aliyun.com/document_detail/55263.html).
        If you call this operation on an instance for multiple times, the call interval must be at least 10 seconds. Otherwise, the `Throttling` error is returned.
        
        @param request: GetInstanceScreenshotRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetInstanceScreenshotResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.wake_up):
            query['WakeUp'] = request.wake_up
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetInstanceScreenshot',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.GetInstanceScreenshotResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_instance_screenshot(
        self,
        request: ecs_20140526_models.GetInstanceScreenshotRequest,
    ) -> ecs_20140526_models.GetInstanceScreenshotResponse:
        """
        @summary Obtains the screenshots of an Elastic Compute Service (ECS) instance.
        
        @description After ECS returns a Base64-encoded instance screenshot in the JPG format, you must decode the screenshot. We recommend that you call this operation for troubleshooting and diagnosis. When you call this operation, take note of the following items:
        The instance must be in the Running state.
        For instances of the retired instance types, you cannot obtain screenshots. For more information, see [Retired instance types](https://help.aliyun.com/document_detail/55263.html).
        If you call this operation on an instance for multiple times, the call interval must be at least 10 seconds. Otherwise, the `Throttling` error is returned.
        
        @param request: GetInstanceScreenshotRequest
        @return: GetInstanceScreenshotResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_instance_screenshot_with_options(request, runtime)

    async def get_instance_screenshot_async(
        self,
        request: ecs_20140526_models.GetInstanceScreenshotRequest,
    ) -> ecs_20140526_models.GetInstanceScreenshotResponse:
        """
        @summary Obtains the screenshots of an Elastic Compute Service (ECS) instance.
        
        @description After ECS returns a Base64-encoded instance screenshot in the JPG format, you must decode the screenshot. We recommend that you call this operation for troubleshooting and diagnosis. When you call this operation, take note of the following items:
        The instance must be in the Running state.
        For instances of the retired instance types, you cannot obtain screenshots. For more information, see [Retired instance types](https://help.aliyun.com/document_detail/55263.html).
        If you call this operation on an instance for multiple times, the call interval must be at least 10 seconds. Otherwise, the `Throttling` error is returned.
        
        @param request: GetInstanceScreenshotRequest
        @return: GetInstanceScreenshotResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_instance_screenshot_with_options_async(request, runtime)

    def import_image_with_options(
        self,
        request: ecs_20140526_models.ImportImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ImportImageResponse:
        """
        @summary Imports an on-premise image to Elastic Compute Service (ECS). The imported image exists as a custom image in the destination region. You can use the imported image to create ECS instances by calling the RunInstances operation or replace the system disk of an ECS instance by calling the ReplaceSystemDisk operation.
        
        @description ### [](#)Usage notes
        Take note of the following items:
        Before you import an image, you must upload the image to an Object Storage Service (OSS) bucket. For more information, see [Upload objects](https://help.aliyun.com/document_detail/31886.html).
        In specific scenarios, you may want to create a custom image based on the operating system data of a source server, import the image to Alibaba Cloud, and then create an ECS instance from the image. The source server can be a physical server, a virtual machine, or a cloud host. If the virtio driver is not installed on the source server, the created ECS instance may be unable to start. To prevent this issue, verify that the virtio driver is installed on the source server before you import the image to Alibaba Cloud. For more information, see [Install the virtio driver](https://help.aliyun.com/document_detail/62423.html).
        Before you import images for the first time, you must use Resource Access Management (RAM) to authorize ECS to access your OSS buckets. If ECS is not authorized to access your OSS buckets, the `NoSetRoletoECSServiceAccount` or `InvalidOperation.CloudBoxImageImportRoleRequired` error code is returned when you call the ImportImage operation. The authorization configuration varies based on whether the image files are imported from a cloud box.
        **If the image files are not imported from a cloud box**, you can complete the authorization on the [Cloud Resource Access Authorization](https://ram.console.aliyun.com/?spm=5176.2020520101image.0.0.2ffa4df57kSoHX#/role/authorize?request=%7B%22Requests%22%3A%20%7B%22request1%22%3A%20%7B%22RoleName%22%3A%20%22AliyunECSImageImportDefaultRole%22%2C%20%22TemplateId%22%3A%20%22ECSImportRole%22%7D%2C%20%22request2%22%3A%20%7B%22RoleName%22%3A%20%22AliyunECSImageExportDefaultRole%22%2C%20%22TemplateId%22%3A%20%22ECSExportRole%22%7D%7D%2C%20%22ReturnUrl%22%3A%20%22https%3A//ecs.console.aliyun.com/%22%2C%20%22Service%22%3A%20%22ECS%22%7D) page of the RAM console. You can also complete the authorization by using a RAM role and RAM policies. The following example shows the policies and permissions required for specific steps in the authorization procedure. For more information, see [Control access to ECS resources by using RAM users](https://help.aliyun.com/document_detail/25481.html).
        1.  Create a RAM role named `AliyunECSImageImportDefaultRole`. You must use this exact role name. Otherwise, the image cannot be imported. Configure the following trust policy for the role:
        {
        "Statement": [
        {
        "Action": "sts:AssumeRole",
        "Effect": "Allow",
        "Principal": {
        "Service": [
        "ecs.aliyuncs.com"
        ]
        }
        }
        ],
        "Version": "1"
        }
        2.  Attach the `AliyunECSImageImportRolePolicy` system policy to the RAM role. You can also create a custom policy that contains the following content and attach the policy to the role:
        ```
        {
        "Version": "1",
        "Statement": [
        {
        "Action": [
        "oss:GetObject",
        "oss:GetBucketLocation",
        "oss:GetBucketInfo"
        ],
        "Resource": "",
        "Effect": "Allow"
        }
        ]
        }
        ```
        **If the image files are imported from a cloud box**, you can complete the authorization on the [Cloud Resource Access Authorization](https://ram.console.aliyun.com/role/authorize?request=%7B%22ReturnUrl%22%3A%22https%3A%2F%2Fecs.console.aliyun.com%2F%22%2C%22Services%22%3A%5B%7B%22Roles%22%3A%5B%7B%22RoleName%22%3A%22AliyunECSCloudBoxImageImportDefaultRole%22%2C%22TemplateId%22%3A%22AliyunECSCloudBoxImageImportDefaultRole%22%7D%5D%2C%22Service%22%3A%22ECS%22%7D%5D%7D) page of the RAM console. You can also complete the authorization by using a RAM role and RAM policies. The following example shows the policies and permissions required for specific steps in the authorization procedure. For more information, see [Control access to ECS resources by using RAM users](https://help.aliyun.com/document_detail/25481.html).
        1.  Create a RAM role named `AliyunECSCloudBoxImageImportDefaultRole`. You must use this exact role name. Otherwise, the image cannot be imported. Configure the following trust policy for the role:
        {
        "Statement": [
        {
        "Action": "sts:AssumeRole",
        "Effect": "Allow",
        "Principal": {
        "Service": [
        "ecs.aliyuncs.com"
        ]
        }
        }
        ],
        "Version": "1"
        }
        2.  Attach the `AliyunECSCloudBoxImageImportRolePolicy` system policy to the RAM role. You can also create a custom policy that contains the following content and attach the policy to the role:
        ```
        {
        "Version": "1",
        "Statement": [
        {
        "Action": [
        "oss-cloudbox:GetObject",
        "oss-cloudbox:GetBucketLocation",
        "oss-cloudbox:GetBucketInfo"
        ],
        "Resource": "",
        "Effect": "Allow"
        }
        ]
        }
        ```
        You cannot delete an image that is being imported. However, you can call the [CancelTask](https://help.aliyun.com/document_detail/25624.html) operation to cancel the image import task.
        You can import an image only to the same region as the OSS bucket to which the image file is uploaded.
        The valid values of N in `DiskDeviceMapping.N` range from 1 to 17. When N is set to 1, the disk is a system disk. When N is set to a value from 2 to 17, the disk is a data disk. When N is set to a value greater than 17, parameters prefixed with DiskDeviceMapping.N are ignored.
        When you set `Architecture` to `arm64` or when you set `Platform` to `CentOS Stream`, `Anolis`, `AlmaLinux`, `UOS`, `Kylin`, or `Rocky Linux`, take note of the following items:
        To ensure that the password can be set or the key pair can be modified for an imported image, make sure that the image meets the following requirements before you import it:
        The kernel of the operating system supports the `CONFIG_FW_CFG_SYSFS` feature. By default, Linux community kernel 4.6 and later and CentOS kernel 3.10.0-826.el7 and later support the CONFIG_FW_CFG_SYSFS feature. You can run the `grep -nr CONFIG_FW_CFG_SYSFS /boot/config-$(uname -r)` command on the source server of the image. If the command output contains `CONFIG_FW_CFG_SYSFS=y`, the kernel of the image supports the `CONFIG_FW_CFG_SYSFS` feature.
        Alibaba Cloud cloud-init of the latest version is installed on the operating system. If the version of cloud-init is 19.1, the minor version must be 19.1.3 or later. If the version of cloud-init is 0.7.6a in some early versions of operating systems, the minor version must be 0.7.6a15 or later. For more information, see [Install cloud-init](https://help.aliyun.com/document_detail/57803.html).
        The operating system supports the SHA-512 encryption algorithm.
        If you want an imported image to support the resizing of disks and file systems, make sure that the image meets the following requirements before you import it:
        The kernel version of the operating system is later than 3.6.
        The image supports the growpart command. To support this command, you must install the `cloud-utils-growpart` package. The methods of installing the package vary based on operating systems. For more information, see [Extend the partitions and file systems of disks on a Linux instance](https://help.aliyun.com/document_detail/25451.html).
        The image supports the resize2fs command. To support this command, you must install the `e2fsprogs` package. By default, the package is installed on the operating system. If the package is not installed, install it.
        Alibaba Cloud cloud-init of the latest version is installed on the operating system. If the version of cloud-init is 19.1, the minor version must be 19.1.3 or later. If the version of cloud-init is 0.7.6a in some early versions of operating systems, the minor version must be 0.7.6a15 or later. For more information, see [Install cloud-init](https://help.aliyun.com/document_detail/57803.html).
        If the image that you want to import uses the Arm64 architecture, configure the real-time clock (RTC) to use the Coordinated Universal Time (UTC) time standard. For more information, see [Linux time and time zones](https://help.aliyun.com/document_detail/405080.html).
        When you import images, we recommend that you specify DetectionStrategy. This way, you can optimize the images based on the image check results. For more information, see [Overview of image check](https://help.aliyun.com/document_detail/439819.html).
        
        @param request: ImportImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ImportImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.architecture):
            query['Architecture'] = request.architecture
        if not UtilClient.is_unset(request.boot_mode):
            query['BootMode'] = request.boot_mode
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.detection_strategy):
            query['DetectionStrategy'] = request.detection_strategy
        if not UtilClient.is_unset(request.disk_device_mapping):
            query['DiskDeviceMapping'] = request.disk_device_mapping
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.features):
            query['Features'] = request.features
        if not UtilClient.is_unset(request.image_name):
            query['ImageName'] = request.image_name
        if not UtilClient.is_unset(request.license_type):
            query['LicenseType'] = request.license_type
        if not UtilClient.is_unset(request.ostype):
            query['OSType'] = request.ostype
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.role_name):
            query['RoleName'] = request.role_name
        if not UtilClient.is_unset(request.storage_location_arn):
            query['StorageLocationArn'] = request.storage_location_arn
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ImportImage',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ImportImageResponse(),
            self.call_api(params, req, runtime)
        )

    async def import_image_with_options_async(
        self,
        request: ecs_20140526_models.ImportImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ImportImageResponse:
        """
        @summary Imports an on-premise image to Elastic Compute Service (ECS). The imported image exists as a custom image in the destination region. You can use the imported image to create ECS instances by calling the RunInstances operation or replace the system disk of an ECS instance by calling the ReplaceSystemDisk operation.
        
        @description ### [](#)Usage notes
        Take note of the following items:
        Before you import an image, you must upload the image to an Object Storage Service (OSS) bucket. For more information, see [Upload objects](https://help.aliyun.com/document_detail/31886.html).
        In specific scenarios, you may want to create a custom image based on the operating system data of a source server, import the image to Alibaba Cloud, and then create an ECS instance from the image. The source server can be a physical server, a virtual machine, or a cloud host. If the virtio driver is not installed on the source server, the created ECS instance may be unable to start. To prevent this issue, verify that the virtio driver is installed on the source server before you import the image to Alibaba Cloud. For more information, see [Install the virtio driver](https://help.aliyun.com/document_detail/62423.html).
        Before you import images for the first time, you must use Resource Access Management (RAM) to authorize ECS to access your OSS buckets. If ECS is not authorized to access your OSS buckets, the `NoSetRoletoECSServiceAccount` or `InvalidOperation.CloudBoxImageImportRoleRequired` error code is returned when you call the ImportImage operation. The authorization configuration varies based on whether the image files are imported from a cloud box.
        **If the image files are not imported from a cloud box**, you can complete the authorization on the [Cloud Resource Access Authorization](https://ram.console.aliyun.com/?spm=5176.2020520101image.0.0.2ffa4df57kSoHX#/role/authorize?request=%7B%22Requests%22%3A%20%7B%22request1%22%3A%20%7B%22RoleName%22%3A%20%22AliyunECSImageImportDefaultRole%22%2C%20%22TemplateId%22%3A%20%22ECSImportRole%22%7D%2C%20%22request2%22%3A%20%7B%22RoleName%22%3A%20%22AliyunECSImageExportDefaultRole%22%2C%20%22TemplateId%22%3A%20%22ECSExportRole%22%7D%7D%2C%20%22ReturnUrl%22%3A%20%22https%3A//ecs.console.aliyun.com/%22%2C%20%22Service%22%3A%20%22ECS%22%7D) page of the RAM console. You can also complete the authorization by using a RAM role and RAM policies. The following example shows the policies and permissions required for specific steps in the authorization procedure. For more information, see [Control access to ECS resources by using RAM users](https://help.aliyun.com/document_detail/25481.html).
        1.  Create a RAM role named `AliyunECSImageImportDefaultRole`. You must use this exact role name. Otherwise, the image cannot be imported. Configure the following trust policy for the role:
        {
        "Statement": [
        {
        "Action": "sts:AssumeRole",
        "Effect": "Allow",
        "Principal": {
        "Service": [
        "ecs.aliyuncs.com"
        ]
        }
        }
        ],
        "Version": "1"
        }
        2.  Attach the `AliyunECSImageImportRolePolicy` system policy to the RAM role. You can also create a custom policy that contains the following content and attach the policy to the role:
        ```
        {
        "Version": "1",
        "Statement": [
        {
        "Action": [
        "oss:GetObject",
        "oss:GetBucketLocation",
        "oss:GetBucketInfo"
        ],
        "Resource": "",
        "Effect": "Allow"
        }
        ]
        }
        ```
        **If the image files are imported from a cloud box**, you can complete the authorization on the [Cloud Resource Access Authorization](https://ram.console.aliyun.com/role/authorize?request=%7B%22ReturnUrl%22%3A%22https%3A%2F%2Fecs.console.aliyun.com%2F%22%2C%22Services%22%3A%5B%7B%22Roles%22%3A%5B%7B%22RoleName%22%3A%22AliyunECSCloudBoxImageImportDefaultRole%22%2C%22TemplateId%22%3A%22AliyunECSCloudBoxImageImportDefaultRole%22%7D%5D%2C%22Service%22%3A%22ECS%22%7D%5D%7D) page of the RAM console. You can also complete the authorization by using a RAM role and RAM policies. The following example shows the policies and permissions required for specific steps in the authorization procedure. For more information, see [Control access to ECS resources by using RAM users](https://help.aliyun.com/document_detail/25481.html).
        1.  Create a RAM role named `AliyunECSCloudBoxImageImportDefaultRole`. You must use this exact role name. Otherwise, the image cannot be imported. Configure the following trust policy for the role:
        {
        "Statement": [
        {
        "Action": "sts:AssumeRole",
        "Effect": "Allow",
        "Principal": {
        "Service": [
        "ecs.aliyuncs.com"
        ]
        }
        }
        ],
        "Version": "1"
        }
        2.  Attach the `AliyunECSCloudBoxImageImportRolePolicy` system policy to the RAM role. You can also create a custom policy that contains the following content and attach the policy to the role:
        ```
        {
        "Version": "1",
        "Statement": [
        {
        "Action": [
        "oss-cloudbox:GetObject",
        "oss-cloudbox:GetBucketLocation",
        "oss-cloudbox:GetBucketInfo"
        ],
        "Resource": "",
        "Effect": "Allow"
        }
        ]
        }
        ```
        You cannot delete an image that is being imported. However, you can call the [CancelTask](https://help.aliyun.com/document_detail/25624.html) operation to cancel the image import task.
        You can import an image only to the same region as the OSS bucket to which the image file is uploaded.
        The valid values of N in `DiskDeviceMapping.N` range from 1 to 17. When N is set to 1, the disk is a system disk. When N is set to a value from 2 to 17, the disk is a data disk. When N is set to a value greater than 17, parameters prefixed with DiskDeviceMapping.N are ignored.
        When you set `Architecture` to `arm64` or when you set `Platform` to `CentOS Stream`, `Anolis`, `AlmaLinux`, `UOS`, `Kylin`, or `Rocky Linux`, take note of the following items:
        To ensure that the password can be set or the key pair can be modified for an imported image, make sure that the image meets the following requirements before you import it:
        The kernel of the operating system supports the `CONFIG_FW_CFG_SYSFS` feature. By default, Linux community kernel 4.6 and later and CentOS kernel 3.10.0-826.el7 and later support the CONFIG_FW_CFG_SYSFS feature. You can run the `grep -nr CONFIG_FW_CFG_SYSFS /boot/config-$(uname -r)` command on the source server of the image. If the command output contains `CONFIG_FW_CFG_SYSFS=y`, the kernel of the image supports the `CONFIG_FW_CFG_SYSFS` feature.
        Alibaba Cloud cloud-init of the latest version is installed on the operating system. If the version of cloud-init is 19.1, the minor version must be 19.1.3 or later. If the version of cloud-init is 0.7.6a in some early versions of operating systems, the minor version must be 0.7.6a15 or later. For more information, see [Install cloud-init](https://help.aliyun.com/document_detail/57803.html).
        The operating system supports the SHA-512 encryption algorithm.
        If you want an imported image to support the resizing of disks and file systems, make sure that the image meets the following requirements before you import it:
        The kernel version of the operating system is later than 3.6.
        The image supports the growpart command. To support this command, you must install the `cloud-utils-growpart` package. The methods of installing the package vary based on operating systems. For more information, see [Extend the partitions and file systems of disks on a Linux instance](https://help.aliyun.com/document_detail/25451.html).
        The image supports the resize2fs command. To support this command, you must install the `e2fsprogs` package. By default, the package is installed on the operating system. If the package is not installed, install it.
        Alibaba Cloud cloud-init of the latest version is installed on the operating system. If the version of cloud-init is 19.1, the minor version must be 19.1.3 or later. If the version of cloud-init is 0.7.6a in some early versions of operating systems, the minor version must be 0.7.6a15 or later. For more information, see [Install cloud-init](https://help.aliyun.com/document_detail/57803.html).
        If the image that you want to import uses the Arm64 architecture, configure the real-time clock (RTC) to use the Coordinated Universal Time (UTC) time standard. For more information, see [Linux time and time zones](https://help.aliyun.com/document_detail/405080.html).
        When you import images, we recommend that you specify DetectionStrategy. This way, you can optimize the images based on the image check results. For more information, see [Overview of image check](https://help.aliyun.com/document_detail/439819.html).
        
        @param request: ImportImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ImportImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.architecture):
            query['Architecture'] = request.architecture
        if not UtilClient.is_unset(request.boot_mode):
            query['BootMode'] = request.boot_mode
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.detection_strategy):
            query['DetectionStrategy'] = request.detection_strategy
        if not UtilClient.is_unset(request.disk_device_mapping):
            query['DiskDeviceMapping'] = request.disk_device_mapping
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.features):
            query['Features'] = request.features
        if not UtilClient.is_unset(request.image_name):
            query['ImageName'] = request.image_name
        if not UtilClient.is_unset(request.license_type):
            query['LicenseType'] = request.license_type
        if not UtilClient.is_unset(request.ostype):
            query['OSType'] = request.ostype
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.role_name):
            query['RoleName'] = request.role_name
        if not UtilClient.is_unset(request.storage_location_arn):
            query['StorageLocationArn'] = request.storage_location_arn
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ImportImage',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ImportImageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def import_image(
        self,
        request: ecs_20140526_models.ImportImageRequest,
    ) -> ecs_20140526_models.ImportImageResponse:
        """
        @summary Imports an on-premise image to Elastic Compute Service (ECS). The imported image exists as a custom image in the destination region. You can use the imported image to create ECS instances by calling the RunInstances operation or replace the system disk of an ECS instance by calling the ReplaceSystemDisk operation.
        
        @description ### [](#)Usage notes
        Take note of the following items:
        Before you import an image, you must upload the image to an Object Storage Service (OSS) bucket. For more information, see [Upload objects](https://help.aliyun.com/document_detail/31886.html).
        In specific scenarios, you may want to create a custom image based on the operating system data of a source server, import the image to Alibaba Cloud, and then create an ECS instance from the image. The source server can be a physical server, a virtual machine, or a cloud host. If the virtio driver is not installed on the source server, the created ECS instance may be unable to start. To prevent this issue, verify that the virtio driver is installed on the source server before you import the image to Alibaba Cloud. For more information, see [Install the virtio driver](https://help.aliyun.com/document_detail/62423.html).
        Before you import images for the first time, you must use Resource Access Management (RAM) to authorize ECS to access your OSS buckets. If ECS is not authorized to access your OSS buckets, the `NoSetRoletoECSServiceAccount` or `InvalidOperation.CloudBoxImageImportRoleRequired` error code is returned when you call the ImportImage operation. The authorization configuration varies based on whether the image files are imported from a cloud box.
        **If the image files are not imported from a cloud box**, you can complete the authorization on the [Cloud Resource Access Authorization](https://ram.console.aliyun.com/?spm=5176.2020520101image.0.0.2ffa4df57kSoHX#/role/authorize?request=%7B%22Requests%22%3A%20%7B%22request1%22%3A%20%7B%22RoleName%22%3A%20%22AliyunECSImageImportDefaultRole%22%2C%20%22TemplateId%22%3A%20%22ECSImportRole%22%7D%2C%20%22request2%22%3A%20%7B%22RoleName%22%3A%20%22AliyunECSImageExportDefaultRole%22%2C%20%22TemplateId%22%3A%20%22ECSExportRole%22%7D%7D%2C%20%22ReturnUrl%22%3A%20%22https%3A//ecs.console.aliyun.com/%22%2C%20%22Service%22%3A%20%22ECS%22%7D) page of the RAM console. You can also complete the authorization by using a RAM role and RAM policies. The following example shows the policies and permissions required for specific steps in the authorization procedure. For more information, see [Control access to ECS resources by using RAM users](https://help.aliyun.com/document_detail/25481.html).
        1.  Create a RAM role named `AliyunECSImageImportDefaultRole`. You must use this exact role name. Otherwise, the image cannot be imported. Configure the following trust policy for the role:
        {
        "Statement": [
        {
        "Action": "sts:AssumeRole",
        "Effect": "Allow",
        "Principal": {
        "Service": [
        "ecs.aliyuncs.com"
        ]
        }
        }
        ],
        "Version": "1"
        }
        2.  Attach the `AliyunECSImageImportRolePolicy` system policy to the RAM role. You can also create a custom policy that contains the following content and attach the policy to the role:
        ```
        {
        "Version": "1",
        "Statement": [
        {
        "Action": [
        "oss:GetObject",
        "oss:GetBucketLocation",
        "oss:GetBucketInfo"
        ],
        "Resource": "",
        "Effect": "Allow"
        }
        ]
        }
        ```
        **If the image files are imported from a cloud box**, you can complete the authorization on the [Cloud Resource Access Authorization](https://ram.console.aliyun.com/role/authorize?request=%7B%22ReturnUrl%22%3A%22https%3A%2F%2Fecs.console.aliyun.com%2F%22%2C%22Services%22%3A%5B%7B%22Roles%22%3A%5B%7B%22RoleName%22%3A%22AliyunECSCloudBoxImageImportDefaultRole%22%2C%22TemplateId%22%3A%22AliyunECSCloudBoxImageImportDefaultRole%22%7D%5D%2C%22Service%22%3A%22ECS%22%7D%5D%7D) page of the RAM console. You can also complete the authorization by using a RAM role and RAM policies. The following example shows the policies and permissions required for specific steps in the authorization procedure. For more information, see [Control access to ECS resources by using RAM users](https://help.aliyun.com/document_detail/25481.html).
        1.  Create a RAM role named `AliyunECSCloudBoxImageImportDefaultRole`. You must use this exact role name. Otherwise, the image cannot be imported. Configure the following trust policy for the role:
        {
        "Statement": [
        {
        "Action": "sts:AssumeRole",
        "Effect": "Allow",
        "Principal": {
        "Service": [
        "ecs.aliyuncs.com"
        ]
        }
        }
        ],
        "Version": "1"
        }
        2.  Attach the `AliyunECSCloudBoxImageImportRolePolicy` system policy to the RAM role. You can also create a custom policy that contains the following content and attach the policy to the role:
        ```
        {
        "Version": "1",
        "Statement": [
        {
        "Action": [
        "oss-cloudbox:GetObject",
        "oss-cloudbox:GetBucketLocation",
        "oss-cloudbox:GetBucketInfo"
        ],
        "Resource": "",
        "Effect": "Allow"
        }
        ]
        }
        ```
        You cannot delete an image that is being imported. However, you can call the [CancelTask](https://help.aliyun.com/document_detail/25624.html) operation to cancel the image import task.
        You can import an image only to the same region as the OSS bucket to which the image file is uploaded.
        The valid values of N in `DiskDeviceMapping.N` range from 1 to 17. When N is set to 1, the disk is a system disk. When N is set to a value from 2 to 17, the disk is a data disk. When N is set to a value greater than 17, parameters prefixed with DiskDeviceMapping.N are ignored.
        When you set `Architecture` to `arm64` or when you set `Platform` to `CentOS Stream`, `Anolis`, `AlmaLinux`, `UOS`, `Kylin`, or `Rocky Linux`, take note of the following items:
        To ensure that the password can be set or the key pair can be modified for an imported image, make sure that the image meets the following requirements before you import it:
        The kernel of the operating system supports the `CONFIG_FW_CFG_SYSFS` feature. By default, Linux community kernel 4.6 and later and CentOS kernel 3.10.0-826.el7 and later support the CONFIG_FW_CFG_SYSFS feature. You can run the `grep -nr CONFIG_FW_CFG_SYSFS /boot/config-$(uname -r)` command on the source server of the image. If the command output contains `CONFIG_FW_CFG_SYSFS=y`, the kernel of the image supports the `CONFIG_FW_CFG_SYSFS` feature.
        Alibaba Cloud cloud-init of the latest version is installed on the operating system. If the version of cloud-init is 19.1, the minor version must be 19.1.3 or later. If the version of cloud-init is 0.7.6a in some early versions of operating systems, the minor version must be 0.7.6a15 or later. For more information, see [Install cloud-init](https://help.aliyun.com/document_detail/57803.html).
        The operating system supports the SHA-512 encryption algorithm.
        If you want an imported image to support the resizing of disks and file systems, make sure that the image meets the following requirements before you import it:
        The kernel version of the operating system is later than 3.6.
        The image supports the growpart command. To support this command, you must install the `cloud-utils-growpart` package. The methods of installing the package vary based on operating systems. For more information, see [Extend the partitions and file systems of disks on a Linux instance](https://help.aliyun.com/document_detail/25451.html).
        The image supports the resize2fs command. To support this command, you must install the `e2fsprogs` package. By default, the package is installed on the operating system. If the package is not installed, install it.
        Alibaba Cloud cloud-init of the latest version is installed on the operating system. If the version of cloud-init is 19.1, the minor version must be 19.1.3 or later. If the version of cloud-init is 0.7.6a in some early versions of operating systems, the minor version must be 0.7.6a15 or later. For more information, see [Install cloud-init](https://help.aliyun.com/document_detail/57803.html).
        If the image that you want to import uses the Arm64 architecture, configure the real-time clock (RTC) to use the Coordinated Universal Time (UTC) time standard. For more information, see [Linux time and time zones](https://help.aliyun.com/document_detail/405080.html).
        When you import images, we recommend that you specify DetectionStrategy. This way, you can optimize the images based on the image check results. For more information, see [Overview of image check](https://help.aliyun.com/document_detail/439819.html).
        
        @param request: ImportImageRequest
        @return: ImportImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.import_image_with_options(request, runtime)

    async def import_image_async(
        self,
        request: ecs_20140526_models.ImportImageRequest,
    ) -> ecs_20140526_models.ImportImageResponse:
        """
        @summary Imports an on-premise image to Elastic Compute Service (ECS). The imported image exists as a custom image in the destination region. You can use the imported image to create ECS instances by calling the RunInstances operation or replace the system disk of an ECS instance by calling the ReplaceSystemDisk operation.
        
        @description ### [](#)Usage notes
        Take note of the following items:
        Before you import an image, you must upload the image to an Object Storage Service (OSS) bucket. For more information, see [Upload objects](https://help.aliyun.com/document_detail/31886.html).
        In specific scenarios, you may want to create a custom image based on the operating system data of a source server, import the image to Alibaba Cloud, and then create an ECS instance from the image. The source server can be a physical server, a virtual machine, or a cloud host. If the virtio driver is not installed on the source server, the created ECS instance may be unable to start. To prevent this issue, verify that the virtio driver is installed on the source server before you import the image to Alibaba Cloud. For more information, see [Install the virtio driver](https://help.aliyun.com/document_detail/62423.html).
        Before you import images for the first time, you must use Resource Access Management (RAM) to authorize ECS to access your OSS buckets. If ECS is not authorized to access your OSS buckets, the `NoSetRoletoECSServiceAccount` or `InvalidOperation.CloudBoxImageImportRoleRequired` error code is returned when you call the ImportImage operation. The authorization configuration varies based on whether the image files are imported from a cloud box.
        **If the image files are not imported from a cloud box**, you can complete the authorization on the [Cloud Resource Access Authorization](https://ram.console.aliyun.com/?spm=5176.2020520101image.0.0.2ffa4df57kSoHX#/role/authorize?request=%7B%22Requests%22%3A%20%7B%22request1%22%3A%20%7B%22RoleName%22%3A%20%22AliyunECSImageImportDefaultRole%22%2C%20%22TemplateId%22%3A%20%22ECSImportRole%22%7D%2C%20%22request2%22%3A%20%7B%22RoleName%22%3A%20%22AliyunECSImageExportDefaultRole%22%2C%20%22TemplateId%22%3A%20%22ECSExportRole%22%7D%7D%2C%20%22ReturnUrl%22%3A%20%22https%3A//ecs.console.aliyun.com/%22%2C%20%22Service%22%3A%20%22ECS%22%7D) page of the RAM console. You can also complete the authorization by using a RAM role and RAM policies. The following example shows the policies and permissions required for specific steps in the authorization procedure. For more information, see [Control access to ECS resources by using RAM users](https://help.aliyun.com/document_detail/25481.html).
        1.  Create a RAM role named `AliyunECSImageImportDefaultRole`. You must use this exact role name. Otherwise, the image cannot be imported. Configure the following trust policy for the role:
        {
        "Statement": [
        {
        "Action": "sts:AssumeRole",
        "Effect": "Allow",
        "Principal": {
        "Service": [
        "ecs.aliyuncs.com"
        ]
        }
        }
        ],
        "Version": "1"
        }
        2.  Attach the `AliyunECSImageImportRolePolicy` system policy to the RAM role. You can also create a custom policy that contains the following content and attach the policy to the role:
        ```
        {
        "Version": "1",
        "Statement": [
        {
        "Action": [
        "oss:GetObject",
        "oss:GetBucketLocation",
        "oss:GetBucketInfo"
        ],
        "Resource": "",
        "Effect": "Allow"
        }
        ]
        }
        ```
        **If the image files are imported from a cloud box**, you can complete the authorization on the [Cloud Resource Access Authorization](https://ram.console.aliyun.com/role/authorize?request=%7B%22ReturnUrl%22%3A%22https%3A%2F%2Fecs.console.aliyun.com%2F%22%2C%22Services%22%3A%5B%7B%22Roles%22%3A%5B%7B%22RoleName%22%3A%22AliyunECSCloudBoxImageImportDefaultRole%22%2C%22TemplateId%22%3A%22AliyunECSCloudBoxImageImportDefaultRole%22%7D%5D%2C%22Service%22%3A%22ECS%22%7D%5D%7D) page of the RAM console. You can also complete the authorization by using a RAM role and RAM policies. The following example shows the policies and permissions required for specific steps in the authorization procedure. For more information, see [Control access to ECS resources by using RAM users](https://help.aliyun.com/document_detail/25481.html).
        1.  Create a RAM role named `AliyunECSCloudBoxImageImportDefaultRole`. You must use this exact role name. Otherwise, the image cannot be imported. Configure the following trust policy for the role:
        {
        "Statement": [
        {
        "Action": "sts:AssumeRole",
        "Effect": "Allow",
        "Principal": {
        "Service": [
        "ecs.aliyuncs.com"
        ]
        }
        }
        ],
        "Version": "1"
        }
        2.  Attach the `AliyunECSCloudBoxImageImportRolePolicy` system policy to the RAM role. You can also create a custom policy that contains the following content and attach the policy to the role:
        ```
        {
        "Version": "1",
        "Statement": [
        {
        "Action": [
        "oss-cloudbox:GetObject",
        "oss-cloudbox:GetBucketLocation",
        "oss-cloudbox:GetBucketInfo"
        ],
        "Resource": "",
        "Effect": "Allow"
        }
        ]
        }
        ```
        You cannot delete an image that is being imported. However, you can call the [CancelTask](https://help.aliyun.com/document_detail/25624.html) operation to cancel the image import task.
        You can import an image only to the same region as the OSS bucket to which the image file is uploaded.
        The valid values of N in `DiskDeviceMapping.N` range from 1 to 17. When N is set to 1, the disk is a system disk. When N is set to a value from 2 to 17, the disk is a data disk. When N is set to a value greater than 17, parameters prefixed with DiskDeviceMapping.N are ignored.
        When you set `Architecture` to `arm64` or when you set `Platform` to `CentOS Stream`, `Anolis`, `AlmaLinux`, `UOS`, `Kylin`, or `Rocky Linux`, take note of the following items:
        To ensure that the password can be set or the key pair can be modified for an imported image, make sure that the image meets the following requirements before you import it:
        The kernel of the operating system supports the `CONFIG_FW_CFG_SYSFS` feature. By default, Linux community kernel 4.6 and later and CentOS kernel 3.10.0-826.el7 and later support the CONFIG_FW_CFG_SYSFS feature. You can run the `grep -nr CONFIG_FW_CFG_SYSFS /boot/config-$(uname -r)` command on the source server of the image. If the command output contains `CONFIG_FW_CFG_SYSFS=y`, the kernel of the image supports the `CONFIG_FW_CFG_SYSFS` feature.
        Alibaba Cloud cloud-init of the latest version is installed on the operating system. If the version of cloud-init is 19.1, the minor version must be 19.1.3 or later. If the version of cloud-init is 0.7.6a in some early versions of operating systems, the minor version must be 0.7.6a15 or later. For more information, see [Install cloud-init](https://help.aliyun.com/document_detail/57803.html).
        The operating system supports the SHA-512 encryption algorithm.
        If you want an imported image to support the resizing of disks and file systems, make sure that the image meets the following requirements before you import it:
        The kernel version of the operating system is later than 3.6.
        The image supports the growpart command. To support this command, you must install the `cloud-utils-growpart` package. The methods of installing the package vary based on operating systems. For more information, see [Extend the partitions and file systems of disks on a Linux instance](https://help.aliyun.com/document_detail/25451.html).
        The image supports the resize2fs command. To support this command, you must install the `e2fsprogs` package. By default, the package is installed on the operating system. If the package is not installed, install it.
        Alibaba Cloud cloud-init of the latest version is installed on the operating system. If the version of cloud-init is 19.1, the minor version must be 19.1.3 or later. If the version of cloud-init is 0.7.6a in some early versions of operating systems, the minor version must be 0.7.6a15 or later. For more information, see [Install cloud-init](https://help.aliyun.com/document_detail/57803.html).
        If the image that you want to import uses the Arm64 architecture, configure the real-time clock (RTC) to use the Coordinated Universal Time (UTC) time standard. For more information, see [Linux time and time zones](https://help.aliyun.com/document_detail/405080.html).
        When you import images, we recommend that you specify DetectionStrategy. This way, you can optimize the images based on the image check results. For more information, see [Overview of image check](https://help.aliyun.com/document_detail/439819.html).
        
        @param request: ImportImageRequest
        @return: ImportImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.import_image_with_options_async(request, runtime)

    def import_key_pair_with_options(
        self,
        request: ecs_20140526_models.ImportKeyPairRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ImportKeyPairResponse:
        """
        @summary Imports the public key of a Rivest-Shamir-Adleman (RSA) key pair that is generated by a third-party tool. After the key pair is imported, Alibaba Cloud stores the public key. You must securely lock away the private key.
        
        @description Take note of the following items:
        A maximum of 500 key pairs can be created in each region.
        The key pair to be imported must support one of the following encryption methods:
        rsa
        dsa
        ssh-rsa
        ssh-dss
        ecdsa
        <ssh-rsa-cert-v00@openssh.com>
        <ssh-dss-cert-v00@openssh.com>
        <ssh-rsa-cert-v01@openssh.com>
        <ssh-dss-cert-v01@openssh.com>
        <ecdsa-sha2-nistp256-cert-v01@openssh.com>
        <ecdsa-sha2-nistp384-cert-v01@openssh.com>
        <ecdsa-sha2-nistp521-cert-v01@openssh.com>
        
        @param request: ImportKeyPairRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ImportKeyPairResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.public_key_body):
            query['PublicKeyBody'] = request.public_key_body
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ImportKeyPair',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ImportKeyPairResponse(),
            self.call_api(params, req, runtime)
        )

    async def import_key_pair_with_options_async(
        self,
        request: ecs_20140526_models.ImportKeyPairRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ImportKeyPairResponse:
        """
        @summary Imports the public key of a Rivest-Shamir-Adleman (RSA) key pair that is generated by a third-party tool. After the key pair is imported, Alibaba Cloud stores the public key. You must securely lock away the private key.
        
        @description Take note of the following items:
        A maximum of 500 key pairs can be created in each region.
        The key pair to be imported must support one of the following encryption methods:
        rsa
        dsa
        ssh-rsa
        ssh-dss
        ecdsa
        <ssh-rsa-cert-v00@openssh.com>
        <ssh-dss-cert-v00@openssh.com>
        <ssh-rsa-cert-v01@openssh.com>
        <ssh-dss-cert-v01@openssh.com>
        <ecdsa-sha2-nistp256-cert-v01@openssh.com>
        <ecdsa-sha2-nistp384-cert-v01@openssh.com>
        <ecdsa-sha2-nistp521-cert-v01@openssh.com>
        
        @param request: ImportKeyPairRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ImportKeyPairResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.public_key_body):
            query['PublicKeyBody'] = request.public_key_body
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ImportKeyPair',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ImportKeyPairResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def import_key_pair(
        self,
        request: ecs_20140526_models.ImportKeyPairRequest,
    ) -> ecs_20140526_models.ImportKeyPairResponse:
        """
        @summary Imports the public key of a Rivest-Shamir-Adleman (RSA) key pair that is generated by a third-party tool. After the key pair is imported, Alibaba Cloud stores the public key. You must securely lock away the private key.
        
        @description Take note of the following items:
        A maximum of 500 key pairs can be created in each region.
        The key pair to be imported must support one of the following encryption methods:
        rsa
        dsa
        ssh-rsa
        ssh-dss
        ecdsa
        <ssh-rsa-cert-v00@openssh.com>
        <ssh-dss-cert-v00@openssh.com>
        <ssh-rsa-cert-v01@openssh.com>
        <ssh-dss-cert-v01@openssh.com>
        <ecdsa-sha2-nistp256-cert-v01@openssh.com>
        <ecdsa-sha2-nistp384-cert-v01@openssh.com>
        <ecdsa-sha2-nistp521-cert-v01@openssh.com>
        
        @param request: ImportKeyPairRequest
        @return: ImportKeyPairResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.import_key_pair_with_options(request, runtime)

    async def import_key_pair_async(
        self,
        request: ecs_20140526_models.ImportKeyPairRequest,
    ) -> ecs_20140526_models.ImportKeyPairResponse:
        """
        @summary Imports the public key of a Rivest-Shamir-Adleman (RSA) key pair that is generated by a third-party tool. After the key pair is imported, Alibaba Cloud stores the public key. You must securely lock away the private key.
        
        @description Take note of the following items:
        A maximum of 500 key pairs can be created in each region.
        The key pair to be imported must support one of the following encryption methods:
        rsa
        dsa
        ssh-rsa
        ssh-dss
        ecdsa
        <ssh-rsa-cert-v00@openssh.com>
        <ssh-dss-cert-v00@openssh.com>
        <ssh-rsa-cert-v01@openssh.com>
        <ssh-dss-cert-v01@openssh.com>
        <ecdsa-sha2-nistp256-cert-v01@openssh.com>
        <ecdsa-sha2-nistp384-cert-v01@openssh.com>
        <ecdsa-sha2-nistp521-cert-v01@openssh.com>
        
        @param request: ImportKeyPairRequest
        @return: ImportKeyPairResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.import_key_pair_with_options_async(request, runtime)

    def install_cloud_assistant_with_options(
        self,
        request: ecs_20140526_models.InstallCloudAssistantRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.InstallCloudAssistantResponse:
        """
        @summary Installs Cloud Assistant Agent on Elastic Compute Service (ECS) instances. After you install Cloud Assistant Agent on ECS instances, restart the instances for the installation to take effect.
        
        @description ## [](#)Usage notes
        After you call the InstallCloudAssistant operation to install Cloud Assistant Agent on an ECS instance, call the [RebootInstance](https://help.aliyun.com/document_detail/25502.html) operation to restart the instance to make the installation take effect.
        
        @param request: InstallCloudAssistantRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: InstallCloudAssistantResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='InstallCloudAssistant',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.InstallCloudAssistantResponse(),
            self.call_api(params, req, runtime)
        )

    async def install_cloud_assistant_with_options_async(
        self,
        request: ecs_20140526_models.InstallCloudAssistantRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.InstallCloudAssistantResponse:
        """
        @summary Installs Cloud Assistant Agent on Elastic Compute Service (ECS) instances. After you install Cloud Assistant Agent on ECS instances, restart the instances for the installation to take effect.
        
        @description ## [](#)Usage notes
        After you call the InstallCloudAssistant operation to install Cloud Assistant Agent on an ECS instance, call the [RebootInstance](https://help.aliyun.com/document_detail/25502.html) operation to restart the instance to make the installation take effect.
        
        @param request: InstallCloudAssistantRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: InstallCloudAssistantResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='InstallCloudAssistant',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.InstallCloudAssistantResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def install_cloud_assistant(
        self,
        request: ecs_20140526_models.InstallCloudAssistantRequest,
    ) -> ecs_20140526_models.InstallCloudAssistantResponse:
        """
        @summary Installs Cloud Assistant Agent on Elastic Compute Service (ECS) instances. After you install Cloud Assistant Agent on ECS instances, restart the instances for the installation to take effect.
        
        @description ## [](#)Usage notes
        After you call the InstallCloudAssistant operation to install Cloud Assistant Agent on an ECS instance, call the [RebootInstance](https://help.aliyun.com/document_detail/25502.html) operation to restart the instance to make the installation take effect.
        
        @param request: InstallCloudAssistantRequest
        @return: InstallCloudAssistantResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.install_cloud_assistant_with_options(request, runtime)

    async def install_cloud_assistant_async(
        self,
        request: ecs_20140526_models.InstallCloudAssistantRequest,
    ) -> ecs_20140526_models.InstallCloudAssistantResponse:
        """
        @summary Installs Cloud Assistant Agent on Elastic Compute Service (ECS) instances. After you install Cloud Assistant Agent on ECS instances, restart the instances for the installation to take effect.
        
        @description ## [](#)Usage notes
        After you call the InstallCloudAssistant operation to install Cloud Assistant Agent on an ECS instance, call the [RebootInstance](https://help.aliyun.com/document_detail/25502.html) operation to restart the instance to make the installation take effect.
        
        @param request: InstallCloudAssistantRequest
        @return: InstallCloudAssistantResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.install_cloud_assistant_with_options_async(request, runtime)

    def invoke_command_with_options(
        self,
        tmp_req: ecs_20140526_models.InvokeCommandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.InvokeCommandResponse:
        """
        @summary Runs a Cloud Assistant command on one or more Elastic Compute Service (ECS) instances. When you call this operation, you can specify parameters, such as CommandId, InstanceId, and ResourceGroupId, in the request.
        
        @description ## [](#)Usage notes
        The ECS instances on which you want to run the Cloud Assistant command must meet the following requirements. If multiple ECS instances are specified and one of the instances does not meet the requirements for running the command, the call fails. You must specify instances that meet the requirements and call the InvokeCommand operation again.
        The instances are in the Running (`Running`) state. You can call the [DescribeInstances](https://help.aliyun.com/document_detail/25506.html) operation to query the status of instances.
        Cloud Assistant Agent is installed on the instances. For more information, see [Install Cloud Assistant Agent](https://help.aliyun.com/document_detail/64921.html).
        If the command is a PowerShell command, make sure that the instances have the PowerShell module configured.
        You can configure the command to run only once on the instances.
        You can configure the command to run on the instances based on a schedule.
        The schedule is specified by Frequency. The results of each execution of the command do not affect the next execution of the command.
        When you use a cron expression to specify a schedule, you can specify a time zone based on your business requirements. If you do not specify a time zone, the schedule is determined by the system time of the instances. Make sure that the time or time zone of the instances meets your business requirements. For more information, see [Manage the time synchronization service](https://help.aliyun.com/document_detail/92704.html).
        To ensure that scheduled tasks can run as expected, make sure that the version of Cloud Assistant Agent is not earlier than the following versions. A scheduled task can run a command at a fixed interval, only once at a specific time, or at specific times based on a cron expression in a specified year or time zone. If the ClientNeedUpgrade error code is returned, you must upgrade Cloud Assistant Agent to the latest version. For more information, see [Upgrade or disable upgrades for Cloud Assistant Agent](https://help.aliyun.com/document_detail/134383.html).
        Linux: 2.2.3.282
        Windows: 2.1.3.282
        Command executions may fail due to instance status exceptions, network exceptions, or exceptions on Cloud Assistant Agent. If a command execution fails, no execution information is generated. For more information, see [Check execution results and troubleshoot common issues](https://help.aliyun.com/document_detail/87029.html).
        If you enable the custom parameter feature when you create the command, you must specify custom parameters (`Parameters`) to run the command.
        Before you run the command on instances, especially new instances, we recommend that you call the [DescribeCloudAssistantStatus](https://help.aliyun.com/document_detail/87346.html) operation to query the status of Cloud Assistant Agent on the instances and run the command when the value of CloudAssistantStatus in the response is true for the instances.
        
        @param tmp_req: InvokeCommandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: InvokeCommandResponse
        """
        UtilClient.validate_model(tmp_req)
        request = ecs_20140526_models.InvokeCommandShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.parameters):
            request.parameters_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.parameters, 'Parameters', 'json')
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.command_id):
            query['CommandId'] = request.command_id
        if not UtilClient.is_unset(request.container_id):
            query['ContainerId'] = request.container_id
        if not UtilClient.is_unset(request.container_name):
            query['ContainerName'] = request.container_name
        if not UtilClient.is_unset(request.frequency):
            query['Frequency'] = request.frequency
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.launcher):
            query['Launcher'] = request.launcher
        if not UtilClient.is_unset(request.oss_output_delivery):
            query['OssOutputDelivery'] = request.oss_output_delivery
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.parameters_shrink):
            query['Parameters'] = request.parameters_shrink
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_mode):
            query['RepeatMode'] = request.repeat_mode
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_tag):
            query['ResourceTag'] = request.resource_tag
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.termination_mode):
            query['TerminationMode'] = request.termination_mode
        if not UtilClient.is_unset(request.timed):
            query['Timed'] = request.timed
        if not UtilClient.is_unset(request.timeout):
            query['Timeout'] = request.timeout
        if not UtilClient.is_unset(request.username):
            query['Username'] = request.username
        if not UtilClient.is_unset(request.windows_password_name):
            query['WindowsPasswordName'] = request.windows_password_name
        if not UtilClient.is_unset(request.working_dir):
            query['WorkingDir'] = request.working_dir
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='InvokeCommand',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.InvokeCommandResponse(),
            self.call_api(params, req, runtime)
        )

    async def invoke_command_with_options_async(
        self,
        tmp_req: ecs_20140526_models.InvokeCommandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.InvokeCommandResponse:
        """
        @summary Runs a Cloud Assistant command on one or more Elastic Compute Service (ECS) instances. When you call this operation, you can specify parameters, such as CommandId, InstanceId, and ResourceGroupId, in the request.
        
        @description ## [](#)Usage notes
        The ECS instances on which you want to run the Cloud Assistant command must meet the following requirements. If multiple ECS instances are specified and one of the instances does not meet the requirements for running the command, the call fails. You must specify instances that meet the requirements and call the InvokeCommand operation again.
        The instances are in the Running (`Running`) state. You can call the [DescribeInstances](https://help.aliyun.com/document_detail/25506.html) operation to query the status of instances.
        Cloud Assistant Agent is installed on the instances. For more information, see [Install Cloud Assistant Agent](https://help.aliyun.com/document_detail/64921.html).
        If the command is a PowerShell command, make sure that the instances have the PowerShell module configured.
        You can configure the command to run only once on the instances.
        You can configure the command to run on the instances based on a schedule.
        The schedule is specified by Frequency. The results of each execution of the command do not affect the next execution of the command.
        When you use a cron expression to specify a schedule, you can specify a time zone based on your business requirements. If you do not specify a time zone, the schedule is determined by the system time of the instances. Make sure that the time or time zone of the instances meets your business requirements. For more information, see [Manage the time synchronization service](https://help.aliyun.com/document_detail/92704.html).
        To ensure that scheduled tasks can run as expected, make sure that the version of Cloud Assistant Agent is not earlier than the following versions. A scheduled task can run a command at a fixed interval, only once at a specific time, or at specific times based on a cron expression in a specified year or time zone. If the ClientNeedUpgrade error code is returned, you must upgrade Cloud Assistant Agent to the latest version. For more information, see [Upgrade or disable upgrades for Cloud Assistant Agent](https://help.aliyun.com/document_detail/134383.html).
        Linux: 2.2.3.282
        Windows: 2.1.3.282
        Command executions may fail due to instance status exceptions, network exceptions, or exceptions on Cloud Assistant Agent. If a command execution fails, no execution information is generated. For more information, see [Check execution results and troubleshoot common issues](https://help.aliyun.com/document_detail/87029.html).
        If you enable the custom parameter feature when you create the command, you must specify custom parameters (`Parameters`) to run the command.
        Before you run the command on instances, especially new instances, we recommend that you call the [DescribeCloudAssistantStatus](https://help.aliyun.com/document_detail/87346.html) operation to query the status of Cloud Assistant Agent on the instances and run the command when the value of CloudAssistantStatus in the response is true for the instances.
        
        @param tmp_req: InvokeCommandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: InvokeCommandResponse
        """
        UtilClient.validate_model(tmp_req)
        request = ecs_20140526_models.InvokeCommandShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.parameters):
            request.parameters_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.parameters, 'Parameters', 'json')
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.command_id):
            query['CommandId'] = request.command_id
        if not UtilClient.is_unset(request.container_id):
            query['ContainerId'] = request.container_id
        if not UtilClient.is_unset(request.container_name):
            query['ContainerName'] = request.container_name
        if not UtilClient.is_unset(request.frequency):
            query['Frequency'] = request.frequency
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.launcher):
            query['Launcher'] = request.launcher
        if not UtilClient.is_unset(request.oss_output_delivery):
            query['OssOutputDelivery'] = request.oss_output_delivery
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.parameters_shrink):
            query['Parameters'] = request.parameters_shrink
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_mode):
            query['RepeatMode'] = request.repeat_mode
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_tag):
            query['ResourceTag'] = request.resource_tag
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.termination_mode):
            query['TerminationMode'] = request.termination_mode
        if not UtilClient.is_unset(request.timed):
            query['Timed'] = request.timed
        if not UtilClient.is_unset(request.timeout):
            query['Timeout'] = request.timeout
        if not UtilClient.is_unset(request.username):
            query['Username'] = request.username
        if not UtilClient.is_unset(request.windows_password_name):
            query['WindowsPasswordName'] = request.windows_password_name
        if not UtilClient.is_unset(request.working_dir):
            query['WorkingDir'] = request.working_dir
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='InvokeCommand',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.InvokeCommandResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def invoke_command(
        self,
        request: ecs_20140526_models.InvokeCommandRequest,
    ) -> ecs_20140526_models.InvokeCommandResponse:
        """
        @summary Runs a Cloud Assistant command on one or more Elastic Compute Service (ECS) instances. When you call this operation, you can specify parameters, such as CommandId, InstanceId, and ResourceGroupId, in the request.
        
        @description ## [](#)Usage notes
        The ECS instances on which you want to run the Cloud Assistant command must meet the following requirements. If multiple ECS instances are specified and one of the instances does not meet the requirements for running the command, the call fails. You must specify instances that meet the requirements and call the InvokeCommand operation again.
        The instances are in the Running (`Running`) state. You can call the [DescribeInstances](https://help.aliyun.com/document_detail/25506.html) operation to query the status of instances.
        Cloud Assistant Agent is installed on the instances. For more information, see [Install Cloud Assistant Agent](https://help.aliyun.com/document_detail/64921.html).
        If the command is a PowerShell command, make sure that the instances have the PowerShell module configured.
        You can configure the command to run only once on the instances.
        You can configure the command to run on the instances based on a schedule.
        The schedule is specified by Frequency. The results of each execution of the command do not affect the next execution of the command.
        When you use a cron expression to specify a schedule, you can specify a time zone based on your business requirements. If you do not specify a time zone, the schedule is determined by the system time of the instances. Make sure that the time or time zone of the instances meets your business requirements. For more information, see [Manage the time synchronization service](https://help.aliyun.com/document_detail/92704.html).
        To ensure that scheduled tasks can run as expected, make sure that the version of Cloud Assistant Agent is not earlier than the following versions. A scheduled task can run a command at a fixed interval, only once at a specific time, or at specific times based on a cron expression in a specified year or time zone. If the ClientNeedUpgrade error code is returned, you must upgrade Cloud Assistant Agent to the latest version. For more information, see [Upgrade or disable upgrades for Cloud Assistant Agent](https://help.aliyun.com/document_detail/134383.html).
        Linux: 2.2.3.282
        Windows: 2.1.3.282
        Command executions may fail due to instance status exceptions, network exceptions, or exceptions on Cloud Assistant Agent. If a command execution fails, no execution information is generated. For more information, see [Check execution results and troubleshoot common issues](https://help.aliyun.com/document_detail/87029.html).
        If you enable the custom parameter feature when you create the command, you must specify custom parameters (`Parameters`) to run the command.
        Before you run the command on instances, especially new instances, we recommend that you call the [DescribeCloudAssistantStatus](https://help.aliyun.com/document_detail/87346.html) operation to query the status of Cloud Assistant Agent on the instances and run the command when the value of CloudAssistantStatus in the response is true for the instances.
        
        @param request: InvokeCommandRequest
        @return: InvokeCommandResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.invoke_command_with_options(request, runtime)

    async def invoke_command_async(
        self,
        request: ecs_20140526_models.InvokeCommandRequest,
    ) -> ecs_20140526_models.InvokeCommandResponse:
        """
        @summary Runs a Cloud Assistant command on one or more Elastic Compute Service (ECS) instances. When you call this operation, you can specify parameters, such as CommandId, InstanceId, and ResourceGroupId, in the request.
        
        @description ## [](#)Usage notes
        The ECS instances on which you want to run the Cloud Assistant command must meet the following requirements. If multiple ECS instances are specified and one of the instances does not meet the requirements for running the command, the call fails. You must specify instances that meet the requirements and call the InvokeCommand operation again.
        The instances are in the Running (`Running`) state. You can call the [DescribeInstances](https://help.aliyun.com/document_detail/25506.html) operation to query the status of instances.
        Cloud Assistant Agent is installed on the instances. For more information, see [Install Cloud Assistant Agent](https://help.aliyun.com/document_detail/64921.html).
        If the command is a PowerShell command, make sure that the instances have the PowerShell module configured.
        You can configure the command to run only once on the instances.
        You can configure the command to run on the instances based on a schedule.
        The schedule is specified by Frequency. The results of each execution of the command do not affect the next execution of the command.
        When you use a cron expression to specify a schedule, you can specify a time zone based on your business requirements. If you do not specify a time zone, the schedule is determined by the system time of the instances. Make sure that the time or time zone of the instances meets your business requirements. For more information, see [Manage the time synchronization service](https://help.aliyun.com/document_detail/92704.html).
        To ensure that scheduled tasks can run as expected, make sure that the version of Cloud Assistant Agent is not earlier than the following versions. A scheduled task can run a command at a fixed interval, only once at a specific time, or at specific times based on a cron expression in a specified year or time zone. If the ClientNeedUpgrade error code is returned, you must upgrade Cloud Assistant Agent to the latest version. For more information, see [Upgrade or disable upgrades for Cloud Assistant Agent](https://help.aliyun.com/document_detail/134383.html).
        Linux: 2.2.3.282
        Windows: 2.1.3.282
        Command executions may fail due to instance status exceptions, network exceptions, or exceptions on Cloud Assistant Agent. If a command execution fails, no execution information is generated. For more information, see [Check execution results and troubleshoot common issues](https://help.aliyun.com/document_detail/87029.html).
        If you enable the custom parameter feature when you create the command, you must specify custom parameters (`Parameters`) to run the command.
        Before you run the command on instances, especially new instances, we recommend that you call the [DescribeCloudAssistantStatus](https://help.aliyun.com/document_detail/87346.html) operation to query the status of Cloud Assistant Agent on the instances and run the command when the value of CloudAssistantStatus in the response is true for the instances.
        
        @param request: InvokeCommandRequest
        @return: InvokeCommandResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.invoke_command_with_options_async(request, runtime)

    def join_resource_group_with_options(
        self,
        request: ecs_20140526_models.JoinResourceGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.JoinResourceGroupResponse:
        """
        @summary Adds an Elastic Compute Service (ECS) resource or service to a resource group.
        
        @description ## [](#)Usage notes
        A resource is a cloud service entity that you create on Alibaba Cloud, such as an ECS instance, an elastic network interface (ENI), or an image. A resource group is a collection of infrastructure for projects, environments, or stacks. In a resource group, you can manage resources and monitor and run tasks in a centralized manner without the need to switch between Alibaba Cloud services.
        
        @param request: JoinResourceGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: JoinResourceGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='JoinResourceGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.JoinResourceGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def join_resource_group_with_options_async(
        self,
        request: ecs_20140526_models.JoinResourceGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.JoinResourceGroupResponse:
        """
        @summary Adds an Elastic Compute Service (ECS) resource or service to a resource group.
        
        @description ## [](#)Usage notes
        A resource is a cloud service entity that you create on Alibaba Cloud, such as an ECS instance, an elastic network interface (ENI), or an image. A resource group is a collection of infrastructure for projects, environments, or stacks. In a resource group, you can manage resources and monitor and run tasks in a centralized manner without the need to switch between Alibaba Cloud services.
        
        @param request: JoinResourceGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: JoinResourceGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='JoinResourceGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.JoinResourceGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def join_resource_group(
        self,
        request: ecs_20140526_models.JoinResourceGroupRequest,
    ) -> ecs_20140526_models.JoinResourceGroupResponse:
        """
        @summary Adds an Elastic Compute Service (ECS) resource or service to a resource group.
        
        @description ## [](#)Usage notes
        A resource is a cloud service entity that you create on Alibaba Cloud, such as an ECS instance, an elastic network interface (ENI), or an image. A resource group is a collection of infrastructure for projects, environments, or stacks. In a resource group, you can manage resources and monitor and run tasks in a centralized manner without the need to switch between Alibaba Cloud services.
        
        @param request: JoinResourceGroupRequest
        @return: JoinResourceGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.join_resource_group_with_options(request, runtime)

    async def join_resource_group_async(
        self,
        request: ecs_20140526_models.JoinResourceGroupRequest,
    ) -> ecs_20140526_models.JoinResourceGroupResponse:
        """
        @summary Adds an Elastic Compute Service (ECS) resource or service to a resource group.
        
        @description ## [](#)Usage notes
        A resource is a cloud service entity that you create on Alibaba Cloud, such as an ECS instance, an elastic network interface (ENI), or an image. A resource group is a collection of infrastructure for projects, environments, or stacks. In a resource group, you can manage resources and monitor and run tasks in a centralized manner without the need to switch between Alibaba Cloud services.
        
        @param request: JoinResourceGroupRequest
        @return: JoinResourceGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.join_resource_group_with_options_async(request, runtime)

    def join_security_group_with_options(
        self,
        request: ecs_20140526_models.JoinSecurityGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.JoinSecurityGroupResponse:
        """
        @summary Adds an Elastic Compute Service (ECS) instance or an elastic network interface (ENI) to a specified security group.
        
        @description > This operation is not recommended. We recommend that you call the [ModifyInstanceAttribute](https://help.aliyun.com/document_detail/25503.html) operation to add an instance to or remove an instance from a security group, and call the [ModifyNetworkInterfaceAttribute](https://help.aliyun.com/document_detail/58513.html) operation to add an ENI to or remove an ENI from a security group.
        An instance and an ENI cannot be added to a security group at the same time. You cannot specify `InstanceId` and `NetworkInterfaceId` at the same time in a request.
        The security group and the ECS instance to be added to the security group must reside in the same region.
        The security group and the instance must be of the same network type. If the network type is Virtual Private Cloud (VPC), the security group and the instance must reside in the same VPC.
        Before you add an instance to a security group, the instance must be in the **Stopped** or **Running** state.
        An instance can be added to up to five security groups by default. For more information, see [Security group limits](~~25412#SecurityGroupQuota1~~).
        
        @param request: JoinSecurityGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: JoinSecurityGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='JoinSecurityGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.JoinSecurityGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def join_security_group_with_options_async(
        self,
        request: ecs_20140526_models.JoinSecurityGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.JoinSecurityGroupResponse:
        """
        @summary Adds an Elastic Compute Service (ECS) instance or an elastic network interface (ENI) to a specified security group.
        
        @description > This operation is not recommended. We recommend that you call the [ModifyInstanceAttribute](https://help.aliyun.com/document_detail/25503.html) operation to add an instance to or remove an instance from a security group, and call the [ModifyNetworkInterfaceAttribute](https://help.aliyun.com/document_detail/58513.html) operation to add an ENI to or remove an ENI from a security group.
        An instance and an ENI cannot be added to a security group at the same time. You cannot specify `InstanceId` and `NetworkInterfaceId` at the same time in a request.
        The security group and the ECS instance to be added to the security group must reside in the same region.
        The security group and the instance must be of the same network type. If the network type is Virtual Private Cloud (VPC), the security group and the instance must reside in the same VPC.
        Before you add an instance to a security group, the instance must be in the **Stopped** or **Running** state.
        An instance can be added to up to five security groups by default. For more information, see [Security group limits](~~25412#SecurityGroupQuota1~~).
        
        @param request: JoinSecurityGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: JoinSecurityGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='JoinSecurityGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.JoinSecurityGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def join_security_group(
        self,
        request: ecs_20140526_models.JoinSecurityGroupRequest,
    ) -> ecs_20140526_models.JoinSecurityGroupResponse:
        """
        @summary Adds an Elastic Compute Service (ECS) instance or an elastic network interface (ENI) to a specified security group.
        
        @description > This operation is not recommended. We recommend that you call the [ModifyInstanceAttribute](https://help.aliyun.com/document_detail/25503.html) operation to add an instance to or remove an instance from a security group, and call the [ModifyNetworkInterfaceAttribute](https://help.aliyun.com/document_detail/58513.html) operation to add an ENI to or remove an ENI from a security group.
        An instance and an ENI cannot be added to a security group at the same time. You cannot specify `InstanceId` and `NetworkInterfaceId` at the same time in a request.
        The security group and the ECS instance to be added to the security group must reside in the same region.
        The security group and the instance must be of the same network type. If the network type is Virtual Private Cloud (VPC), the security group and the instance must reside in the same VPC.
        Before you add an instance to a security group, the instance must be in the **Stopped** or **Running** state.
        An instance can be added to up to five security groups by default. For more information, see [Security group limits](~~25412#SecurityGroupQuota1~~).
        
        @param request: JoinSecurityGroupRequest
        @return: JoinSecurityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.join_security_group_with_options(request, runtime)

    async def join_security_group_async(
        self,
        request: ecs_20140526_models.JoinSecurityGroupRequest,
    ) -> ecs_20140526_models.JoinSecurityGroupResponse:
        """
        @summary Adds an Elastic Compute Service (ECS) instance or an elastic network interface (ENI) to a specified security group.
        
        @description > This operation is not recommended. We recommend that you call the [ModifyInstanceAttribute](https://help.aliyun.com/document_detail/25503.html) operation to add an instance to or remove an instance from a security group, and call the [ModifyNetworkInterfaceAttribute](https://help.aliyun.com/document_detail/58513.html) operation to add an ENI to or remove an ENI from a security group.
        An instance and an ENI cannot be added to a security group at the same time. You cannot specify `InstanceId` and `NetworkInterfaceId` at the same time in a request.
        The security group and the ECS instance to be added to the security group must reside in the same region.
        The security group and the instance must be of the same network type. If the network type is Virtual Private Cloud (VPC), the security group and the instance must reside in the same VPC.
        Before you add an instance to a security group, the instance must be in the **Stopped** or **Running** state.
        An instance can be added to up to five security groups by default. For more information, see [Security group limits](~~25412#SecurityGroupQuota1~~).
        
        @param request: JoinSecurityGroupRequest
        @return: JoinSecurityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.join_security_group_with_options_async(request, runtime)

    def leave_security_group_with_options(
        self,
        request: ecs_20140526_models.LeaveSecurityGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.LeaveSecurityGroupResponse:
        """
        @summary Removes an Elastic Compute Service (ECS) instance or an elastic network interface (ENI) from a security group.
        
        @description >  This operation is not recommended. We recommend that you call the [ModifyInstanceAttribute](https://help.aliyun.com/document_detail/25503.html) operation to add an instance to or remove an instance from a security group, and call the [ModifyNetworkInterfaceAttribute](https://help.aliyun.com/document_detail/58513.html) operation to add an ENI to or remove an ENI from a security group.
        >  Alibaba Cloud modified verification rules for the LeaveSecurityGroup operation on July 8, 2024. When you remove an ECS instance or ENI that does not belong to a security group from the security group, the "InvalidSecurityGroupAssociation.NotFound" error code is returned instead of a success response. Update the LeaveSecurityGroup operation to use the new verification rules with the new error code based on your business requirements.
        You cannot remove an instance and an ENI from a security group at the same time. This indicates that you cannot specify `InstanceId` and `NetworkInterfaceId` in one request.
        Before you remove an instance from a security group, the instance must be in the **Stopped** (Stopped) or **Running** (Running) state.
        An instance or ENI must be added to at least one security group. If you remove an instance or ENI from the only security group, the removal request fails and an error is returned.
        When you remove an instance or ENI that is not in a security group from the security group, the removal request fails and an error is returned.
        
        @param request: LeaveSecurityGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: LeaveSecurityGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='LeaveSecurityGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.LeaveSecurityGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def leave_security_group_with_options_async(
        self,
        request: ecs_20140526_models.LeaveSecurityGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.LeaveSecurityGroupResponse:
        """
        @summary Removes an Elastic Compute Service (ECS) instance or an elastic network interface (ENI) from a security group.
        
        @description >  This operation is not recommended. We recommend that you call the [ModifyInstanceAttribute](https://help.aliyun.com/document_detail/25503.html) operation to add an instance to or remove an instance from a security group, and call the [ModifyNetworkInterfaceAttribute](https://help.aliyun.com/document_detail/58513.html) operation to add an ENI to or remove an ENI from a security group.
        >  Alibaba Cloud modified verification rules for the LeaveSecurityGroup operation on July 8, 2024. When you remove an ECS instance or ENI that does not belong to a security group from the security group, the "InvalidSecurityGroupAssociation.NotFound" error code is returned instead of a success response. Update the LeaveSecurityGroup operation to use the new verification rules with the new error code based on your business requirements.
        You cannot remove an instance and an ENI from a security group at the same time. This indicates that you cannot specify `InstanceId` and `NetworkInterfaceId` in one request.
        Before you remove an instance from a security group, the instance must be in the **Stopped** (Stopped) or **Running** (Running) state.
        An instance or ENI must be added to at least one security group. If you remove an instance or ENI from the only security group, the removal request fails and an error is returned.
        When you remove an instance or ENI that is not in a security group from the security group, the removal request fails and an error is returned.
        
        @param request: LeaveSecurityGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: LeaveSecurityGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='LeaveSecurityGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.LeaveSecurityGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def leave_security_group(
        self,
        request: ecs_20140526_models.LeaveSecurityGroupRequest,
    ) -> ecs_20140526_models.LeaveSecurityGroupResponse:
        """
        @summary Removes an Elastic Compute Service (ECS) instance or an elastic network interface (ENI) from a security group.
        
        @description >  This operation is not recommended. We recommend that you call the [ModifyInstanceAttribute](https://help.aliyun.com/document_detail/25503.html) operation to add an instance to or remove an instance from a security group, and call the [ModifyNetworkInterfaceAttribute](https://help.aliyun.com/document_detail/58513.html) operation to add an ENI to or remove an ENI from a security group.
        >  Alibaba Cloud modified verification rules for the LeaveSecurityGroup operation on July 8, 2024. When you remove an ECS instance or ENI that does not belong to a security group from the security group, the "InvalidSecurityGroupAssociation.NotFound" error code is returned instead of a success response. Update the LeaveSecurityGroup operation to use the new verification rules with the new error code based on your business requirements.
        You cannot remove an instance and an ENI from a security group at the same time. This indicates that you cannot specify `InstanceId` and `NetworkInterfaceId` in one request.
        Before you remove an instance from a security group, the instance must be in the **Stopped** (Stopped) or **Running** (Running) state.
        An instance or ENI must be added to at least one security group. If you remove an instance or ENI from the only security group, the removal request fails and an error is returned.
        When you remove an instance or ENI that is not in a security group from the security group, the removal request fails and an error is returned.
        
        @param request: LeaveSecurityGroupRequest
        @return: LeaveSecurityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.leave_security_group_with_options(request, runtime)

    async def leave_security_group_async(
        self,
        request: ecs_20140526_models.LeaveSecurityGroupRequest,
    ) -> ecs_20140526_models.LeaveSecurityGroupResponse:
        """
        @summary Removes an Elastic Compute Service (ECS) instance or an elastic network interface (ENI) from a security group.
        
        @description >  This operation is not recommended. We recommend that you call the [ModifyInstanceAttribute](https://help.aliyun.com/document_detail/25503.html) operation to add an instance to or remove an instance from a security group, and call the [ModifyNetworkInterfaceAttribute](https://help.aliyun.com/document_detail/58513.html) operation to add an ENI to or remove an ENI from a security group.
        >  Alibaba Cloud modified verification rules for the LeaveSecurityGroup operation on July 8, 2024. When you remove an ECS instance or ENI that does not belong to a security group from the security group, the "InvalidSecurityGroupAssociation.NotFound" error code is returned instead of a success response. Update the LeaveSecurityGroup operation to use the new verification rules with the new error code based on your business requirements.
        You cannot remove an instance and an ENI from a security group at the same time. This indicates that you cannot specify `InstanceId` and `NetworkInterfaceId` in one request.
        Before you remove an instance from a security group, the instance must be in the **Stopped** (Stopped) or **Running** (Running) state.
        An instance or ENI must be added to at least one security group. If you remove an instance or ENI from the only security group, the removal request fails and an error is returned.
        When you remove an instance or ENI that is not in a security group from the security group, the removal request fails and an error is returned.
        
        @param request: LeaveSecurityGroupRequest
        @return: LeaveSecurityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.leave_security_group_with_options_async(request, runtime)

    def list_plugin_status_with_options(
        self,
        request: ecs_20140526_models.ListPluginStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ListPluginStatusResponse:
        """
        @summary Queries the states of Cloud Assistant plug-ins on Elastic Compute Service (ECS) instances.
        
        @description    Before you call this operation to query the status of Cloud Assistant plug-ins on ECS instances, make sure that the versions of Cloud Assistant Agent on the instances are not earlier than the following ones:
        2.2.3.344 for Linux instances
        2.1.3.344 for Windows instances
        During a paged query, when you call the ListPluginStatus operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the ListPluginStatus operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: ListPluginStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPluginStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPluginStatus',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ListPluginStatusResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_plugin_status_with_options_async(
        self,
        request: ecs_20140526_models.ListPluginStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ListPluginStatusResponse:
        """
        @summary Queries the states of Cloud Assistant plug-ins on Elastic Compute Service (ECS) instances.
        
        @description    Before you call this operation to query the status of Cloud Assistant plug-ins on ECS instances, make sure that the versions of Cloud Assistant Agent on the instances are not earlier than the following ones:
        2.2.3.344 for Linux instances
        2.1.3.344 for Windows instances
        During a paged query, when you call the ListPluginStatus operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the ListPluginStatus operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: ListPluginStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPluginStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPluginStatus',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ListPluginStatusResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_plugin_status(
        self,
        request: ecs_20140526_models.ListPluginStatusRequest,
    ) -> ecs_20140526_models.ListPluginStatusResponse:
        """
        @summary Queries the states of Cloud Assistant plug-ins on Elastic Compute Service (ECS) instances.
        
        @description    Before you call this operation to query the status of Cloud Assistant plug-ins on ECS instances, make sure that the versions of Cloud Assistant Agent on the instances are not earlier than the following ones:
        2.2.3.344 for Linux instances
        2.1.3.344 for Windows instances
        During a paged query, when you call the ListPluginStatus operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the ListPluginStatus operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: ListPluginStatusRequest
        @return: ListPluginStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_plugin_status_with_options(request, runtime)

    async def list_plugin_status_async(
        self,
        request: ecs_20140526_models.ListPluginStatusRequest,
    ) -> ecs_20140526_models.ListPluginStatusResponse:
        """
        @summary Queries the states of Cloud Assistant plug-ins on Elastic Compute Service (ECS) instances.
        
        @description    Before you call this operation to query the status of Cloud Assistant plug-ins on ECS instances, make sure that the versions of Cloud Assistant Agent on the instances are not earlier than the following ones:
        2.2.3.344 for Linux instances
        2.1.3.344 for Windows instances
        During a paged query, when you call the ListPluginStatus operation to retrieve the first page of results, set `MaxResults` to specify the maximum number of entries to return in the call. The return value of `NextToken` is a pagination token that can be used in the next call to retrieve a new page of results. When you call the ListPluginStatus operation to retrieve a new page of results, set `NextToken` to the `NextToken` value returned in the previous call and set `MaxResults` to specify the maximum number of entries to return in this call.
        
        @param request: ListPluginStatusRequest
        @return: ListPluginStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_plugin_status_with_options_async(request, runtime)

    def list_tag_resources_with_options(
        self,
        request: ecs_20140526_models.ListTagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ListTagResourcesResponse:
        """
        @summary Queries the tags that are added to one or more Elastic Compute Service (ECS) resources.
        
        @description ## [](#)Usage notes
        Specify at least one of the following parameters or parameter pairs in a request to determine a query object:
        `ResourceId.N`
        `Tag.N` parameter pair (`Tag.N.Key` and `Tag.N.Value`)
        `TagFilter.N`
        If one of the following sets of request parameters is specified as filter conditions, only ECS resources that meet all the specified filter conditions are returned:
        Set 1: `Tag.N.Key, Tag.N.Value` and `ResourceId.N`
        Set 2: `TagFilter.N.TagKey, TagFilter.N.TagValues.N` and `ResourceId.N`
        
        @param request: ListTagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.tag_filter):
            query['TagFilter'] = request.tag_filter
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTagResources',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ListTagResourcesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_tag_resources_with_options_async(
        self,
        request: ecs_20140526_models.ListTagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ListTagResourcesResponse:
        """
        @summary Queries the tags that are added to one or more Elastic Compute Service (ECS) resources.
        
        @description ## [](#)Usage notes
        Specify at least one of the following parameters or parameter pairs in a request to determine a query object:
        `ResourceId.N`
        `Tag.N` parameter pair (`Tag.N.Key` and `Tag.N.Value`)
        `TagFilter.N`
        If one of the following sets of request parameters is specified as filter conditions, only ECS resources that meet all the specified filter conditions are returned:
        Set 1: `Tag.N.Key, Tag.N.Value` and `ResourceId.N`
        Set 2: `TagFilter.N.TagKey, TagFilter.N.TagValues.N` and `ResourceId.N`
        
        @param request: ListTagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.tag_filter):
            query['TagFilter'] = request.tag_filter
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTagResources',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ListTagResourcesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_tag_resources(
        self,
        request: ecs_20140526_models.ListTagResourcesRequest,
    ) -> ecs_20140526_models.ListTagResourcesResponse:
        """
        @summary Queries the tags that are added to one or more Elastic Compute Service (ECS) resources.
        
        @description ## [](#)Usage notes
        Specify at least one of the following parameters or parameter pairs in a request to determine a query object:
        `ResourceId.N`
        `Tag.N` parameter pair (`Tag.N.Key` and `Tag.N.Value`)
        `TagFilter.N`
        If one of the following sets of request parameters is specified as filter conditions, only ECS resources that meet all the specified filter conditions are returned:
        Set 1: `Tag.N.Key, Tag.N.Value` and `ResourceId.N`
        Set 2: `TagFilter.N.TagKey, TagFilter.N.TagValues.N` and `ResourceId.N`
        
        @param request: ListTagResourcesRequest
        @return: ListTagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_tag_resources_with_options(request, runtime)

    async def list_tag_resources_async(
        self,
        request: ecs_20140526_models.ListTagResourcesRequest,
    ) -> ecs_20140526_models.ListTagResourcesResponse:
        """
        @summary Queries the tags that are added to one or more Elastic Compute Service (ECS) resources.
        
        @description ## [](#)Usage notes
        Specify at least one of the following parameters or parameter pairs in a request to determine a query object:
        `ResourceId.N`
        `Tag.N` parameter pair (`Tag.N.Key` and `Tag.N.Value`)
        `TagFilter.N`
        If one of the following sets of request parameters is specified as filter conditions, only ECS resources that meet all the specified filter conditions are returned:
        Set 1: `Tag.N.Key, Tag.N.Value` and `ResourceId.N`
        Set 2: `TagFilter.N.TagKey, TagFilter.N.TagValues.N` and `ResourceId.N`
        
        @param request: ListTagResourcesRequest
        @return: ListTagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_tag_resources_with_options_async(request, runtime)

    def modify_auto_provisioning_group_with_options(
        self,
        request: ecs_20140526_models.ModifyAutoProvisioningGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyAutoProvisioningGroupResponse:
        """
        @summary Modifies the configurations of an auto provisioning group.
        
        @description Before you call this operation, take note of the following items:
        If you modify the capacity or capacity-related settings of an auto-provisioning group, the group executes a scheduling task after the group is modified.
        You cannot modify an auto-provisioning group when the group is being deleted.
        
        @param request: ModifyAutoProvisioningGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyAutoProvisioningGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_provisioning_group_id):
            query['AutoProvisioningGroupId'] = request.auto_provisioning_group_id
        if not UtilClient.is_unset(request.auto_provisioning_group_name):
            query['AutoProvisioningGroupName'] = request.auto_provisioning_group_name
        if not UtilClient.is_unset(request.default_target_capacity_type):
            query['DefaultTargetCapacityType'] = request.default_target_capacity_type
        if not UtilClient.is_unset(request.excess_capacity_termination_policy):
            query['ExcessCapacityTerminationPolicy'] = request.excess_capacity_termination_policy
        if not UtilClient.is_unset(request.launch_template_config):
            query['LaunchTemplateConfig'] = request.launch_template_config
        if not UtilClient.is_unset(request.max_spot_price):
            query['MaxSpotPrice'] = request.max_spot_price
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pay_as_you_go_target_capacity):
            query['PayAsYouGoTargetCapacity'] = request.pay_as_you_go_target_capacity
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.spot_target_capacity):
            query['SpotTargetCapacity'] = request.spot_target_capacity
        if not UtilClient.is_unset(request.terminate_instances_with_expiration):
            query['TerminateInstancesWithExpiration'] = request.terminate_instances_with_expiration
        if not UtilClient.is_unset(request.total_target_capacity):
            query['TotalTargetCapacity'] = request.total_target_capacity
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyAutoProvisioningGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyAutoProvisioningGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_auto_provisioning_group_with_options_async(
        self,
        request: ecs_20140526_models.ModifyAutoProvisioningGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyAutoProvisioningGroupResponse:
        """
        @summary Modifies the configurations of an auto provisioning group.
        
        @description Before you call this operation, take note of the following items:
        If you modify the capacity or capacity-related settings of an auto-provisioning group, the group executes a scheduling task after the group is modified.
        You cannot modify an auto-provisioning group when the group is being deleted.
        
        @param request: ModifyAutoProvisioningGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyAutoProvisioningGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_provisioning_group_id):
            query['AutoProvisioningGroupId'] = request.auto_provisioning_group_id
        if not UtilClient.is_unset(request.auto_provisioning_group_name):
            query['AutoProvisioningGroupName'] = request.auto_provisioning_group_name
        if not UtilClient.is_unset(request.default_target_capacity_type):
            query['DefaultTargetCapacityType'] = request.default_target_capacity_type
        if not UtilClient.is_unset(request.excess_capacity_termination_policy):
            query['ExcessCapacityTerminationPolicy'] = request.excess_capacity_termination_policy
        if not UtilClient.is_unset(request.launch_template_config):
            query['LaunchTemplateConfig'] = request.launch_template_config
        if not UtilClient.is_unset(request.max_spot_price):
            query['MaxSpotPrice'] = request.max_spot_price
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pay_as_you_go_target_capacity):
            query['PayAsYouGoTargetCapacity'] = request.pay_as_you_go_target_capacity
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.spot_target_capacity):
            query['SpotTargetCapacity'] = request.spot_target_capacity
        if not UtilClient.is_unset(request.terminate_instances_with_expiration):
            query['TerminateInstancesWithExpiration'] = request.terminate_instances_with_expiration
        if not UtilClient.is_unset(request.total_target_capacity):
            query['TotalTargetCapacity'] = request.total_target_capacity
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyAutoProvisioningGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyAutoProvisioningGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_auto_provisioning_group(
        self,
        request: ecs_20140526_models.ModifyAutoProvisioningGroupRequest,
    ) -> ecs_20140526_models.ModifyAutoProvisioningGroupResponse:
        """
        @summary Modifies the configurations of an auto provisioning group.
        
        @description Before you call this operation, take note of the following items:
        If you modify the capacity or capacity-related settings of an auto-provisioning group, the group executes a scheduling task after the group is modified.
        You cannot modify an auto-provisioning group when the group is being deleted.
        
        @param request: ModifyAutoProvisioningGroupRequest
        @return: ModifyAutoProvisioningGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_auto_provisioning_group_with_options(request, runtime)

    async def modify_auto_provisioning_group_async(
        self,
        request: ecs_20140526_models.ModifyAutoProvisioningGroupRequest,
    ) -> ecs_20140526_models.ModifyAutoProvisioningGroupResponse:
        """
        @summary Modifies the configurations of an auto provisioning group.
        
        @description Before you call this operation, take note of the following items:
        If you modify the capacity or capacity-related settings of an auto-provisioning group, the group executes a scheduling task after the group is modified.
        You cannot modify an auto-provisioning group when the group is being deleted.
        
        @param request: ModifyAutoProvisioningGroupRequest
        @return: ModifyAutoProvisioningGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_auto_provisioning_group_with_options_async(request, runtime)

    def modify_auto_snapshot_policy_ex_with_options(
        self,
        request: ecs_20140526_models.ModifyAutoSnapshotPolicyExRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyAutoSnapshotPolicyExResponse:
        """
        @summary Modifies an automatic snapshot policy. For example, you can change the points in time of the day at which to create automatic snapshots, days of the week on which to create automatic snapshots, and retention period of automatic snapshots for the automatic snapshot policy.
        
        @description Before you call this operation, take note of the following items:
        You cannot modify system policies.
        After an automatic snapshot policy is modified, the modifications immediately take effect on the disks that are associated with the policy.
        If cross-region replication for snapshots is enabled and no encryption parameters are configured, the generated encrypted snapshot copies are encrypted by using the Key Management Service (KMS) encryption keys in the region to which the snapshots are copied.
        
        @param request: ModifyAutoSnapshotPolicyExRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyAutoSnapshotPolicyExResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.copied_snapshots_retention_days):
            query['CopiedSnapshotsRetentionDays'] = request.copied_snapshots_retention_days
        if not UtilClient.is_unset(request.copy_encryption_configuration):
            query['CopyEncryptionConfiguration'] = request.copy_encryption_configuration
        if not UtilClient.is_unset(request.enable_cross_region_copy):
            query['EnableCrossRegionCopy'] = request.enable_cross_region_copy
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.target_copy_regions):
            query['TargetCopyRegions'] = request.target_copy_regions
        if not UtilClient.is_unset(request.auto_snapshot_policy_id):
            query['autoSnapshotPolicyId'] = request.auto_snapshot_policy_id
        if not UtilClient.is_unset(request.auto_snapshot_policy_name):
            query['autoSnapshotPolicyName'] = request.auto_snapshot_policy_name
        if not UtilClient.is_unset(request.region_id):
            query['regionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_weekdays):
            query['repeatWeekdays'] = request.repeat_weekdays
        if not UtilClient.is_unset(request.retention_days):
            query['retentionDays'] = request.retention_days
        if not UtilClient.is_unset(request.time_points):
            query['timePoints'] = request.time_points
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyAutoSnapshotPolicyEx',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyAutoSnapshotPolicyExResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_auto_snapshot_policy_ex_with_options_async(
        self,
        request: ecs_20140526_models.ModifyAutoSnapshotPolicyExRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyAutoSnapshotPolicyExResponse:
        """
        @summary Modifies an automatic snapshot policy. For example, you can change the points in time of the day at which to create automatic snapshots, days of the week on which to create automatic snapshots, and retention period of automatic snapshots for the automatic snapshot policy.
        
        @description Before you call this operation, take note of the following items:
        You cannot modify system policies.
        After an automatic snapshot policy is modified, the modifications immediately take effect on the disks that are associated with the policy.
        If cross-region replication for snapshots is enabled and no encryption parameters are configured, the generated encrypted snapshot copies are encrypted by using the Key Management Service (KMS) encryption keys in the region to which the snapshots are copied.
        
        @param request: ModifyAutoSnapshotPolicyExRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyAutoSnapshotPolicyExResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.copied_snapshots_retention_days):
            query['CopiedSnapshotsRetentionDays'] = request.copied_snapshots_retention_days
        if not UtilClient.is_unset(request.copy_encryption_configuration):
            query['CopyEncryptionConfiguration'] = request.copy_encryption_configuration
        if not UtilClient.is_unset(request.enable_cross_region_copy):
            query['EnableCrossRegionCopy'] = request.enable_cross_region_copy
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.target_copy_regions):
            query['TargetCopyRegions'] = request.target_copy_regions
        if not UtilClient.is_unset(request.auto_snapshot_policy_id):
            query['autoSnapshotPolicyId'] = request.auto_snapshot_policy_id
        if not UtilClient.is_unset(request.auto_snapshot_policy_name):
            query['autoSnapshotPolicyName'] = request.auto_snapshot_policy_name
        if not UtilClient.is_unset(request.region_id):
            query['regionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_weekdays):
            query['repeatWeekdays'] = request.repeat_weekdays
        if not UtilClient.is_unset(request.retention_days):
            query['retentionDays'] = request.retention_days
        if not UtilClient.is_unset(request.time_points):
            query['timePoints'] = request.time_points
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyAutoSnapshotPolicyEx',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyAutoSnapshotPolicyExResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_auto_snapshot_policy_ex(
        self,
        request: ecs_20140526_models.ModifyAutoSnapshotPolicyExRequest,
    ) -> ecs_20140526_models.ModifyAutoSnapshotPolicyExResponse:
        """
        @summary Modifies an automatic snapshot policy. For example, you can change the points in time of the day at which to create automatic snapshots, days of the week on which to create automatic snapshots, and retention period of automatic snapshots for the automatic snapshot policy.
        
        @description Before you call this operation, take note of the following items:
        You cannot modify system policies.
        After an automatic snapshot policy is modified, the modifications immediately take effect on the disks that are associated with the policy.
        If cross-region replication for snapshots is enabled and no encryption parameters are configured, the generated encrypted snapshot copies are encrypted by using the Key Management Service (KMS) encryption keys in the region to which the snapshots are copied.
        
        @param request: ModifyAutoSnapshotPolicyExRequest
        @return: ModifyAutoSnapshotPolicyExResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_auto_snapshot_policy_ex_with_options(request, runtime)

    async def modify_auto_snapshot_policy_ex_async(
        self,
        request: ecs_20140526_models.ModifyAutoSnapshotPolicyExRequest,
    ) -> ecs_20140526_models.ModifyAutoSnapshotPolicyExResponse:
        """
        @summary Modifies an automatic snapshot policy. For example, you can change the points in time of the day at which to create automatic snapshots, days of the week on which to create automatic snapshots, and retention period of automatic snapshots for the automatic snapshot policy.
        
        @description Before you call this operation, take note of the following items:
        You cannot modify system policies.
        After an automatic snapshot policy is modified, the modifications immediately take effect on the disks that are associated with the policy.
        If cross-region replication for snapshots is enabled and no encryption parameters are configured, the generated encrypted snapshot copies are encrypted by using the Key Management Service (KMS) encryption keys in the region to which the snapshots are copied.
        
        @param request: ModifyAutoSnapshotPolicyExRequest
        @return: ModifyAutoSnapshotPolicyExResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_auto_snapshot_policy_ex_with_options_async(request, runtime)

    def modify_bandwidth_package_spec_with_options(
        self,
        request: ecs_20140526_models.ModifyBandwidthPackageSpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyBandwidthPackageSpecResponse:
        """
        @deprecated OpenAPI ModifyBandwidthPackageSpec is deprecated, please use Vpc::2016-04-28::ModifyBandwidthPackageSpec instead.
        
        @summary ModifyBandwidthPackageSpec
        
        @param request: ModifyBandwidthPackageSpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyBandwidthPackageSpecResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyBandwidthPackageSpec',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyBandwidthPackageSpecResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_bandwidth_package_spec_with_options_async(
        self,
        request: ecs_20140526_models.ModifyBandwidthPackageSpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyBandwidthPackageSpecResponse:
        """
        @deprecated OpenAPI ModifyBandwidthPackageSpec is deprecated, please use Vpc::2016-04-28::ModifyBandwidthPackageSpec instead.
        
        @summary ModifyBandwidthPackageSpec
        
        @param request: ModifyBandwidthPackageSpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyBandwidthPackageSpecResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyBandwidthPackageSpec',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyBandwidthPackageSpecResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_bandwidth_package_spec(
        self,
        request: ecs_20140526_models.ModifyBandwidthPackageSpecRequest,
    ) -> ecs_20140526_models.ModifyBandwidthPackageSpecResponse:
        """
        @deprecated OpenAPI ModifyBandwidthPackageSpec is deprecated, please use Vpc::2016-04-28::ModifyBandwidthPackageSpec instead.
        
        @summary ModifyBandwidthPackageSpec
        
        @param request: ModifyBandwidthPackageSpecRequest
        @return: ModifyBandwidthPackageSpecResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_bandwidth_package_spec_with_options(request, runtime)

    async def modify_bandwidth_package_spec_async(
        self,
        request: ecs_20140526_models.ModifyBandwidthPackageSpecRequest,
    ) -> ecs_20140526_models.ModifyBandwidthPackageSpecResponse:
        """
        @deprecated OpenAPI ModifyBandwidthPackageSpec is deprecated, please use Vpc::2016-04-28::ModifyBandwidthPackageSpec instead.
        
        @summary ModifyBandwidthPackageSpec
        
        @param request: ModifyBandwidthPackageSpecRequest
        @return: ModifyBandwidthPackageSpecResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_bandwidth_package_spec_with_options_async(request, runtime)

    def modify_capacity_reservation_with_options(
        self,
        request: ecs_20140526_models.ModifyCapacityReservationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyCapacityReservationResponse:
        """
        @summary Modifies the information of a capacity reservation, including the name, description, release mode, and the total number of Elastic Compute Service (ECS) instances for which capacity is reserved.
        
        @param request: ModifyCapacityReservationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCapacityReservationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.end_time_type):
            query['EndTimeType'] = request.end_time_type
        if not UtilClient.is_unset(request.instance_amount):
            query['InstanceAmount'] = request.instance_amount
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCapacityReservation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyCapacityReservationResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_capacity_reservation_with_options_async(
        self,
        request: ecs_20140526_models.ModifyCapacityReservationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyCapacityReservationResponse:
        """
        @summary Modifies the information of a capacity reservation, including the name, description, release mode, and the total number of Elastic Compute Service (ECS) instances for which capacity is reserved.
        
        @param request: ModifyCapacityReservationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCapacityReservationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.end_time_type):
            query['EndTimeType'] = request.end_time_type
        if not UtilClient.is_unset(request.instance_amount):
            query['InstanceAmount'] = request.instance_amount
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCapacityReservation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyCapacityReservationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_capacity_reservation(
        self,
        request: ecs_20140526_models.ModifyCapacityReservationRequest,
    ) -> ecs_20140526_models.ModifyCapacityReservationResponse:
        """
        @summary Modifies the information of a capacity reservation, including the name, description, release mode, and the total number of Elastic Compute Service (ECS) instances for which capacity is reserved.
        
        @param request: ModifyCapacityReservationRequest
        @return: ModifyCapacityReservationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_capacity_reservation_with_options(request, runtime)

    async def modify_capacity_reservation_async(
        self,
        request: ecs_20140526_models.ModifyCapacityReservationRequest,
    ) -> ecs_20140526_models.ModifyCapacityReservationResponse:
        """
        @summary Modifies the information of a capacity reservation, including the name, description, release mode, and the total number of Elastic Compute Service (ECS) instances for which capacity is reserved.
        
        @param request: ModifyCapacityReservationRequest
        @return: ModifyCapacityReservationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_capacity_reservation_with_options_async(request, runtime)

    def modify_cloud_assistant_settings_with_options(
        self,
        tmp_req: ecs_20140526_models.ModifyCloudAssistantSettingsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyCloudAssistantSettingsResponse:
        """
        @summary Modifies the configurations of a Cloud Assistant feature.
        
        @param tmp_req: ModifyCloudAssistantSettingsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCloudAssistantSettingsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = ecs_20140526_models.ModifyCloudAssistantSettingsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.agent_upgrade_config):
            request.agent_upgrade_config_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.agent_upgrade_config, 'AgentUpgradeConfig', 'json')
        if not UtilClient.is_unset(tmp_req.oss_delivery_config):
            request.oss_delivery_config_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.oss_delivery_config, 'OssDeliveryConfig', 'json')
        if not UtilClient.is_unset(tmp_req.session_manager_config):
            request.session_manager_config_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.session_manager_config, 'SessionManagerConfig', 'json')
        if not UtilClient.is_unset(tmp_req.sls_delivery_config):
            request.sls_delivery_config_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.sls_delivery_config, 'SlsDeliveryConfig', 'json')
        query = {}
        if not UtilClient.is_unset(request.agent_upgrade_config_shrink):
            query['AgentUpgradeConfig'] = request.agent_upgrade_config_shrink
        if not UtilClient.is_unset(request.oss_delivery_config_shrink):
            query['OssDeliveryConfig'] = request.oss_delivery_config_shrink
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.session_manager_config_shrink):
            query['SessionManagerConfig'] = request.session_manager_config_shrink
        if not UtilClient.is_unset(request.setting_type):
            query['SettingType'] = request.setting_type
        if not UtilClient.is_unset(request.sls_delivery_config_shrink):
            query['SlsDeliveryConfig'] = request.sls_delivery_config_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCloudAssistantSettings',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyCloudAssistantSettingsResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_cloud_assistant_settings_with_options_async(
        self,
        tmp_req: ecs_20140526_models.ModifyCloudAssistantSettingsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyCloudAssistantSettingsResponse:
        """
        @summary Modifies the configurations of a Cloud Assistant feature.
        
        @param tmp_req: ModifyCloudAssistantSettingsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCloudAssistantSettingsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = ecs_20140526_models.ModifyCloudAssistantSettingsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.agent_upgrade_config):
            request.agent_upgrade_config_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.agent_upgrade_config, 'AgentUpgradeConfig', 'json')
        if not UtilClient.is_unset(tmp_req.oss_delivery_config):
            request.oss_delivery_config_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.oss_delivery_config, 'OssDeliveryConfig', 'json')
        if not UtilClient.is_unset(tmp_req.session_manager_config):
            request.session_manager_config_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.session_manager_config, 'SessionManagerConfig', 'json')
        if not UtilClient.is_unset(tmp_req.sls_delivery_config):
            request.sls_delivery_config_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.sls_delivery_config, 'SlsDeliveryConfig', 'json')
        query = {}
        if not UtilClient.is_unset(request.agent_upgrade_config_shrink):
            query['AgentUpgradeConfig'] = request.agent_upgrade_config_shrink
        if not UtilClient.is_unset(request.oss_delivery_config_shrink):
            query['OssDeliveryConfig'] = request.oss_delivery_config_shrink
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.session_manager_config_shrink):
            query['SessionManagerConfig'] = request.session_manager_config_shrink
        if not UtilClient.is_unset(request.setting_type):
            query['SettingType'] = request.setting_type
        if not UtilClient.is_unset(request.sls_delivery_config_shrink):
            query['SlsDeliveryConfig'] = request.sls_delivery_config_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCloudAssistantSettings',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyCloudAssistantSettingsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_cloud_assistant_settings(
        self,
        request: ecs_20140526_models.ModifyCloudAssistantSettingsRequest,
    ) -> ecs_20140526_models.ModifyCloudAssistantSettingsResponse:
        """
        @summary Modifies the configurations of a Cloud Assistant feature.
        
        @param request: ModifyCloudAssistantSettingsRequest
        @return: ModifyCloudAssistantSettingsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_cloud_assistant_settings_with_options(request, runtime)

    async def modify_cloud_assistant_settings_async(
        self,
        request: ecs_20140526_models.ModifyCloudAssistantSettingsRequest,
    ) -> ecs_20140526_models.ModifyCloudAssistantSettingsResponse:
        """
        @summary Modifies the configurations of a Cloud Assistant feature.
        
        @param request: ModifyCloudAssistantSettingsRequest
        @return: ModifyCloudAssistantSettingsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_cloud_assistant_settings_with_options_async(request, runtime)

    def modify_command_with_options(
        self,
        request: ecs_20140526_models.ModifyCommandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyCommandResponse:
        """
        @summary Modifies the parameters of a Cloud Assistant command.
        
        @description You can modify a command when it is run. After the command is modified, the new command content applies to subsequent executions.
        You cannot modify the command type. For example, you cannot change a shell command (RunShellScript) to a batch command (RunBatScript).
        
        @param request: ModifyCommandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCommandResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.command_content):
            query['CommandContent'] = request.command_content
        if not UtilClient.is_unset(request.command_id):
            query['CommandId'] = request.command_id
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.launcher):
            query['Launcher'] = request.launcher
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.timeout):
            query['Timeout'] = request.timeout
        if not UtilClient.is_unset(request.working_dir):
            query['WorkingDir'] = request.working_dir
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCommand',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyCommandResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_command_with_options_async(
        self,
        request: ecs_20140526_models.ModifyCommandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyCommandResponse:
        """
        @summary Modifies the parameters of a Cloud Assistant command.
        
        @description You can modify a command when it is run. After the command is modified, the new command content applies to subsequent executions.
        You cannot modify the command type. For example, you cannot change a shell command (RunShellScript) to a batch command (RunBatScript).
        
        @param request: ModifyCommandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCommandResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.command_content):
            query['CommandContent'] = request.command_content
        if not UtilClient.is_unset(request.command_id):
            query['CommandId'] = request.command_id
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.launcher):
            query['Launcher'] = request.launcher
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.timeout):
            query['Timeout'] = request.timeout
        if not UtilClient.is_unset(request.working_dir):
            query['WorkingDir'] = request.working_dir
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCommand',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyCommandResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_command(
        self,
        request: ecs_20140526_models.ModifyCommandRequest,
    ) -> ecs_20140526_models.ModifyCommandResponse:
        """
        @summary Modifies the parameters of a Cloud Assistant command.
        
        @description You can modify a command when it is run. After the command is modified, the new command content applies to subsequent executions.
        You cannot modify the command type. For example, you cannot change a shell command (RunShellScript) to a batch command (RunBatScript).
        
        @param request: ModifyCommandRequest
        @return: ModifyCommandResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_command_with_options(request, runtime)

    async def modify_command_async(
        self,
        request: ecs_20140526_models.ModifyCommandRequest,
    ) -> ecs_20140526_models.ModifyCommandResponse:
        """
        @summary Modifies the parameters of a Cloud Assistant command.
        
        @description You can modify a command when it is run. After the command is modified, the new command content applies to subsequent executions.
        You cannot modify the command type. For example, you cannot change a shell command (RunShellScript) to a batch command (RunBatScript).
        
        @param request: ModifyCommandRequest
        @return: ModifyCommandResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_command_with_options_async(request, runtime)

    def modify_dedicated_host_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDedicatedHostAttributeResponse:
        """
        @summary Modifies the information about a dedicated host, such as the name, description, and instance migration policy that is applied when the dedicated host fails.
        
        @description ## [](#)Usage notes
        All Elastic Compute Service (ECS) instances that are hosted on a dedicated host must be in the Stopped (`Stopped`) state before you can modify the CPU overcommit ratio of the dedicated host.
        Changes to the CPU overcommit ratio of a dedicated host do not affect the running status of the dedicated host. After the CPU overcommit ratio is changed, the number of allocated vCPUs on the dedicated host cannot exceed the new total number of vCPUs. Otherwise, ECS instances that use the excess vCPUs cannot start.
        
        @param request: ModifyDedicatedHostAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDedicatedHostAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.action_on_maintenance):
            query['ActionOnMaintenance'] = request.action_on_maintenance
        if not UtilClient.is_unset(request.auto_placement):
            query['AutoPlacement'] = request.auto_placement
        if not UtilClient.is_unset(request.cpu_over_commit_ratio):
            query['CpuOverCommitRatio'] = request.cpu_over_commit_ratio
        if not UtilClient.is_unset(request.dedicated_host_cluster_id):
            query['DedicatedHostClusterId'] = request.dedicated_host_cluster_id
        if not UtilClient.is_unset(request.dedicated_host_id):
            query['DedicatedHostId'] = request.dedicated_host_id
        if not UtilClient.is_unset(request.dedicated_host_name):
            query['DedicatedHostName'] = request.dedicated_host_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.network_attributes):
            query['NetworkAttributes'] = request.network_attributes
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDedicatedHostAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDedicatedHostAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_dedicated_host_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDedicatedHostAttributeResponse:
        """
        @summary Modifies the information about a dedicated host, such as the name, description, and instance migration policy that is applied when the dedicated host fails.
        
        @description ## [](#)Usage notes
        All Elastic Compute Service (ECS) instances that are hosted on a dedicated host must be in the Stopped (`Stopped`) state before you can modify the CPU overcommit ratio of the dedicated host.
        Changes to the CPU overcommit ratio of a dedicated host do not affect the running status of the dedicated host. After the CPU overcommit ratio is changed, the number of allocated vCPUs on the dedicated host cannot exceed the new total number of vCPUs. Otherwise, ECS instances that use the excess vCPUs cannot start.
        
        @param request: ModifyDedicatedHostAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDedicatedHostAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.action_on_maintenance):
            query['ActionOnMaintenance'] = request.action_on_maintenance
        if not UtilClient.is_unset(request.auto_placement):
            query['AutoPlacement'] = request.auto_placement
        if not UtilClient.is_unset(request.cpu_over_commit_ratio):
            query['CpuOverCommitRatio'] = request.cpu_over_commit_ratio
        if not UtilClient.is_unset(request.dedicated_host_cluster_id):
            query['DedicatedHostClusterId'] = request.dedicated_host_cluster_id
        if not UtilClient.is_unset(request.dedicated_host_id):
            query['DedicatedHostId'] = request.dedicated_host_id
        if not UtilClient.is_unset(request.dedicated_host_name):
            query['DedicatedHostName'] = request.dedicated_host_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.network_attributes):
            query['NetworkAttributes'] = request.network_attributes
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDedicatedHostAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDedicatedHostAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_dedicated_host_attribute(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostAttributeRequest,
    ) -> ecs_20140526_models.ModifyDedicatedHostAttributeResponse:
        """
        @summary Modifies the information about a dedicated host, such as the name, description, and instance migration policy that is applied when the dedicated host fails.
        
        @description ## [](#)Usage notes
        All Elastic Compute Service (ECS) instances that are hosted on a dedicated host must be in the Stopped (`Stopped`) state before you can modify the CPU overcommit ratio of the dedicated host.
        Changes to the CPU overcommit ratio of a dedicated host do not affect the running status of the dedicated host. After the CPU overcommit ratio is changed, the number of allocated vCPUs on the dedicated host cannot exceed the new total number of vCPUs. Otherwise, ECS instances that use the excess vCPUs cannot start.
        
        @param request: ModifyDedicatedHostAttributeRequest
        @return: ModifyDedicatedHostAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_dedicated_host_attribute_with_options(request, runtime)

    async def modify_dedicated_host_attribute_async(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostAttributeRequest,
    ) -> ecs_20140526_models.ModifyDedicatedHostAttributeResponse:
        """
        @summary Modifies the information about a dedicated host, such as the name, description, and instance migration policy that is applied when the dedicated host fails.
        
        @description ## [](#)Usage notes
        All Elastic Compute Service (ECS) instances that are hosted on a dedicated host must be in the Stopped (`Stopped`) state before you can modify the CPU overcommit ratio of the dedicated host.
        Changes to the CPU overcommit ratio of a dedicated host do not affect the running status of the dedicated host. After the CPU overcommit ratio is changed, the number of allocated vCPUs on the dedicated host cannot exceed the new total number of vCPUs. Otherwise, ECS instances that use the excess vCPUs cannot start.
        
        @param request: ModifyDedicatedHostAttributeRequest
        @return: ModifyDedicatedHostAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_dedicated_host_attribute_with_options_async(request, runtime)

    def modify_dedicated_host_auto_release_time_with_options(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostAutoReleaseTimeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDedicatedHostAutoReleaseTimeResponse:
        """
        @summary Sets the automatic release time for a pay-as-you-go dedicated host or cancels its automatic release.
        
        @description ## Usage notes
        A pay-as-you-go dedicated host can be automatically released at the specified time. Before you release a pay-as-you-go dedicated host, make sure that the host is no longer required and all necessary application data is backed up.
        
        @param request: ModifyDedicatedHostAutoReleaseTimeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDedicatedHostAutoReleaseTimeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_release_time):
            query['AutoReleaseTime'] = request.auto_release_time
        if not UtilClient.is_unset(request.dedicated_host_id):
            query['DedicatedHostId'] = request.dedicated_host_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDedicatedHostAutoReleaseTime',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDedicatedHostAutoReleaseTimeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_dedicated_host_auto_release_time_with_options_async(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostAutoReleaseTimeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDedicatedHostAutoReleaseTimeResponse:
        """
        @summary Sets the automatic release time for a pay-as-you-go dedicated host or cancels its automatic release.
        
        @description ## Usage notes
        A pay-as-you-go dedicated host can be automatically released at the specified time. Before you release a pay-as-you-go dedicated host, make sure that the host is no longer required and all necessary application data is backed up.
        
        @param request: ModifyDedicatedHostAutoReleaseTimeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDedicatedHostAutoReleaseTimeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_release_time):
            query['AutoReleaseTime'] = request.auto_release_time
        if not UtilClient.is_unset(request.dedicated_host_id):
            query['DedicatedHostId'] = request.dedicated_host_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDedicatedHostAutoReleaseTime',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDedicatedHostAutoReleaseTimeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_dedicated_host_auto_release_time(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostAutoReleaseTimeRequest,
    ) -> ecs_20140526_models.ModifyDedicatedHostAutoReleaseTimeResponse:
        """
        @summary Sets the automatic release time for a pay-as-you-go dedicated host or cancels its automatic release.
        
        @description ## Usage notes
        A pay-as-you-go dedicated host can be automatically released at the specified time. Before you release a pay-as-you-go dedicated host, make sure that the host is no longer required and all necessary application data is backed up.
        
        @param request: ModifyDedicatedHostAutoReleaseTimeRequest
        @return: ModifyDedicatedHostAutoReleaseTimeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_dedicated_host_auto_release_time_with_options(request, runtime)

    async def modify_dedicated_host_auto_release_time_async(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostAutoReleaseTimeRequest,
    ) -> ecs_20140526_models.ModifyDedicatedHostAutoReleaseTimeResponse:
        """
        @summary Sets the automatic release time for a pay-as-you-go dedicated host or cancels its automatic release.
        
        @description ## Usage notes
        A pay-as-you-go dedicated host can be automatically released at the specified time. Before you release a pay-as-you-go dedicated host, make sure that the host is no longer required and all necessary application data is backed up.
        
        @param request: ModifyDedicatedHostAutoReleaseTimeRequest
        @return: ModifyDedicatedHostAutoReleaseTimeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_dedicated_host_auto_release_time_with_options_async(request, runtime)

    def modify_dedicated_host_auto_renew_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostAutoRenewAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDedicatedHostAutoRenewAttributeResponse:
        """
        @summary Enables or disables auto-renewal for one or more subscription dedicated hosts.
        
        @description    If you enable auto-renewal for your subscription dedicated host, the system attempts to deduct the renewal payment at 08:00:00 (UTC+8) nine days before the dedicated host expires to renew the dedicated host. If this deduction attempt fails, the system attempt to deduct the payment at the same point in time the next day. The system attempts to deduct the payment once every day until the dedicated host expires or until the payment is deducted. Make sure that your account balance is sufficient.
        Subscription dedicated hosts can be automatically renewed along with the subscription Elastic Compute Service (ECS) instances hosted on the dedicated hosts. For more information, see the description of the AutoRenewWithEcs parameter.
        
        @param request: ModifyDedicatedHostAutoRenewAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDedicatedHostAutoRenewAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_with_ecs):
            query['AutoRenewWithEcs'] = request.auto_renew_with_ecs
        if not UtilClient.is_unset(request.dedicated_host_ids):
            query['DedicatedHostIds'] = request.dedicated_host_ids
        if not UtilClient.is_unset(request.duration):
            query['Duration'] = request.duration
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.renewal_status):
            query['RenewalStatus'] = request.renewal_status
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDedicatedHostAutoRenewAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDedicatedHostAutoRenewAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_dedicated_host_auto_renew_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostAutoRenewAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDedicatedHostAutoRenewAttributeResponse:
        """
        @summary Enables or disables auto-renewal for one or more subscription dedicated hosts.
        
        @description    If you enable auto-renewal for your subscription dedicated host, the system attempts to deduct the renewal payment at 08:00:00 (UTC+8) nine days before the dedicated host expires to renew the dedicated host. If this deduction attempt fails, the system attempt to deduct the payment at the same point in time the next day. The system attempts to deduct the payment once every day until the dedicated host expires or until the payment is deducted. Make sure that your account balance is sufficient.
        Subscription dedicated hosts can be automatically renewed along with the subscription Elastic Compute Service (ECS) instances hosted on the dedicated hosts. For more information, see the description of the AutoRenewWithEcs parameter.
        
        @param request: ModifyDedicatedHostAutoRenewAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDedicatedHostAutoRenewAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_with_ecs):
            query['AutoRenewWithEcs'] = request.auto_renew_with_ecs
        if not UtilClient.is_unset(request.dedicated_host_ids):
            query['DedicatedHostIds'] = request.dedicated_host_ids
        if not UtilClient.is_unset(request.duration):
            query['Duration'] = request.duration
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.renewal_status):
            query['RenewalStatus'] = request.renewal_status
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDedicatedHostAutoRenewAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDedicatedHostAutoRenewAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_dedicated_host_auto_renew_attribute(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostAutoRenewAttributeRequest,
    ) -> ecs_20140526_models.ModifyDedicatedHostAutoRenewAttributeResponse:
        """
        @summary Enables or disables auto-renewal for one or more subscription dedicated hosts.
        
        @description    If you enable auto-renewal for your subscription dedicated host, the system attempts to deduct the renewal payment at 08:00:00 (UTC+8) nine days before the dedicated host expires to renew the dedicated host. If this deduction attempt fails, the system attempt to deduct the payment at the same point in time the next day. The system attempts to deduct the payment once every day until the dedicated host expires or until the payment is deducted. Make sure that your account balance is sufficient.
        Subscription dedicated hosts can be automatically renewed along with the subscription Elastic Compute Service (ECS) instances hosted on the dedicated hosts. For more information, see the description of the AutoRenewWithEcs parameter.
        
        @param request: ModifyDedicatedHostAutoRenewAttributeRequest
        @return: ModifyDedicatedHostAutoRenewAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_dedicated_host_auto_renew_attribute_with_options(request, runtime)

    async def modify_dedicated_host_auto_renew_attribute_async(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostAutoRenewAttributeRequest,
    ) -> ecs_20140526_models.ModifyDedicatedHostAutoRenewAttributeResponse:
        """
        @summary Enables or disables auto-renewal for one or more subscription dedicated hosts.
        
        @description    If you enable auto-renewal for your subscription dedicated host, the system attempts to deduct the renewal payment at 08:00:00 (UTC+8) nine days before the dedicated host expires to renew the dedicated host. If this deduction attempt fails, the system attempt to deduct the payment at the same point in time the next day. The system attempts to deduct the payment once every day until the dedicated host expires or until the payment is deducted. Make sure that your account balance is sufficient.
        Subscription dedicated hosts can be automatically renewed along with the subscription Elastic Compute Service (ECS) instances hosted on the dedicated hosts. For more information, see the description of the AutoRenewWithEcs parameter.
        
        @param request: ModifyDedicatedHostAutoRenewAttributeRequest
        @return: ModifyDedicatedHostAutoRenewAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_dedicated_host_auto_renew_attribute_with_options_async(request, runtime)

    def modify_dedicated_host_cluster_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostClusterAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDedicatedHostClusterAttributeResponse:
        """
        @summary Modifies the information of a dedicated host group, including the name, description, and properties.
        
        @param request: ModifyDedicatedHostClusterAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDedicatedHostClusterAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dedicated_host_cluster_id):
            query['DedicatedHostClusterId'] = request.dedicated_host_cluster_id
        if not UtilClient.is_unset(request.dedicated_host_cluster_name):
            query['DedicatedHostClusterName'] = request.dedicated_host_cluster_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDedicatedHostClusterAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDedicatedHostClusterAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_dedicated_host_cluster_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostClusterAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDedicatedHostClusterAttributeResponse:
        """
        @summary Modifies the information of a dedicated host group, including the name, description, and properties.
        
        @param request: ModifyDedicatedHostClusterAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDedicatedHostClusterAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dedicated_host_cluster_id):
            query['DedicatedHostClusterId'] = request.dedicated_host_cluster_id
        if not UtilClient.is_unset(request.dedicated_host_cluster_name):
            query['DedicatedHostClusterName'] = request.dedicated_host_cluster_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDedicatedHostClusterAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDedicatedHostClusterAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_dedicated_host_cluster_attribute(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostClusterAttributeRequest,
    ) -> ecs_20140526_models.ModifyDedicatedHostClusterAttributeResponse:
        """
        @summary Modifies the information of a dedicated host group, including the name, description, and properties.
        
        @param request: ModifyDedicatedHostClusterAttributeRequest
        @return: ModifyDedicatedHostClusterAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_dedicated_host_cluster_attribute_with_options(request, runtime)

    async def modify_dedicated_host_cluster_attribute_async(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostClusterAttributeRequest,
    ) -> ecs_20140526_models.ModifyDedicatedHostClusterAttributeResponse:
        """
        @summary Modifies the information of a dedicated host group, including the name, description, and properties.
        
        @param request: ModifyDedicatedHostClusterAttributeRequest
        @return: ModifyDedicatedHostClusterAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_dedicated_host_cluster_attribute_with_options_async(request, runtime)

    def modify_dedicated_hosts_charge_type_with_options(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostsChargeTypeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDedicatedHostsChargeTypeResponse:
        """
        @summary Changes the billing method of dedicated hosts.
        
        @param request: ModifyDedicatedHostsChargeTypeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDedicatedHostsChargeTypeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dedicated_host_charge_type):
            query['DedicatedHostChargeType'] = request.dedicated_host_charge_type
        if not UtilClient.is_unset(request.dedicated_host_ids):
            query['DedicatedHostIds'] = request.dedicated_host_ids
        if not UtilClient.is_unset(request.detail_fee):
            query['DetailFee'] = request.detail_fee
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDedicatedHostsChargeType',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDedicatedHostsChargeTypeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_dedicated_hosts_charge_type_with_options_async(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostsChargeTypeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDedicatedHostsChargeTypeResponse:
        """
        @summary Changes the billing method of dedicated hosts.
        
        @param request: ModifyDedicatedHostsChargeTypeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDedicatedHostsChargeTypeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dedicated_host_charge_type):
            query['DedicatedHostChargeType'] = request.dedicated_host_charge_type
        if not UtilClient.is_unset(request.dedicated_host_ids):
            query['DedicatedHostIds'] = request.dedicated_host_ids
        if not UtilClient.is_unset(request.detail_fee):
            query['DetailFee'] = request.detail_fee
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDedicatedHostsChargeType',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDedicatedHostsChargeTypeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_dedicated_hosts_charge_type(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostsChargeTypeRequest,
    ) -> ecs_20140526_models.ModifyDedicatedHostsChargeTypeResponse:
        """
        @summary Changes the billing method of dedicated hosts.
        
        @param request: ModifyDedicatedHostsChargeTypeRequest
        @return: ModifyDedicatedHostsChargeTypeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_dedicated_hosts_charge_type_with_options(request, runtime)

    async def modify_dedicated_hosts_charge_type_async(
        self,
        request: ecs_20140526_models.ModifyDedicatedHostsChargeTypeRequest,
    ) -> ecs_20140526_models.ModifyDedicatedHostsChargeTypeResponse:
        """
        @summary Changes the billing method of dedicated hosts.
        
        @param request: ModifyDedicatedHostsChargeTypeRequest
        @return: ModifyDedicatedHostsChargeTypeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_dedicated_hosts_charge_type_with_options_async(request, runtime)

    def modify_deployment_set_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyDeploymentSetAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDeploymentSetAttributeResponse:
        """
        @summary Modifies the name and description of a deployment set.
        
        @param request: ModifyDeploymentSetAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDeploymentSetAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.deployment_set_id):
            query['DeploymentSetId'] = request.deployment_set_id
        if not UtilClient.is_unset(request.deployment_set_name):
            query['DeploymentSetName'] = request.deployment_set_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDeploymentSetAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDeploymentSetAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_deployment_set_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyDeploymentSetAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDeploymentSetAttributeResponse:
        """
        @summary Modifies the name and description of a deployment set.
        
        @param request: ModifyDeploymentSetAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDeploymentSetAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.deployment_set_id):
            query['DeploymentSetId'] = request.deployment_set_id
        if not UtilClient.is_unset(request.deployment_set_name):
            query['DeploymentSetName'] = request.deployment_set_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDeploymentSetAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDeploymentSetAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_deployment_set_attribute(
        self,
        request: ecs_20140526_models.ModifyDeploymentSetAttributeRequest,
    ) -> ecs_20140526_models.ModifyDeploymentSetAttributeResponse:
        """
        @summary Modifies the name and description of a deployment set.
        
        @param request: ModifyDeploymentSetAttributeRequest
        @return: ModifyDeploymentSetAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_deployment_set_attribute_with_options(request, runtime)

    async def modify_deployment_set_attribute_async(
        self,
        request: ecs_20140526_models.ModifyDeploymentSetAttributeRequest,
    ) -> ecs_20140526_models.ModifyDeploymentSetAttributeResponse:
        """
        @summary Modifies the name and description of a deployment set.
        
        @param request: ModifyDeploymentSetAttributeRequest
        @return: ModifyDeploymentSetAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_deployment_set_attribute_with_options_async(request, runtime)

    def modify_diagnostic_metric_set_with_options(
        self,
        request: ecs_20140526_models.ModifyDiagnosticMetricSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDiagnosticMetricSetResponse:
        """
        @summary Modifies a diagnostic metric set.
        
        @param request: ModifyDiagnosticMetricSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDiagnosticMetricSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.metric_ids):
            query['MetricIds'] = request.metric_ids
        if not UtilClient.is_unset(request.metric_set_id):
            query['MetricSetId'] = request.metric_set_id
        if not UtilClient.is_unset(request.metric_set_name):
            query['MetricSetName'] = request.metric_set_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDiagnosticMetricSet',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDiagnosticMetricSetResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_diagnostic_metric_set_with_options_async(
        self,
        request: ecs_20140526_models.ModifyDiagnosticMetricSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDiagnosticMetricSetResponse:
        """
        @summary Modifies a diagnostic metric set.
        
        @param request: ModifyDiagnosticMetricSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDiagnosticMetricSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.metric_ids):
            query['MetricIds'] = request.metric_ids
        if not UtilClient.is_unset(request.metric_set_id):
            query['MetricSetId'] = request.metric_set_id
        if not UtilClient.is_unset(request.metric_set_name):
            query['MetricSetName'] = request.metric_set_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDiagnosticMetricSet',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDiagnosticMetricSetResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_diagnostic_metric_set(
        self,
        request: ecs_20140526_models.ModifyDiagnosticMetricSetRequest,
    ) -> ecs_20140526_models.ModifyDiagnosticMetricSetResponse:
        """
        @summary Modifies a diagnostic metric set.
        
        @param request: ModifyDiagnosticMetricSetRequest
        @return: ModifyDiagnosticMetricSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_diagnostic_metric_set_with_options(request, runtime)

    async def modify_diagnostic_metric_set_async(
        self,
        request: ecs_20140526_models.ModifyDiagnosticMetricSetRequest,
    ) -> ecs_20140526_models.ModifyDiagnosticMetricSetResponse:
        """
        @summary Modifies a diagnostic metric set.
        
        @param request: ModifyDiagnosticMetricSetRequest
        @return: ModifyDiagnosticMetricSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_diagnostic_metric_set_with_options_async(request, runtime)

    def modify_disk_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyDiskAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDiskAttributeResponse:
        """
        @summary Modifies the name, description, release behavior with ECS instance, snapshot deletion on disk removal, automatic snapshot policy feature, and performance burst feature for one or more block storage devices.
        
        @description You can use `DiskId` to specify a block storage device and modify the attributes of the device, such as the name and description of the device and whether to release the device together with the associated instance. You can use `DiskIds.N` to specify multiple block storage devices and batch modify the attributes of the devices.
        
        @param request: ModifyDiskAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDiskAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bursting_enabled):
            query['BurstingEnabled'] = request.bursting_enabled
        if not UtilClient.is_unset(request.delete_auto_snapshot):
            query['DeleteAutoSnapshot'] = request.delete_auto_snapshot
        if not UtilClient.is_unset(request.delete_with_instance):
            query['DeleteWithInstance'] = request.delete_with_instance
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.disk_ids):
            query['DiskIds'] = request.disk_ids
        if not UtilClient.is_unset(request.disk_name):
            query['DiskName'] = request.disk_name
        if not UtilClient.is_unset(request.enable_auto_snapshot):
            query['EnableAutoSnapshot'] = request.enable_auto_snapshot
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDiskAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDiskAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_disk_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyDiskAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDiskAttributeResponse:
        """
        @summary Modifies the name, description, release behavior with ECS instance, snapshot deletion on disk removal, automatic snapshot policy feature, and performance burst feature for one or more block storage devices.
        
        @description You can use `DiskId` to specify a block storage device and modify the attributes of the device, such as the name and description of the device and whether to release the device together with the associated instance. You can use `DiskIds.N` to specify multiple block storage devices and batch modify the attributes of the devices.
        
        @param request: ModifyDiskAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDiskAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bursting_enabled):
            query['BurstingEnabled'] = request.bursting_enabled
        if not UtilClient.is_unset(request.delete_auto_snapshot):
            query['DeleteAutoSnapshot'] = request.delete_auto_snapshot
        if not UtilClient.is_unset(request.delete_with_instance):
            query['DeleteWithInstance'] = request.delete_with_instance
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.disk_ids):
            query['DiskIds'] = request.disk_ids
        if not UtilClient.is_unset(request.disk_name):
            query['DiskName'] = request.disk_name
        if not UtilClient.is_unset(request.enable_auto_snapshot):
            query['EnableAutoSnapshot'] = request.enable_auto_snapshot
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDiskAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDiskAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_disk_attribute(
        self,
        request: ecs_20140526_models.ModifyDiskAttributeRequest,
    ) -> ecs_20140526_models.ModifyDiskAttributeResponse:
        """
        @summary Modifies the name, description, release behavior with ECS instance, snapshot deletion on disk removal, automatic snapshot policy feature, and performance burst feature for one or more block storage devices.
        
        @description You can use `DiskId` to specify a block storage device and modify the attributes of the device, such as the name and description of the device and whether to release the device together with the associated instance. You can use `DiskIds.N` to specify multiple block storage devices and batch modify the attributes of the devices.
        
        @param request: ModifyDiskAttributeRequest
        @return: ModifyDiskAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_disk_attribute_with_options(request, runtime)

    async def modify_disk_attribute_async(
        self,
        request: ecs_20140526_models.ModifyDiskAttributeRequest,
    ) -> ecs_20140526_models.ModifyDiskAttributeResponse:
        """
        @summary Modifies the name, description, release behavior with ECS instance, snapshot deletion on disk removal, automatic snapshot policy feature, and performance burst feature for one or more block storage devices.
        
        @description You can use `DiskId` to specify a block storage device and modify the attributes of the device, such as the name and description of the device and whether to release the device together with the associated instance. You can use `DiskIds.N` to specify multiple block storage devices and batch modify the attributes of the devices.
        
        @param request: ModifyDiskAttributeRequest
        @return: ModifyDiskAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_disk_attribute_with_options_async(request, runtime)

    def modify_disk_charge_type_with_options(
        self,
        request: ecs_20140526_models.ModifyDiskChargeTypeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDiskChargeTypeResponse:
        """
        @summary Converts the billing method of a data disk attached to a subscription ECS instance between pay-as-you-go and subscription.
        
        @description For information about how to change the billing method of cloud disks, see [Change the billing methods of a disk](https://help.aliyun.com/document_detail/145018.html).
        Take note of the following items:
        Only pay-as-you-go disks can be attached to pay-as-you-go instances, and the billing methods of the disks cannot be changed.
        The instance to which data disks are attached cannot be in the Stopped state due to expiration.
        The price difference is refunded to the payment account that you used. Vouchers that have been redeemed are nonrefundable.
        You cannot change the billing method again within 5 minutes of a successful change.
        After you change the billing method, the payment (if any) is automatically completed. Maintain sufficient balance in your account. Otherwise, your order becomes invalid and must be canceled. If your account balance is insufficient, you can set AutoPay to false to generate an unpaid order. Then, log on to the *Expenses and Costs console**, go to the [Orders page](https://usercenter2-intl.aliyun.com/order/list), and pay for the order.
        
        @param request: ModifyDiskChargeTypeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDiskChargeTypeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.disk_charge_type):
            query['DiskChargeType'] = request.disk_charge_type
        if not UtilClient.is_unset(request.disk_ids):
            query['DiskIds'] = request.disk_ids
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDiskChargeType',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDiskChargeTypeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_disk_charge_type_with_options_async(
        self,
        request: ecs_20140526_models.ModifyDiskChargeTypeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDiskChargeTypeResponse:
        """
        @summary Converts the billing method of a data disk attached to a subscription ECS instance between pay-as-you-go and subscription.
        
        @description For information about how to change the billing method of cloud disks, see [Change the billing methods of a disk](https://help.aliyun.com/document_detail/145018.html).
        Take note of the following items:
        Only pay-as-you-go disks can be attached to pay-as-you-go instances, and the billing methods of the disks cannot be changed.
        The instance to which data disks are attached cannot be in the Stopped state due to expiration.
        The price difference is refunded to the payment account that you used. Vouchers that have been redeemed are nonrefundable.
        You cannot change the billing method again within 5 minutes of a successful change.
        After you change the billing method, the payment (if any) is automatically completed. Maintain sufficient balance in your account. Otherwise, your order becomes invalid and must be canceled. If your account balance is insufficient, you can set AutoPay to false to generate an unpaid order. Then, log on to the *Expenses and Costs console**, go to the [Orders page](https://usercenter2-intl.aliyun.com/order/list), and pay for the order.
        
        @param request: ModifyDiskChargeTypeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDiskChargeTypeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.disk_charge_type):
            query['DiskChargeType'] = request.disk_charge_type
        if not UtilClient.is_unset(request.disk_ids):
            query['DiskIds'] = request.disk_ids
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDiskChargeType',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDiskChargeTypeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_disk_charge_type(
        self,
        request: ecs_20140526_models.ModifyDiskChargeTypeRequest,
    ) -> ecs_20140526_models.ModifyDiskChargeTypeResponse:
        """
        @summary Converts the billing method of a data disk attached to a subscription ECS instance between pay-as-you-go and subscription.
        
        @description For information about how to change the billing method of cloud disks, see [Change the billing methods of a disk](https://help.aliyun.com/document_detail/145018.html).
        Take note of the following items:
        Only pay-as-you-go disks can be attached to pay-as-you-go instances, and the billing methods of the disks cannot be changed.
        The instance to which data disks are attached cannot be in the Stopped state due to expiration.
        The price difference is refunded to the payment account that you used. Vouchers that have been redeemed are nonrefundable.
        You cannot change the billing method again within 5 minutes of a successful change.
        After you change the billing method, the payment (if any) is automatically completed. Maintain sufficient balance in your account. Otherwise, your order becomes invalid and must be canceled. If your account balance is insufficient, you can set AutoPay to false to generate an unpaid order. Then, log on to the *Expenses and Costs console**, go to the [Orders page](https://usercenter2-intl.aliyun.com/order/list), and pay for the order.
        
        @param request: ModifyDiskChargeTypeRequest
        @return: ModifyDiskChargeTypeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_disk_charge_type_with_options(request, runtime)

    async def modify_disk_charge_type_async(
        self,
        request: ecs_20140526_models.ModifyDiskChargeTypeRequest,
    ) -> ecs_20140526_models.ModifyDiskChargeTypeResponse:
        """
        @summary Converts the billing method of a data disk attached to a subscription ECS instance between pay-as-you-go and subscription.
        
        @description For information about how to change the billing method of cloud disks, see [Change the billing methods of a disk](https://help.aliyun.com/document_detail/145018.html).
        Take note of the following items:
        Only pay-as-you-go disks can be attached to pay-as-you-go instances, and the billing methods of the disks cannot be changed.
        The instance to which data disks are attached cannot be in the Stopped state due to expiration.
        The price difference is refunded to the payment account that you used. Vouchers that have been redeemed are nonrefundable.
        You cannot change the billing method again within 5 minutes of a successful change.
        After you change the billing method, the payment (if any) is automatically completed. Maintain sufficient balance in your account. Otherwise, your order becomes invalid and must be canceled. If your account balance is insufficient, you can set AutoPay to false to generate an unpaid order. Then, log on to the *Expenses and Costs console**, go to the [Orders page](https://usercenter2-intl.aliyun.com/order/list), and pay for the order.
        
        @param request: ModifyDiskChargeTypeRequest
        @return: ModifyDiskChargeTypeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_disk_charge_type_with_options_async(request, runtime)

    def modify_disk_default_kmskey_id_with_options(
        self,
        request: ecs_20140526_models.ModifyDiskDefaultKMSKeyIdRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDiskDefaultKMSKeyIdResponse:
        """
        @summary Changes the Key Management Service (KMS) key used by the Account-level Elastic Block Storage (EBS) Default Encryption feature in a region.
        
        @description    To call this operation as a Resource Access Management (RAM) user, grant the `AliyunECSFullAccess` permission to the RAM user. For more information, see [Grant permissions to a RAM user](https://help.aliyun.com/document_detail/116146.html).
        Before you can call this operation in a region, make sure that the Account-level EBS Default Encryption feature is enabled in the region.
        The first time you use a customer master key (CMK), you must use the `AliyunECSDiskEncryptDefaultRole` role to grant Elastic Compute Service (ECS) access to KMS resources. For more information, see [Grant access to KMS keys through RAM roles](https://help.aliyun.com/document_detail/2838993.html).
        
        @param request: ModifyDiskDefaultKMSKeyIdRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDiskDefaultKMSKeyIdResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.kmskey_id):
            query['KMSKeyId'] = request.kmskey_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDiskDefaultKMSKeyId',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDiskDefaultKMSKeyIdResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_disk_default_kmskey_id_with_options_async(
        self,
        request: ecs_20140526_models.ModifyDiskDefaultKMSKeyIdRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDiskDefaultKMSKeyIdResponse:
        """
        @summary Changes the Key Management Service (KMS) key used by the Account-level Elastic Block Storage (EBS) Default Encryption feature in a region.
        
        @description    To call this operation as a Resource Access Management (RAM) user, grant the `AliyunECSFullAccess` permission to the RAM user. For more information, see [Grant permissions to a RAM user](https://help.aliyun.com/document_detail/116146.html).
        Before you can call this operation in a region, make sure that the Account-level EBS Default Encryption feature is enabled in the region.
        The first time you use a customer master key (CMK), you must use the `AliyunECSDiskEncryptDefaultRole` role to grant Elastic Compute Service (ECS) access to KMS resources. For more information, see [Grant access to KMS keys through RAM roles](https://help.aliyun.com/document_detail/2838993.html).
        
        @param request: ModifyDiskDefaultKMSKeyIdRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDiskDefaultKMSKeyIdResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.kmskey_id):
            query['KMSKeyId'] = request.kmskey_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDiskDefaultKMSKeyId',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDiskDefaultKMSKeyIdResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_disk_default_kmskey_id(
        self,
        request: ecs_20140526_models.ModifyDiskDefaultKMSKeyIdRequest,
    ) -> ecs_20140526_models.ModifyDiskDefaultKMSKeyIdResponse:
        """
        @summary Changes the Key Management Service (KMS) key used by the Account-level Elastic Block Storage (EBS) Default Encryption feature in a region.
        
        @description    To call this operation as a Resource Access Management (RAM) user, grant the `AliyunECSFullAccess` permission to the RAM user. For more information, see [Grant permissions to a RAM user](https://help.aliyun.com/document_detail/116146.html).
        Before you can call this operation in a region, make sure that the Account-level EBS Default Encryption feature is enabled in the region.
        The first time you use a customer master key (CMK), you must use the `AliyunECSDiskEncryptDefaultRole` role to grant Elastic Compute Service (ECS) access to KMS resources. For more information, see [Grant access to KMS keys through RAM roles](https://help.aliyun.com/document_detail/2838993.html).
        
        @param request: ModifyDiskDefaultKMSKeyIdRequest
        @return: ModifyDiskDefaultKMSKeyIdResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_disk_default_kmskey_id_with_options(request, runtime)

    async def modify_disk_default_kmskey_id_async(
        self,
        request: ecs_20140526_models.ModifyDiskDefaultKMSKeyIdRequest,
    ) -> ecs_20140526_models.ModifyDiskDefaultKMSKeyIdResponse:
        """
        @summary Changes the Key Management Service (KMS) key used by the Account-level Elastic Block Storage (EBS) Default Encryption feature in a region.
        
        @description    To call this operation as a Resource Access Management (RAM) user, grant the `AliyunECSFullAccess` permission to the RAM user. For more information, see [Grant permissions to a RAM user](https://help.aliyun.com/document_detail/116146.html).
        Before you can call this operation in a region, make sure that the Account-level EBS Default Encryption feature is enabled in the region.
        The first time you use a customer master key (CMK), you must use the `AliyunECSDiskEncryptDefaultRole` role to grant Elastic Compute Service (ECS) access to KMS resources. For more information, see [Grant access to KMS keys through RAM roles](https://help.aliyun.com/document_detail/2838993.html).
        
        @param request: ModifyDiskDefaultKMSKeyIdRequest
        @return: ModifyDiskDefaultKMSKeyIdResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_disk_default_kmskey_id_with_options_async(request, runtime)

    def modify_disk_deployment_with_options(
        self,
        request: ecs_20140526_models.ModifyDiskDeploymentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDiskDeploymentResponse:
        """
        @summary Migrates disks to or from a dedicated block storage cluster, or migrates disks between different dedicated block storage clusters.
        
        @description >  The Dedicated Block Storage Cluster feature is available in the following regions: China (Hangzhou), China (Shanghai), China (Beijing), China (Zhangjiakou), China (Ulanqab), China (Shenzhen), China (Heyuan), Indonesia (Jakarta), Germany (Frankfurt), and China South 1 Finance.
        Before you call the ModifyDiskDeployment operation, make sure that you fully understand the billing methods and prices of disks and dedicated block storage clusters. In addition, make sure that the dedicated block storage clusters are unexpired and your account has no overdue payments. For more information, see [Dedicated block storage cluster](https://help.aliyun.com/document_detail/208883.html) and [Block storage devices](https://help.aliyun.com/document_detail/179022.html).
        Take note of the following items:
        The disks and a dedicated block storage cluster to which you want to migrate the disk must be in the same zone.
        You can migrate only pay-as-you-go disks. If you want to migrate subscription disks, change the disks to pay-as-you-go disks first. For more information, see [Change the billing method of a disk](https://help.aliyun.com/document_detail/145018.html).
        The specifications of disks that you want to migrate to a destination block storage cluster must the same as the disk specifications that the destination dedicated block storage cluster supports. During migration, you can change the specifications of the disks to ensure specification consistency.
        The disk must be in the **In Use** (In_Use) or **Available** (Available) state.
        If the disk is attached to an Elastic Compute Service (ECS) instance, the instance must be in the **Running** (Running) or **Stopped** (Stopped) state. The ECS instance cannot be in the Expired state.
        The performance level of an Enterprise SSD (ESSD) is limited by the ESSD disk size. If you cannot upgrade the performance level of an ESSD, extend the ESSD and try again. For more information, see [ResizeDisk](https://help.aliyun.com/document_detail/25522.html) and [ESSDs](https://help.aliyun.com/document_detail/122389.html).
        An account can perform up to five disk migration tasks in the same region at the same time.
        When a disk is being migrated, you cannot cancel the migration task, create snapshots for the disk, change the disk configurations, resize the disk, mount the disk, unmount the disk, or re-initialize the disk.
        >  After you migrate a disk to a destination cluster by calling the ModifyDiskDeployment operation, the billing method, disk specifications, and capabilities of the destination cluster take effect immediately on the disk. Alibaba Cloud charges the disk based on the disk category and performance level. For more information, see [Dedicated block storage cluster](https://help.aliyun.com/document_detail/208883.html) and [Block storage devices](https://help.aliyun.com/document_detail/179022.html).
        
        @param request: ModifyDiskDeploymentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDiskDeploymentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.disk_category):
            query['DiskCategory'] = request.disk_category
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.performance_level):
            query['PerformanceLevel'] = request.performance_level
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_cluster_id):
            query['StorageClusterId'] = request.storage_cluster_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDiskDeployment',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDiskDeploymentResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_disk_deployment_with_options_async(
        self,
        request: ecs_20140526_models.ModifyDiskDeploymentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDiskDeploymentResponse:
        """
        @summary Migrates disks to or from a dedicated block storage cluster, or migrates disks between different dedicated block storage clusters.
        
        @description >  The Dedicated Block Storage Cluster feature is available in the following regions: China (Hangzhou), China (Shanghai), China (Beijing), China (Zhangjiakou), China (Ulanqab), China (Shenzhen), China (Heyuan), Indonesia (Jakarta), Germany (Frankfurt), and China South 1 Finance.
        Before you call the ModifyDiskDeployment operation, make sure that you fully understand the billing methods and prices of disks and dedicated block storage clusters. In addition, make sure that the dedicated block storage clusters are unexpired and your account has no overdue payments. For more information, see [Dedicated block storage cluster](https://help.aliyun.com/document_detail/208883.html) and [Block storage devices](https://help.aliyun.com/document_detail/179022.html).
        Take note of the following items:
        The disks and a dedicated block storage cluster to which you want to migrate the disk must be in the same zone.
        You can migrate only pay-as-you-go disks. If you want to migrate subscription disks, change the disks to pay-as-you-go disks first. For more information, see [Change the billing method of a disk](https://help.aliyun.com/document_detail/145018.html).
        The specifications of disks that you want to migrate to a destination block storage cluster must the same as the disk specifications that the destination dedicated block storage cluster supports. During migration, you can change the specifications of the disks to ensure specification consistency.
        The disk must be in the **In Use** (In_Use) or **Available** (Available) state.
        If the disk is attached to an Elastic Compute Service (ECS) instance, the instance must be in the **Running** (Running) or **Stopped** (Stopped) state. The ECS instance cannot be in the Expired state.
        The performance level of an Enterprise SSD (ESSD) is limited by the ESSD disk size. If you cannot upgrade the performance level of an ESSD, extend the ESSD and try again. For more information, see [ResizeDisk](https://help.aliyun.com/document_detail/25522.html) and [ESSDs](https://help.aliyun.com/document_detail/122389.html).
        An account can perform up to five disk migration tasks in the same region at the same time.
        When a disk is being migrated, you cannot cancel the migration task, create snapshots for the disk, change the disk configurations, resize the disk, mount the disk, unmount the disk, or re-initialize the disk.
        >  After you migrate a disk to a destination cluster by calling the ModifyDiskDeployment operation, the billing method, disk specifications, and capabilities of the destination cluster take effect immediately on the disk. Alibaba Cloud charges the disk based on the disk category and performance level. For more information, see [Dedicated block storage cluster](https://help.aliyun.com/document_detail/208883.html) and [Block storage devices](https://help.aliyun.com/document_detail/179022.html).
        
        @param request: ModifyDiskDeploymentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDiskDeploymentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.disk_category):
            query['DiskCategory'] = request.disk_category
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.performance_level):
            query['PerformanceLevel'] = request.performance_level
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_cluster_id):
            query['StorageClusterId'] = request.storage_cluster_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDiskDeployment',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDiskDeploymentResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_disk_deployment(
        self,
        request: ecs_20140526_models.ModifyDiskDeploymentRequest,
    ) -> ecs_20140526_models.ModifyDiskDeploymentResponse:
        """
        @summary Migrates disks to or from a dedicated block storage cluster, or migrates disks between different dedicated block storage clusters.
        
        @description >  The Dedicated Block Storage Cluster feature is available in the following regions: China (Hangzhou), China (Shanghai), China (Beijing), China (Zhangjiakou), China (Ulanqab), China (Shenzhen), China (Heyuan), Indonesia (Jakarta), Germany (Frankfurt), and China South 1 Finance.
        Before you call the ModifyDiskDeployment operation, make sure that you fully understand the billing methods and prices of disks and dedicated block storage clusters. In addition, make sure that the dedicated block storage clusters are unexpired and your account has no overdue payments. For more information, see [Dedicated block storage cluster](https://help.aliyun.com/document_detail/208883.html) and [Block storage devices](https://help.aliyun.com/document_detail/179022.html).
        Take note of the following items:
        The disks and a dedicated block storage cluster to which you want to migrate the disk must be in the same zone.
        You can migrate only pay-as-you-go disks. If you want to migrate subscription disks, change the disks to pay-as-you-go disks first. For more information, see [Change the billing method of a disk](https://help.aliyun.com/document_detail/145018.html).
        The specifications of disks that you want to migrate to a destination block storage cluster must the same as the disk specifications that the destination dedicated block storage cluster supports. During migration, you can change the specifications of the disks to ensure specification consistency.
        The disk must be in the **In Use** (In_Use) or **Available** (Available) state.
        If the disk is attached to an Elastic Compute Service (ECS) instance, the instance must be in the **Running** (Running) or **Stopped** (Stopped) state. The ECS instance cannot be in the Expired state.
        The performance level of an Enterprise SSD (ESSD) is limited by the ESSD disk size. If you cannot upgrade the performance level of an ESSD, extend the ESSD and try again. For more information, see [ResizeDisk](https://help.aliyun.com/document_detail/25522.html) and [ESSDs](https://help.aliyun.com/document_detail/122389.html).
        An account can perform up to five disk migration tasks in the same region at the same time.
        When a disk is being migrated, you cannot cancel the migration task, create snapshots for the disk, change the disk configurations, resize the disk, mount the disk, unmount the disk, or re-initialize the disk.
        >  After you migrate a disk to a destination cluster by calling the ModifyDiskDeployment operation, the billing method, disk specifications, and capabilities of the destination cluster take effect immediately on the disk. Alibaba Cloud charges the disk based on the disk category and performance level. For more information, see [Dedicated block storage cluster](https://help.aliyun.com/document_detail/208883.html) and [Block storage devices](https://help.aliyun.com/document_detail/179022.html).
        
        @param request: ModifyDiskDeploymentRequest
        @return: ModifyDiskDeploymentResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_disk_deployment_with_options(request, runtime)

    async def modify_disk_deployment_async(
        self,
        request: ecs_20140526_models.ModifyDiskDeploymentRequest,
    ) -> ecs_20140526_models.ModifyDiskDeploymentResponse:
        """
        @summary Migrates disks to or from a dedicated block storage cluster, or migrates disks between different dedicated block storage clusters.
        
        @description >  The Dedicated Block Storage Cluster feature is available in the following regions: China (Hangzhou), China (Shanghai), China (Beijing), China (Zhangjiakou), China (Ulanqab), China (Shenzhen), China (Heyuan), Indonesia (Jakarta), Germany (Frankfurt), and China South 1 Finance.
        Before you call the ModifyDiskDeployment operation, make sure that you fully understand the billing methods and prices of disks and dedicated block storage clusters. In addition, make sure that the dedicated block storage clusters are unexpired and your account has no overdue payments. For more information, see [Dedicated block storage cluster](https://help.aliyun.com/document_detail/208883.html) and [Block storage devices](https://help.aliyun.com/document_detail/179022.html).
        Take note of the following items:
        The disks and a dedicated block storage cluster to which you want to migrate the disk must be in the same zone.
        You can migrate only pay-as-you-go disks. If you want to migrate subscription disks, change the disks to pay-as-you-go disks first. For more information, see [Change the billing method of a disk](https://help.aliyun.com/document_detail/145018.html).
        The specifications of disks that you want to migrate to a destination block storage cluster must the same as the disk specifications that the destination dedicated block storage cluster supports. During migration, you can change the specifications of the disks to ensure specification consistency.
        The disk must be in the **In Use** (In_Use) or **Available** (Available) state.
        If the disk is attached to an Elastic Compute Service (ECS) instance, the instance must be in the **Running** (Running) or **Stopped** (Stopped) state. The ECS instance cannot be in the Expired state.
        The performance level of an Enterprise SSD (ESSD) is limited by the ESSD disk size. If you cannot upgrade the performance level of an ESSD, extend the ESSD and try again. For more information, see [ResizeDisk](https://help.aliyun.com/document_detail/25522.html) and [ESSDs](https://help.aliyun.com/document_detail/122389.html).
        An account can perform up to five disk migration tasks in the same region at the same time.
        When a disk is being migrated, you cannot cancel the migration task, create snapshots for the disk, change the disk configurations, resize the disk, mount the disk, unmount the disk, or re-initialize the disk.
        >  After you migrate a disk to a destination cluster by calling the ModifyDiskDeployment operation, the billing method, disk specifications, and capabilities of the destination cluster take effect immediately on the disk. Alibaba Cloud charges the disk based on the disk category and performance level. For more information, see [Dedicated block storage cluster](https://help.aliyun.com/document_detail/208883.html) and [Block storage devices](https://help.aliyun.com/document_detail/179022.html).
        
        @param request: ModifyDiskDeploymentRequest
        @return: ModifyDiskDeploymentResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_disk_deployment_with_options_async(request, runtime)

    def modify_disk_spec_with_options(
        self,
        request: ecs_20140526_models.ModifyDiskSpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDiskSpecResponse:
        """
        @summary Changes the disk category of a cloud disk or the performance level of an Enterprise SSD (ESSD). You cannot change the disk categories of Regional ESSDs, basic disks, elastic ephemeral disks, and local disks.
        
        @description To minimize impacts on your business, change the disk categories or performance levels of cloud disks during off-peak hours.
        Take note of the following items:
        To change the performance level of an ESSD, take note of the following items:
        If the ESSD is a subscription ESSD, you can only upgrade its performance level.
        If the ESSD is a pay-as-you-go ESSD, you can upgrade or downgrade its performance level. However, you cannot downgrade the performance level to PL0.
        The ESSD must be in the **In Use** (In_Use) or **Unattached** (Available) state.
        If the ESSD is attached to an Elastic Compute Service (ECS) instance, the instance must be in the **Running** (Running) or **Stopped** (Stopped) state. The instance cannot be in the Expired state or stopped due to an overdue payment.
        If you cannot upgrade the performance level of an ESSD due to the capacity limit, extend the ESSD by calling the [ResizeDisk](https://help.aliyun.com/document_detail/25522.html) operation and then try again. For more information, see [ESSDs](https://help.aliyun.com/document_detail/122389.html).
        For information about the limits on changing the disk category of a cloud disk, see [Change the category of a disk](~~161980#section_s4a_to0_1jx~~).
        For the disk categories to which cloud disks of each disk category can be changed, see [Change the category of a disk](~~161980#eb8bb54032nho~~).
        After the disk category of a cloud disk is changed, the billing of the cloud disk has the following changes:
        If the cloud disk is a pay-as-you-go disk, you are charged for the disk based on the new disk category.
        If the cloud disk is a subscription disk, you may be charged additionally based on the price difference between the old and new disk categories and the remaining days of the billing cycle, starting from 00:00 the next day until the end of the subscription period.
        For information about the billing of cloud disks, see [Block storage devices](https://help.aliyun.com/document_detail/179022.html).
        
        @param request: ModifyDiskSpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDiskSpecResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.destination_zone_id):
            query['DestinationZoneId'] = request.destination_zone_id
        if not UtilClient.is_unset(request.disk_category):
            query['DiskCategory'] = request.disk_category
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.performance_control_options):
            query['PerformanceControlOptions'] = request.performance_control_options
        if not UtilClient.is_unset(request.performance_level):
            query['PerformanceLevel'] = request.performance_level
        if not UtilClient.is_unset(request.provisioned_iops):
            query['ProvisionedIops'] = request.provisioned_iops
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDiskSpec',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDiskSpecResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_disk_spec_with_options_async(
        self,
        request: ecs_20140526_models.ModifyDiskSpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyDiskSpecResponse:
        """
        @summary Changes the disk category of a cloud disk or the performance level of an Enterprise SSD (ESSD). You cannot change the disk categories of Regional ESSDs, basic disks, elastic ephemeral disks, and local disks.
        
        @description To minimize impacts on your business, change the disk categories or performance levels of cloud disks during off-peak hours.
        Take note of the following items:
        To change the performance level of an ESSD, take note of the following items:
        If the ESSD is a subscription ESSD, you can only upgrade its performance level.
        If the ESSD is a pay-as-you-go ESSD, you can upgrade or downgrade its performance level. However, you cannot downgrade the performance level to PL0.
        The ESSD must be in the **In Use** (In_Use) or **Unattached** (Available) state.
        If the ESSD is attached to an Elastic Compute Service (ECS) instance, the instance must be in the **Running** (Running) or **Stopped** (Stopped) state. The instance cannot be in the Expired state or stopped due to an overdue payment.
        If you cannot upgrade the performance level of an ESSD due to the capacity limit, extend the ESSD by calling the [ResizeDisk](https://help.aliyun.com/document_detail/25522.html) operation and then try again. For more information, see [ESSDs](https://help.aliyun.com/document_detail/122389.html).
        For information about the limits on changing the disk category of a cloud disk, see [Change the category of a disk](~~161980#section_s4a_to0_1jx~~).
        For the disk categories to which cloud disks of each disk category can be changed, see [Change the category of a disk](~~161980#eb8bb54032nho~~).
        After the disk category of a cloud disk is changed, the billing of the cloud disk has the following changes:
        If the cloud disk is a pay-as-you-go disk, you are charged for the disk based on the new disk category.
        If the cloud disk is a subscription disk, you may be charged additionally based on the price difference between the old and new disk categories and the remaining days of the billing cycle, starting from 00:00 the next day until the end of the subscription period.
        For information about the billing of cloud disks, see [Block storage devices](https://help.aliyun.com/document_detail/179022.html).
        
        @param request: ModifyDiskSpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDiskSpecResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.destination_zone_id):
            query['DestinationZoneId'] = request.destination_zone_id
        if not UtilClient.is_unset(request.disk_category):
            query['DiskCategory'] = request.disk_category
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.performance_control_options):
            query['PerformanceControlOptions'] = request.performance_control_options
        if not UtilClient.is_unset(request.performance_level):
            query['PerformanceLevel'] = request.performance_level
        if not UtilClient.is_unset(request.provisioned_iops):
            query['ProvisionedIops'] = request.provisioned_iops
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDiskSpec',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyDiskSpecResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_disk_spec(
        self,
        request: ecs_20140526_models.ModifyDiskSpecRequest,
    ) -> ecs_20140526_models.ModifyDiskSpecResponse:
        """
        @summary Changes the disk category of a cloud disk or the performance level of an Enterprise SSD (ESSD). You cannot change the disk categories of Regional ESSDs, basic disks, elastic ephemeral disks, and local disks.
        
        @description To minimize impacts on your business, change the disk categories or performance levels of cloud disks during off-peak hours.
        Take note of the following items:
        To change the performance level of an ESSD, take note of the following items:
        If the ESSD is a subscription ESSD, you can only upgrade its performance level.
        If the ESSD is a pay-as-you-go ESSD, you can upgrade or downgrade its performance level. However, you cannot downgrade the performance level to PL0.
        The ESSD must be in the **In Use** (In_Use) or **Unattached** (Available) state.
        If the ESSD is attached to an Elastic Compute Service (ECS) instance, the instance must be in the **Running** (Running) or **Stopped** (Stopped) state. The instance cannot be in the Expired state or stopped due to an overdue payment.
        If you cannot upgrade the performance level of an ESSD due to the capacity limit, extend the ESSD by calling the [ResizeDisk](https://help.aliyun.com/document_detail/25522.html) operation and then try again. For more information, see [ESSDs](https://help.aliyun.com/document_detail/122389.html).
        For information about the limits on changing the disk category of a cloud disk, see [Change the category of a disk](~~161980#section_s4a_to0_1jx~~).
        For the disk categories to which cloud disks of each disk category can be changed, see [Change the category of a disk](~~161980#eb8bb54032nho~~).
        After the disk category of a cloud disk is changed, the billing of the cloud disk has the following changes:
        If the cloud disk is a pay-as-you-go disk, you are charged for the disk based on the new disk category.
        If the cloud disk is a subscription disk, you may be charged additionally based on the price difference between the old and new disk categories and the remaining days of the billing cycle, starting from 00:00 the next day until the end of the subscription period.
        For information about the billing of cloud disks, see [Block storage devices](https://help.aliyun.com/document_detail/179022.html).
        
        @param request: ModifyDiskSpecRequest
        @return: ModifyDiskSpecResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_disk_spec_with_options(request, runtime)

    async def modify_disk_spec_async(
        self,
        request: ecs_20140526_models.ModifyDiskSpecRequest,
    ) -> ecs_20140526_models.ModifyDiskSpecResponse:
        """
        @summary Changes the disk category of a cloud disk or the performance level of an Enterprise SSD (ESSD). You cannot change the disk categories of Regional ESSDs, basic disks, elastic ephemeral disks, and local disks.
        
        @description To minimize impacts on your business, change the disk categories or performance levels of cloud disks during off-peak hours.
        Take note of the following items:
        To change the performance level of an ESSD, take note of the following items:
        If the ESSD is a subscription ESSD, you can only upgrade its performance level.
        If the ESSD is a pay-as-you-go ESSD, you can upgrade or downgrade its performance level. However, you cannot downgrade the performance level to PL0.
        The ESSD must be in the **In Use** (In_Use) or **Unattached** (Available) state.
        If the ESSD is attached to an Elastic Compute Service (ECS) instance, the instance must be in the **Running** (Running) or **Stopped** (Stopped) state. The instance cannot be in the Expired state or stopped due to an overdue payment.
        If you cannot upgrade the performance level of an ESSD due to the capacity limit, extend the ESSD by calling the [ResizeDisk](https://help.aliyun.com/document_detail/25522.html) operation and then try again. For more information, see [ESSDs](https://help.aliyun.com/document_detail/122389.html).
        For information about the limits on changing the disk category of a cloud disk, see [Change the category of a disk](~~161980#section_s4a_to0_1jx~~).
        For the disk categories to which cloud disks of each disk category can be changed, see [Change the category of a disk](~~161980#eb8bb54032nho~~).
        After the disk category of a cloud disk is changed, the billing of the cloud disk has the following changes:
        If the cloud disk is a pay-as-you-go disk, you are charged for the disk based on the new disk category.
        If the cloud disk is a subscription disk, you may be charged additionally based on the price difference between the old and new disk categories and the remaining days of the billing cycle, starting from 00:00 the next day until the end of the subscription period.
        For information about the billing of cloud disks, see [Block storage devices](https://help.aliyun.com/document_detail/179022.html).
        
        @param request: ModifyDiskSpecRequest
        @return: ModifyDiskSpecResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_disk_spec_with_options_async(request, runtime)

    def modify_eip_address_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyEipAddressAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyEipAddressAttributeResponse:
        """
        @deprecated OpenAPI ModifyEipAddressAttribute is deprecated, please use Vpc::2016-04-28::ModifyEipAddressAttribute instead.
        
        @summary ModifyEipAddressAttribute
        
        @param request: ModifyEipAddressAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyEipAddressAttributeResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyEipAddressAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyEipAddressAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_eip_address_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyEipAddressAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyEipAddressAttributeResponse:
        """
        @deprecated OpenAPI ModifyEipAddressAttribute is deprecated, please use Vpc::2016-04-28::ModifyEipAddressAttribute instead.
        
        @summary ModifyEipAddressAttribute
        
        @param request: ModifyEipAddressAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyEipAddressAttributeResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyEipAddressAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyEipAddressAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_eip_address_attribute(
        self,
        request: ecs_20140526_models.ModifyEipAddressAttributeRequest,
    ) -> ecs_20140526_models.ModifyEipAddressAttributeResponse:
        """
        @deprecated OpenAPI ModifyEipAddressAttribute is deprecated, please use Vpc::2016-04-28::ModifyEipAddressAttribute instead.
        
        @summary ModifyEipAddressAttribute
        
        @param request: ModifyEipAddressAttributeRequest
        @return: ModifyEipAddressAttributeResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_eip_address_attribute_with_options(request, runtime)

    async def modify_eip_address_attribute_async(
        self,
        request: ecs_20140526_models.ModifyEipAddressAttributeRequest,
    ) -> ecs_20140526_models.ModifyEipAddressAttributeResponse:
        """
        @deprecated OpenAPI ModifyEipAddressAttribute is deprecated, please use Vpc::2016-04-28::ModifyEipAddressAttribute instead.
        
        @summary ModifyEipAddressAttribute
        
        @param request: ModifyEipAddressAttributeRequest
        @return: ModifyEipAddressAttributeResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_eip_address_attribute_with_options_async(request, runtime)

    def modify_elasticity_assurance_with_options(
        self,
        request: ecs_20140526_models.ModifyElasticityAssuranceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyElasticityAssuranceResponse:
        """
        @summary Modifies information about an elasticity assurance, including the name, description, and capacity. Only capacity scale-in is supported .
        
        @param request: ModifyElasticityAssuranceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyElasticityAssuranceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.instance_amount):
            query['InstanceAmount'] = request.instance_amount
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.recurrence_rules):
            query['RecurrenceRules'] = request.recurrence_rules
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyElasticityAssurance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyElasticityAssuranceResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_elasticity_assurance_with_options_async(
        self,
        request: ecs_20140526_models.ModifyElasticityAssuranceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyElasticityAssuranceResponse:
        """
        @summary Modifies information about an elasticity assurance, including the name, description, and capacity. Only capacity scale-in is supported .
        
        @param request: ModifyElasticityAssuranceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyElasticityAssuranceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.instance_amount):
            query['InstanceAmount'] = request.instance_amount
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.recurrence_rules):
            query['RecurrenceRules'] = request.recurrence_rules
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyElasticityAssurance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyElasticityAssuranceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_elasticity_assurance(
        self,
        request: ecs_20140526_models.ModifyElasticityAssuranceRequest,
    ) -> ecs_20140526_models.ModifyElasticityAssuranceResponse:
        """
        @summary Modifies information about an elasticity assurance, including the name, description, and capacity. Only capacity scale-in is supported .
        
        @param request: ModifyElasticityAssuranceRequest
        @return: ModifyElasticityAssuranceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_elasticity_assurance_with_options(request, runtime)

    async def modify_elasticity_assurance_async(
        self,
        request: ecs_20140526_models.ModifyElasticityAssuranceRequest,
    ) -> ecs_20140526_models.ModifyElasticityAssuranceResponse:
        """
        @summary Modifies information about an elasticity assurance, including the name, description, and capacity. Only capacity scale-in is supported .
        
        @param request: ModifyElasticityAssuranceRequest
        @return: ModifyElasticityAssuranceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_elasticity_assurance_with_options_async(request, runtime)

    def modify_elasticity_assurance_auto_renew_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyElasticityAssuranceAutoRenewAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyElasticityAssuranceAutoRenewAttributeResponse:
        """
        @summary Modifies the auto-renewal attribute of elasticity assurances.
        
        @param request: ModifyElasticityAssuranceAutoRenewAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyElasticityAssuranceAutoRenewAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.renewal_status):
            query['RenewalStatus'] = request.renewal_status
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyElasticityAssuranceAutoRenewAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyElasticityAssuranceAutoRenewAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_elasticity_assurance_auto_renew_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyElasticityAssuranceAutoRenewAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyElasticityAssuranceAutoRenewAttributeResponse:
        """
        @summary Modifies the auto-renewal attribute of elasticity assurances.
        
        @param request: ModifyElasticityAssuranceAutoRenewAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyElasticityAssuranceAutoRenewAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.renewal_status):
            query['RenewalStatus'] = request.renewal_status
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyElasticityAssuranceAutoRenewAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyElasticityAssuranceAutoRenewAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_elasticity_assurance_auto_renew_attribute(
        self,
        request: ecs_20140526_models.ModifyElasticityAssuranceAutoRenewAttributeRequest,
    ) -> ecs_20140526_models.ModifyElasticityAssuranceAutoRenewAttributeResponse:
        """
        @summary Modifies the auto-renewal attribute of elasticity assurances.
        
        @param request: ModifyElasticityAssuranceAutoRenewAttributeRequest
        @return: ModifyElasticityAssuranceAutoRenewAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_elasticity_assurance_auto_renew_attribute_with_options(request, runtime)

    async def modify_elasticity_assurance_auto_renew_attribute_async(
        self,
        request: ecs_20140526_models.ModifyElasticityAssuranceAutoRenewAttributeRequest,
    ) -> ecs_20140526_models.ModifyElasticityAssuranceAutoRenewAttributeResponse:
        """
        @summary Modifies the auto-renewal attribute of elasticity assurances.
        
        @param request: ModifyElasticityAssuranceAutoRenewAttributeRequest
        @return: ModifyElasticityAssuranceAutoRenewAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_elasticity_assurance_auto_renew_attribute_with_options_async(request, runtime)

    def modify_forward_entry_with_options(
        self,
        request: ecs_20140526_models.ModifyForwardEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyForwardEntryResponse:
        """
        @deprecated OpenAPI ModifyForwardEntry is deprecated, please use Vpc::2016-04-28::ModifyForwardEntry instead.
        
        @summary ModifyForwardEntry
        
        @param request: ModifyForwardEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyForwardEntryResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.external_ip):
            query['ExternalIp'] = request.external_ip
        if not UtilClient.is_unset(request.external_port):
            query['ExternalPort'] = request.external_port
        if not UtilClient.is_unset(request.forward_entry_id):
            query['ForwardEntryId'] = request.forward_entry_id
        if not UtilClient.is_unset(request.forward_table_id):
            query['ForwardTableId'] = request.forward_table_id
        if not UtilClient.is_unset(request.internal_ip):
            query['InternalIp'] = request.internal_ip
        if not UtilClient.is_unset(request.internal_port):
            query['InternalPort'] = request.internal_port
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyForwardEntry',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyForwardEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_forward_entry_with_options_async(
        self,
        request: ecs_20140526_models.ModifyForwardEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyForwardEntryResponse:
        """
        @deprecated OpenAPI ModifyForwardEntry is deprecated, please use Vpc::2016-04-28::ModifyForwardEntry instead.
        
        @summary ModifyForwardEntry
        
        @param request: ModifyForwardEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyForwardEntryResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.external_ip):
            query['ExternalIp'] = request.external_ip
        if not UtilClient.is_unset(request.external_port):
            query['ExternalPort'] = request.external_port
        if not UtilClient.is_unset(request.forward_entry_id):
            query['ForwardEntryId'] = request.forward_entry_id
        if not UtilClient.is_unset(request.forward_table_id):
            query['ForwardTableId'] = request.forward_table_id
        if not UtilClient.is_unset(request.internal_ip):
            query['InternalIp'] = request.internal_ip
        if not UtilClient.is_unset(request.internal_port):
            query['InternalPort'] = request.internal_port
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyForwardEntry',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyForwardEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_forward_entry(
        self,
        request: ecs_20140526_models.ModifyForwardEntryRequest,
    ) -> ecs_20140526_models.ModifyForwardEntryResponse:
        """
        @deprecated OpenAPI ModifyForwardEntry is deprecated, please use Vpc::2016-04-28::ModifyForwardEntry instead.
        
        @summary ModifyForwardEntry
        
        @param request: ModifyForwardEntryRequest
        @return: ModifyForwardEntryResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_forward_entry_with_options(request, runtime)

    async def modify_forward_entry_async(
        self,
        request: ecs_20140526_models.ModifyForwardEntryRequest,
    ) -> ecs_20140526_models.ModifyForwardEntryResponse:
        """
        @deprecated OpenAPI ModifyForwardEntry is deprecated, please use Vpc::2016-04-28::ModifyForwardEntry instead.
        
        @summary ModifyForwardEntry
        
        @param request: ModifyForwardEntryRequest
        @return: ModifyForwardEntryResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_forward_entry_with_options_async(request, runtime)

    def modify_ha_vip_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyHaVipAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyHaVipAttributeResponse:
        """
        @deprecated OpenAPI ModifyHaVipAttribute is deprecated, please use Vpc::2016-04-28::ModifyHaVipAttribute instead.
        
        @summary ModifyHaVipAttribute
        
        @param request: ModifyHaVipAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyHaVipAttributeResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ha_vip_id):
            query['HaVipId'] = request.ha_vip_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyHaVipAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyHaVipAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_ha_vip_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyHaVipAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyHaVipAttributeResponse:
        """
        @deprecated OpenAPI ModifyHaVipAttribute is deprecated, please use Vpc::2016-04-28::ModifyHaVipAttribute instead.
        
        @summary ModifyHaVipAttribute
        
        @param request: ModifyHaVipAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyHaVipAttributeResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ha_vip_id):
            query['HaVipId'] = request.ha_vip_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyHaVipAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyHaVipAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_ha_vip_attribute(
        self,
        request: ecs_20140526_models.ModifyHaVipAttributeRequest,
    ) -> ecs_20140526_models.ModifyHaVipAttributeResponse:
        """
        @deprecated OpenAPI ModifyHaVipAttribute is deprecated, please use Vpc::2016-04-28::ModifyHaVipAttribute instead.
        
        @summary ModifyHaVipAttribute
        
        @param request: ModifyHaVipAttributeRequest
        @return: ModifyHaVipAttributeResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_ha_vip_attribute_with_options(request, runtime)

    async def modify_ha_vip_attribute_async(
        self,
        request: ecs_20140526_models.ModifyHaVipAttributeRequest,
    ) -> ecs_20140526_models.ModifyHaVipAttributeResponse:
        """
        @deprecated OpenAPI ModifyHaVipAttribute is deprecated, please use Vpc::2016-04-28::ModifyHaVipAttribute instead.
        
        @summary ModifyHaVipAttribute
        
        @param request: ModifyHaVipAttributeRequest
        @return: ModifyHaVipAttributeResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_ha_vip_attribute_with_options_async(request, runtime)

    def modify_hpc_cluster_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyHpcClusterAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyHpcClusterAttributeResponse:
        """
        @summary Modifies the description of a high performance computing (HPC) cluster.
        
        @param request: ModifyHpcClusterAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyHpcClusterAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.hpc_cluster_id):
            query['HpcClusterId'] = request.hpc_cluster_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyHpcClusterAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyHpcClusterAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_hpc_cluster_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyHpcClusterAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyHpcClusterAttributeResponse:
        """
        @summary Modifies the description of a high performance computing (HPC) cluster.
        
        @param request: ModifyHpcClusterAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyHpcClusterAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.hpc_cluster_id):
            query['HpcClusterId'] = request.hpc_cluster_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyHpcClusterAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyHpcClusterAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_hpc_cluster_attribute(
        self,
        request: ecs_20140526_models.ModifyHpcClusterAttributeRequest,
    ) -> ecs_20140526_models.ModifyHpcClusterAttributeResponse:
        """
        @summary Modifies the description of a high performance computing (HPC) cluster.
        
        @param request: ModifyHpcClusterAttributeRequest
        @return: ModifyHpcClusterAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_hpc_cluster_attribute_with_options(request, runtime)

    async def modify_hpc_cluster_attribute_async(
        self,
        request: ecs_20140526_models.ModifyHpcClusterAttributeRequest,
    ) -> ecs_20140526_models.ModifyHpcClusterAttributeResponse:
        """
        @summary Modifies the description of a high performance computing (HPC) cluster.
        
        @param request: ModifyHpcClusterAttributeRequest
        @return: ModifyHpcClusterAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_hpc_cluster_attribute_with_options_async(request, runtime)

    def modify_image_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyImageAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyImageAttributeResponse:
        """
        @summary Modifies the attributes of a custom image, such as the image family, name, boot mode, and status and whether the image supports the Non-Volatile Memory Express (NVMe) protocol. When you call this operation, you can specify parameters, such as ImageId and ImageFamily, in the request.
        
        @param request: ModifyImageAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyImageAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.boot_mode):
            query['BootMode'] = request.boot_mode
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.features):
            query['Features'] = request.features
        if not UtilClient.is_unset(request.image_family):
            query['ImageFamily'] = request.image_family
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.image_name):
            query['ImageName'] = request.image_name
        if not UtilClient.is_unset(request.license_type):
            query['LicenseType'] = request.license_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyImageAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyImageAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_image_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyImageAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyImageAttributeResponse:
        """
        @summary Modifies the attributes of a custom image, such as the image family, name, boot mode, and status and whether the image supports the Non-Volatile Memory Express (NVMe) protocol. When you call this operation, you can specify parameters, such as ImageId and ImageFamily, in the request.
        
        @param request: ModifyImageAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyImageAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.boot_mode):
            query['BootMode'] = request.boot_mode
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.features):
            query['Features'] = request.features
        if not UtilClient.is_unset(request.image_family):
            query['ImageFamily'] = request.image_family
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.image_name):
            query['ImageName'] = request.image_name
        if not UtilClient.is_unset(request.license_type):
            query['LicenseType'] = request.license_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyImageAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyImageAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_image_attribute(
        self,
        request: ecs_20140526_models.ModifyImageAttributeRequest,
    ) -> ecs_20140526_models.ModifyImageAttributeResponse:
        """
        @summary Modifies the attributes of a custom image, such as the image family, name, boot mode, and status and whether the image supports the Non-Volatile Memory Express (NVMe) protocol. When you call this operation, you can specify parameters, such as ImageId and ImageFamily, in the request.
        
        @param request: ModifyImageAttributeRequest
        @return: ModifyImageAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_image_attribute_with_options(request, runtime)

    async def modify_image_attribute_async(
        self,
        request: ecs_20140526_models.ModifyImageAttributeRequest,
    ) -> ecs_20140526_models.ModifyImageAttributeResponse:
        """
        @summary Modifies the attributes of a custom image, such as the image family, name, boot mode, and status and whether the image supports the Non-Volatile Memory Express (NVMe) protocol. When you call this operation, you can specify parameters, such as ImageId and ImageFamily, in the request.
        
        @param request: ModifyImageAttributeRequest
        @return: ModifyImageAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_image_attribute_with_options_async(request, runtime)

    def modify_image_share_group_permission_with_options(
        self,
        request: ecs_20140526_models.ModifyImageShareGroupPermissionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyImageShareGroupPermissionResponse:
        """
        @deprecated OpenAPI ModifyImageShareGroupPermission is deprecated, please use Ecs::2014-05-26::ModifyImageSharePermission instead.
        
        @summary 修改镜像共享组权限
        
        @param request: ModifyImageShareGroupPermissionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyImageShareGroupPermissionResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.add_group):
            query['AddGroup'] = request.add_group
        if not UtilClient.is_unset(request.remove_group):
            query['RemoveGroup'] = request.remove_group
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyImageShareGroupPermission',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyImageShareGroupPermissionResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_image_share_group_permission_with_options_async(
        self,
        request: ecs_20140526_models.ModifyImageShareGroupPermissionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyImageShareGroupPermissionResponse:
        """
        @deprecated OpenAPI ModifyImageShareGroupPermission is deprecated, please use Ecs::2014-05-26::ModifyImageSharePermission instead.
        
        @summary 修改镜像共享组权限
        
        @param request: ModifyImageShareGroupPermissionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyImageShareGroupPermissionResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.add_group):
            query['AddGroup'] = request.add_group
        if not UtilClient.is_unset(request.remove_group):
            query['RemoveGroup'] = request.remove_group
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyImageShareGroupPermission',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyImageShareGroupPermissionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_image_share_group_permission(
        self,
        request: ecs_20140526_models.ModifyImageShareGroupPermissionRequest,
    ) -> ecs_20140526_models.ModifyImageShareGroupPermissionResponse:
        """
        @deprecated OpenAPI ModifyImageShareGroupPermission is deprecated, please use Ecs::2014-05-26::ModifyImageSharePermission instead.
        
        @summary 修改镜像共享组权限
        
        @param request: ModifyImageShareGroupPermissionRequest
        @return: ModifyImageShareGroupPermissionResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_image_share_group_permission_with_options(request, runtime)

    async def modify_image_share_group_permission_async(
        self,
        request: ecs_20140526_models.ModifyImageShareGroupPermissionRequest,
    ) -> ecs_20140526_models.ModifyImageShareGroupPermissionResponse:
        """
        @deprecated OpenAPI ModifyImageShareGroupPermission is deprecated, please use Ecs::2014-05-26::ModifyImageSharePermission instead.
        
        @summary 修改镜像共享组权限
        
        @param request: ModifyImageShareGroupPermissionRequest
        @return: ModifyImageShareGroupPermissionResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_image_share_group_permission_with_options_async(request, runtime)

    def modify_image_share_permission_with_options(
        self,
        request: ecs_20140526_models.ModifyImageSharePermissionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyImageSharePermissionResponse:
        """
        @summary Modifies the share permissions on an image. You can share your custom images with other Alibaba Cloud accounts or publish the images as community images.
        
        @description Before you call this operation, read [Share a custom image](https://help.aliyun.com/document_detail/25463.html).
        When you call this operation, take note of the following sharing rules:
        **Sharing limits**: You can share only the custom images created in your Alibaba Cloud account to other Alibaba Cloud accounts. A custom image can be shared to up to 50 Alibaba Cloud accounts. You can share a custom image to up to 10 Alibaba Cloud accounts at a time.
        **Impacts on an instance**: If an instance was created ([RunInstances](https://help.aliyun.com/document_detail/63440.html)) from a shared image, you cannot re-initialize the system disk of the instance ([ReInitDisk](https://help.aliyun.com/document_detail/25519.html)) after the image owner unshares or deletes the image ([DeleteImage](https://help.aliyun.com/document_detail/25537.html)).
        >  You can share images encrypted by using customer master keys (CMKs) but cannot share images encrypted by using service keys. When you share an image encrypted by using a service key, an error is reported. If you want to share an image encrypted by using a service key, call the CopyImage operation to copy the image and change the encryption key of the image copy to a CMK.
        When you publish or unpublish a community image, take note of the following items:
        **Responsibilities and agreement**: Alibaba Cloud provides only the platform on which community images can be published and managed. The owner of a community image is responsible for the quality and updates of the image. Make sure that you acknowledge and agree to the Community Image Agreement. Otherwise, you cannot publish community images. For more information, see [Publish a community image](https://help.aliyun.com/document_detail/208370.html).
        **Encryption limits**: You cannot publish encrypted images as community images.
        **Openness**: Community images are publicly available. A community image is available to all Alibaba Cloud accounts in the region where the image resides.
        **Feature limits**: You cannot share, export, or copy community images.
        **Unpublication impacts**: After you unpublish a community image, the image is no longer available to other Alibaba Cloud accounts. If an image is shared to other Alibaba Cloud accounts before it is unpublished, the image remains available to the accounts.
        
        @param request: ModifyImageSharePermissionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyImageSharePermissionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.add_account):
            query['AddAccount'] = request.add_account
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.is_public):
            query['IsPublic'] = request.is_public
        if not UtilClient.is_unset(request.launch_permission):
            query['LaunchPermission'] = request.launch_permission
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remove_account):
            query['RemoveAccount'] = request.remove_account
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyImageSharePermission',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyImageSharePermissionResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_image_share_permission_with_options_async(
        self,
        request: ecs_20140526_models.ModifyImageSharePermissionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyImageSharePermissionResponse:
        """
        @summary Modifies the share permissions on an image. You can share your custom images with other Alibaba Cloud accounts or publish the images as community images.
        
        @description Before you call this operation, read [Share a custom image](https://help.aliyun.com/document_detail/25463.html).
        When you call this operation, take note of the following sharing rules:
        **Sharing limits**: You can share only the custom images created in your Alibaba Cloud account to other Alibaba Cloud accounts. A custom image can be shared to up to 50 Alibaba Cloud accounts. You can share a custom image to up to 10 Alibaba Cloud accounts at a time.
        **Impacts on an instance**: If an instance was created ([RunInstances](https://help.aliyun.com/document_detail/63440.html)) from a shared image, you cannot re-initialize the system disk of the instance ([ReInitDisk](https://help.aliyun.com/document_detail/25519.html)) after the image owner unshares or deletes the image ([DeleteImage](https://help.aliyun.com/document_detail/25537.html)).
        >  You can share images encrypted by using customer master keys (CMKs) but cannot share images encrypted by using service keys. When you share an image encrypted by using a service key, an error is reported. If you want to share an image encrypted by using a service key, call the CopyImage operation to copy the image and change the encryption key of the image copy to a CMK.
        When you publish or unpublish a community image, take note of the following items:
        **Responsibilities and agreement**: Alibaba Cloud provides only the platform on which community images can be published and managed. The owner of a community image is responsible for the quality and updates of the image. Make sure that you acknowledge and agree to the Community Image Agreement. Otherwise, you cannot publish community images. For more information, see [Publish a community image](https://help.aliyun.com/document_detail/208370.html).
        **Encryption limits**: You cannot publish encrypted images as community images.
        **Openness**: Community images are publicly available. A community image is available to all Alibaba Cloud accounts in the region where the image resides.
        **Feature limits**: You cannot share, export, or copy community images.
        **Unpublication impacts**: After you unpublish a community image, the image is no longer available to other Alibaba Cloud accounts. If an image is shared to other Alibaba Cloud accounts before it is unpublished, the image remains available to the accounts.
        
        @param request: ModifyImageSharePermissionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyImageSharePermissionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.add_account):
            query['AddAccount'] = request.add_account
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.is_public):
            query['IsPublic'] = request.is_public
        if not UtilClient.is_unset(request.launch_permission):
            query['LaunchPermission'] = request.launch_permission
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remove_account):
            query['RemoveAccount'] = request.remove_account
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyImageSharePermission',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyImageSharePermissionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_image_share_permission(
        self,
        request: ecs_20140526_models.ModifyImageSharePermissionRequest,
    ) -> ecs_20140526_models.ModifyImageSharePermissionResponse:
        """
        @summary Modifies the share permissions on an image. You can share your custom images with other Alibaba Cloud accounts or publish the images as community images.
        
        @description Before you call this operation, read [Share a custom image](https://help.aliyun.com/document_detail/25463.html).
        When you call this operation, take note of the following sharing rules:
        **Sharing limits**: You can share only the custom images created in your Alibaba Cloud account to other Alibaba Cloud accounts. A custom image can be shared to up to 50 Alibaba Cloud accounts. You can share a custom image to up to 10 Alibaba Cloud accounts at a time.
        **Impacts on an instance**: If an instance was created ([RunInstances](https://help.aliyun.com/document_detail/63440.html)) from a shared image, you cannot re-initialize the system disk of the instance ([ReInitDisk](https://help.aliyun.com/document_detail/25519.html)) after the image owner unshares or deletes the image ([DeleteImage](https://help.aliyun.com/document_detail/25537.html)).
        >  You can share images encrypted by using customer master keys (CMKs) but cannot share images encrypted by using service keys. When you share an image encrypted by using a service key, an error is reported. If you want to share an image encrypted by using a service key, call the CopyImage operation to copy the image and change the encryption key of the image copy to a CMK.
        When you publish or unpublish a community image, take note of the following items:
        **Responsibilities and agreement**: Alibaba Cloud provides only the platform on which community images can be published and managed. The owner of a community image is responsible for the quality and updates of the image. Make sure that you acknowledge and agree to the Community Image Agreement. Otherwise, you cannot publish community images. For more information, see [Publish a community image](https://help.aliyun.com/document_detail/208370.html).
        **Encryption limits**: You cannot publish encrypted images as community images.
        **Openness**: Community images are publicly available. A community image is available to all Alibaba Cloud accounts in the region where the image resides.
        **Feature limits**: You cannot share, export, or copy community images.
        **Unpublication impacts**: After you unpublish a community image, the image is no longer available to other Alibaba Cloud accounts. If an image is shared to other Alibaba Cloud accounts before it is unpublished, the image remains available to the accounts.
        
        @param request: ModifyImageSharePermissionRequest
        @return: ModifyImageSharePermissionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_image_share_permission_with_options(request, runtime)

    async def modify_image_share_permission_async(
        self,
        request: ecs_20140526_models.ModifyImageSharePermissionRequest,
    ) -> ecs_20140526_models.ModifyImageSharePermissionResponse:
        """
        @summary Modifies the share permissions on an image. You can share your custom images with other Alibaba Cloud accounts or publish the images as community images.
        
        @description Before you call this operation, read [Share a custom image](https://help.aliyun.com/document_detail/25463.html).
        When you call this operation, take note of the following sharing rules:
        **Sharing limits**: You can share only the custom images created in your Alibaba Cloud account to other Alibaba Cloud accounts. A custom image can be shared to up to 50 Alibaba Cloud accounts. You can share a custom image to up to 10 Alibaba Cloud accounts at a time.
        **Impacts on an instance**: If an instance was created ([RunInstances](https://help.aliyun.com/document_detail/63440.html)) from a shared image, you cannot re-initialize the system disk of the instance ([ReInitDisk](https://help.aliyun.com/document_detail/25519.html)) after the image owner unshares or deletes the image ([DeleteImage](https://help.aliyun.com/document_detail/25537.html)).
        >  You can share images encrypted by using customer master keys (CMKs) but cannot share images encrypted by using service keys. When you share an image encrypted by using a service key, an error is reported. If you want to share an image encrypted by using a service key, call the CopyImage operation to copy the image and change the encryption key of the image copy to a CMK.
        When you publish or unpublish a community image, take note of the following items:
        **Responsibilities and agreement**: Alibaba Cloud provides only the platform on which community images can be published and managed. The owner of a community image is responsible for the quality and updates of the image. Make sure that you acknowledge and agree to the Community Image Agreement. Otherwise, you cannot publish community images. For more information, see [Publish a community image](https://help.aliyun.com/document_detail/208370.html).
        **Encryption limits**: You cannot publish encrypted images as community images.
        **Openness**: Community images are publicly available. A community image is available to all Alibaba Cloud accounts in the region where the image resides.
        **Feature limits**: You cannot share, export, or copy community images.
        **Unpublication impacts**: After you unpublish a community image, the image is no longer available to other Alibaba Cloud accounts. If an image is shared to other Alibaba Cloud accounts before it is unpublished, the image remains available to the accounts.
        
        @param request: ModifyImageSharePermissionRequest
        @return: ModifyImageSharePermissionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_image_share_permission_with_options_async(request, runtime)

    def modify_instance_attachment_attributes_with_options(
        self,
        request: ecs_20140526_models.ModifyInstanceAttachmentAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceAttachmentAttributesResponse:
        """
        @summary Changes the type of the private pool for an Elastic Compute Service (ECS) instance.
        
        @description A private pool is generated after an elasticity assurance or a capacity reservation is created. The private pool is associated with information about the instances that use the private pool. You can specify whether to use a private pool when you create an ECS instance to match the instance with the associated elasticity assurance or capacity reservation.
        After you call this operation to modify the private pool attributes of an ECS instance, you do not need to restart the instance for the changes to take effect.
        When you call the following operations on an ECS instance, the system attempts to match the instance with active private pools. If the instance is already matched to a specified private pool, the call to an operation may fail when the private pool capacity is used up or the private pool expires. If the call fails, call the ModifyInstanceAttachmentAttributes operation to change the type of the private pool to `Open`.
        [StartInstance](https://help.aliyun.com/document_detail/2679679.html): start an ECS instance that is stopped in economical mode.
        [ReActivateInstances](https://help.aliyun.com/document_detail/2679707.html): reactivates an ECS instance that has expired or is reclaimed due to an overdue payment.
        [ModifyInstanceChargeType](https://help.aliyun.com/document_detail/2679704.html): changes the billing method of an ECS instance.
        [ModifyPrepayInstanceSpec](https://help.aliyun.com/document_detail/2679706.html): changes the instance type of an ECS instance.
        [ReplaceSystemDisk](https://help.aliyun.com/document_detail/2679771.html): replaces the operating system of an ECS instance.
        
        @param request: ModifyInstanceAttachmentAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceAttachmentAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceAttachmentAttributes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceAttachmentAttributesResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_instance_attachment_attributes_with_options_async(
        self,
        request: ecs_20140526_models.ModifyInstanceAttachmentAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceAttachmentAttributesResponse:
        """
        @summary Changes the type of the private pool for an Elastic Compute Service (ECS) instance.
        
        @description A private pool is generated after an elasticity assurance or a capacity reservation is created. The private pool is associated with information about the instances that use the private pool. You can specify whether to use a private pool when you create an ECS instance to match the instance with the associated elasticity assurance or capacity reservation.
        After you call this operation to modify the private pool attributes of an ECS instance, you do not need to restart the instance for the changes to take effect.
        When you call the following operations on an ECS instance, the system attempts to match the instance with active private pools. If the instance is already matched to a specified private pool, the call to an operation may fail when the private pool capacity is used up or the private pool expires. If the call fails, call the ModifyInstanceAttachmentAttributes operation to change the type of the private pool to `Open`.
        [StartInstance](https://help.aliyun.com/document_detail/2679679.html): start an ECS instance that is stopped in economical mode.
        [ReActivateInstances](https://help.aliyun.com/document_detail/2679707.html): reactivates an ECS instance that has expired or is reclaimed due to an overdue payment.
        [ModifyInstanceChargeType](https://help.aliyun.com/document_detail/2679704.html): changes the billing method of an ECS instance.
        [ModifyPrepayInstanceSpec](https://help.aliyun.com/document_detail/2679706.html): changes the instance type of an ECS instance.
        [ReplaceSystemDisk](https://help.aliyun.com/document_detail/2679771.html): replaces the operating system of an ECS instance.
        
        @param request: ModifyInstanceAttachmentAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceAttachmentAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceAttachmentAttributes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceAttachmentAttributesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_instance_attachment_attributes(
        self,
        request: ecs_20140526_models.ModifyInstanceAttachmentAttributesRequest,
    ) -> ecs_20140526_models.ModifyInstanceAttachmentAttributesResponse:
        """
        @summary Changes the type of the private pool for an Elastic Compute Service (ECS) instance.
        
        @description A private pool is generated after an elasticity assurance or a capacity reservation is created. The private pool is associated with information about the instances that use the private pool. You can specify whether to use a private pool when you create an ECS instance to match the instance with the associated elasticity assurance or capacity reservation.
        After you call this operation to modify the private pool attributes of an ECS instance, you do not need to restart the instance for the changes to take effect.
        When you call the following operations on an ECS instance, the system attempts to match the instance with active private pools. If the instance is already matched to a specified private pool, the call to an operation may fail when the private pool capacity is used up or the private pool expires. If the call fails, call the ModifyInstanceAttachmentAttributes operation to change the type of the private pool to `Open`.
        [StartInstance](https://help.aliyun.com/document_detail/2679679.html): start an ECS instance that is stopped in economical mode.
        [ReActivateInstances](https://help.aliyun.com/document_detail/2679707.html): reactivates an ECS instance that has expired or is reclaimed due to an overdue payment.
        [ModifyInstanceChargeType](https://help.aliyun.com/document_detail/2679704.html): changes the billing method of an ECS instance.
        [ModifyPrepayInstanceSpec](https://help.aliyun.com/document_detail/2679706.html): changes the instance type of an ECS instance.
        [ReplaceSystemDisk](https://help.aliyun.com/document_detail/2679771.html): replaces the operating system of an ECS instance.
        
        @param request: ModifyInstanceAttachmentAttributesRequest
        @return: ModifyInstanceAttachmentAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_instance_attachment_attributes_with_options(request, runtime)

    async def modify_instance_attachment_attributes_async(
        self,
        request: ecs_20140526_models.ModifyInstanceAttachmentAttributesRequest,
    ) -> ecs_20140526_models.ModifyInstanceAttachmentAttributesResponse:
        """
        @summary Changes the type of the private pool for an Elastic Compute Service (ECS) instance.
        
        @description A private pool is generated after an elasticity assurance or a capacity reservation is created. The private pool is associated with information about the instances that use the private pool. You can specify whether to use a private pool when you create an ECS instance to match the instance with the associated elasticity assurance or capacity reservation.
        After you call this operation to modify the private pool attributes of an ECS instance, you do not need to restart the instance for the changes to take effect.
        When you call the following operations on an ECS instance, the system attempts to match the instance with active private pools. If the instance is already matched to a specified private pool, the call to an operation may fail when the private pool capacity is used up or the private pool expires. If the call fails, call the ModifyInstanceAttachmentAttributes operation to change the type of the private pool to `Open`.
        [StartInstance](https://help.aliyun.com/document_detail/2679679.html): start an ECS instance that is stopped in economical mode.
        [ReActivateInstances](https://help.aliyun.com/document_detail/2679707.html): reactivates an ECS instance that has expired or is reclaimed due to an overdue payment.
        [ModifyInstanceChargeType](https://help.aliyun.com/document_detail/2679704.html): changes the billing method of an ECS instance.
        [ModifyPrepayInstanceSpec](https://help.aliyun.com/document_detail/2679706.html): changes the instance type of an ECS instance.
        [ReplaceSystemDisk](https://help.aliyun.com/document_detail/2679771.html): replaces the operating system of an ECS instance.
        
        @param request: ModifyInstanceAttachmentAttributesRequest
        @return: ModifyInstanceAttachmentAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_instance_attachment_attributes_with_options_async(request, runtime)

    def modify_instance_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyInstanceAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceAttributeResponse:
        """
        @summary Modifies the attributes of an Elastic Compute Service (ECS) instance, such as the password, name, description, hostname, security groups, maximum transmission unit (MTU), and user data of the instance.
        
        @description You cannot call this operation to modify the attributes of the ECS instances that are locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        
        @param request: ModifyInstanceAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.credit_specification):
            query['CreditSpecification'] = request.credit_specification
        if not UtilClient.is_unset(request.deletion_protection):
            query['DeletionProtection'] = request.deletion_protection
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enable_jumbo_frame):
            query['EnableJumboFrame'] = request.enable_jumbo_frame
        if not UtilClient.is_unset(request.enable_network_encryption):
            query['EnableNetworkEncryption'] = request.enable_network_encryption
        if not UtilClient.is_unset(request.host_name):
            query['HostName'] = request.host_name
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.network_interface_queue_number):
            query['NetworkInterfaceQueueNumber'] = request.network_interface_queue_number
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.password):
            query['Password'] = request.password
        if not UtilClient.is_unset(request.private_dns_name_options):
            query['PrivateDnsNameOptions'] = request.private_dns_name_options
        if not UtilClient.is_unset(request.recyclable):
            query['Recyclable'] = request.recyclable
        if not UtilClient.is_unset(request.remote_connection_options):
            query['RemoteConnectionOptions'] = request.remote_connection_options
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_ids):
            query['SecurityGroupIds'] = request.security_group_ids
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.cpu_options):
            query['CpuOptions'] = request.cpu_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_instance_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyInstanceAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceAttributeResponse:
        """
        @summary Modifies the attributes of an Elastic Compute Service (ECS) instance, such as the password, name, description, hostname, security groups, maximum transmission unit (MTU), and user data of the instance.
        
        @description You cannot call this operation to modify the attributes of the ECS instances that are locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        
        @param request: ModifyInstanceAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.credit_specification):
            query['CreditSpecification'] = request.credit_specification
        if not UtilClient.is_unset(request.deletion_protection):
            query['DeletionProtection'] = request.deletion_protection
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enable_jumbo_frame):
            query['EnableJumboFrame'] = request.enable_jumbo_frame
        if not UtilClient.is_unset(request.enable_network_encryption):
            query['EnableNetworkEncryption'] = request.enable_network_encryption
        if not UtilClient.is_unset(request.host_name):
            query['HostName'] = request.host_name
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.network_interface_queue_number):
            query['NetworkInterfaceQueueNumber'] = request.network_interface_queue_number
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.password):
            query['Password'] = request.password
        if not UtilClient.is_unset(request.private_dns_name_options):
            query['PrivateDnsNameOptions'] = request.private_dns_name_options
        if not UtilClient.is_unset(request.recyclable):
            query['Recyclable'] = request.recyclable
        if not UtilClient.is_unset(request.remote_connection_options):
            query['RemoteConnectionOptions'] = request.remote_connection_options
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_ids):
            query['SecurityGroupIds'] = request.security_group_ids
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.cpu_options):
            query['CpuOptions'] = request.cpu_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_instance_attribute(
        self,
        request: ecs_20140526_models.ModifyInstanceAttributeRequest,
    ) -> ecs_20140526_models.ModifyInstanceAttributeResponse:
        """
        @summary Modifies the attributes of an Elastic Compute Service (ECS) instance, such as the password, name, description, hostname, security groups, maximum transmission unit (MTU), and user data of the instance.
        
        @description You cannot call this operation to modify the attributes of the ECS instances that are locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        
        @param request: ModifyInstanceAttributeRequest
        @return: ModifyInstanceAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_instance_attribute_with_options(request, runtime)

    async def modify_instance_attribute_async(
        self,
        request: ecs_20140526_models.ModifyInstanceAttributeRequest,
    ) -> ecs_20140526_models.ModifyInstanceAttributeResponse:
        """
        @summary Modifies the attributes of an Elastic Compute Service (ECS) instance, such as the password, name, description, hostname, security groups, maximum transmission unit (MTU), and user data of the instance.
        
        @description You cannot call this operation to modify the attributes of the ECS instances that are locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        
        @param request: ModifyInstanceAttributeRequest
        @return: ModifyInstanceAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_instance_attribute_with_options_async(request, runtime)

    def modify_instance_auto_release_time_with_options(
        self,
        request: ecs_20140526_models.ModifyInstanceAutoReleaseTimeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceAutoReleaseTimeResponse:
        """
        @summary Changes the automatic release time of a pay-as-you-go or spot instance or cancels the automatic release of the instance.
        
        @param request: ModifyInstanceAutoReleaseTimeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceAutoReleaseTimeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_release_time):
            query['AutoReleaseTime'] = request.auto_release_time
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceAutoReleaseTime',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceAutoReleaseTimeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_instance_auto_release_time_with_options_async(
        self,
        request: ecs_20140526_models.ModifyInstanceAutoReleaseTimeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceAutoReleaseTimeResponse:
        """
        @summary Changes the automatic release time of a pay-as-you-go or spot instance or cancels the automatic release of the instance.
        
        @param request: ModifyInstanceAutoReleaseTimeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceAutoReleaseTimeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_release_time):
            query['AutoReleaseTime'] = request.auto_release_time
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceAutoReleaseTime',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceAutoReleaseTimeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_instance_auto_release_time(
        self,
        request: ecs_20140526_models.ModifyInstanceAutoReleaseTimeRequest,
    ) -> ecs_20140526_models.ModifyInstanceAutoReleaseTimeResponse:
        """
        @summary Changes the automatic release time of a pay-as-you-go or spot instance or cancels the automatic release of the instance.
        
        @param request: ModifyInstanceAutoReleaseTimeRequest
        @return: ModifyInstanceAutoReleaseTimeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_instance_auto_release_time_with_options(request, runtime)

    async def modify_instance_auto_release_time_async(
        self,
        request: ecs_20140526_models.ModifyInstanceAutoReleaseTimeRequest,
    ) -> ecs_20140526_models.ModifyInstanceAutoReleaseTimeResponse:
        """
        @summary Changes the automatic release time of a pay-as-you-go or spot instance or cancels the automatic release of the instance.
        
        @param request: ModifyInstanceAutoReleaseTimeRequest
        @return: ModifyInstanceAutoReleaseTimeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_instance_auto_release_time_with_options_async(request, runtime)

    def modify_instance_auto_renew_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyInstanceAutoRenewAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceAutoRenewAttributeResponse:
        """
        @summary Configures auto-renewal for subscription instances to help reduce the maintenance workloads on instance expiration.
        
        @description *Before you call this operation, make sure that you are familiar with the billing methods and [pricing](https://www.alibabacloud.com/product/ecs#pricing) of Elastic Compute Service (ECS)**.
        Make sure that your account balance or credit balance is sufficient.
        Only subscription instances are supported. If you call this operation for a pay-as-you-go instance, an error is returned.
        The payment for auto-renewal of an instance is automatically deducted at 08:00:00 (UTC+8) nine days before the instance expires.
        If the deduction fails, Alibaba Cloud attempts to deduct the payment every day until the payment is deducted or until the instance is locked on expiration.
        
        @param request: ModifyInstanceAutoRenewAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceAutoRenewAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.duration):
            query['Duration'] = request.duration
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.renewal_status):
            query['RenewalStatus'] = request.renewal_status
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceAutoRenewAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceAutoRenewAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_instance_auto_renew_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyInstanceAutoRenewAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceAutoRenewAttributeResponse:
        """
        @summary Configures auto-renewal for subscription instances to help reduce the maintenance workloads on instance expiration.
        
        @description *Before you call this operation, make sure that you are familiar with the billing methods and [pricing](https://www.alibabacloud.com/product/ecs#pricing) of Elastic Compute Service (ECS)**.
        Make sure that your account balance or credit balance is sufficient.
        Only subscription instances are supported. If you call this operation for a pay-as-you-go instance, an error is returned.
        The payment for auto-renewal of an instance is automatically deducted at 08:00:00 (UTC+8) nine days before the instance expires.
        If the deduction fails, Alibaba Cloud attempts to deduct the payment every day until the payment is deducted or until the instance is locked on expiration.
        
        @param request: ModifyInstanceAutoRenewAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceAutoRenewAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.duration):
            query['Duration'] = request.duration
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.renewal_status):
            query['RenewalStatus'] = request.renewal_status
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceAutoRenewAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceAutoRenewAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_instance_auto_renew_attribute(
        self,
        request: ecs_20140526_models.ModifyInstanceAutoRenewAttributeRequest,
    ) -> ecs_20140526_models.ModifyInstanceAutoRenewAttributeResponse:
        """
        @summary Configures auto-renewal for subscription instances to help reduce the maintenance workloads on instance expiration.
        
        @description *Before you call this operation, make sure that you are familiar with the billing methods and [pricing](https://www.alibabacloud.com/product/ecs#pricing) of Elastic Compute Service (ECS)**.
        Make sure that your account balance or credit balance is sufficient.
        Only subscription instances are supported. If you call this operation for a pay-as-you-go instance, an error is returned.
        The payment for auto-renewal of an instance is automatically deducted at 08:00:00 (UTC+8) nine days before the instance expires.
        If the deduction fails, Alibaba Cloud attempts to deduct the payment every day until the payment is deducted or until the instance is locked on expiration.
        
        @param request: ModifyInstanceAutoRenewAttributeRequest
        @return: ModifyInstanceAutoRenewAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_instance_auto_renew_attribute_with_options(request, runtime)

    async def modify_instance_auto_renew_attribute_async(
        self,
        request: ecs_20140526_models.ModifyInstanceAutoRenewAttributeRequest,
    ) -> ecs_20140526_models.ModifyInstanceAutoRenewAttributeResponse:
        """
        @summary Configures auto-renewal for subscription instances to help reduce the maintenance workloads on instance expiration.
        
        @description *Before you call this operation, make sure that you are familiar with the billing methods and [pricing](https://www.alibabacloud.com/product/ecs#pricing) of Elastic Compute Service (ECS)**.
        Make sure that your account balance or credit balance is sufficient.
        Only subscription instances are supported. If you call this operation for a pay-as-you-go instance, an error is returned.
        The payment for auto-renewal of an instance is automatically deducted at 08:00:00 (UTC+8) nine days before the instance expires.
        If the deduction fails, Alibaba Cloud attempts to deduct the payment every day until the payment is deducted or until the instance is locked on expiration.
        
        @param request: ModifyInstanceAutoRenewAttributeRequest
        @return: ModifyInstanceAutoRenewAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_instance_auto_renew_attribute_with_options_async(request, runtime)

    def modify_instance_charge_type_with_options(
        self,
        request: ecs_20140526_models.ModifyInstanceChargeTypeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceChargeTypeResponse:
        """
        @summary Changes the billing method of Elastic Compute Service (ECS) instances in batches.
        
        @description ### [](#)Precautions
        Before you call this operation, make sure that you are familiar with the [subscription](https://help.aliyun.com/document_detail/56220.html) and [pay-as-you-go](https://help.aliyun.com/document_detail/40653.html) billing methods and [pricing](https://www.alibabacloud.com/product/ecs#pricing) of ECS.
        The instances must be in the **Running** (`Running`) or **Stopped** (`Stopped`) state, and you have no overdue payments for the instances.
        After you change the billing method, the payment is automatically completed. Make sure that the balance in your account is sufficient. Otherwise, your order becomes invalid and is canceled. If your account balance is insufficient, you can set `AutoPay` to `false` to generate an unpaid order. Then, you can log on to the [ECS console](https://ecs.console.aliyun.com/) to pay for the order.
        ### [](#)Considerations
        **Change the billing method from subscription to pay-as-you-go**:
        After you change the billing method of an instance from subscription to pay-as-you-go, the new billing method remains in effect for the remaining lifecycle of the instance. The price difference is refunded to the payment account that you used. Vouchers that have been redeemed are not refundable.
        **Refund rule**: You have a quota for the total refund amount each month, and unused balance of this quota is not carried forward into the next month. After you use up the refund quota of the current month, you can change the billing method only in the next month. The refund amount incurred when you change the billing method is calculated based on the following formula: **Number of vCPUs × (Number of remaining days × 24 ± Number of remaining or elapsed hours)**. For more information, see [Change the billing method of an instance from subscription to pay-as-you-go](https://help.aliyun.com/document_detail/85517.html).
        **Change the billing method from pay-as-you-go to subscription**:
        You can change the billing method of all data disks attached to an instance from pay-as-you-go to subscription.
        This operation cannot be called for a pay-as-you-go instance that has an automatic release time set. For more information, see [Change the billing method of an instance from subscription to pay-as-you-go](https://help.aliyun.com/document_detail/49884.html).
        
        @param request: ModifyInstanceChargeTypeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceChargeTypeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.include_data_disks):
            query['IncludeDataDisks'] = request.include_data_disks
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.is_detail_fee):
            query['IsDetailFee'] = request.is_detail_fee
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceChargeType',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceChargeTypeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_instance_charge_type_with_options_async(
        self,
        request: ecs_20140526_models.ModifyInstanceChargeTypeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceChargeTypeResponse:
        """
        @summary Changes the billing method of Elastic Compute Service (ECS) instances in batches.
        
        @description ### [](#)Precautions
        Before you call this operation, make sure that you are familiar with the [subscription](https://help.aliyun.com/document_detail/56220.html) and [pay-as-you-go](https://help.aliyun.com/document_detail/40653.html) billing methods and [pricing](https://www.alibabacloud.com/product/ecs#pricing) of ECS.
        The instances must be in the **Running** (`Running`) or **Stopped** (`Stopped`) state, and you have no overdue payments for the instances.
        After you change the billing method, the payment is automatically completed. Make sure that the balance in your account is sufficient. Otherwise, your order becomes invalid and is canceled. If your account balance is insufficient, you can set `AutoPay` to `false` to generate an unpaid order. Then, you can log on to the [ECS console](https://ecs.console.aliyun.com/) to pay for the order.
        ### [](#)Considerations
        **Change the billing method from subscription to pay-as-you-go**:
        After you change the billing method of an instance from subscription to pay-as-you-go, the new billing method remains in effect for the remaining lifecycle of the instance. The price difference is refunded to the payment account that you used. Vouchers that have been redeemed are not refundable.
        **Refund rule**: You have a quota for the total refund amount each month, and unused balance of this quota is not carried forward into the next month. After you use up the refund quota of the current month, you can change the billing method only in the next month. The refund amount incurred when you change the billing method is calculated based on the following formula: **Number of vCPUs × (Number of remaining days × 24 ± Number of remaining or elapsed hours)**. For more information, see [Change the billing method of an instance from subscription to pay-as-you-go](https://help.aliyun.com/document_detail/85517.html).
        **Change the billing method from pay-as-you-go to subscription**:
        You can change the billing method of all data disks attached to an instance from pay-as-you-go to subscription.
        This operation cannot be called for a pay-as-you-go instance that has an automatic release time set. For more information, see [Change the billing method of an instance from subscription to pay-as-you-go](https://help.aliyun.com/document_detail/49884.html).
        
        @param request: ModifyInstanceChargeTypeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceChargeTypeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.include_data_disks):
            query['IncludeDataDisks'] = request.include_data_disks
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.is_detail_fee):
            query['IsDetailFee'] = request.is_detail_fee
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceChargeType',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceChargeTypeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_instance_charge_type(
        self,
        request: ecs_20140526_models.ModifyInstanceChargeTypeRequest,
    ) -> ecs_20140526_models.ModifyInstanceChargeTypeResponse:
        """
        @summary Changes the billing method of Elastic Compute Service (ECS) instances in batches.
        
        @description ### [](#)Precautions
        Before you call this operation, make sure that you are familiar with the [subscription](https://help.aliyun.com/document_detail/56220.html) and [pay-as-you-go](https://help.aliyun.com/document_detail/40653.html) billing methods and [pricing](https://www.alibabacloud.com/product/ecs#pricing) of ECS.
        The instances must be in the **Running** (`Running`) or **Stopped** (`Stopped`) state, and you have no overdue payments for the instances.
        After you change the billing method, the payment is automatically completed. Make sure that the balance in your account is sufficient. Otherwise, your order becomes invalid and is canceled. If your account balance is insufficient, you can set `AutoPay` to `false` to generate an unpaid order. Then, you can log on to the [ECS console](https://ecs.console.aliyun.com/) to pay for the order.
        ### [](#)Considerations
        **Change the billing method from subscription to pay-as-you-go**:
        After you change the billing method of an instance from subscription to pay-as-you-go, the new billing method remains in effect for the remaining lifecycle of the instance. The price difference is refunded to the payment account that you used. Vouchers that have been redeemed are not refundable.
        **Refund rule**: You have a quota for the total refund amount each month, and unused balance of this quota is not carried forward into the next month. After you use up the refund quota of the current month, you can change the billing method only in the next month. The refund amount incurred when you change the billing method is calculated based on the following formula: **Number of vCPUs × (Number of remaining days × 24 ± Number of remaining or elapsed hours)**. For more information, see [Change the billing method of an instance from subscription to pay-as-you-go](https://help.aliyun.com/document_detail/85517.html).
        **Change the billing method from pay-as-you-go to subscription**:
        You can change the billing method of all data disks attached to an instance from pay-as-you-go to subscription.
        This operation cannot be called for a pay-as-you-go instance that has an automatic release time set. For more information, see [Change the billing method of an instance from subscription to pay-as-you-go](https://help.aliyun.com/document_detail/49884.html).
        
        @param request: ModifyInstanceChargeTypeRequest
        @return: ModifyInstanceChargeTypeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_instance_charge_type_with_options(request, runtime)

    async def modify_instance_charge_type_async(
        self,
        request: ecs_20140526_models.ModifyInstanceChargeTypeRequest,
    ) -> ecs_20140526_models.ModifyInstanceChargeTypeResponse:
        """
        @summary Changes the billing method of Elastic Compute Service (ECS) instances in batches.
        
        @description ### [](#)Precautions
        Before you call this operation, make sure that you are familiar with the [subscription](https://help.aliyun.com/document_detail/56220.html) and [pay-as-you-go](https://help.aliyun.com/document_detail/40653.html) billing methods and [pricing](https://www.alibabacloud.com/product/ecs#pricing) of ECS.
        The instances must be in the **Running** (`Running`) or **Stopped** (`Stopped`) state, and you have no overdue payments for the instances.
        After you change the billing method, the payment is automatically completed. Make sure that the balance in your account is sufficient. Otherwise, your order becomes invalid and is canceled. If your account balance is insufficient, you can set `AutoPay` to `false` to generate an unpaid order. Then, you can log on to the [ECS console](https://ecs.console.aliyun.com/) to pay for the order.
        ### [](#)Considerations
        **Change the billing method from subscription to pay-as-you-go**:
        After you change the billing method of an instance from subscription to pay-as-you-go, the new billing method remains in effect for the remaining lifecycle of the instance. The price difference is refunded to the payment account that you used. Vouchers that have been redeemed are not refundable.
        **Refund rule**: You have a quota for the total refund amount each month, and unused balance of this quota is not carried forward into the next month. After you use up the refund quota of the current month, you can change the billing method only in the next month. The refund amount incurred when you change the billing method is calculated based on the following formula: **Number of vCPUs × (Number of remaining days × 24 ± Number of remaining or elapsed hours)**. For more information, see [Change the billing method of an instance from subscription to pay-as-you-go](https://help.aliyun.com/document_detail/85517.html).
        **Change the billing method from pay-as-you-go to subscription**:
        You can change the billing method of all data disks attached to an instance from pay-as-you-go to subscription.
        This operation cannot be called for a pay-as-you-go instance that has an automatic release time set. For more information, see [Change the billing method of an instance from subscription to pay-as-you-go](https://help.aliyun.com/document_detail/49884.html).
        
        @param request: ModifyInstanceChargeTypeRequest
        @return: ModifyInstanceChargeTypeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_instance_charge_type_with_options_async(request, runtime)

    def modify_instance_deployment_with_options(
        self,
        request: ecs_20140526_models.ModifyInstanceDeploymentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceDeploymentResponse:
        """
        @summary Changes the deployment set of an Elastic Compute Service (ECS) instance or migrates an ECS instance to a dedicated host. You can change the instance type of an ECS instance when you migrate the instance.
        
        @description Take note of the following items:
        The instance must be in the **Stopped** (Stopped) state. The instance is automatically restarted after it is migrated.
        The network type of the instance must be Virtual Private Cloud (VPC).
        The instance and the destination dedicated host to which to migrate the instance must belong to the same account and reside in the same region and zone.
        A pay-as-you-go instance can be migrated to a subscription dedicated host. A subscription instance can be migrated only between subscription dedicated hosts. The expiration date of the subscription instance cannot be later than that of the destination dedicated host.
        You can migrate only pay-as-you-go instances from a shared host to a dedicated host. You cannot migrate subscription instances or spot instances from a shared host to a dedicated host.
        You can redeploy an instance to a specific dedicated host cluster.
        
        @param request: ModifyInstanceDeploymentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceDeploymentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.affinity):
            query['Affinity'] = request.affinity
        if not UtilClient.is_unset(request.dedicated_host_cluster_id):
            query['DedicatedHostClusterId'] = request.dedicated_host_cluster_id
        if not UtilClient.is_unset(request.dedicated_host_id):
            query['DedicatedHostId'] = request.dedicated_host_id
        if not UtilClient.is_unset(request.deployment_set_group_no):
            query['DeploymentSetGroupNo'] = request.deployment_set_group_no
        if not UtilClient.is_unset(request.deployment_set_id):
            query['DeploymentSetId'] = request.deployment_set_id
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.migration_type):
            query['MigrationType'] = request.migration_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remove_from_deployment_set):
            query['RemoveFromDeploymentSet'] = request.remove_from_deployment_set
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tenancy):
            query['Tenancy'] = request.tenancy
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceDeployment',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceDeploymentResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_instance_deployment_with_options_async(
        self,
        request: ecs_20140526_models.ModifyInstanceDeploymentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceDeploymentResponse:
        """
        @summary Changes the deployment set of an Elastic Compute Service (ECS) instance or migrates an ECS instance to a dedicated host. You can change the instance type of an ECS instance when you migrate the instance.
        
        @description Take note of the following items:
        The instance must be in the **Stopped** (Stopped) state. The instance is automatically restarted after it is migrated.
        The network type of the instance must be Virtual Private Cloud (VPC).
        The instance and the destination dedicated host to which to migrate the instance must belong to the same account and reside in the same region and zone.
        A pay-as-you-go instance can be migrated to a subscription dedicated host. A subscription instance can be migrated only between subscription dedicated hosts. The expiration date of the subscription instance cannot be later than that of the destination dedicated host.
        You can migrate only pay-as-you-go instances from a shared host to a dedicated host. You cannot migrate subscription instances or spot instances from a shared host to a dedicated host.
        You can redeploy an instance to a specific dedicated host cluster.
        
        @param request: ModifyInstanceDeploymentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceDeploymentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.affinity):
            query['Affinity'] = request.affinity
        if not UtilClient.is_unset(request.dedicated_host_cluster_id):
            query['DedicatedHostClusterId'] = request.dedicated_host_cluster_id
        if not UtilClient.is_unset(request.dedicated_host_id):
            query['DedicatedHostId'] = request.dedicated_host_id
        if not UtilClient.is_unset(request.deployment_set_group_no):
            query['DeploymentSetGroupNo'] = request.deployment_set_group_no
        if not UtilClient.is_unset(request.deployment_set_id):
            query['DeploymentSetId'] = request.deployment_set_id
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.migration_type):
            query['MigrationType'] = request.migration_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remove_from_deployment_set):
            query['RemoveFromDeploymentSet'] = request.remove_from_deployment_set
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tenancy):
            query['Tenancy'] = request.tenancy
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceDeployment',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceDeploymentResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_instance_deployment(
        self,
        request: ecs_20140526_models.ModifyInstanceDeploymentRequest,
    ) -> ecs_20140526_models.ModifyInstanceDeploymentResponse:
        """
        @summary Changes the deployment set of an Elastic Compute Service (ECS) instance or migrates an ECS instance to a dedicated host. You can change the instance type of an ECS instance when you migrate the instance.
        
        @description Take note of the following items:
        The instance must be in the **Stopped** (Stopped) state. The instance is automatically restarted after it is migrated.
        The network type of the instance must be Virtual Private Cloud (VPC).
        The instance and the destination dedicated host to which to migrate the instance must belong to the same account and reside in the same region and zone.
        A pay-as-you-go instance can be migrated to a subscription dedicated host. A subscription instance can be migrated only between subscription dedicated hosts. The expiration date of the subscription instance cannot be later than that of the destination dedicated host.
        You can migrate only pay-as-you-go instances from a shared host to a dedicated host. You cannot migrate subscription instances or spot instances from a shared host to a dedicated host.
        You can redeploy an instance to a specific dedicated host cluster.
        
        @param request: ModifyInstanceDeploymentRequest
        @return: ModifyInstanceDeploymentResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_instance_deployment_with_options(request, runtime)

    async def modify_instance_deployment_async(
        self,
        request: ecs_20140526_models.ModifyInstanceDeploymentRequest,
    ) -> ecs_20140526_models.ModifyInstanceDeploymentResponse:
        """
        @summary Changes the deployment set of an Elastic Compute Service (ECS) instance or migrates an ECS instance to a dedicated host. You can change the instance type of an ECS instance when you migrate the instance.
        
        @description Take note of the following items:
        The instance must be in the **Stopped** (Stopped) state. The instance is automatically restarted after it is migrated.
        The network type of the instance must be Virtual Private Cloud (VPC).
        The instance and the destination dedicated host to which to migrate the instance must belong to the same account and reside in the same region and zone.
        A pay-as-you-go instance can be migrated to a subscription dedicated host. A subscription instance can be migrated only between subscription dedicated hosts. The expiration date of the subscription instance cannot be later than that of the destination dedicated host.
        You can migrate only pay-as-you-go instances from a shared host to a dedicated host. You cannot migrate subscription instances or spot instances from a shared host to a dedicated host.
        You can redeploy an instance to a specific dedicated host cluster.
        
        @param request: ModifyInstanceDeploymentRequest
        @return: ModifyInstanceDeploymentResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_instance_deployment_with_options_async(request, runtime)

    def modify_instance_maintenance_attributes_with_options(
        self,
        request: ecs_20140526_models.ModifyInstanceMaintenanceAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceMaintenanceAttributesResponse:
        """
        @summary Modifies the maintenance attributes of an instance.
        
        @description This operation is used to modify the maintenance policy of an instance. The maintenance policy consists of the following maintenance attributes:
        Maintenance window: the time period that you specify for maintenance.
        Maintenance action: the action that you specify in response to instance shutdown.
        
        @param request: ModifyInstanceMaintenanceAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceMaintenanceAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.action_on_maintenance):
            query['ActionOnMaintenance'] = request.action_on_maintenance
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.maintenance_window):
            query['MaintenanceWindow'] = request.maintenance_window
        if not UtilClient.is_unset(request.notify_on_maintenance):
            query['NotifyOnMaintenance'] = request.notify_on_maintenance
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceMaintenanceAttributes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceMaintenanceAttributesResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_instance_maintenance_attributes_with_options_async(
        self,
        request: ecs_20140526_models.ModifyInstanceMaintenanceAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceMaintenanceAttributesResponse:
        """
        @summary Modifies the maintenance attributes of an instance.
        
        @description This operation is used to modify the maintenance policy of an instance. The maintenance policy consists of the following maintenance attributes:
        Maintenance window: the time period that you specify for maintenance.
        Maintenance action: the action that you specify in response to instance shutdown.
        
        @param request: ModifyInstanceMaintenanceAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceMaintenanceAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.action_on_maintenance):
            query['ActionOnMaintenance'] = request.action_on_maintenance
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.maintenance_window):
            query['MaintenanceWindow'] = request.maintenance_window
        if not UtilClient.is_unset(request.notify_on_maintenance):
            query['NotifyOnMaintenance'] = request.notify_on_maintenance
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceMaintenanceAttributes',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceMaintenanceAttributesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_instance_maintenance_attributes(
        self,
        request: ecs_20140526_models.ModifyInstanceMaintenanceAttributesRequest,
    ) -> ecs_20140526_models.ModifyInstanceMaintenanceAttributesResponse:
        """
        @summary Modifies the maintenance attributes of an instance.
        
        @description This operation is used to modify the maintenance policy of an instance. The maintenance policy consists of the following maintenance attributes:
        Maintenance window: the time period that you specify for maintenance.
        Maintenance action: the action that you specify in response to instance shutdown.
        
        @param request: ModifyInstanceMaintenanceAttributesRequest
        @return: ModifyInstanceMaintenanceAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_instance_maintenance_attributes_with_options(request, runtime)

    async def modify_instance_maintenance_attributes_async(
        self,
        request: ecs_20140526_models.ModifyInstanceMaintenanceAttributesRequest,
    ) -> ecs_20140526_models.ModifyInstanceMaintenanceAttributesResponse:
        """
        @summary Modifies the maintenance attributes of an instance.
        
        @description This operation is used to modify the maintenance policy of an instance. The maintenance policy consists of the following maintenance attributes:
        Maintenance window: the time period that you specify for maintenance.
        Maintenance action: the action that you specify in response to instance shutdown.
        
        @param request: ModifyInstanceMaintenanceAttributesRequest
        @return: ModifyInstanceMaintenanceAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_instance_maintenance_attributes_with_options_async(request, runtime)

    def modify_instance_metadata_options_with_options(
        self,
        request: ecs_20140526_models.ModifyInstanceMetadataOptionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceMetadataOptionsResponse:
        """
        @summary Modifies the metadata access configurations of instances in a specific region, including whether to enable the metadata access channel and whether to forcefully use the security hardening mode to access instance metadata.
        
        @param request: ModifyInstanceMetadataOptionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceMetadataOptionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.http_endpoint):
            query['HttpEndpoint'] = request.http_endpoint
        if not UtilClient.is_unset(request.http_put_response_hop_limit):
            query['HttpPutResponseHopLimit'] = request.http_put_response_hop_limit
        if not UtilClient.is_unset(request.http_tokens):
            query['HttpTokens'] = request.http_tokens
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_metadata_tags):
            query['InstanceMetadataTags'] = request.instance_metadata_tags
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceMetadataOptions',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceMetadataOptionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_instance_metadata_options_with_options_async(
        self,
        request: ecs_20140526_models.ModifyInstanceMetadataOptionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceMetadataOptionsResponse:
        """
        @summary Modifies the metadata access configurations of instances in a specific region, including whether to enable the metadata access channel and whether to forcefully use the security hardening mode to access instance metadata.
        
        @param request: ModifyInstanceMetadataOptionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceMetadataOptionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.http_endpoint):
            query['HttpEndpoint'] = request.http_endpoint
        if not UtilClient.is_unset(request.http_put_response_hop_limit):
            query['HttpPutResponseHopLimit'] = request.http_put_response_hop_limit
        if not UtilClient.is_unset(request.http_tokens):
            query['HttpTokens'] = request.http_tokens
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_metadata_tags):
            query['InstanceMetadataTags'] = request.instance_metadata_tags
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceMetadataOptions',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceMetadataOptionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_instance_metadata_options(
        self,
        request: ecs_20140526_models.ModifyInstanceMetadataOptionsRequest,
    ) -> ecs_20140526_models.ModifyInstanceMetadataOptionsResponse:
        """
        @summary Modifies the metadata access configurations of instances in a specific region, including whether to enable the metadata access channel and whether to forcefully use the security hardening mode to access instance metadata.
        
        @param request: ModifyInstanceMetadataOptionsRequest
        @return: ModifyInstanceMetadataOptionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_instance_metadata_options_with_options(request, runtime)

    async def modify_instance_metadata_options_async(
        self,
        request: ecs_20140526_models.ModifyInstanceMetadataOptionsRequest,
    ) -> ecs_20140526_models.ModifyInstanceMetadataOptionsResponse:
        """
        @summary Modifies the metadata access configurations of instances in a specific region, including whether to enable the metadata access channel and whether to forcefully use the security hardening mode to access instance metadata.
        
        @param request: ModifyInstanceMetadataOptionsRequest
        @return: ModifyInstanceMetadataOptionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_instance_metadata_options_with_options_async(request, runtime)

    def modify_instance_network_options_with_options(
        self,
        request: ecs_20140526_models.ModifyInstanceNetworkOptionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceNetworkOptionsResponse:
        """
        @summary 修改实例网络选项
        
        @param request: ModifyInstanceNetworkOptionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceNetworkOptionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_weighting):
            query['BandwidthWeighting'] = request.bandwidth_weighting
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceNetworkOptions',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceNetworkOptionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_instance_network_options_with_options_async(
        self,
        request: ecs_20140526_models.ModifyInstanceNetworkOptionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceNetworkOptionsResponse:
        """
        @summary 修改实例网络选项
        
        @param request: ModifyInstanceNetworkOptionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceNetworkOptionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_weighting):
            query['BandwidthWeighting'] = request.bandwidth_weighting
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceNetworkOptions',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceNetworkOptionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_instance_network_options(
        self,
        request: ecs_20140526_models.ModifyInstanceNetworkOptionsRequest,
    ) -> ecs_20140526_models.ModifyInstanceNetworkOptionsResponse:
        """
        @summary 修改实例网络选项
        
        @param request: ModifyInstanceNetworkOptionsRequest
        @return: ModifyInstanceNetworkOptionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_instance_network_options_with_options(request, runtime)

    async def modify_instance_network_options_async(
        self,
        request: ecs_20140526_models.ModifyInstanceNetworkOptionsRequest,
    ) -> ecs_20140526_models.ModifyInstanceNetworkOptionsResponse:
        """
        @summary 修改实例网络选项
        
        @param request: ModifyInstanceNetworkOptionsRequest
        @return: ModifyInstanceNetworkOptionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_instance_network_options_with_options_async(request, runtime)

    def modify_instance_network_spec_with_options(
        self,
        request: ecs_20140526_models.ModifyInstanceNetworkSpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceNetworkSpecResponse:
        """
        @summary Modifies the network configurations of an Elastic Compute Service (ECS) instance, such as the public bandwidth, assignment or unassignment of a static public IP address (also known as system-assigned or auto-assigned public IP address), and billing method for network usage. You can call this operation to upgrade or downgrade the network configurations of ECS instances.
        
        @description Take note of the following items:
        If you upgrade the outbound public bandwidth (InternetMaxBandwidthOut) of a subscription (PrePaid) instance from 0 Mbit/s when you modify the network configurations of the instance, a static public IP address is automatically assigned to the instance.
        If you upgrade the outbound public bandwidth (InternetMaxBandwidthOut) of a pay-as-you-go (PostPaid) instance from 0 Mbit/s when you modify the network configurations of the instance, no static public IP address is automatically assigned to the instance. In this case, to assign a static public IP address to the instance, you must set `AllocatePublicIp` to `true`.
        You can upgrade the outbound public bandwidth (InternetMaxBandwidthOut) of an instance in the classic network from 0 Mbit/s only if the instance is in the Stopped state.
        >  For the limits on the sum of maximum public bandwidths of ECS instances that use the pay-by-bandwidth billing method for network usage per region per Alibaba Cloud account, see the [Public bandwidth limits](~~25412#BandwidthQuota~~) section of the "Limits" topic.
        Billing:
        After the public bandwidth is upgraded, AutoPay is automatically set to true and the payment is automatically made. Make sure that your account balance is sufficient. Otherwise, your order becomes invalid and is canceled. If your account balance is insufficient, you can set AutoPay to false. In this case, when you call the ModifyInstanceNetworkSpec operation, an unpaid order is generated. Then, you can log on to the ECS console to pay for the order.
        After the public bandwidth is downgraded, the price difference is refunded to the payment account that you used. Vouchers or coupons that have been redeemed are not refundable.
        
        @param request: ModifyInstanceNetworkSpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceNetworkSpecResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocate_public_ip):
            query['AllocatePublicIp'] = request.allocate_public_ip
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.isp):
            query['ISP'] = request.isp
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.internet_max_bandwidth_in):
            query['InternetMaxBandwidthIn'] = request.internet_max_bandwidth_in
        if not UtilClient.is_unset(request.internet_max_bandwidth_out):
            query['InternetMaxBandwidthOut'] = request.internet_max_bandwidth_out
        if not UtilClient.is_unset(request.network_charge_type):
            query['NetworkChargeType'] = request.network_charge_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceNetworkSpec',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceNetworkSpecResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_instance_network_spec_with_options_async(
        self,
        request: ecs_20140526_models.ModifyInstanceNetworkSpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceNetworkSpecResponse:
        """
        @summary Modifies the network configurations of an Elastic Compute Service (ECS) instance, such as the public bandwidth, assignment or unassignment of a static public IP address (also known as system-assigned or auto-assigned public IP address), and billing method for network usage. You can call this operation to upgrade or downgrade the network configurations of ECS instances.
        
        @description Take note of the following items:
        If you upgrade the outbound public bandwidth (InternetMaxBandwidthOut) of a subscription (PrePaid) instance from 0 Mbit/s when you modify the network configurations of the instance, a static public IP address is automatically assigned to the instance.
        If you upgrade the outbound public bandwidth (InternetMaxBandwidthOut) of a pay-as-you-go (PostPaid) instance from 0 Mbit/s when you modify the network configurations of the instance, no static public IP address is automatically assigned to the instance. In this case, to assign a static public IP address to the instance, you must set `AllocatePublicIp` to `true`.
        You can upgrade the outbound public bandwidth (InternetMaxBandwidthOut) of an instance in the classic network from 0 Mbit/s only if the instance is in the Stopped state.
        >  For the limits on the sum of maximum public bandwidths of ECS instances that use the pay-by-bandwidth billing method for network usage per region per Alibaba Cloud account, see the [Public bandwidth limits](~~25412#BandwidthQuota~~) section of the "Limits" topic.
        Billing:
        After the public bandwidth is upgraded, AutoPay is automatically set to true and the payment is automatically made. Make sure that your account balance is sufficient. Otherwise, your order becomes invalid and is canceled. If your account balance is insufficient, you can set AutoPay to false. In this case, when you call the ModifyInstanceNetworkSpec operation, an unpaid order is generated. Then, you can log on to the ECS console to pay for the order.
        After the public bandwidth is downgraded, the price difference is refunded to the payment account that you used. Vouchers or coupons that have been redeemed are not refundable.
        
        @param request: ModifyInstanceNetworkSpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceNetworkSpecResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocate_public_ip):
            query['AllocatePublicIp'] = request.allocate_public_ip
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.isp):
            query['ISP'] = request.isp
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.internet_max_bandwidth_in):
            query['InternetMaxBandwidthIn'] = request.internet_max_bandwidth_in
        if not UtilClient.is_unset(request.internet_max_bandwidth_out):
            query['InternetMaxBandwidthOut'] = request.internet_max_bandwidth_out
        if not UtilClient.is_unset(request.network_charge_type):
            query['NetworkChargeType'] = request.network_charge_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceNetworkSpec',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceNetworkSpecResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_instance_network_spec(
        self,
        request: ecs_20140526_models.ModifyInstanceNetworkSpecRequest,
    ) -> ecs_20140526_models.ModifyInstanceNetworkSpecResponse:
        """
        @summary Modifies the network configurations of an Elastic Compute Service (ECS) instance, such as the public bandwidth, assignment or unassignment of a static public IP address (also known as system-assigned or auto-assigned public IP address), and billing method for network usage. You can call this operation to upgrade or downgrade the network configurations of ECS instances.
        
        @description Take note of the following items:
        If you upgrade the outbound public bandwidth (InternetMaxBandwidthOut) of a subscription (PrePaid) instance from 0 Mbit/s when you modify the network configurations of the instance, a static public IP address is automatically assigned to the instance.
        If you upgrade the outbound public bandwidth (InternetMaxBandwidthOut) of a pay-as-you-go (PostPaid) instance from 0 Mbit/s when you modify the network configurations of the instance, no static public IP address is automatically assigned to the instance. In this case, to assign a static public IP address to the instance, you must set `AllocatePublicIp` to `true`.
        You can upgrade the outbound public bandwidth (InternetMaxBandwidthOut) of an instance in the classic network from 0 Mbit/s only if the instance is in the Stopped state.
        >  For the limits on the sum of maximum public bandwidths of ECS instances that use the pay-by-bandwidth billing method for network usage per region per Alibaba Cloud account, see the [Public bandwidth limits](~~25412#BandwidthQuota~~) section of the "Limits" topic.
        Billing:
        After the public bandwidth is upgraded, AutoPay is automatically set to true and the payment is automatically made. Make sure that your account balance is sufficient. Otherwise, your order becomes invalid and is canceled. If your account balance is insufficient, you can set AutoPay to false. In this case, when you call the ModifyInstanceNetworkSpec operation, an unpaid order is generated. Then, you can log on to the ECS console to pay for the order.
        After the public bandwidth is downgraded, the price difference is refunded to the payment account that you used. Vouchers or coupons that have been redeemed are not refundable.
        
        @param request: ModifyInstanceNetworkSpecRequest
        @return: ModifyInstanceNetworkSpecResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_instance_network_spec_with_options(request, runtime)

    async def modify_instance_network_spec_async(
        self,
        request: ecs_20140526_models.ModifyInstanceNetworkSpecRequest,
    ) -> ecs_20140526_models.ModifyInstanceNetworkSpecResponse:
        """
        @summary Modifies the network configurations of an Elastic Compute Service (ECS) instance, such as the public bandwidth, assignment or unassignment of a static public IP address (also known as system-assigned or auto-assigned public IP address), and billing method for network usage. You can call this operation to upgrade or downgrade the network configurations of ECS instances.
        
        @description Take note of the following items:
        If you upgrade the outbound public bandwidth (InternetMaxBandwidthOut) of a subscription (PrePaid) instance from 0 Mbit/s when you modify the network configurations of the instance, a static public IP address is automatically assigned to the instance.
        If you upgrade the outbound public bandwidth (InternetMaxBandwidthOut) of a pay-as-you-go (PostPaid) instance from 0 Mbit/s when you modify the network configurations of the instance, no static public IP address is automatically assigned to the instance. In this case, to assign a static public IP address to the instance, you must set `AllocatePublicIp` to `true`.
        You can upgrade the outbound public bandwidth (InternetMaxBandwidthOut) of an instance in the classic network from 0 Mbit/s only if the instance is in the Stopped state.
        >  For the limits on the sum of maximum public bandwidths of ECS instances that use the pay-by-bandwidth billing method for network usage per region per Alibaba Cloud account, see the [Public bandwidth limits](~~25412#BandwidthQuota~~) section of the "Limits" topic.
        Billing:
        After the public bandwidth is upgraded, AutoPay is automatically set to true and the payment is automatically made. Make sure that your account balance is sufficient. Otherwise, your order becomes invalid and is canceled. If your account balance is insufficient, you can set AutoPay to false. In this case, when you call the ModifyInstanceNetworkSpec operation, an unpaid order is generated. Then, you can log on to the ECS console to pay for the order.
        After the public bandwidth is downgraded, the price difference is refunded to the payment account that you used. Vouchers or coupons that have been redeemed are not refundable.
        
        @param request: ModifyInstanceNetworkSpecRequest
        @return: ModifyInstanceNetworkSpecResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_instance_network_spec_with_options_async(request, runtime)

    def modify_instance_spec_with_options(
        self,
        request: ecs_20140526_models.ModifyInstanceSpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceSpecResponse:
        """
        @summary Changes the instance type or public bandwidth of a pay-as-you-go Elastic Compute Service (ECS) instance.
        
        @description *Before you call this operation, familiarize yourself with the billing and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of ECS resources.**\
        Before you [change the instance type of a pay-as-you-go instance](https://help.aliyun.com/document_detail/60051.html), call the [DescribeResourcesModification](https://help.aliyun.com/document_detail/66187.html) operation to query compatible instance types.
        *Considerations**\
        Make sure that you have no overdue payments in your account.
        You can change only the instance type or only the public bandwidth of an ECS instance at a time. The instance type and the public bandwidth of an ECS instance cannot be changed together.
        You can change the public bandwidth of an ECS instance only when the instance is in the **Running** (`Running`) or **Stopped** (`Stopped`) state. The change immediately takes effect.
        You can change the instance type of an ECS instance only when the instance is in the **Stopped** (`Stopped`) state. You must [start the instance](https://help.aliyun.com/document_detail/25441.html) for the change to take effect.
        >  A limit is imposed on the sum of public bandwidths of all ECS instances that use the pay-by-bandwidth billing method for network usage per region in an Alibaba Cloud account. For more information, see the [Public bandwidth limits](~~25412#BandwidthQuota~~) section of the "Limits and quotas" topic.
        
        @param request: ModifyInstanceSpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceSpecResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allow_migrate_across_zone):
            query['AllowMigrateAcrossZone'] = request.allow_migrate_across_zone
        if not UtilClient.is_unset(request.async_):
            query['Async'] = request.async_
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.disk):
            query['Disk'] = request.disk
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.internet_max_bandwidth_in):
            query['InternetMaxBandwidthIn'] = request.internet_max_bandwidth_in
        if not UtilClient.is_unset(request.internet_max_bandwidth_out):
            query['InternetMaxBandwidthOut'] = request.internet_max_bandwidth_out
        if not UtilClient.is_unset(request.modify_mode):
            query['ModifyMode'] = request.modify_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.system_disk):
            query['SystemDisk'] = request.system_disk
        if not UtilClient.is_unset(request.temporary):
            query['Temporary'] = request.temporary
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceSpec',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceSpecResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_instance_spec_with_options_async(
        self,
        request: ecs_20140526_models.ModifyInstanceSpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceSpecResponse:
        """
        @summary Changes the instance type or public bandwidth of a pay-as-you-go Elastic Compute Service (ECS) instance.
        
        @description *Before you call this operation, familiarize yourself with the billing and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of ECS resources.**\
        Before you [change the instance type of a pay-as-you-go instance](https://help.aliyun.com/document_detail/60051.html), call the [DescribeResourcesModification](https://help.aliyun.com/document_detail/66187.html) operation to query compatible instance types.
        *Considerations**\
        Make sure that you have no overdue payments in your account.
        You can change only the instance type or only the public bandwidth of an ECS instance at a time. The instance type and the public bandwidth of an ECS instance cannot be changed together.
        You can change the public bandwidth of an ECS instance only when the instance is in the **Running** (`Running`) or **Stopped** (`Stopped`) state. The change immediately takes effect.
        You can change the instance type of an ECS instance only when the instance is in the **Stopped** (`Stopped`) state. You must [start the instance](https://help.aliyun.com/document_detail/25441.html) for the change to take effect.
        >  A limit is imposed on the sum of public bandwidths of all ECS instances that use the pay-by-bandwidth billing method for network usage per region in an Alibaba Cloud account. For more information, see the [Public bandwidth limits](~~25412#BandwidthQuota~~) section of the "Limits and quotas" topic.
        
        @param request: ModifyInstanceSpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceSpecResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allow_migrate_across_zone):
            query['AllowMigrateAcrossZone'] = request.allow_migrate_across_zone
        if not UtilClient.is_unset(request.async_):
            query['Async'] = request.async_
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.disk):
            query['Disk'] = request.disk
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.internet_max_bandwidth_in):
            query['InternetMaxBandwidthIn'] = request.internet_max_bandwidth_in
        if not UtilClient.is_unset(request.internet_max_bandwidth_out):
            query['InternetMaxBandwidthOut'] = request.internet_max_bandwidth_out
        if not UtilClient.is_unset(request.modify_mode):
            query['ModifyMode'] = request.modify_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.system_disk):
            query['SystemDisk'] = request.system_disk
        if not UtilClient.is_unset(request.temporary):
            query['Temporary'] = request.temporary
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceSpec',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceSpecResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_instance_spec(
        self,
        request: ecs_20140526_models.ModifyInstanceSpecRequest,
    ) -> ecs_20140526_models.ModifyInstanceSpecResponse:
        """
        @summary Changes the instance type or public bandwidth of a pay-as-you-go Elastic Compute Service (ECS) instance.
        
        @description *Before you call this operation, familiarize yourself with the billing and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of ECS resources.**\
        Before you [change the instance type of a pay-as-you-go instance](https://help.aliyun.com/document_detail/60051.html), call the [DescribeResourcesModification](https://help.aliyun.com/document_detail/66187.html) operation to query compatible instance types.
        *Considerations**\
        Make sure that you have no overdue payments in your account.
        You can change only the instance type or only the public bandwidth of an ECS instance at a time. The instance type and the public bandwidth of an ECS instance cannot be changed together.
        You can change the public bandwidth of an ECS instance only when the instance is in the **Running** (`Running`) or **Stopped** (`Stopped`) state. The change immediately takes effect.
        You can change the instance type of an ECS instance only when the instance is in the **Stopped** (`Stopped`) state. You must [start the instance](https://help.aliyun.com/document_detail/25441.html) for the change to take effect.
        >  A limit is imposed on the sum of public bandwidths of all ECS instances that use the pay-by-bandwidth billing method for network usage per region in an Alibaba Cloud account. For more information, see the [Public bandwidth limits](~~25412#BandwidthQuota~~) section of the "Limits and quotas" topic.
        
        @param request: ModifyInstanceSpecRequest
        @return: ModifyInstanceSpecResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_instance_spec_with_options(request, runtime)

    async def modify_instance_spec_async(
        self,
        request: ecs_20140526_models.ModifyInstanceSpecRequest,
    ) -> ecs_20140526_models.ModifyInstanceSpecResponse:
        """
        @summary Changes the instance type or public bandwidth of a pay-as-you-go Elastic Compute Service (ECS) instance.
        
        @description *Before you call this operation, familiarize yourself with the billing and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of ECS resources.**\
        Before you [change the instance type of a pay-as-you-go instance](https://help.aliyun.com/document_detail/60051.html), call the [DescribeResourcesModification](https://help.aliyun.com/document_detail/66187.html) operation to query compatible instance types.
        *Considerations**\
        Make sure that you have no overdue payments in your account.
        You can change only the instance type or only the public bandwidth of an ECS instance at a time. The instance type and the public bandwidth of an ECS instance cannot be changed together.
        You can change the public bandwidth of an ECS instance only when the instance is in the **Running** (`Running`) or **Stopped** (`Stopped`) state. The change immediately takes effect.
        You can change the instance type of an ECS instance only when the instance is in the **Stopped** (`Stopped`) state. You must [start the instance](https://help.aliyun.com/document_detail/25441.html) for the change to take effect.
        >  A limit is imposed on the sum of public bandwidths of all ECS instances that use the pay-by-bandwidth billing method for network usage per region in an Alibaba Cloud account. For more information, see the [Public bandwidth limits](~~25412#BandwidthQuota~~) section of the "Limits and quotas" topic.
        
        @param request: ModifyInstanceSpecRequest
        @return: ModifyInstanceSpecResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_instance_spec_with_options_async(request, runtime)

    def modify_instance_vnc_passwd_with_options(
        self,
        request: ecs_20140526_models.ModifyInstanceVncPasswdRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceVncPasswdResponse:
        """
        @summary Changes the Virtual Network Computing (VNC) password of an Elastic Compute Service (ECS) instance.
        
        @description    The VNC password must be six characters in length and can contain uppercase letters, lowercase letters, and digits.
        After you modify the VNC password of an ECS instance, take note of the following items:
        If the instance is I/O optimized, the new password takes effect immediately without the need to restart the instance.
        If the instance is not I/O optimized, you must [restart the instance](https://help.aliyun.com/document_detail/25440.html) in the ECS console or by calling the [RebootInstance](https://help.aliyun.com/document_detail/25502.html) operation for the new password to take effect.
        
        @param request: ModifyInstanceVncPasswdRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceVncPasswdResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vnc_password):
            query['VncPassword'] = request.vnc_password
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceVncPasswd',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceVncPasswdResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_instance_vnc_passwd_with_options_async(
        self,
        request: ecs_20140526_models.ModifyInstanceVncPasswdRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceVncPasswdResponse:
        """
        @summary Changes the Virtual Network Computing (VNC) password of an Elastic Compute Service (ECS) instance.
        
        @description    The VNC password must be six characters in length and can contain uppercase letters, lowercase letters, and digits.
        After you modify the VNC password of an ECS instance, take note of the following items:
        If the instance is I/O optimized, the new password takes effect immediately without the need to restart the instance.
        If the instance is not I/O optimized, you must [restart the instance](https://help.aliyun.com/document_detail/25440.html) in the ECS console or by calling the [RebootInstance](https://help.aliyun.com/document_detail/25502.html) operation for the new password to take effect.
        
        @param request: ModifyInstanceVncPasswdRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceVncPasswdResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vnc_password):
            query['VncPassword'] = request.vnc_password
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceVncPasswd',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceVncPasswdResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_instance_vnc_passwd(
        self,
        request: ecs_20140526_models.ModifyInstanceVncPasswdRequest,
    ) -> ecs_20140526_models.ModifyInstanceVncPasswdResponse:
        """
        @summary Changes the Virtual Network Computing (VNC) password of an Elastic Compute Service (ECS) instance.
        
        @description    The VNC password must be six characters in length and can contain uppercase letters, lowercase letters, and digits.
        After you modify the VNC password of an ECS instance, take note of the following items:
        If the instance is I/O optimized, the new password takes effect immediately without the need to restart the instance.
        If the instance is not I/O optimized, you must [restart the instance](https://help.aliyun.com/document_detail/25440.html) in the ECS console or by calling the [RebootInstance](https://help.aliyun.com/document_detail/25502.html) operation for the new password to take effect.
        
        @param request: ModifyInstanceVncPasswdRequest
        @return: ModifyInstanceVncPasswdResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_instance_vnc_passwd_with_options(request, runtime)

    async def modify_instance_vnc_passwd_async(
        self,
        request: ecs_20140526_models.ModifyInstanceVncPasswdRequest,
    ) -> ecs_20140526_models.ModifyInstanceVncPasswdResponse:
        """
        @summary Changes the Virtual Network Computing (VNC) password of an Elastic Compute Service (ECS) instance.
        
        @description    The VNC password must be six characters in length and can contain uppercase letters, lowercase letters, and digits.
        After you modify the VNC password of an ECS instance, take note of the following items:
        If the instance is I/O optimized, the new password takes effect immediately without the need to restart the instance.
        If the instance is not I/O optimized, you must [restart the instance](https://help.aliyun.com/document_detail/25440.html) in the ECS console or by calling the [RebootInstance](https://help.aliyun.com/document_detail/25502.html) operation for the new password to take effect.
        
        @param request: ModifyInstanceVncPasswdRequest
        @return: ModifyInstanceVncPasswdResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_instance_vnc_passwd_with_options_async(request, runtime)

    def modify_instance_vpc_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyInstanceVpcAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceVpcAttributeResponse:
        """
        @summary Changes the virtual private cloud (VPC), private IP address, security groups, or vSwitch of an Elastic Compute Service (ECS) instance located in a VPC.
        
        @description The ECS instance that you want to manage must be in the *Stopped** (`Stopped`) state.
        When you call this operation to change the private IP address or vSwitch of an ECS instance, take note of the following items:
        If the instance is a new instance, you must restart the instance before you call this operation.
        After the private IP address or vSwitch of the instance is changed, you must restart the instance before you can recall this operation.
        When you call this operation to change the VPC of an ECS instance, take note of the following items:
        **ECS instance:**\
        The instance cannot be in the Locked, To Be Released, Expired, To Be Recycled, Expired and Being Recycled, or Overdue and Being Recycled state. For more information, see [Overview of instances](https://help.aliyun.com/document_detail/25380.html).
        The instance cannot be associated with Server Load Balancer (SLB) instances.
        The instance cannot be used in other Alibaba Cloud services. For example, the instance cannot be in the process of being migrated or having its VPC changed, or the databases deployed on the instance cannot be managed by Data Transmission Service (DTS).
        **Network:**\
        The cut-through mode or the multi-elastic IP address (EIP)-to-elastic network interface (ENI) mode cannot be enabled for the ECS instance.
        The ECS instance cannot be associated with a high-availability virtual IP address (HAVIP).
        The vSwitch of the ECS instance cannot be associated with a custom route table.
        Global Accelerator (GA) cannot be activated for the ECS instance.
        Secondary ENIs cannot be attached to the ECS instance.
        The ECS instance cannot be assigned an IPv6 address.
        The primary ENI of the ECS instance cannot be associated with multiple IP addresses.
        The vSwitch must belong to the new VPC.
        The original and new vSwitches must reside in the same zone.
        If you assign a private IP address to the primary ENI of the ECS instance, the private IP address must be an idle IP address within the CIDR block of the new vSwitch. If you do not assign a private IP address to the primary ENI of the ECS instance, a private IP address is randomly assigned to the ENI. Make sure that sufficient IP addresses are available in the CIDR block of the new vSwitch.
        If you use a VPC that is shared by another Alibaba Cloud account with your account and want to change the security groups of the ECS instance, specify the security groups that you created in the VPC, instead of the security group created by the VPC owner, as the new security groups.
        
        @param request: ModifyInstanceVpcAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceVpcAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceVpcAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceVpcAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_instance_vpc_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyInstanceVpcAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInstanceVpcAttributeResponse:
        """
        @summary Changes the virtual private cloud (VPC), private IP address, security groups, or vSwitch of an Elastic Compute Service (ECS) instance located in a VPC.
        
        @description The ECS instance that you want to manage must be in the *Stopped** (`Stopped`) state.
        When you call this operation to change the private IP address or vSwitch of an ECS instance, take note of the following items:
        If the instance is a new instance, you must restart the instance before you call this operation.
        After the private IP address or vSwitch of the instance is changed, you must restart the instance before you can recall this operation.
        When you call this operation to change the VPC of an ECS instance, take note of the following items:
        **ECS instance:**\
        The instance cannot be in the Locked, To Be Released, Expired, To Be Recycled, Expired and Being Recycled, or Overdue and Being Recycled state. For more information, see [Overview of instances](https://help.aliyun.com/document_detail/25380.html).
        The instance cannot be associated with Server Load Balancer (SLB) instances.
        The instance cannot be used in other Alibaba Cloud services. For example, the instance cannot be in the process of being migrated or having its VPC changed, or the databases deployed on the instance cannot be managed by Data Transmission Service (DTS).
        **Network:**\
        The cut-through mode or the multi-elastic IP address (EIP)-to-elastic network interface (ENI) mode cannot be enabled for the ECS instance.
        The ECS instance cannot be associated with a high-availability virtual IP address (HAVIP).
        The vSwitch of the ECS instance cannot be associated with a custom route table.
        Global Accelerator (GA) cannot be activated for the ECS instance.
        Secondary ENIs cannot be attached to the ECS instance.
        The ECS instance cannot be assigned an IPv6 address.
        The primary ENI of the ECS instance cannot be associated with multiple IP addresses.
        The vSwitch must belong to the new VPC.
        The original and new vSwitches must reside in the same zone.
        If you assign a private IP address to the primary ENI of the ECS instance, the private IP address must be an idle IP address within the CIDR block of the new vSwitch. If you do not assign a private IP address to the primary ENI of the ECS instance, a private IP address is randomly assigned to the ENI. Make sure that sufficient IP addresses are available in the CIDR block of the new vSwitch.
        If you use a VPC that is shared by another Alibaba Cloud account with your account and want to change the security groups of the ECS instance, specify the security groups that you created in the VPC, instead of the security group created by the VPC owner, as the new security groups.
        
        @param request: ModifyInstanceVpcAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceVpcAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstanceVpcAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInstanceVpcAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_instance_vpc_attribute(
        self,
        request: ecs_20140526_models.ModifyInstanceVpcAttributeRequest,
    ) -> ecs_20140526_models.ModifyInstanceVpcAttributeResponse:
        """
        @summary Changes the virtual private cloud (VPC), private IP address, security groups, or vSwitch of an Elastic Compute Service (ECS) instance located in a VPC.
        
        @description The ECS instance that you want to manage must be in the *Stopped** (`Stopped`) state.
        When you call this operation to change the private IP address or vSwitch of an ECS instance, take note of the following items:
        If the instance is a new instance, you must restart the instance before you call this operation.
        After the private IP address or vSwitch of the instance is changed, you must restart the instance before you can recall this operation.
        When you call this operation to change the VPC of an ECS instance, take note of the following items:
        **ECS instance:**\
        The instance cannot be in the Locked, To Be Released, Expired, To Be Recycled, Expired and Being Recycled, or Overdue and Being Recycled state. For more information, see [Overview of instances](https://help.aliyun.com/document_detail/25380.html).
        The instance cannot be associated with Server Load Balancer (SLB) instances.
        The instance cannot be used in other Alibaba Cloud services. For example, the instance cannot be in the process of being migrated or having its VPC changed, or the databases deployed on the instance cannot be managed by Data Transmission Service (DTS).
        **Network:**\
        The cut-through mode or the multi-elastic IP address (EIP)-to-elastic network interface (ENI) mode cannot be enabled for the ECS instance.
        The ECS instance cannot be associated with a high-availability virtual IP address (HAVIP).
        The vSwitch of the ECS instance cannot be associated with a custom route table.
        Global Accelerator (GA) cannot be activated for the ECS instance.
        Secondary ENIs cannot be attached to the ECS instance.
        The ECS instance cannot be assigned an IPv6 address.
        The primary ENI of the ECS instance cannot be associated with multiple IP addresses.
        The vSwitch must belong to the new VPC.
        The original and new vSwitches must reside in the same zone.
        If you assign a private IP address to the primary ENI of the ECS instance, the private IP address must be an idle IP address within the CIDR block of the new vSwitch. If you do not assign a private IP address to the primary ENI of the ECS instance, a private IP address is randomly assigned to the ENI. Make sure that sufficient IP addresses are available in the CIDR block of the new vSwitch.
        If you use a VPC that is shared by another Alibaba Cloud account with your account and want to change the security groups of the ECS instance, specify the security groups that you created in the VPC, instead of the security group created by the VPC owner, as the new security groups.
        
        @param request: ModifyInstanceVpcAttributeRequest
        @return: ModifyInstanceVpcAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_instance_vpc_attribute_with_options(request, runtime)

    async def modify_instance_vpc_attribute_async(
        self,
        request: ecs_20140526_models.ModifyInstanceVpcAttributeRequest,
    ) -> ecs_20140526_models.ModifyInstanceVpcAttributeResponse:
        """
        @summary Changes the virtual private cloud (VPC), private IP address, security groups, or vSwitch of an Elastic Compute Service (ECS) instance located in a VPC.
        
        @description The ECS instance that you want to manage must be in the *Stopped** (`Stopped`) state.
        When you call this operation to change the private IP address or vSwitch of an ECS instance, take note of the following items:
        If the instance is a new instance, you must restart the instance before you call this operation.
        After the private IP address or vSwitch of the instance is changed, you must restart the instance before you can recall this operation.
        When you call this operation to change the VPC of an ECS instance, take note of the following items:
        **ECS instance:**\
        The instance cannot be in the Locked, To Be Released, Expired, To Be Recycled, Expired and Being Recycled, or Overdue and Being Recycled state. For more information, see [Overview of instances](https://help.aliyun.com/document_detail/25380.html).
        The instance cannot be associated with Server Load Balancer (SLB) instances.
        The instance cannot be used in other Alibaba Cloud services. For example, the instance cannot be in the process of being migrated or having its VPC changed, or the databases deployed on the instance cannot be managed by Data Transmission Service (DTS).
        **Network:**\
        The cut-through mode or the multi-elastic IP address (EIP)-to-elastic network interface (ENI) mode cannot be enabled for the ECS instance.
        The ECS instance cannot be associated with a high-availability virtual IP address (HAVIP).
        The vSwitch of the ECS instance cannot be associated with a custom route table.
        Global Accelerator (GA) cannot be activated for the ECS instance.
        Secondary ENIs cannot be attached to the ECS instance.
        The ECS instance cannot be assigned an IPv6 address.
        The primary ENI of the ECS instance cannot be associated with multiple IP addresses.
        The vSwitch must belong to the new VPC.
        The original and new vSwitches must reside in the same zone.
        If you assign a private IP address to the primary ENI of the ECS instance, the private IP address must be an idle IP address within the CIDR block of the new vSwitch. If you do not assign a private IP address to the primary ENI of the ECS instance, a private IP address is randomly assigned to the ENI. Make sure that sufficient IP addresses are available in the CIDR block of the new vSwitch.
        If you use a VPC that is shared by another Alibaba Cloud account with your account and want to change the security groups of the ECS instance, specify the security groups that you created in the VPC, instead of the security group created by the VPC owner, as the new security groups.
        
        @param request: ModifyInstanceVpcAttributeRequest
        @return: ModifyInstanceVpcAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_instance_vpc_attribute_with_options_async(request, runtime)

    def modify_invocation_attribute_with_options(
        self,
        tmp_req: ecs_20140526_models.ModifyInvocationAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInvocationAttributeResponse:
        """
        @summary Modifies the execution information of a Cloud Assistant scheduled command task, including modifying the content and execution frequency of the command and adding Elastic Compute Service (ECS) instances or Alibaba Cloud managed instances to the command task.
        
        @description    You can modify the execution information of a task that runs a command in one of the following modes. To query the execution mode of a command, you can call the [DescribeInvocations](https://help.aliyun.com/document_detail/2679916.html) operation and check the `RepeatMode` value in the response.
        Period: The task runs the command on a schedule.
        NextRebootOnly: The task runs the command the next time the associated instances start.
        EveryReboot: The task runs the command every time the associated instances start.
        You can modify the execution information of a command task in one of the following execution states. To query the execution status of a command, you can call the [DescribeInvocations](https://help.aliyun.com/document_detail/2679916.html) operation and check the `InvocationStatus` value.
        Pending: The command is being verified or sent. When the execution state on at least one instance is Pending, the overall execution state is Pending.
        Running: The command is being run on instances. When the execution state on at least one instance is Running, the overall execution state is Running.
        Scheduled: The command that is set to run on a schedule is sent and waiting to be run. When the execution state on at least one instance is Scheduled, the overall execution state is Scheduled.
        Stopping: The command task is being stopped. When the execution state on at least one instance is Stopping, the overall execution state is Stopping.
        Before you modify the execution information of a scheduled task, such as the command content, custom parameters, and execution frequency, make sure that the version of Cloud Assistant Agent on the ECS instances or managed instances associated with the task is later than the following versions:
        Linux: 2.2.3.541
        Windows: 2.1.3.541
        If the `InvalidOperation.CloudAssistantVersionUnsupported` error code is returned in the response, update Cloud Assistant Agent to the latest version.
        You cannot modify `CommandContent` for a common Cloud Assistant command.
        If you modify the `CommandContent` value of a command and set `KeepCommand` to `true` when you call the [InvokeCommand](https://help.aliyun.com/document_detail/64841.html) or [RunCommand](https://help.aliyun.com/document_detail/141751.html) operation to run the command, a new command is added and retained. The new command consumes the quota for Cloud Assistant commands. You can retain up to 500 to 50,000 Cloud Assistant commands in each region. You can apply for a quota increase. For information about how to query and increase quotas, see [Manage quotas](https://help.aliyun.com/document_detail/184116.html).
        
        @param tmp_req: ModifyInvocationAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInvocationAttributeResponse
        """
        UtilClient.validate_model(tmp_req)
        request = ecs_20140526_models.ModifyInvocationAttributeShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.parameters):
            request.parameters_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.parameters, 'Parameters', 'json')
        query = {}
        if not UtilClient.is_unset(request.command_content):
            query['CommandContent'] = request.command_content
        if not UtilClient.is_unset(request.content_encoding):
            query['ContentEncoding'] = request.content_encoding
        if not UtilClient.is_unset(request.enable_parameter):
            query['EnableParameter'] = request.enable_parameter
        if not UtilClient.is_unset(request.frequency):
            query['Frequency'] = request.frequency
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.invoke_id):
            query['InvokeId'] = request.invoke_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.parameters_shrink):
            query['Parameters'] = request.parameters_shrink
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInvocationAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInvocationAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_invocation_attribute_with_options_async(
        self,
        tmp_req: ecs_20140526_models.ModifyInvocationAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyInvocationAttributeResponse:
        """
        @summary Modifies the execution information of a Cloud Assistant scheduled command task, including modifying the content and execution frequency of the command and adding Elastic Compute Service (ECS) instances or Alibaba Cloud managed instances to the command task.
        
        @description    You can modify the execution information of a task that runs a command in one of the following modes. To query the execution mode of a command, you can call the [DescribeInvocations](https://help.aliyun.com/document_detail/2679916.html) operation and check the `RepeatMode` value in the response.
        Period: The task runs the command on a schedule.
        NextRebootOnly: The task runs the command the next time the associated instances start.
        EveryReboot: The task runs the command every time the associated instances start.
        You can modify the execution information of a command task in one of the following execution states. To query the execution status of a command, you can call the [DescribeInvocations](https://help.aliyun.com/document_detail/2679916.html) operation and check the `InvocationStatus` value.
        Pending: The command is being verified or sent. When the execution state on at least one instance is Pending, the overall execution state is Pending.
        Running: The command is being run on instances. When the execution state on at least one instance is Running, the overall execution state is Running.
        Scheduled: The command that is set to run on a schedule is sent and waiting to be run. When the execution state on at least one instance is Scheduled, the overall execution state is Scheduled.
        Stopping: The command task is being stopped. When the execution state on at least one instance is Stopping, the overall execution state is Stopping.
        Before you modify the execution information of a scheduled task, such as the command content, custom parameters, and execution frequency, make sure that the version of Cloud Assistant Agent on the ECS instances or managed instances associated with the task is later than the following versions:
        Linux: 2.2.3.541
        Windows: 2.1.3.541
        If the `InvalidOperation.CloudAssistantVersionUnsupported` error code is returned in the response, update Cloud Assistant Agent to the latest version.
        You cannot modify `CommandContent` for a common Cloud Assistant command.
        If you modify the `CommandContent` value of a command and set `KeepCommand` to `true` when you call the [InvokeCommand](https://help.aliyun.com/document_detail/64841.html) or [RunCommand](https://help.aliyun.com/document_detail/141751.html) operation to run the command, a new command is added and retained. The new command consumes the quota for Cloud Assistant commands. You can retain up to 500 to 50,000 Cloud Assistant commands in each region. You can apply for a quota increase. For information about how to query and increase quotas, see [Manage quotas](https://help.aliyun.com/document_detail/184116.html).
        
        @param tmp_req: ModifyInvocationAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInvocationAttributeResponse
        """
        UtilClient.validate_model(tmp_req)
        request = ecs_20140526_models.ModifyInvocationAttributeShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.parameters):
            request.parameters_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.parameters, 'Parameters', 'json')
        query = {}
        if not UtilClient.is_unset(request.command_content):
            query['CommandContent'] = request.command_content
        if not UtilClient.is_unset(request.content_encoding):
            query['ContentEncoding'] = request.content_encoding
        if not UtilClient.is_unset(request.enable_parameter):
            query['EnableParameter'] = request.enable_parameter
        if not UtilClient.is_unset(request.frequency):
            query['Frequency'] = request.frequency
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.invoke_id):
            query['InvokeId'] = request.invoke_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.parameters_shrink):
            query['Parameters'] = request.parameters_shrink
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInvocationAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyInvocationAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_invocation_attribute(
        self,
        request: ecs_20140526_models.ModifyInvocationAttributeRequest,
    ) -> ecs_20140526_models.ModifyInvocationAttributeResponse:
        """
        @summary Modifies the execution information of a Cloud Assistant scheduled command task, including modifying the content and execution frequency of the command and adding Elastic Compute Service (ECS) instances or Alibaba Cloud managed instances to the command task.
        
        @description    You can modify the execution information of a task that runs a command in one of the following modes. To query the execution mode of a command, you can call the [DescribeInvocations](https://help.aliyun.com/document_detail/2679916.html) operation and check the `RepeatMode` value in the response.
        Period: The task runs the command on a schedule.
        NextRebootOnly: The task runs the command the next time the associated instances start.
        EveryReboot: The task runs the command every time the associated instances start.
        You can modify the execution information of a command task in one of the following execution states. To query the execution status of a command, you can call the [DescribeInvocations](https://help.aliyun.com/document_detail/2679916.html) operation and check the `InvocationStatus` value.
        Pending: The command is being verified or sent. When the execution state on at least one instance is Pending, the overall execution state is Pending.
        Running: The command is being run on instances. When the execution state on at least one instance is Running, the overall execution state is Running.
        Scheduled: The command that is set to run on a schedule is sent and waiting to be run. When the execution state on at least one instance is Scheduled, the overall execution state is Scheduled.
        Stopping: The command task is being stopped. When the execution state on at least one instance is Stopping, the overall execution state is Stopping.
        Before you modify the execution information of a scheduled task, such as the command content, custom parameters, and execution frequency, make sure that the version of Cloud Assistant Agent on the ECS instances or managed instances associated with the task is later than the following versions:
        Linux: 2.2.3.541
        Windows: 2.1.3.541
        If the `InvalidOperation.CloudAssistantVersionUnsupported` error code is returned in the response, update Cloud Assistant Agent to the latest version.
        You cannot modify `CommandContent` for a common Cloud Assistant command.
        If you modify the `CommandContent` value of a command and set `KeepCommand` to `true` when you call the [InvokeCommand](https://help.aliyun.com/document_detail/64841.html) or [RunCommand](https://help.aliyun.com/document_detail/141751.html) operation to run the command, a new command is added and retained. The new command consumes the quota for Cloud Assistant commands. You can retain up to 500 to 50,000 Cloud Assistant commands in each region. You can apply for a quota increase. For information about how to query and increase quotas, see [Manage quotas](https://help.aliyun.com/document_detail/184116.html).
        
        @param request: ModifyInvocationAttributeRequest
        @return: ModifyInvocationAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_invocation_attribute_with_options(request, runtime)

    async def modify_invocation_attribute_async(
        self,
        request: ecs_20140526_models.ModifyInvocationAttributeRequest,
    ) -> ecs_20140526_models.ModifyInvocationAttributeResponse:
        """
        @summary Modifies the execution information of a Cloud Assistant scheduled command task, including modifying the content and execution frequency of the command and adding Elastic Compute Service (ECS) instances or Alibaba Cloud managed instances to the command task.
        
        @description    You can modify the execution information of a task that runs a command in one of the following modes. To query the execution mode of a command, you can call the [DescribeInvocations](https://help.aliyun.com/document_detail/2679916.html) operation and check the `RepeatMode` value in the response.
        Period: The task runs the command on a schedule.
        NextRebootOnly: The task runs the command the next time the associated instances start.
        EveryReboot: The task runs the command every time the associated instances start.
        You can modify the execution information of a command task in one of the following execution states. To query the execution status of a command, you can call the [DescribeInvocations](https://help.aliyun.com/document_detail/2679916.html) operation and check the `InvocationStatus` value.
        Pending: The command is being verified or sent. When the execution state on at least one instance is Pending, the overall execution state is Pending.
        Running: The command is being run on instances. When the execution state on at least one instance is Running, the overall execution state is Running.
        Scheduled: The command that is set to run on a schedule is sent and waiting to be run. When the execution state on at least one instance is Scheduled, the overall execution state is Scheduled.
        Stopping: The command task is being stopped. When the execution state on at least one instance is Stopping, the overall execution state is Stopping.
        Before you modify the execution information of a scheduled task, such as the command content, custom parameters, and execution frequency, make sure that the version of Cloud Assistant Agent on the ECS instances or managed instances associated with the task is later than the following versions:
        Linux: 2.2.3.541
        Windows: 2.1.3.541
        If the `InvalidOperation.CloudAssistantVersionUnsupported` error code is returned in the response, update Cloud Assistant Agent to the latest version.
        You cannot modify `CommandContent` for a common Cloud Assistant command.
        If you modify the `CommandContent` value of a command and set `KeepCommand` to `true` when you call the [InvokeCommand](https://help.aliyun.com/document_detail/64841.html) or [RunCommand](https://help.aliyun.com/document_detail/141751.html) operation to run the command, a new command is added and retained. The new command consumes the quota for Cloud Assistant commands. You can retain up to 500 to 50,000 Cloud Assistant commands in each region. You can apply for a quota increase. For information about how to query and increase quotas, see [Manage quotas](https://help.aliyun.com/document_detail/184116.html).
        
        @param request: ModifyInvocationAttributeRequest
        @return: ModifyInvocationAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_invocation_attribute_with_options_async(request, runtime)

    def modify_launch_template_default_version_with_options(
        self,
        request: ecs_20140526_models.ModifyLaunchTemplateDefaultVersionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyLaunchTemplateDefaultVersionResponse:
        """
        @summary Changes the default version of a launch template. When you call this operation, you can specify DefaultVersionNumber in the request. If you do not specify a version when you create Elastic Compute Service (ECS) instances based on a launch template, the default version of the launch template is used.
        
        @description ## Debugging
        [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Ecs\\&api=ModifyLaunchTemplateDefaultVersion\\&type=RPC\\&version=2014-05-26)
        
        @param request: ModifyLaunchTemplateDefaultVersionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLaunchTemplateDefaultVersionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.default_version_number):
            query['DefaultVersionNumber'] = request.default_version_number
        if not UtilClient.is_unset(request.launch_template_id):
            query['LaunchTemplateId'] = request.launch_template_id
        if not UtilClient.is_unset(request.launch_template_name):
            query['LaunchTemplateName'] = request.launch_template_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLaunchTemplateDefaultVersion',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyLaunchTemplateDefaultVersionResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_launch_template_default_version_with_options_async(
        self,
        request: ecs_20140526_models.ModifyLaunchTemplateDefaultVersionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyLaunchTemplateDefaultVersionResponse:
        """
        @summary Changes the default version of a launch template. When you call this operation, you can specify DefaultVersionNumber in the request. If you do not specify a version when you create Elastic Compute Service (ECS) instances based on a launch template, the default version of the launch template is used.
        
        @description ## Debugging
        [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Ecs\\&api=ModifyLaunchTemplateDefaultVersion\\&type=RPC\\&version=2014-05-26)
        
        @param request: ModifyLaunchTemplateDefaultVersionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLaunchTemplateDefaultVersionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.default_version_number):
            query['DefaultVersionNumber'] = request.default_version_number
        if not UtilClient.is_unset(request.launch_template_id):
            query['LaunchTemplateId'] = request.launch_template_id
        if not UtilClient.is_unset(request.launch_template_name):
            query['LaunchTemplateName'] = request.launch_template_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLaunchTemplateDefaultVersion',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyLaunchTemplateDefaultVersionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_launch_template_default_version(
        self,
        request: ecs_20140526_models.ModifyLaunchTemplateDefaultVersionRequest,
    ) -> ecs_20140526_models.ModifyLaunchTemplateDefaultVersionResponse:
        """
        @summary Changes the default version of a launch template. When you call this operation, you can specify DefaultVersionNumber in the request. If you do not specify a version when you create Elastic Compute Service (ECS) instances based on a launch template, the default version of the launch template is used.
        
        @description ## Debugging
        [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Ecs\\&api=ModifyLaunchTemplateDefaultVersion\\&type=RPC\\&version=2014-05-26)
        
        @param request: ModifyLaunchTemplateDefaultVersionRequest
        @return: ModifyLaunchTemplateDefaultVersionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_launch_template_default_version_with_options(request, runtime)

    async def modify_launch_template_default_version_async(
        self,
        request: ecs_20140526_models.ModifyLaunchTemplateDefaultVersionRequest,
    ) -> ecs_20140526_models.ModifyLaunchTemplateDefaultVersionResponse:
        """
        @summary Changes the default version of a launch template. When you call this operation, you can specify DefaultVersionNumber in the request. If you do not specify a version when you create Elastic Compute Service (ECS) instances based on a launch template, the default version of the launch template is used.
        
        @description ## Debugging
        [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Ecs\\&api=ModifyLaunchTemplateDefaultVersion\\&type=RPC\\&version=2014-05-26)
        
        @param request: ModifyLaunchTemplateDefaultVersionRequest
        @return: ModifyLaunchTemplateDefaultVersionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_launch_template_default_version_with_options_async(request, runtime)

    def modify_managed_instance_with_options(
        self,
        request: ecs_20140526_models.ModifyManagedInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyManagedInstanceResponse:
        """
        @summary Modifies the information of a managed instance.
        
        @description ## [](#)Usage notes
        The ModifyManagedInstance operation can be called to change only the name of a single managed instance.
        
        @param request: ModifyManagedInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyManagedInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyManagedInstance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyManagedInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_managed_instance_with_options_async(
        self,
        request: ecs_20140526_models.ModifyManagedInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyManagedInstanceResponse:
        """
        @summary Modifies the information of a managed instance.
        
        @description ## [](#)Usage notes
        The ModifyManagedInstance operation can be called to change only the name of a single managed instance.
        
        @param request: ModifyManagedInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyManagedInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyManagedInstance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyManagedInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_managed_instance(
        self,
        request: ecs_20140526_models.ModifyManagedInstanceRequest,
    ) -> ecs_20140526_models.ModifyManagedInstanceResponse:
        """
        @summary Modifies the information of a managed instance.
        
        @description ## [](#)Usage notes
        The ModifyManagedInstance operation can be called to change only the name of a single managed instance.
        
        @param request: ModifyManagedInstanceRequest
        @return: ModifyManagedInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_managed_instance_with_options(request, runtime)

    async def modify_managed_instance_async(
        self,
        request: ecs_20140526_models.ModifyManagedInstanceRequest,
    ) -> ecs_20140526_models.ModifyManagedInstanceResponse:
        """
        @summary Modifies the information of a managed instance.
        
        @description ## [](#)Usage notes
        The ModifyManagedInstance operation can be called to change only the name of a single managed instance.
        
        @param request: ModifyManagedInstanceRequest
        @return: ModifyManagedInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_managed_instance_with_options_async(request, runtime)

    def modify_network_interface_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyNetworkInterfaceAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyNetworkInterfaceAttributeResponse:
        """
        @summary Modifies the attributes of an elastic network interface (ENI), such as the number of queues supported by the ENI, the security groups to which the ENI belongs, the queue depth, the communication mode, and whether to retain the ENI when the Elastic Compute Service (ECS) instance to which the ENI is attached is released.
        
        @param request: ModifyNetworkInterfaceAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyNetworkInterfaceAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.connection_tracking_configuration):
            query['ConnectionTrackingConfiguration'] = request.connection_tracking_configuration
        if not UtilClient.is_unset(request.delete_on_release):
            query['DeleteOnRelease'] = request.delete_on_release
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enhanced_network):
            query['EnhancedNetwork'] = request.enhanced_network
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.network_interface_name):
            query['NetworkInterfaceName'] = request.network_interface_name
        if not UtilClient.is_unset(request.network_interface_traffic_config):
            query['NetworkInterfaceTrafficConfig'] = request.network_interface_traffic_config
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.queue_number):
            query['QueueNumber'] = request.queue_number
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.rx_queue_size):
            query['RxQueueSize'] = request.rx_queue_size
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.source_dest_check):
            query['SourceDestCheck'] = request.source_dest_check
        if not UtilClient.is_unset(request.tx_queue_size):
            query['TxQueueSize'] = request.tx_queue_size
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyNetworkInterfaceAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyNetworkInterfaceAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_network_interface_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyNetworkInterfaceAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyNetworkInterfaceAttributeResponse:
        """
        @summary Modifies the attributes of an elastic network interface (ENI), such as the number of queues supported by the ENI, the security groups to which the ENI belongs, the queue depth, the communication mode, and whether to retain the ENI when the Elastic Compute Service (ECS) instance to which the ENI is attached is released.
        
        @param request: ModifyNetworkInterfaceAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyNetworkInterfaceAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.connection_tracking_configuration):
            query['ConnectionTrackingConfiguration'] = request.connection_tracking_configuration
        if not UtilClient.is_unset(request.delete_on_release):
            query['DeleteOnRelease'] = request.delete_on_release
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enhanced_network):
            query['EnhancedNetwork'] = request.enhanced_network
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.network_interface_name):
            query['NetworkInterfaceName'] = request.network_interface_name
        if not UtilClient.is_unset(request.network_interface_traffic_config):
            query['NetworkInterfaceTrafficConfig'] = request.network_interface_traffic_config
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.queue_number):
            query['QueueNumber'] = request.queue_number
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.rx_queue_size):
            query['RxQueueSize'] = request.rx_queue_size
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.source_dest_check):
            query['SourceDestCheck'] = request.source_dest_check
        if not UtilClient.is_unset(request.tx_queue_size):
            query['TxQueueSize'] = request.tx_queue_size
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyNetworkInterfaceAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyNetworkInterfaceAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_network_interface_attribute(
        self,
        request: ecs_20140526_models.ModifyNetworkInterfaceAttributeRequest,
    ) -> ecs_20140526_models.ModifyNetworkInterfaceAttributeResponse:
        """
        @summary Modifies the attributes of an elastic network interface (ENI), such as the number of queues supported by the ENI, the security groups to which the ENI belongs, the queue depth, the communication mode, and whether to retain the ENI when the Elastic Compute Service (ECS) instance to which the ENI is attached is released.
        
        @param request: ModifyNetworkInterfaceAttributeRequest
        @return: ModifyNetworkInterfaceAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_network_interface_attribute_with_options(request, runtime)

    async def modify_network_interface_attribute_async(
        self,
        request: ecs_20140526_models.ModifyNetworkInterfaceAttributeRequest,
    ) -> ecs_20140526_models.ModifyNetworkInterfaceAttributeResponse:
        """
        @summary Modifies the attributes of an elastic network interface (ENI), such as the number of queues supported by the ENI, the security groups to which the ENI belongs, the queue depth, the communication mode, and whether to retain the ENI when the Elastic Compute Service (ECS) instance to which the ENI is attached is released.
        
        @param request: ModifyNetworkInterfaceAttributeRequest
        @return: ModifyNetworkInterfaceAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_network_interface_attribute_with_options_async(request, runtime)

    def modify_physical_connection_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyPhysicalConnectionAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyPhysicalConnectionAttributeResponse:
        """
        @deprecated OpenAPI ModifyPhysicalConnectionAttribute is deprecated, please use Vpc::2016-04-28::ModifyPhysicalConnectionAttribute instead.
        
        @summary ModifyPhysicalConnectionAttribute
        
        @param request: ModifyPhysicalConnectionAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyPhysicalConnectionAttributeResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.circuit_code):
            query['CircuitCode'] = request.circuit_code
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.line_operator):
            query['LineOperator'] = request.line_operator
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_location):
            query['PeerLocation'] = request.peer_location
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.port_type):
            query['PortType'] = request.port_type
        if not UtilClient.is_unset(request.redundant_physical_connection_id):
            query['RedundantPhysicalConnectionId'] = request.redundant_physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.bandwidth):
            query['bandwidth'] = request.bandwidth
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyPhysicalConnectionAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyPhysicalConnectionAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_physical_connection_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyPhysicalConnectionAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyPhysicalConnectionAttributeResponse:
        """
        @deprecated OpenAPI ModifyPhysicalConnectionAttribute is deprecated, please use Vpc::2016-04-28::ModifyPhysicalConnectionAttribute instead.
        
        @summary ModifyPhysicalConnectionAttribute
        
        @param request: ModifyPhysicalConnectionAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyPhysicalConnectionAttributeResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.circuit_code):
            query['CircuitCode'] = request.circuit_code
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.line_operator):
            query['LineOperator'] = request.line_operator
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_location):
            query['PeerLocation'] = request.peer_location
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.port_type):
            query['PortType'] = request.port_type
        if not UtilClient.is_unset(request.redundant_physical_connection_id):
            query['RedundantPhysicalConnectionId'] = request.redundant_physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.bandwidth):
            query['bandwidth'] = request.bandwidth
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyPhysicalConnectionAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyPhysicalConnectionAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_physical_connection_attribute(
        self,
        request: ecs_20140526_models.ModifyPhysicalConnectionAttributeRequest,
    ) -> ecs_20140526_models.ModifyPhysicalConnectionAttributeResponse:
        """
        @deprecated OpenAPI ModifyPhysicalConnectionAttribute is deprecated, please use Vpc::2016-04-28::ModifyPhysicalConnectionAttribute instead.
        
        @summary ModifyPhysicalConnectionAttribute
        
        @param request: ModifyPhysicalConnectionAttributeRequest
        @return: ModifyPhysicalConnectionAttributeResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_physical_connection_attribute_with_options(request, runtime)

    async def modify_physical_connection_attribute_async(
        self,
        request: ecs_20140526_models.ModifyPhysicalConnectionAttributeRequest,
    ) -> ecs_20140526_models.ModifyPhysicalConnectionAttributeResponse:
        """
        @deprecated OpenAPI ModifyPhysicalConnectionAttribute is deprecated, please use Vpc::2016-04-28::ModifyPhysicalConnectionAttribute instead.
        
        @summary ModifyPhysicalConnectionAttribute
        
        @param request: ModifyPhysicalConnectionAttributeRequest
        @return: ModifyPhysicalConnectionAttributeResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_physical_connection_attribute_with_options_async(request, runtime)

    def modify_port_range_list_with_options(
        self,
        request: ecs_20140526_models.ModifyPortRangeListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyPortRangeListResponse:
        """
        @summary Modifies the name and entries of a port list. You can call this operation to add, modify, and remove entries for a port list.
        
        @param request: ModifyPortRangeListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyPortRangeListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.add_entry):
            query['AddEntry'] = request.add_entry
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_range_list_id):
            query['PortRangeListId'] = request.port_range_list_id
        if not UtilClient.is_unset(request.port_range_list_name):
            query['PortRangeListName'] = request.port_range_list_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remove_entry):
            query['RemoveEntry'] = request.remove_entry
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyPortRangeList',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyPortRangeListResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_port_range_list_with_options_async(
        self,
        request: ecs_20140526_models.ModifyPortRangeListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyPortRangeListResponse:
        """
        @summary Modifies the name and entries of a port list. You can call this operation to add, modify, and remove entries for a port list.
        
        @param request: ModifyPortRangeListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyPortRangeListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.add_entry):
            query['AddEntry'] = request.add_entry
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_range_list_id):
            query['PortRangeListId'] = request.port_range_list_id
        if not UtilClient.is_unset(request.port_range_list_name):
            query['PortRangeListName'] = request.port_range_list_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remove_entry):
            query['RemoveEntry'] = request.remove_entry
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyPortRangeList',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyPortRangeListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_port_range_list(
        self,
        request: ecs_20140526_models.ModifyPortRangeListRequest,
    ) -> ecs_20140526_models.ModifyPortRangeListResponse:
        """
        @summary Modifies the name and entries of a port list. You can call this operation to add, modify, and remove entries for a port list.
        
        @param request: ModifyPortRangeListRequest
        @return: ModifyPortRangeListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_port_range_list_with_options(request, runtime)

    async def modify_port_range_list_async(
        self,
        request: ecs_20140526_models.ModifyPortRangeListRequest,
    ) -> ecs_20140526_models.ModifyPortRangeListResponse:
        """
        @summary Modifies the name and entries of a port list. You can call this operation to add, modify, and remove entries for a port list.
        
        @param request: ModifyPortRangeListRequest
        @return: ModifyPortRangeListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_port_range_list_with_options_async(request, runtime)

    def modify_prefix_list_with_options(
        self,
        request: ecs_20140526_models.ModifyPrefixListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyPrefixListResponse:
        """
        @summary Modifies the name, description, or entries of a prefix list. You can add, modify, and delete entries in the prefix list.
        
        @description ## [](#)Usage notes
        The specified CIDR block must be valid. For example, 10.0.0.0/8 is a valid CIDR block while 10.0.0.1/8 is not. For more information, see the [What is CIDR?](~~40637#section-jua-0tj-q5m~~) section in the "Network FAQ" topic.
        When you add or delete an entry, you cannot specify duplicate CIDR blocks. Examples:
        For IPv4 CIDR blocks, you cannot specify the 10.0.0.0/8 CIDR block in two entries. You cannot specify the 10.0.0.1/32 CIDR block in one entry and the 10.0.0.1 CIDR block in another entry. The two CIDR blocks are the same.
        For IPv6 CIDR blocks, you cannot specify the 2001:fd01:0:0:0:0:0:0/32 CIDR block in one entry and the 2001:fd01::/32 CIDR block in another entry. The two CIDR blocks are the same.
        The CIDR block in an entry to be added cannot the same as that in an entry to be deleted. For example, when you add an entry in which the 10.0.0.0/8 CIDR block is specified, make sure that the 10.0.0.0/8 CIDR block is not specified in an entry to be deleted.
        If you want to modify the description of an entry, you must specify the CIDR block (`AddEntry.N.Cidr`) and new description (`AddEntry.N.Description`) for the entry.
        
        @param request: ModifyPrefixListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyPrefixListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.add_entry):
            query['AddEntry'] = request.add_entry
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.prefix_list_name):
            query['PrefixListName'] = request.prefix_list_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remove_entry):
            query['RemoveEntry'] = request.remove_entry
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyPrefixList',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyPrefixListResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_prefix_list_with_options_async(
        self,
        request: ecs_20140526_models.ModifyPrefixListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyPrefixListResponse:
        """
        @summary Modifies the name, description, or entries of a prefix list. You can add, modify, and delete entries in the prefix list.
        
        @description ## [](#)Usage notes
        The specified CIDR block must be valid. For example, 10.0.0.0/8 is a valid CIDR block while 10.0.0.1/8 is not. For more information, see the [What is CIDR?](~~40637#section-jua-0tj-q5m~~) section in the "Network FAQ" topic.
        When you add or delete an entry, you cannot specify duplicate CIDR blocks. Examples:
        For IPv4 CIDR blocks, you cannot specify the 10.0.0.0/8 CIDR block in two entries. You cannot specify the 10.0.0.1/32 CIDR block in one entry and the 10.0.0.1 CIDR block in another entry. The two CIDR blocks are the same.
        For IPv6 CIDR blocks, you cannot specify the 2001:fd01:0:0:0:0:0:0/32 CIDR block in one entry and the 2001:fd01::/32 CIDR block in another entry. The two CIDR blocks are the same.
        The CIDR block in an entry to be added cannot the same as that in an entry to be deleted. For example, when you add an entry in which the 10.0.0.0/8 CIDR block is specified, make sure that the 10.0.0.0/8 CIDR block is not specified in an entry to be deleted.
        If you want to modify the description of an entry, you must specify the CIDR block (`AddEntry.N.Cidr`) and new description (`AddEntry.N.Description`) for the entry.
        
        @param request: ModifyPrefixListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyPrefixListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.add_entry):
            query['AddEntry'] = request.add_entry
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.prefix_list_name):
            query['PrefixListName'] = request.prefix_list_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remove_entry):
            query['RemoveEntry'] = request.remove_entry
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyPrefixList',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyPrefixListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_prefix_list(
        self,
        request: ecs_20140526_models.ModifyPrefixListRequest,
    ) -> ecs_20140526_models.ModifyPrefixListResponse:
        """
        @summary Modifies the name, description, or entries of a prefix list. You can add, modify, and delete entries in the prefix list.
        
        @description ## [](#)Usage notes
        The specified CIDR block must be valid. For example, 10.0.0.0/8 is a valid CIDR block while 10.0.0.1/8 is not. For more information, see the [What is CIDR?](~~40637#section-jua-0tj-q5m~~) section in the "Network FAQ" topic.
        When you add or delete an entry, you cannot specify duplicate CIDR blocks. Examples:
        For IPv4 CIDR blocks, you cannot specify the 10.0.0.0/8 CIDR block in two entries. You cannot specify the 10.0.0.1/32 CIDR block in one entry and the 10.0.0.1 CIDR block in another entry. The two CIDR blocks are the same.
        For IPv6 CIDR blocks, you cannot specify the 2001:fd01:0:0:0:0:0:0/32 CIDR block in one entry and the 2001:fd01::/32 CIDR block in another entry. The two CIDR blocks are the same.
        The CIDR block in an entry to be added cannot the same as that in an entry to be deleted. For example, when you add an entry in which the 10.0.0.0/8 CIDR block is specified, make sure that the 10.0.0.0/8 CIDR block is not specified in an entry to be deleted.
        If you want to modify the description of an entry, you must specify the CIDR block (`AddEntry.N.Cidr`) and new description (`AddEntry.N.Description`) for the entry.
        
        @param request: ModifyPrefixListRequest
        @return: ModifyPrefixListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_prefix_list_with_options(request, runtime)

    async def modify_prefix_list_async(
        self,
        request: ecs_20140526_models.ModifyPrefixListRequest,
    ) -> ecs_20140526_models.ModifyPrefixListResponse:
        """
        @summary Modifies the name, description, or entries of a prefix list. You can add, modify, and delete entries in the prefix list.
        
        @description ## [](#)Usage notes
        The specified CIDR block must be valid. For example, 10.0.0.0/8 is a valid CIDR block while 10.0.0.1/8 is not. For more information, see the [What is CIDR?](~~40637#section-jua-0tj-q5m~~) section in the "Network FAQ" topic.
        When you add or delete an entry, you cannot specify duplicate CIDR blocks. Examples:
        For IPv4 CIDR blocks, you cannot specify the 10.0.0.0/8 CIDR block in two entries. You cannot specify the 10.0.0.1/32 CIDR block in one entry and the 10.0.0.1 CIDR block in another entry. The two CIDR blocks are the same.
        For IPv6 CIDR blocks, you cannot specify the 2001:fd01:0:0:0:0:0:0/32 CIDR block in one entry and the 2001:fd01::/32 CIDR block in another entry. The two CIDR blocks are the same.
        The CIDR block in an entry to be added cannot the same as that in an entry to be deleted. For example, when you add an entry in which the 10.0.0.0/8 CIDR block is specified, make sure that the 10.0.0.0/8 CIDR block is not specified in an entry to be deleted.
        If you want to modify the description of an entry, you must specify the CIDR block (`AddEntry.N.Cidr`) and new description (`AddEntry.N.Description`) for the entry.
        
        @param request: ModifyPrefixListRequest
        @return: ModifyPrefixListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_prefix_list_with_options_async(request, runtime)

    def modify_prepay_instance_spec_with_options(
        self,
        request: ecs_20140526_models.ModifyPrepayInstanceSpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyPrepayInstanceSpecResponse:
        """
        @summary Changes the instance type of a subscription Elastic Compute Service (ECS) instance. You can upgrade or downgrade the instance type. The new instance type takes effect for the entire lifecycle of the subscription ECS instance.
        
        @description *Before you call this operation, make sure that you are familiar with the billing methods, [prices](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl), and [rules for unsubscribing from resources](https://help.aliyun.com/document_detail/476339.html) of ECS.**\
        ModifyPrepayInstanceSpec is an asynchronous operation. After a request is sent, wait for 5 to 10 seconds for the instance type change to complete. Before you change the instance type of a subscription ECS instance, call the [DescribeResourcesModification](https://help.aliyun.com/document_detail/66187.html) operation to query the instance types to which you can change the instance.
        *Considerations**\
        Before you change the instance type of an expired instance, you must renew the instance.
        When you downgrade the instance type of a subscription ECS instance, take note of the following items:
        The instance must be in the **Stopped** (`Stopped`) state.
        The price difference is refunded to the payment account that you used. Redeemed vouchers are not refundable.
        The new instance type takes effect only after you [start the instance](https://help.aliyun.com/document_detail/25441.html).
        When you upgrade the instance type of a subscription ECS instance, take note of the following items:
        The instance must be in the **Stopped** (`Stopped`) or **Running** (`Running`) state.
        The new instance type takes effect only after you [start the instance](https://help.aliyun.com/document_detail/25441.html) or [restart the instance](https://help.aliyun.com/document_detail/25440.html).
        
        @param request: ModifyPrepayInstanceSpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyPrepayInstanceSpecResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.disk):
            query['Disk'] = request.disk
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.migrate_across_zone):
            query['MigrateAcrossZone'] = request.migrate_across_zone
        if not UtilClient.is_unset(request.modify_mode):
            query['ModifyMode'] = request.modify_mode
        if not UtilClient.is_unset(request.operator_type):
            query['OperatorType'] = request.operator_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.reboot_time):
            query['RebootTime'] = request.reboot_time
        if not UtilClient.is_unset(request.reboot_when_finished):
            query['RebootWhenFinished'] = request.reboot_when_finished
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.system_disk):
            query['SystemDisk'] = request.system_disk
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyPrepayInstanceSpec',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyPrepayInstanceSpecResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_prepay_instance_spec_with_options_async(
        self,
        request: ecs_20140526_models.ModifyPrepayInstanceSpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyPrepayInstanceSpecResponse:
        """
        @summary Changes the instance type of a subscription Elastic Compute Service (ECS) instance. You can upgrade or downgrade the instance type. The new instance type takes effect for the entire lifecycle of the subscription ECS instance.
        
        @description *Before you call this operation, make sure that you are familiar with the billing methods, [prices](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl), and [rules for unsubscribing from resources](https://help.aliyun.com/document_detail/476339.html) of ECS.**\
        ModifyPrepayInstanceSpec is an asynchronous operation. After a request is sent, wait for 5 to 10 seconds for the instance type change to complete. Before you change the instance type of a subscription ECS instance, call the [DescribeResourcesModification](https://help.aliyun.com/document_detail/66187.html) operation to query the instance types to which you can change the instance.
        *Considerations**\
        Before you change the instance type of an expired instance, you must renew the instance.
        When you downgrade the instance type of a subscription ECS instance, take note of the following items:
        The instance must be in the **Stopped** (`Stopped`) state.
        The price difference is refunded to the payment account that you used. Redeemed vouchers are not refundable.
        The new instance type takes effect only after you [start the instance](https://help.aliyun.com/document_detail/25441.html).
        When you upgrade the instance type of a subscription ECS instance, take note of the following items:
        The instance must be in the **Stopped** (`Stopped`) or **Running** (`Running`) state.
        The new instance type takes effect only after you [start the instance](https://help.aliyun.com/document_detail/25441.html) or [restart the instance](https://help.aliyun.com/document_detail/25440.html).
        
        @param request: ModifyPrepayInstanceSpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyPrepayInstanceSpecResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.disk):
            query['Disk'] = request.disk
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.migrate_across_zone):
            query['MigrateAcrossZone'] = request.migrate_across_zone
        if not UtilClient.is_unset(request.modify_mode):
            query['ModifyMode'] = request.modify_mode
        if not UtilClient.is_unset(request.operator_type):
            query['OperatorType'] = request.operator_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.reboot_time):
            query['RebootTime'] = request.reboot_time
        if not UtilClient.is_unset(request.reboot_when_finished):
            query['RebootWhenFinished'] = request.reboot_when_finished
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.system_disk):
            query['SystemDisk'] = request.system_disk
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyPrepayInstanceSpec',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyPrepayInstanceSpecResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_prepay_instance_spec(
        self,
        request: ecs_20140526_models.ModifyPrepayInstanceSpecRequest,
    ) -> ecs_20140526_models.ModifyPrepayInstanceSpecResponse:
        """
        @summary Changes the instance type of a subscription Elastic Compute Service (ECS) instance. You can upgrade or downgrade the instance type. The new instance type takes effect for the entire lifecycle of the subscription ECS instance.
        
        @description *Before you call this operation, make sure that you are familiar with the billing methods, [prices](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl), and [rules for unsubscribing from resources](https://help.aliyun.com/document_detail/476339.html) of ECS.**\
        ModifyPrepayInstanceSpec is an asynchronous operation. After a request is sent, wait for 5 to 10 seconds for the instance type change to complete. Before you change the instance type of a subscription ECS instance, call the [DescribeResourcesModification](https://help.aliyun.com/document_detail/66187.html) operation to query the instance types to which you can change the instance.
        *Considerations**\
        Before you change the instance type of an expired instance, you must renew the instance.
        When you downgrade the instance type of a subscription ECS instance, take note of the following items:
        The instance must be in the **Stopped** (`Stopped`) state.
        The price difference is refunded to the payment account that you used. Redeemed vouchers are not refundable.
        The new instance type takes effect only after you [start the instance](https://help.aliyun.com/document_detail/25441.html).
        When you upgrade the instance type of a subscription ECS instance, take note of the following items:
        The instance must be in the **Stopped** (`Stopped`) or **Running** (`Running`) state.
        The new instance type takes effect only after you [start the instance](https://help.aliyun.com/document_detail/25441.html) or [restart the instance](https://help.aliyun.com/document_detail/25440.html).
        
        @param request: ModifyPrepayInstanceSpecRequest
        @return: ModifyPrepayInstanceSpecResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_prepay_instance_spec_with_options(request, runtime)

    async def modify_prepay_instance_spec_async(
        self,
        request: ecs_20140526_models.ModifyPrepayInstanceSpecRequest,
    ) -> ecs_20140526_models.ModifyPrepayInstanceSpecResponse:
        """
        @summary Changes the instance type of a subscription Elastic Compute Service (ECS) instance. You can upgrade or downgrade the instance type. The new instance type takes effect for the entire lifecycle of the subscription ECS instance.
        
        @description *Before you call this operation, make sure that you are familiar with the billing methods, [prices](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl), and [rules for unsubscribing from resources](https://help.aliyun.com/document_detail/476339.html) of ECS.**\
        ModifyPrepayInstanceSpec is an asynchronous operation. After a request is sent, wait for 5 to 10 seconds for the instance type change to complete. Before you change the instance type of a subscription ECS instance, call the [DescribeResourcesModification](https://help.aliyun.com/document_detail/66187.html) operation to query the instance types to which you can change the instance.
        *Considerations**\
        Before you change the instance type of an expired instance, you must renew the instance.
        When you downgrade the instance type of a subscription ECS instance, take note of the following items:
        The instance must be in the **Stopped** (`Stopped`) state.
        The price difference is refunded to the payment account that you used. Redeemed vouchers are not refundable.
        The new instance type takes effect only after you [start the instance](https://help.aliyun.com/document_detail/25441.html).
        When you upgrade the instance type of a subscription ECS instance, take note of the following items:
        The instance must be in the **Stopped** (`Stopped`) or **Running** (`Running`) state.
        The new instance type takes effect only after you [start the instance](https://help.aliyun.com/document_detail/25441.html) or [restart the instance](https://help.aliyun.com/document_detail/25440.html).
        
        @param request: ModifyPrepayInstanceSpecRequest
        @return: ModifyPrepayInstanceSpecResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_prepay_instance_spec_with_options_async(request, runtime)

    def modify_reserved_instance_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyReservedInstanceAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyReservedInstanceAttributeResponse:
        """
        @summary Modifies the attributes of a reserved instance, such as the name and description of the instance.
        
        @param request: ModifyReservedInstanceAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyReservedInstanceAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.reserved_instance_id):
            query['ReservedInstanceId'] = request.reserved_instance_id
        if not UtilClient.is_unset(request.reserved_instance_name):
            query['ReservedInstanceName'] = request.reserved_instance_name
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyReservedInstanceAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyReservedInstanceAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_reserved_instance_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyReservedInstanceAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyReservedInstanceAttributeResponse:
        """
        @summary Modifies the attributes of a reserved instance, such as the name and description of the instance.
        
        @param request: ModifyReservedInstanceAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyReservedInstanceAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.reserved_instance_id):
            query['ReservedInstanceId'] = request.reserved_instance_id
        if not UtilClient.is_unset(request.reserved_instance_name):
            query['ReservedInstanceName'] = request.reserved_instance_name
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyReservedInstanceAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyReservedInstanceAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_reserved_instance_attribute(
        self,
        request: ecs_20140526_models.ModifyReservedInstanceAttributeRequest,
    ) -> ecs_20140526_models.ModifyReservedInstanceAttributeResponse:
        """
        @summary Modifies the attributes of a reserved instance, such as the name and description of the instance.
        
        @param request: ModifyReservedInstanceAttributeRequest
        @return: ModifyReservedInstanceAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_reserved_instance_attribute_with_options(request, runtime)

    async def modify_reserved_instance_attribute_async(
        self,
        request: ecs_20140526_models.ModifyReservedInstanceAttributeRequest,
    ) -> ecs_20140526_models.ModifyReservedInstanceAttributeResponse:
        """
        @summary Modifies the attributes of a reserved instance, such as the name and description of the instance.
        
        @param request: ModifyReservedInstanceAttributeRequest
        @return: ModifyReservedInstanceAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_reserved_instance_attribute_with_options_async(request, runtime)

    def modify_reserved_instance_auto_renew_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyReservedInstanceAutoRenewAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyReservedInstanceAutoRenewAttributeResponse:
        """
        @summary Modifies the auto-renewal attributes of reserved instances. You can cancel or disable the auto-renewal feature for reserved instances.
        
        @param request: ModifyReservedInstanceAutoRenewAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyReservedInstanceAutoRenewAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.renewal_status):
            query['RenewalStatus'] = request.renewal_status
        if not UtilClient.is_unset(request.reserved_instance_id):
            query['ReservedInstanceId'] = request.reserved_instance_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyReservedInstanceAutoRenewAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyReservedInstanceAutoRenewAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_reserved_instance_auto_renew_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyReservedInstanceAutoRenewAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyReservedInstanceAutoRenewAttributeResponse:
        """
        @summary Modifies the auto-renewal attributes of reserved instances. You can cancel or disable the auto-renewal feature for reserved instances.
        
        @param request: ModifyReservedInstanceAutoRenewAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyReservedInstanceAutoRenewAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.renewal_status):
            query['RenewalStatus'] = request.renewal_status
        if not UtilClient.is_unset(request.reserved_instance_id):
            query['ReservedInstanceId'] = request.reserved_instance_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyReservedInstanceAutoRenewAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyReservedInstanceAutoRenewAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_reserved_instance_auto_renew_attribute(
        self,
        request: ecs_20140526_models.ModifyReservedInstanceAutoRenewAttributeRequest,
    ) -> ecs_20140526_models.ModifyReservedInstanceAutoRenewAttributeResponse:
        """
        @summary Modifies the auto-renewal attributes of reserved instances. You can cancel or disable the auto-renewal feature for reserved instances.
        
        @param request: ModifyReservedInstanceAutoRenewAttributeRequest
        @return: ModifyReservedInstanceAutoRenewAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_reserved_instance_auto_renew_attribute_with_options(request, runtime)

    async def modify_reserved_instance_auto_renew_attribute_async(
        self,
        request: ecs_20140526_models.ModifyReservedInstanceAutoRenewAttributeRequest,
    ) -> ecs_20140526_models.ModifyReservedInstanceAutoRenewAttributeResponse:
        """
        @summary Modifies the auto-renewal attributes of reserved instances. You can cancel or disable the auto-renewal feature for reserved instances.
        
        @param request: ModifyReservedInstanceAutoRenewAttributeRequest
        @return: ModifyReservedInstanceAutoRenewAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_reserved_instance_auto_renew_attribute_with_options_async(request, runtime)

    def modify_reserved_instances_with_options(
        self,
        request: ecs_20140526_models.ModifyReservedInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyReservedInstancesResponse:
        """
        @summary Modifies the configurations of a reserved instance, such as the instance type, quantity, and zone, to split, merge, or change the scope of the reserved instance.
        
        @description This operation is an asynchronous operation. After you call this operation to modify a reserved instance, the operation starts the modification process and returns the ID of the resulting new reserved instance. The original reserved instance enters the `Updating` state and then the `Inactive` state. At the same time, the resulting new reserved instance is generated and enters the Creating state and then the Active state. You can call the [DescribeReservedInstances](https://help.aliyun.com/document_detail/2679781.html) operation to query the states of the reserved instance.
        You can modify the configurations of a reserved instance only if the reserved instance is in the **Active** state.
        Make sure that the [computing power](~~140660#2742f3844abzz~~) of the reserved instance remains unchanged before and after the modification. Otherwise, the modification fails.
        You cannot split, merge, or change the scope of a reserved instance at the same time.
        For more information, see [Split, merge, or modify reserved instances](https://help.aliyun.com/document_detail/100375.html).
        ## [](#)Sample requests
        **Sample request to split a reserved instance**: Split a regional reserved instance that is scoped to the China (Hangzhou) region and can match two pay-as-you-go instances of the ecs.g5.xlarge instance type into two regional reserved instances that are scoped to the China (Hangzhou) region and each can match one pay-as-you-go instance of the ecs.g5.large instance type:
        <!---->
        "RegionId":"cn-hangzhou", //The ID of the region.
        "ReservedInstanceId":["ecsri-bp1hd03e9uv19e75***"], //The ID of the reserved instance that you want to split.
        "Configuration":[
        {
        "ReservedInstanceName":"testReservedInstanceName1", //The name of the new reserved instance.
        "InstanceType":"ecs.g5.large", //The instance type that the new reserved instance can match.
        "Scope":"Region", //The scope level of the new reserved instance, which must be the same as the scope level of the original reserved instance.
        "InstanceAmount":1 //The number of pay-as-you-go instances of the specified instance type that each new reserved instance can match.
        },
        {
        "ReservedInstanceName":"testReservedInstanceName2",
        "InstanceType":"ecs.g5.large",
        "Scope":"Region",
        "InstanceAmount":1
        }
        ]
        **Sample request to merge reserved instance:**: Merge two zonal reserved instances that are scoped to Hangzhou Zone H and can match four pay-as-you-go instances of the ecs.g5.xlarge instance type into one zonal reserved instance that is scoped to Hangzhou Zone H and can match two pay-as-you-go instances of the ecs.g5.4xlarge instance type:
        <!---->
        "RegionId":"cn-hangzhou", //The ID of the region.
        "ReservedInstanceId":["ecsri-bp1hd03e9uv16b75***",""ecsri-bp1hd03e9uv16b76****""], //The IDs of the reserved instances that you want to merge.
        "Configuration":[
        {
        "ReservedInstanceName":"testReservedInstanceName", //The name of the new reserved instance.
        "InstanceType":"ecs.g5.4xlarge", //The instance type that the new reserved instance can match.
        "Scope":"Zone", //The scope level of the new reserved instance, which must be the same as the scope level of the original reserved instances.
        "ZoneId":"cn-hangzhou-h", //\
        "InstanceAmount":2 //The number of pay-as-you-go instances of the specified instance type that the new reserved instance can match.
        }
        ]
        **Sample request to change the scope of a reserved instance**: Change a regional reserved instance that is scoped to Hangzhou Zone H and can match six pay-as-you-go instances of the ecs.g5.xlarge instance type to a regional reserved instance that is scoped to the China (Hangzhou) region and can match three pay-as-you-go instances of the ecs.g5.2xlarge instance type.
        <!---->
        "RegionId":"cn-hangzhou", //The ID of the region.
        "ReservedInstanceId":["ecsri-bp1hd03e9uv16b77***"], //The ID of the reserved instance whose scope you want to change.
        "Configuration":[
        {
        "ReservedInstanceName":"testReservedInstanceName", //The name of the new reserved instance.
        "InstanceType":"ecs.g5.2xlarge", //The instance type that the new reserved instance can match.
        "Scope":"Region", //The scope level of the new reserved instance.
        "InstanceAmount":3 //The number of pay-as-you-go instances of the specified instance type that the new reserved instance can match.
        }
        ]
        
        @param request: ModifyReservedInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyReservedInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.configuration):
            query['Configuration'] = request.configuration
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.reserved_instance_id):
            query['ReservedInstanceId'] = request.reserved_instance_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyReservedInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyReservedInstancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_reserved_instances_with_options_async(
        self,
        request: ecs_20140526_models.ModifyReservedInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyReservedInstancesResponse:
        """
        @summary Modifies the configurations of a reserved instance, such as the instance type, quantity, and zone, to split, merge, or change the scope of the reserved instance.
        
        @description This operation is an asynchronous operation. After you call this operation to modify a reserved instance, the operation starts the modification process and returns the ID of the resulting new reserved instance. The original reserved instance enters the `Updating` state and then the `Inactive` state. At the same time, the resulting new reserved instance is generated and enters the Creating state and then the Active state. You can call the [DescribeReservedInstances](https://help.aliyun.com/document_detail/2679781.html) operation to query the states of the reserved instance.
        You can modify the configurations of a reserved instance only if the reserved instance is in the **Active** state.
        Make sure that the [computing power](~~140660#2742f3844abzz~~) of the reserved instance remains unchanged before and after the modification. Otherwise, the modification fails.
        You cannot split, merge, or change the scope of a reserved instance at the same time.
        For more information, see [Split, merge, or modify reserved instances](https://help.aliyun.com/document_detail/100375.html).
        ## [](#)Sample requests
        **Sample request to split a reserved instance**: Split a regional reserved instance that is scoped to the China (Hangzhou) region and can match two pay-as-you-go instances of the ecs.g5.xlarge instance type into two regional reserved instances that are scoped to the China (Hangzhou) region and each can match one pay-as-you-go instance of the ecs.g5.large instance type:
        <!---->
        "RegionId":"cn-hangzhou", //The ID of the region.
        "ReservedInstanceId":["ecsri-bp1hd03e9uv19e75***"], //The ID of the reserved instance that you want to split.
        "Configuration":[
        {
        "ReservedInstanceName":"testReservedInstanceName1", //The name of the new reserved instance.
        "InstanceType":"ecs.g5.large", //The instance type that the new reserved instance can match.
        "Scope":"Region", //The scope level of the new reserved instance, which must be the same as the scope level of the original reserved instance.
        "InstanceAmount":1 //The number of pay-as-you-go instances of the specified instance type that each new reserved instance can match.
        },
        {
        "ReservedInstanceName":"testReservedInstanceName2",
        "InstanceType":"ecs.g5.large",
        "Scope":"Region",
        "InstanceAmount":1
        }
        ]
        **Sample request to merge reserved instance:**: Merge two zonal reserved instances that are scoped to Hangzhou Zone H and can match four pay-as-you-go instances of the ecs.g5.xlarge instance type into one zonal reserved instance that is scoped to Hangzhou Zone H and can match two pay-as-you-go instances of the ecs.g5.4xlarge instance type:
        <!---->
        "RegionId":"cn-hangzhou", //The ID of the region.
        "ReservedInstanceId":["ecsri-bp1hd03e9uv16b75***",""ecsri-bp1hd03e9uv16b76****""], //The IDs of the reserved instances that you want to merge.
        "Configuration":[
        {
        "ReservedInstanceName":"testReservedInstanceName", //The name of the new reserved instance.
        "InstanceType":"ecs.g5.4xlarge", //The instance type that the new reserved instance can match.
        "Scope":"Zone", //The scope level of the new reserved instance, which must be the same as the scope level of the original reserved instances.
        "ZoneId":"cn-hangzhou-h", //\
        "InstanceAmount":2 //The number of pay-as-you-go instances of the specified instance type that the new reserved instance can match.
        }
        ]
        **Sample request to change the scope of a reserved instance**: Change a regional reserved instance that is scoped to Hangzhou Zone H and can match six pay-as-you-go instances of the ecs.g5.xlarge instance type to a regional reserved instance that is scoped to the China (Hangzhou) region and can match three pay-as-you-go instances of the ecs.g5.2xlarge instance type.
        <!---->
        "RegionId":"cn-hangzhou", //The ID of the region.
        "ReservedInstanceId":["ecsri-bp1hd03e9uv16b77***"], //The ID of the reserved instance whose scope you want to change.
        "Configuration":[
        {
        "ReservedInstanceName":"testReservedInstanceName", //The name of the new reserved instance.
        "InstanceType":"ecs.g5.2xlarge", //The instance type that the new reserved instance can match.
        "Scope":"Region", //The scope level of the new reserved instance.
        "InstanceAmount":3 //The number of pay-as-you-go instances of the specified instance type that the new reserved instance can match.
        }
        ]
        
        @param request: ModifyReservedInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyReservedInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.configuration):
            query['Configuration'] = request.configuration
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.reserved_instance_id):
            query['ReservedInstanceId'] = request.reserved_instance_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyReservedInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyReservedInstancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_reserved_instances(
        self,
        request: ecs_20140526_models.ModifyReservedInstancesRequest,
    ) -> ecs_20140526_models.ModifyReservedInstancesResponse:
        """
        @summary Modifies the configurations of a reserved instance, such as the instance type, quantity, and zone, to split, merge, or change the scope of the reserved instance.
        
        @description This operation is an asynchronous operation. After you call this operation to modify a reserved instance, the operation starts the modification process and returns the ID of the resulting new reserved instance. The original reserved instance enters the `Updating` state and then the `Inactive` state. At the same time, the resulting new reserved instance is generated and enters the Creating state and then the Active state. You can call the [DescribeReservedInstances](https://help.aliyun.com/document_detail/2679781.html) operation to query the states of the reserved instance.
        You can modify the configurations of a reserved instance only if the reserved instance is in the **Active** state.
        Make sure that the [computing power](~~140660#2742f3844abzz~~) of the reserved instance remains unchanged before and after the modification. Otherwise, the modification fails.
        You cannot split, merge, or change the scope of a reserved instance at the same time.
        For more information, see [Split, merge, or modify reserved instances](https://help.aliyun.com/document_detail/100375.html).
        ## [](#)Sample requests
        **Sample request to split a reserved instance**: Split a regional reserved instance that is scoped to the China (Hangzhou) region and can match two pay-as-you-go instances of the ecs.g5.xlarge instance type into two regional reserved instances that are scoped to the China (Hangzhou) region and each can match one pay-as-you-go instance of the ecs.g5.large instance type:
        <!---->
        "RegionId":"cn-hangzhou", //The ID of the region.
        "ReservedInstanceId":["ecsri-bp1hd03e9uv19e75***"], //The ID of the reserved instance that you want to split.
        "Configuration":[
        {
        "ReservedInstanceName":"testReservedInstanceName1", //The name of the new reserved instance.
        "InstanceType":"ecs.g5.large", //The instance type that the new reserved instance can match.
        "Scope":"Region", //The scope level of the new reserved instance, which must be the same as the scope level of the original reserved instance.
        "InstanceAmount":1 //The number of pay-as-you-go instances of the specified instance type that each new reserved instance can match.
        },
        {
        "ReservedInstanceName":"testReservedInstanceName2",
        "InstanceType":"ecs.g5.large",
        "Scope":"Region",
        "InstanceAmount":1
        }
        ]
        **Sample request to merge reserved instance:**: Merge two zonal reserved instances that are scoped to Hangzhou Zone H and can match four pay-as-you-go instances of the ecs.g5.xlarge instance type into one zonal reserved instance that is scoped to Hangzhou Zone H and can match two pay-as-you-go instances of the ecs.g5.4xlarge instance type:
        <!---->
        "RegionId":"cn-hangzhou", //The ID of the region.
        "ReservedInstanceId":["ecsri-bp1hd03e9uv16b75***",""ecsri-bp1hd03e9uv16b76****""], //The IDs of the reserved instances that you want to merge.
        "Configuration":[
        {
        "ReservedInstanceName":"testReservedInstanceName", //The name of the new reserved instance.
        "InstanceType":"ecs.g5.4xlarge", //The instance type that the new reserved instance can match.
        "Scope":"Zone", //The scope level of the new reserved instance, which must be the same as the scope level of the original reserved instances.
        "ZoneId":"cn-hangzhou-h", //\
        "InstanceAmount":2 //The number of pay-as-you-go instances of the specified instance type that the new reserved instance can match.
        }
        ]
        **Sample request to change the scope of a reserved instance**: Change a regional reserved instance that is scoped to Hangzhou Zone H and can match six pay-as-you-go instances of the ecs.g5.xlarge instance type to a regional reserved instance that is scoped to the China (Hangzhou) region and can match three pay-as-you-go instances of the ecs.g5.2xlarge instance type.
        <!---->
        "RegionId":"cn-hangzhou", //The ID of the region.
        "ReservedInstanceId":["ecsri-bp1hd03e9uv16b77***"], //The ID of the reserved instance whose scope you want to change.
        "Configuration":[
        {
        "ReservedInstanceName":"testReservedInstanceName", //The name of the new reserved instance.
        "InstanceType":"ecs.g5.2xlarge", //The instance type that the new reserved instance can match.
        "Scope":"Region", //The scope level of the new reserved instance.
        "InstanceAmount":3 //The number of pay-as-you-go instances of the specified instance type that the new reserved instance can match.
        }
        ]
        
        @param request: ModifyReservedInstancesRequest
        @return: ModifyReservedInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_reserved_instances_with_options(request, runtime)

    async def modify_reserved_instances_async(
        self,
        request: ecs_20140526_models.ModifyReservedInstancesRequest,
    ) -> ecs_20140526_models.ModifyReservedInstancesResponse:
        """
        @summary Modifies the configurations of a reserved instance, such as the instance type, quantity, and zone, to split, merge, or change the scope of the reserved instance.
        
        @description This operation is an asynchronous operation. After you call this operation to modify a reserved instance, the operation starts the modification process and returns the ID of the resulting new reserved instance. The original reserved instance enters the `Updating` state and then the `Inactive` state. At the same time, the resulting new reserved instance is generated and enters the Creating state and then the Active state. You can call the [DescribeReservedInstances](https://help.aliyun.com/document_detail/2679781.html) operation to query the states of the reserved instance.
        You can modify the configurations of a reserved instance only if the reserved instance is in the **Active** state.
        Make sure that the [computing power](~~140660#2742f3844abzz~~) of the reserved instance remains unchanged before and after the modification. Otherwise, the modification fails.
        You cannot split, merge, or change the scope of a reserved instance at the same time.
        For more information, see [Split, merge, or modify reserved instances](https://help.aliyun.com/document_detail/100375.html).
        ## [](#)Sample requests
        **Sample request to split a reserved instance**: Split a regional reserved instance that is scoped to the China (Hangzhou) region and can match two pay-as-you-go instances of the ecs.g5.xlarge instance type into two regional reserved instances that are scoped to the China (Hangzhou) region and each can match one pay-as-you-go instance of the ecs.g5.large instance type:
        <!---->
        "RegionId":"cn-hangzhou", //The ID of the region.
        "ReservedInstanceId":["ecsri-bp1hd03e9uv19e75***"], //The ID of the reserved instance that you want to split.
        "Configuration":[
        {
        "ReservedInstanceName":"testReservedInstanceName1", //The name of the new reserved instance.
        "InstanceType":"ecs.g5.large", //The instance type that the new reserved instance can match.
        "Scope":"Region", //The scope level of the new reserved instance, which must be the same as the scope level of the original reserved instance.
        "InstanceAmount":1 //The number of pay-as-you-go instances of the specified instance type that each new reserved instance can match.
        },
        {
        "ReservedInstanceName":"testReservedInstanceName2",
        "InstanceType":"ecs.g5.large",
        "Scope":"Region",
        "InstanceAmount":1
        }
        ]
        **Sample request to merge reserved instance:**: Merge two zonal reserved instances that are scoped to Hangzhou Zone H and can match four pay-as-you-go instances of the ecs.g5.xlarge instance type into one zonal reserved instance that is scoped to Hangzhou Zone H and can match two pay-as-you-go instances of the ecs.g5.4xlarge instance type:
        <!---->
        "RegionId":"cn-hangzhou", //The ID of the region.
        "ReservedInstanceId":["ecsri-bp1hd03e9uv16b75***",""ecsri-bp1hd03e9uv16b76****""], //The IDs of the reserved instances that you want to merge.
        "Configuration":[
        {
        "ReservedInstanceName":"testReservedInstanceName", //The name of the new reserved instance.
        "InstanceType":"ecs.g5.4xlarge", //The instance type that the new reserved instance can match.
        "Scope":"Zone", //The scope level of the new reserved instance, which must be the same as the scope level of the original reserved instances.
        "ZoneId":"cn-hangzhou-h", //\
        "InstanceAmount":2 //The number of pay-as-you-go instances of the specified instance type that the new reserved instance can match.
        }
        ]
        **Sample request to change the scope of a reserved instance**: Change a regional reserved instance that is scoped to Hangzhou Zone H and can match six pay-as-you-go instances of the ecs.g5.xlarge instance type to a regional reserved instance that is scoped to the China (Hangzhou) region and can match three pay-as-you-go instances of the ecs.g5.2xlarge instance type.
        <!---->
        "RegionId":"cn-hangzhou", //The ID of the region.
        "ReservedInstanceId":["ecsri-bp1hd03e9uv16b77***"], //The ID of the reserved instance whose scope you want to change.
        "Configuration":[
        {
        "ReservedInstanceName":"testReservedInstanceName", //The name of the new reserved instance.
        "InstanceType":"ecs.g5.2xlarge", //The instance type that the new reserved instance can match.
        "Scope":"Region", //The scope level of the new reserved instance.
        "InstanceAmount":3 //The number of pay-as-you-go instances of the specified instance type that the new reserved instance can match.
        }
        ]
        
        @param request: ModifyReservedInstancesRequest
        @return: ModifyReservedInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_reserved_instances_with_options_async(request, runtime)

    def modify_router_interface_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyRouterInterfaceAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyRouterInterfaceAttributeResponse:
        """
        @deprecated OpenAPI ModifyRouterInterfaceAttribute is deprecated, please use Vpc::2016-04-28::ModifyRouterInterfaceAttribute instead.
        
        @summary ModifyRouterInterfaceAttribute
        
        @param request: ModifyRouterInterfaceAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyRouterInterfaceAttributeResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.health_check_source_ip):
            query['HealthCheckSourceIp'] = request.health_check_source_ip
        if not UtilClient.is_unset(request.health_check_target_ip):
            query['HealthCheckTargetIp'] = request.health_check_target_ip
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.opposite_interface_id):
            query['OppositeInterfaceId'] = request.opposite_interface_id
        if not UtilClient.is_unset(request.opposite_interface_owner_id):
            query['OppositeInterfaceOwnerId'] = request.opposite_interface_owner_id
        if not UtilClient.is_unset(request.opposite_router_id):
            query['OppositeRouterId'] = request.opposite_router_id
        if not UtilClient.is_unset(request.opposite_router_type):
            query['OppositeRouterType'] = request.opposite_router_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyRouterInterfaceAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyRouterInterfaceAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_router_interface_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyRouterInterfaceAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyRouterInterfaceAttributeResponse:
        """
        @deprecated OpenAPI ModifyRouterInterfaceAttribute is deprecated, please use Vpc::2016-04-28::ModifyRouterInterfaceAttribute instead.
        
        @summary ModifyRouterInterfaceAttribute
        
        @param request: ModifyRouterInterfaceAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyRouterInterfaceAttributeResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.health_check_source_ip):
            query['HealthCheckSourceIp'] = request.health_check_source_ip
        if not UtilClient.is_unset(request.health_check_target_ip):
            query['HealthCheckTargetIp'] = request.health_check_target_ip
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.opposite_interface_id):
            query['OppositeInterfaceId'] = request.opposite_interface_id
        if not UtilClient.is_unset(request.opposite_interface_owner_id):
            query['OppositeInterfaceOwnerId'] = request.opposite_interface_owner_id
        if not UtilClient.is_unset(request.opposite_router_id):
            query['OppositeRouterId'] = request.opposite_router_id
        if not UtilClient.is_unset(request.opposite_router_type):
            query['OppositeRouterType'] = request.opposite_router_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyRouterInterfaceAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyRouterInterfaceAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_router_interface_attribute(
        self,
        request: ecs_20140526_models.ModifyRouterInterfaceAttributeRequest,
    ) -> ecs_20140526_models.ModifyRouterInterfaceAttributeResponse:
        """
        @deprecated OpenAPI ModifyRouterInterfaceAttribute is deprecated, please use Vpc::2016-04-28::ModifyRouterInterfaceAttribute instead.
        
        @summary ModifyRouterInterfaceAttribute
        
        @param request: ModifyRouterInterfaceAttributeRequest
        @return: ModifyRouterInterfaceAttributeResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_router_interface_attribute_with_options(request, runtime)

    async def modify_router_interface_attribute_async(
        self,
        request: ecs_20140526_models.ModifyRouterInterfaceAttributeRequest,
    ) -> ecs_20140526_models.ModifyRouterInterfaceAttributeResponse:
        """
        @deprecated OpenAPI ModifyRouterInterfaceAttribute is deprecated, please use Vpc::2016-04-28::ModifyRouterInterfaceAttribute instead.
        
        @summary ModifyRouterInterfaceAttribute
        
        @param request: ModifyRouterInterfaceAttributeRequest
        @return: ModifyRouterInterfaceAttributeResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_router_interface_attribute_with_options_async(request, runtime)

    def modify_router_interface_spec_with_options(
        self,
        request: ecs_20140526_models.ModifyRouterInterfaceSpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyRouterInterfaceSpecResponse:
        """
        @deprecated OpenAPI ModifyRouterInterfaceSpec is deprecated, please use Vpc::2016-04-28::ModifyRouterInterfaceSpec instead.
        
        @summary ModifyRouterInterfaceSpec
        
        @param request: ModifyRouterInterfaceSpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyRouterInterfaceSpecResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyRouterInterfaceSpec',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyRouterInterfaceSpecResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_router_interface_spec_with_options_async(
        self,
        request: ecs_20140526_models.ModifyRouterInterfaceSpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyRouterInterfaceSpecResponse:
        """
        @deprecated OpenAPI ModifyRouterInterfaceSpec is deprecated, please use Vpc::2016-04-28::ModifyRouterInterfaceSpec instead.
        
        @summary ModifyRouterInterfaceSpec
        
        @param request: ModifyRouterInterfaceSpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyRouterInterfaceSpecResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyRouterInterfaceSpec',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyRouterInterfaceSpecResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_router_interface_spec(
        self,
        request: ecs_20140526_models.ModifyRouterInterfaceSpecRequest,
    ) -> ecs_20140526_models.ModifyRouterInterfaceSpecResponse:
        """
        @deprecated OpenAPI ModifyRouterInterfaceSpec is deprecated, please use Vpc::2016-04-28::ModifyRouterInterfaceSpec instead.
        
        @summary ModifyRouterInterfaceSpec
        
        @param request: ModifyRouterInterfaceSpecRequest
        @return: ModifyRouterInterfaceSpecResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_router_interface_spec_with_options(request, runtime)

    async def modify_router_interface_spec_async(
        self,
        request: ecs_20140526_models.ModifyRouterInterfaceSpecRequest,
    ) -> ecs_20140526_models.ModifyRouterInterfaceSpecResponse:
        """
        @deprecated OpenAPI ModifyRouterInterfaceSpec is deprecated, please use Vpc::2016-04-28::ModifyRouterInterfaceSpec instead.
        
        @summary ModifyRouterInterfaceSpec
        
        @param request: ModifyRouterInterfaceSpecRequest
        @return: ModifyRouterInterfaceSpecResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_router_interface_spec_with_options_async(request, runtime)

    def modify_security_group_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifySecurityGroupAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifySecurityGroupAttributeResponse:
        """
        @summary Modifies the name or description of a specific security group.
        
        @param request: ModifySecurityGroupAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySecurityGroupAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_name):
            query['SecurityGroupName'] = request.security_group_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySecurityGroupAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifySecurityGroupAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_security_group_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifySecurityGroupAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifySecurityGroupAttributeResponse:
        """
        @summary Modifies the name or description of a specific security group.
        
        @param request: ModifySecurityGroupAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySecurityGroupAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_name):
            query['SecurityGroupName'] = request.security_group_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySecurityGroupAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifySecurityGroupAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_security_group_attribute(
        self,
        request: ecs_20140526_models.ModifySecurityGroupAttributeRequest,
    ) -> ecs_20140526_models.ModifySecurityGroupAttributeResponse:
        """
        @summary Modifies the name or description of a specific security group.
        
        @param request: ModifySecurityGroupAttributeRequest
        @return: ModifySecurityGroupAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_security_group_attribute_with_options(request, runtime)

    async def modify_security_group_attribute_async(
        self,
        request: ecs_20140526_models.ModifySecurityGroupAttributeRequest,
    ) -> ecs_20140526_models.ModifySecurityGroupAttributeResponse:
        """
        @summary Modifies the name or description of a specific security group.
        
        @param request: ModifySecurityGroupAttributeRequest
        @return: ModifySecurityGroupAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_security_group_attribute_with_options_async(request, runtime)

    def modify_security_group_egress_rule_with_options(
        self,
        request: ecs_20140526_models.ModifySecurityGroupEgressRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifySecurityGroupEgressRuleResponse:
        """
        @summary Modifies an outbound security group rule in a security group.
        
        @description Take note of the following items:
        An authorization object in a security group rule can be of one of the following types: IPv4 CIDR block or address, IPv6 CIDR block or address, security group, or prefix list. You cannot call this operation to change the type of an existing authorization object. For example, if an authorization object is an IPv4 CIDR block, you can change the authorization object to a different IPv4 CIDR block or an IPv4 address, but you cannot change the authorization object to an IPv6 CIDR block or address, a security group, or a prefix list.
        You cannot delete the value of a non-empty parameter. If you want to delete the values of non-empty parameters, we recommend that you create another rule and delete the original rule.
        
        @param request: ModifySecurityGroupEgressRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySecurityGroupEgressRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dest_cidr_ip):
            query['DestCidrIp'] = request.dest_cidr_ip
        if not UtilClient.is_unset(request.dest_group_id):
            query['DestGroupId'] = request.dest_group_id
        if not UtilClient.is_unset(request.dest_group_owner_account):
            query['DestGroupOwnerAccount'] = request.dest_group_owner_account
        if not UtilClient.is_unset(request.dest_group_owner_id):
            query['DestGroupOwnerId'] = request.dest_group_owner_id
        if not UtilClient.is_unset(request.dest_prefix_list_id):
            query['DestPrefixListId'] = request.dest_prefix_list_id
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.ipv_6dest_cidr_ip):
            query['Ipv6DestCidrIp'] = request.ipv_6dest_cidr_ip
        if not UtilClient.is_unset(request.ipv_6source_cidr_ip):
            query['Ipv6SourceCidrIp'] = request.ipv_6source_cidr_ip
        if not UtilClient.is_unset(request.nic_type):
            query['NicType'] = request.nic_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.policy):
            query['Policy'] = request.policy
        if not UtilClient.is_unset(request.port_range):
            query['PortRange'] = request.port_range
        if not UtilClient.is_unset(request.port_range_list_id):
            query['PortRangeListId'] = request.port_range_list_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_rule_id):
            query['SecurityGroupRuleId'] = request.security_group_rule_id
        if not UtilClient.is_unset(request.source_cidr_ip):
            query['SourceCidrIp'] = request.source_cidr_ip
        if not UtilClient.is_unset(request.source_port_range):
            query['SourcePortRange'] = request.source_port_range
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySecurityGroupEgressRule',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifySecurityGroupEgressRuleResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_security_group_egress_rule_with_options_async(
        self,
        request: ecs_20140526_models.ModifySecurityGroupEgressRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifySecurityGroupEgressRuleResponse:
        """
        @summary Modifies an outbound security group rule in a security group.
        
        @description Take note of the following items:
        An authorization object in a security group rule can be of one of the following types: IPv4 CIDR block or address, IPv6 CIDR block or address, security group, or prefix list. You cannot call this operation to change the type of an existing authorization object. For example, if an authorization object is an IPv4 CIDR block, you can change the authorization object to a different IPv4 CIDR block or an IPv4 address, but you cannot change the authorization object to an IPv6 CIDR block or address, a security group, or a prefix list.
        You cannot delete the value of a non-empty parameter. If you want to delete the values of non-empty parameters, we recommend that you create another rule and delete the original rule.
        
        @param request: ModifySecurityGroupEgressRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySecurityGroupEgressRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dest_cidr_ip):
            query['DestCidrIp'] = request.dest_cidr_ip
        if not UtilClient.is_unset(request.dest_group_id):
            query['DestGroupId'] = request.dest_group_id
        if not UtilClient.is_unset(request.dest_group_owner_account):
            query['DestGroupOwnerAccount'] = request.dest_group_owner_account
        if not UtilClient.is_unset(request.dest_group_owner_id):
            query['DestGroupOwnerId'] = request.dest_group_owner_id
        if not UtilClient.is_unset(request.dest_prefix_list_id):
            query['DestPrefixListId'] = request.dest_prefix_list_id
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.ipv_6dest_cidr_ip):
            query['Ipv6DestCidrIp'] = request.ipv_6dest_cidr_ip
        if not UtilClient.is_unset(request.ipv_6source_cidr_ip):
            query['Ipv6SourceCidrIp'] = request.ipv_6source_cidr_ip
        if not UtilClient.is_unset(request.nic_type):
            query['NicType'] = request.nic_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.policy):
            query['Policy'] = request.policy
        if not UtilClient.is_unset(request.port_range):
            query['PortRange'] = request.port_range
        if not UtilClient.is_unset(request.port_range_list_id):
            query['PortRangeListId'] = request.port_range_list_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_rule_id):
            query['SecurityGroupRuleId'] = request.security_group_rule_id
        if not UtilClient.is_unset(request.source_cidr_ip):
            query['SourceCidrIp'] = request.source_cidr_ip
        if not UtilClient.is_unset(request.source_port_range):
            query['SourcePortRange'] = request.source_port_range
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySecurityGroupEgressRule',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifySecurityGroupEgressRuleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_security_group_egress_rule(
        self,
        request: ecs_20140526_models.ModifySecurityGroupEgressRuleRequest,
    ) -> ecs_20140526_models.ModifySecurityGroupEgressRuleResponse:
        """
        @summary Modifies an outbound security group rule in a security group.
        
        @description Take note of the following items:
        An authorization object in a security group rule can be of one of the following types: IPv4 CIDR block or address, IPv6 CIDR block or address, security group, or prefix list. You cannot call this operation to change the type of an existing authorization object. For example, if an authorization object is an IPv4 CIDR block, you can change the authorization object to a different IPv4 CIDR block or an IPv4 address, but you cannot change the authorization object to an IPv6 CIDR block or address, a security group, or a prefix list.
        You cannot delete the value of a non-empty parameter. If you want to delete the values of non-empty parameters, we recommend that you create another rule and delete the original rule.
        
        @param request: ModifySecurityGroupEgressRuleRequest
        @return: ModifySecurityGroupEgressRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_security_group_egress_rule_with_options(request, runtime)

    async def modify_security_group_egress_rule_async(
        self,
        request: ecs_20140526_models.ModifySecurityGroupEgressRuleRequest,
    ) -> ecs_20140526_models.ModifySecurityGroupEgressRuleResponse:
        """
        @summary Modifies an outbound security group rule in a security group.
        
        @description Take note of the following items:
        An authorization object in a security group rule can be of one of the following types: IPv4 CIDR block or address, IPv6 CIDR block or address, security group, or prefix list. You cannot call this operation to change the type of an existing authorization object. For example, if an authorization object is an IPv4 CIDR block, you can change the authorization object to a different IPv4 CIDR block or an IPv4 address, but you cannot change the authorization object to an IPv6 CIDR block or address, a security group, or a prefix list.
        You cannot delete the value of a non-empty parameter. If you want to delete the values of non-empty parameters, we recommend that you create another rule and delete the original rule.
        
        @param request: ModifySecurityGroupEgressRuleRequest
        @return: ModifySecurityGroupEgressRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_security_group_egress_rule_with_options_async(request, runtime)

    def modify_security_group_policy_with_options(
        self,
        request: ecs_20140526_models.ModifySecurityGroupPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifySecurityGroupPolicyResponse:
        """
        @summary Modifies the internal access control policy of a basic security group.
        
        @description    By default, advanced security groups use the **internal isolation policy**, and Elastic Compute Service (ECS) instances in each advanced security group cannot communicate with each other. The internal access control policy of advanced security groups cannot be modified.
        You can call the [DescribeSecurityGroupAttribute](https://help.aliyun.com/document_detail/25555.html) operation to query the internal access control policy of a security group.
        If the internal access control policy of a security group is set to **Accept**, the security group uses the internal interconnectivity policy and all ECS instances in the security group can communicate with each other over the internal network, regardless of whether custom rules exist in the security group.
        If the internal access control policy of a security group is set to **Drop** and the security group contains no custom rules, the security group uses the internal isolation policy and all ECS instances in the security group cannot communicate with each other over the internal network. In this case, you can use custom rules to allow ECS instances in the security group to communicate with each other. For example, you can call the [AuthorizeSecurityGroup](https://help.aliyun.com/document_detail/25554.html) operation to configure custom rules.
        
        @param request: ModifySecurityGroupPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySecurityGroupPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.inner_access_policy):
            query['InnerAccessPolicy'] = request.inner_access_policy
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySecurityGroupPolicy',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifySecurityGroupPolicyResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_security_group_policy_with_options_async(
        self,
        request: ecs_20140526_models.ModifySecurityGroupPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifySecurityGroupPolicyResponse:
        """
        @summary Modifies the internal access control policy of a basic security group.
        
        @description    By default, advanced security groups use the **internal isolation policy**, and Elastic Compute Service (ECS) instances in each advanced security group cannot communicate with each other. The internal access control policy of advanced security groups cannot be modified.
        You can call the [DescribeSecurityGroupAttribute](https://help.aliyun.com/document_detail/25555.html) operation to query the internal access control policy of a security group.
        If the internal access control policy of a security group is set to **Accept**, the security group uses the internal interconnectivity policy and all ECS instances in the security group can communicate with each other over the internal network, regardless of whether custom rules exist in the security group.
        If the internal access control policy of a security group is set to **Drop** and the security group contains no custom rules, the security group uses the internal isolation policy and all ECS instances in the security group cannot communicate with each other over the internal network. In this case, you can use custom rules to allow ECS instances in the security group to communicate with each other. For example, you can call the [AuthorizeSecurityGroup](https://help.aliyun.com/document_detail/25554.html) operation to configure custom rules.
        
        @param request: ModifySecurityGroupPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySecurityGroupPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.inner_access_policy):
            query['InnerAccessPolicy'] = request.inner_access_policy
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySecurityGroupPolicy',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifySecurityGroupPolicyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_security_group_policy(
        self,
        request: ecs_20140526_models.ModifySecurityGroupPolicyRequest,
    ) -> ecs_20140526_models.ModifySecurityGroupPolicyResponse:
        """
        @summary Modifies the internal access control policy of a basic security group.
        
        @description    By default, advanced security groups use the **internal isolation policy**, and Elastic Compute Service (ECS) instances in each advanced security group cannot communicate with each other. The internal access control policy of advanced security groups cannot be modified.
        You can call the [DescribeSecurityGroupAttribute](https://help.aliyun.com/document_detail/25555.html) operation to query the internal access control policy of a security group.
        If the internal access control policy of a security group is set to **Accept**, the security group uses the internal interconnectivity policy and all ECS instances in the security group can communicate with each other over the internal network, regardless of whether custom rules exist in the security group.
        If the internal access control policy of a security group is set to **Drop** and the security group contains no custom rules, the security group uses the internal isolation policy and all ECS instances in the security group cannot communicate with each other over the internal network. In this case, you can use custom rules to allow ECS instances in the security group to communicate with each other. For example, you can call the [AuthorizeSecurityGroup](https://help.aliyun.com/document_detail/25554.html) operation to configure custom rules.
        
        @param request: ModifySecurityGroupPolicyRequest
        @return: ModifySecurityGroupPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_security_group_policy_with_options(request, runtime)

    async def modify_security_group_policy_async(
        self,
        request: ecs_20140526_models.ModifySecurityGroupPolicyRequest,
    ) -> ecs_20140526_models.ModifySecurityGroupPolicyResponse:
        """
        @summary Modifies the internal access control policy of a basic security group.
        
        @description    By default, advanced security groups use the **internal isolation policy**, and Elastic Compute Service (ECS) instances in each advanced security group cannot communicate with each other. The internal access control policy of advanced security groups cannot be modified.
        You can call the [DescribeSecurityGroupAttribute](https://help.aliyun.com/document_detail/25555.html) operation to query the internal access control policy of a security group.
        If the internal access control policy of a security group is set to **Accept**, the security group uses the internal interconnectivity policy and all ECS instances in the security group can communicate with each other over the internal network, regardless of whether custom rules exist in the security group.
        If the internal access control policy of a security group is set to **Drop** and the security group contains no custom rules, the security group uses the internal isolation policy and all ECS instances in the security group cannot communicate with each other over the internal network. In this case, you can use custom rules to allow ECS instances in the security group to communicate with each other. For example, you can call the [AuthorizeSecurityGroup](https://help.aliyun.com/document_detail/25554.html) operation to configure custom rules.
        
        @param request: ModifySecurityGroupPolicyRequest
        @return: ModifySecurityGroupPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_security_group_policy_with_options_async(request, runtime)

    def modify_security_group_rule_with_options(
        self,
        request: ecs_20140526_models.ModifySecurityGroupRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifySecurityGroupRuleResponse:
        """
        @summary Modifies an inbound security group rule in a security group.
        
        @description Take note of the following items:
        An authorization object in a security group rule can be of one of the following types: IPv4 CIDR block or address, IPv6 CIDR block or address, security group, or prefix list. You cannot call this operation to change the type of an existing authorization object. For example, if an authorization object is an IPv4 CIDR block, you can change the authorization object to a different IPv4 CIDR block or an IPv4 address, but you cannot change the authorization object to an IPv6 CIDR block or address, a security group, or a prefix list.
        You cannot delete the value of a non-empty parameter. If you want to delete the values of non-empty parameters, we recommend that you create a security group rule and delete the original security group rule.
        
        @param request: ModifySecurityGroupRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySecurityGroupRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dest_cidr_ip):
            query['DestCidrIp'] = request.dest_cidr_ip
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.ipv_6dest_cidr_ip):
            query['Ipv6DestCidrIp'] = request.ipv_6dest_cidr_ip
        if not UtilClient.is_unset(request.ipv_6source_cidr_ip):
            query['Ipv6SourceCidrIp'] = request.ipv_6source_cidr_ip
        if not UtilClient.is_unset(request.nic_type):
            query['NicType'] = request.nic_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.policy):
            query['Policy'] = request.policy
        if not UtilClient.is_unset(request.port_range):
            query['PortRange'] = request.port_range
        if not UtilClient.is_unset(request.port_range_list_id):
            query['PortRangeListId'] = request.port_range_list_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_rule_id):
            query['SecurityGroupRuleId'] = request.security_group_rule_id
        if not UtilClient.is_unset(request.source_cidr_ip):
            query['SourceCidrIp'] = request.source_cidr_ip
        if not UtilClient.is_unset(request.source_group_id):
            query['SourceGroupId'] = request.source_group_id
        if not UtilClient.is_unset(request.source_group_owner_account):
            query['SourceGroupOwnerAccount'] = request.source_group_owner_account
        if not UtilClient.is_unset(request.source_group_owner_id):
            query['SourceGroupOwnerId'] = request.source_group_owner_id
        if not UtilClient.is_unset(request.source_port_range):
            query['SourcePortRange'] = request.source_port_range
        if not UtilClient.is_unset(request.source_prefix_list_id):
            query['SourcePrefixListId'] = request.source_prefix_list_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySecurityGroupRule',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifySecurityGroupRuleResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_security_group_rule_with_options_async(
        self,
        request: ecs_20140526_models.ModifySecurityGroupRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifySecurityGroupRuleResponse:
        """
        @summary Modifies an inbound security group rule in a security group.
        
        @description Take note of the following items:
        An authorization object in a security group rule can be of one of the following types: IPv4 CIDR block or address, IPv6 CIDR block or address, security group, or prefix list. You cannot call this operation to change the type of an existing authorization object. For example, if an authorization object is an IPv4 CIDR block, you can change the authorization object to a different IPv4 CIDR block or an IPv4 address, but you cannot change the authorization object to an IPv6 CIDR block or address, a security group, or a prefix list.
        You cannot delete the value of a non-empty parameter. If you want to delete the values of non-empty parameters, we recommend that you create a security group rule and delete the original security group rule.
        
        @param request: ModifySecurityGroupRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySecurityGroupRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dest_cidr_ip):
            query['DestCidrIp'] = request.dest_cidr_ip
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.ipv_6dest_cidr_ip):
            query['Ipv6DestCidrIp'] = request.ipv_6dest_cidr_ip
        if not UtilClient.is_unset(request.ipv_6source_cidr_ip):
            query['Ipv6SourceCidrIp'] = request.ipv_6source_cidr_ip
        if not UtilClient.is_unset(request.nic_type):
            query['NicType'] = request.nic_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.policy):
            query['Policy'] = request.policy
        if not UtilClient.is_unset(request.port_range):
            query['PortRange'] = request.port_range
        if not UtilClient.is_unset(request.port_range_list_id):
            query['PortRangeListId'] = request.port_range_list_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_rule_id):
            query['SecurityGroupRuleId'] = request.security_group_rule_id
        if not UtilClient.is_unset(request.source_cidr_ip):
            query['SourceCidrIp'] = request.source_cidr_ip
        if not UtilClient.is_unset(request.source_group_id):
            query['SourceGroupId'] = request.source_group_id
        if not UtilClient.is_unset(request.source_group_owner_account):
            query['SourceGroupOwnerAccount'] = request.source_group_owner_account
        if not UtilClient.is_unset(request.source_group_owner_id):
            query['SourceGroupOwnerId'] = request.source_group_owner_id
        if not UtilClient.is_unset(request.source_port_range):
            query['SourcePortRange'] = request.source_port_range
        if not UtilClient.is_unset(request.source_prefix_list_id):
            query['SourcePrefixListId'] = request.source_prefix_list_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySecurityGroupRule',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifySecurityGroupRuleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_security_group_rule(
        self,
        request: ecs_20140526_models.ModifySecurityGroupRuleRequest,
    ) -> ecs_20140526_models.ModifySecurityGroupRuleResponse:
        """
        @summary Modifies an inbound security group rule in a security group.
        
        @description Take note of the following items:
        An authorization object in a security group rule can be of one of the following types: IPv4 CIDR block or address, IPv6 CIDR block or address, security group, or prefix list. You cannot call this operation to change the type of an existing authorization object. For example, if an authorization object is an IPv4 CIDR block, you can change the authorization object to a different IPv4 CIDR block or an IPv4 address, but you cannot change the authorization object to an IPv6 CIDR block or address, a security group, or a prefix list.
        You cannot delete the value of a non-empty parameter. If you want to delete the values of non-empty parameters, we recommend that you create a security group rule and delete the original security group rule.
        
        @param request: ModifySecurityGroupRuleRequest
        @return: ModifySecurityGroupRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_security_group_rule_with_options(request, runtime)

    async def modify_security_group_rule_async(
        self,
        request: ecs_20140526_models.ModifySecurityGroupRuleRequest,
    ) -> ecs_20140526_models.ModifySecurityGroupRuleResponse:
        """
        @summary Modifies an inbound security group rule in a security group.
        
        @description Take note of the following items:
        An authorization object in a security group rule can be of one of the following types: IPv4 CIDR block or address, IPv6 CIDR block or address, security group, or prefix list. You cannot call this operation to change the type of an existing authorization object. For example, if an authorization object is an IPv4 CIDR block, you can change the authorization object to a different IPv4 CIDR block or an IPv4 address, but you cannot change the authorization object to an IPv6 CIDR block or address, a security group, or a prefix list.
        You cannot delete the value of a non-empty parameter. If you want to delete the values of non-empty parameters, we recommend that you create a security group rule and delete the original security group rule.
        
        @param request: ModifySecurityGroupRuleRequest
        @return: ModifySecurityGroupRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_security_group_rule_with_options_async(request, runtime)

    def modify_snapshot_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifySnapshotAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifySnapshotAttributeResponse:
        """
        @summary Modifies the name, description, or retention period of a snapshot.
        
        @param request: ModifySnapshotAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySnapshotAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.disable_instant_access):
            query['DisableInstantAccess'] = request.disable_instant_access
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.retention_days):
            query['RetentionDays'] = request.retention_days
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        if not UtilClient.is_unset(request.snapshot_name):
            query['SnapshotName'] = request.snapshot_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySnapshotAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifySnapshotAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_snapshot_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifySnapshotAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifySnapshotAttributeResponse:
        """
        @summary Modifies the name, description, or retention period of a snapshot.
        
        @param request: ModifySnapshotAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySnapshotAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.disable_instant_access):
            query['DisableInstantAccess'] = request.disable_instant_access
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.retention_days):
            query['RetentionDays'] = request.retention_days
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        if not UtilClient.is_unset(request.snapshot_name):
            query['SnapshotName'] = request.snapshot_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySnapshotAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifySnapshotAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_snapshot_attribute(
        self,
        request: ecs_20140526_models.ModifySnapshotAttributeRequest,
    ) -> ecs_20140526_models.ModifySnapshotAttributeResponse:
        """
        @summary Modifies the name, description, or retention period of a snapshot.
        
        @param request: ModifySnapshotAttributeRequest
        @return: ModifySnapshotAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_snapshot_attribute_with_options(request, runtime)

    async def modify_snapshot_attribute_async(
        self,
        request: ecs_20140526_models.ModifySnapshotAttributeRequest,
    ) -> ecs_20140526_models.ModifySnapshotAttributeResponse:
        """
        @summary Modifies the name, description, or retention period of a snapshot.
        
        @param request: ModifySnapshotAttributeRequest
        @return: ModifySnapshotAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_snapshot_attribute_with_options_async(request, runtime)

    def modify_snapshot_category_with_options(
        self,
        request: ecs_20140526_models.ModifySnapshotCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifySnapshotCategoryResponse:
        """
        @summary Changes the type of a snapshot. You can call this operation to convert a standard snapshot into an archive snapshot.
        
        @description    Archive snapshots cannot be restored to standard snapshots.
        You can archive only standard snapshots that have been retained for at least 14 days.
        You cannot archive encrypted snapshots.
        You cannot archive snapshots that are shared to you, snapshots managed by Cloud Backup, or snapshots in cloud boxes.
        The archive snapshot feature is available only in the China (Hohhot), Malaysia (Kuala Lumpur), South Korea (Seoul), Philippines (Manila), Thailand (Bangkok), and Mexico regions. The availability of the feature in other regions is subject to notice.
        
        @param request: ModifySnapshotCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySnapshotCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category):
            query['Category'] = request.category
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.retention_days):
            query['RetentionDays'] = request.retention_days
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySnapshotCategory',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifySnapshotCategoryResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_snapshot_category_with_options_async(
        self,
        request: ecs_20140526_models.ModifySnapshotCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifySnapshotCategoryResponse:
        """
        @summary Changes the type of a snapshot. You can call this operation to convert a standard snapshot into an archive snapshot.
        
        @description    Archive snapshots cannot be restored to standard snapshots.
        You can archive only standard snapshots that have been retained for at least 14 days.
        You cannot archive encrypted snapshots.
        You cannot archive snapshots that are shared to you, snapshots managed by Cloud Backup, or snapshots in cloud boxes.
        The archive snapshot feature is available only in the China (Hohhot), Malaysia (Kuala Lumpur), South Korea (Seoul), Philippines (Manila), Thailand (Bangkok), and Mexico regions. The availability of the feature in other regions is subject to notice.
        
        @param request: ModifySnapshotCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySnapshotCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category):
            query['Category'] = request.category
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.retention_days):
            query['RetentionDays'] = request.retention_days
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySnapshotCategory',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifySnapshotCategoryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_snapshot_category(
        self,
        request: ecs_20140526_models.ModifySnapshotCategoryRequest,
    ) -> ecs_20140526_models.ModifySnapshotCategoryResponse:
        """
        @summary Changes the type of a snapshot. You can call this operation to convert a standard snapshot into an archive snapshot.
        
        @description    Archive snapshots cannot be restored to standard snapshots.
        You can archive only standard snapshots that have been retained for at least 14 days.
        You cannot archive encrypted snapshots.
        You cannot archive snapshots that are shared to you, snapshots managed by Cloud Backup, or snapshots in cloud boxes.
        The archive snapshot feature is available only in the China (Hohhot), Malaysia (Kuala Lumpur), South Korea (Seoul), Philippines (Manila), Thailand (Bangkok), and Mexico regions. The availability of the feature in other regions is subject to notice.
        
        @param request: ModifySnapshotCategoryRequest
        @return: ModifySnapshotCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_snapshot_category_with_options(request, runtime)

    async def modify_snapshot_category_async(
        self,
        request: ecs_20140526_models.ModifySnapshotCategoryRequest,
    ) -> ecs_20140526_models.ModifySnapshotCategoryResponse:
        """
        @summary Changes the type of a snapshot. You can call this operation to convert a standard snapshot into an archive snapshot.
        
        @description    Archive snapshots cannot be restored to standard snapshots.
        You can archive only standard snapshots that have been retained for at least 14 days.
        You cannot archive encrypted snapshots.
        You cannot archive snapshots that are shared to you, snapshots managed by Cloud Backup, or snapshots in cloud boxes.
        The archive snapshot feature is available only in the China (Hohhot), Malaysia (Kuala Lumpur), South Korea (Seoul), Philippines (Manila), Thailand (Bangkok), and Mexico regions. The availability of the feature in other regions is subject to notice.
        
        @param request: ModifySnapshotCategoryRequest
        @return: ModifySnapshotCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_snapshot_category_with_options_async(request, runtime)

    def modify_snapshot_group_with_options(
        self,
        request: ecs_20140526_models.ModifySnapshotGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifySnapshotGroupResponse:
        """
        @summary Modifies the name and description of a snapshot-consistent group.
        
        @param request: ModifySnapshotGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySnapshotGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snapshot_group_id):
            query['SnapshotGroupId'] = request.snapshot_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySnapshotGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifySnapshotGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_snapshot_group_with_options_async(
        self,
        request: ecs_20140526_models.ModifySnapshotGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifySnapshotGroupResponse:
        """
        @summary Modifies the name and description of a snapshot-consistent group.
        
        @param request: ModifySnapshotGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySnapshotGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snapshot_group_id):
            query['SnapshotGroupId'] = request.snapshot_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySnapshotGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifySnapshotGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_snapshot_group(
        self,
        request: ecs_20140526_models.ModifySnapshotGroupRequest,
    ) -> ecs_20140526_models.ModifySnapshotGroupResponse:
        """
        @summary Modifies the name and description of a snapshot-consistent group.
        
        @param request: ModifySnapshotGroupRequest
        @return: ModifySnapshotGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_snapshot_group_with_options(request, runtime)

    async def modify_snapshot_group_async(
        self,
        request: ecs_20140526_models.ModifySnapshotGroupRequest,
    ) -> ecs_20140526_models.ModifySnapshotGroupResponse:
        """
        @summary Modifies the name and description of a snapshot-consistent group.
        
        @param request: ModifySnapshotGroupRequest
        @return: ModifySnapshotGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_snapshot_group_with_options_async(request, runtime)

    def modify_storage_capacity_unit_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyStorageCapacityUnitAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyStorageCapacityUnitAttributeResponse:
        """
        @summary Changes the name or modifies the description of a storage capacity unit (SCU).
        
        @param request: ModifyStorageCapacityUnitAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyStorageCapacityUnitAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_capacity_unit_id):
            query['StorageCapacityUnitId'] = request.storage_capacity_unit_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyStorageCapacityUnitAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyStorageCapacityUnitAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_storage_capacity_unit_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyStorageCapacityUnitAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyStorageCapacityUnitAttributeResponse:
        """
        @summary Changes the name or modifies the description of a storage capacity unit (SCU).
        
        @param request: ModifyStorageCapacityUnitAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyStorageCapacityUnitAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_capacity_unit_id):
            query['StorageCapacityUnitId'] = request.storage_capacity_unit_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyStorageCapacityUnitAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyStorageCapacityUnitAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_storage_capacity_unit_attribute(
        self,
        request: ecs_20140526_models.ModifyStorageCapacityUnitAttributeRequest,
    ) -> ecs_20140526_models.ModifyStorageCapacityUnitAttributeResponse:
        """
        @summary Changes the name or modifies the description of a storage capacity unit (SCU).
        
        @param request: ModifyStorageCapacityUnitAttributeRequest
        @return: ModifyStorageCapacityUnitAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_storage_capacity_unit_attribute_with_options(request, runtime)

    async def modify_storage_capacity_unit_attribute_async(
        self,
        request: ecs_20140526_models.ModifyStorageCapacityUnitAttributeRequest,
    ) -> ecs_20140526_models.ModifyStorageCapacityUnitAttributeResponse:
        """
        @summary Changes the name or modifies the description of a storage capacity unit (SCU).
        
        @param request: ModifyStorageCapacityUnitAttributeRequest
        @return: ModifyStorageCapacityUnitAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_storage_capacity_unit_attribute_with_options_async(request, runtime)

    def modify_storage_set_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyStorageSetAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyStorageSetAttributeResponse:
        """
        @summary Modifies the name or description of a storage set.
        
        @param request: ModifyStorageSetAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyStorageSetAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_set_id):
            query['StorageSetId'] = request.storage_set_id
        if not UtilClient.is_unset(request.storage_set_name):
            query['StorageSetName'] = request.storage_set_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyStorageSetAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyStorageSetAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_storage_set_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyStorageSetAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyStorageSetAttributeResponse:
        """
        @summary Modifies the name or description of a storage set.
        
        @param request: ModifyStorageSetAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyStorageSetAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_set_id):
            query['StorageSetId'] = request.storage_set_id
        if not UtilClient.is_unset(request.storage_set_name):
            query['StorageSetName'] = request.storage_set_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyStorageSetAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyStorageSetAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_storage_set_attribute(
        self,
        request: ecs_20140526_models.ModifyStorageSetAttributeRequest,
    ) -> ecs_20140526_models.ModifyStorageSetAttributeResponse:
        """
        @summary Modifies the name or description of a storage set.
        
        @param request: ModifyStorageSetAttributeRequest
        @return: ModifyStorageSetAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_storage_set_attribute_with_options(request, runtime)

    async def modify_storage_set_attribute_async(
        self,
        request: ecs_20140526_models.ModifyStorageSetAttributeRequest,
    ) -> ecs_20140526_models.ModifyStorageSetAttributeResponse:
        """
        @summary Modifies the name or description of a storage set.
        
        @param request: ModifyStorageSetAttributeRequest
        @return: ModifyStorageSetAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_storage_set_attribute_with_options_async(request, runtime)

    def modify_user_business_behavior_with_options(
        self,
        request: ecs_20140526_models.ModifyUserBusinessBehaviorRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyUserBusinessBehaviorResponse:
        """
        @deprecated OpenAPI ModifyUserBusinessBehavior is deprecated
        
        @summary 设置用户级别默认属性
        
        @param request: ModifyUserBusinessBehaviorRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyUserBusinessBehaviorResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status_key):
            query['statusKey'] = request.status_key
        if not UtilClient.is_unset(request.status_value):
            query['statusValue'] = request.status_value
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyUserBusinessBehavior',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyUserBusinessBehaviorResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_user_business_behavior_with_options_async(
        self,
        request: ecs_20140526_models.ModifyUserBusinessBehaviorRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyUserBusinessBehaviorResponse:
        """
        @deprecated OpenAPI ModifyUserBusinessBehavior is deprecated
        
        @summary 设置用户级别默认属性
        
        @param request: ModifyUserBusinessBehaviorRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyUserBusinessBehaviorResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status_key):
            query['statusKey'] = request.status_key
        if not UtilClient.is_unset(request.status_value):
            query['statusValue'] = request.status_value
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyUserBusinessBehavior',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyUserBusinessBehaviorResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_user_business_behavior(
        self,
        request: ecs_20140526_models.ModifyUserBusinessBehaviorRequest,
    ) -> ecs_20140526_models.ModifyUserBusinessBehaviorResponse:
        """
        @deprecated OpenAPI ModifyUserBusinessBehavior is deprecated
        
        @summary 设置用户级别默认属性
        
        @param request: ModifyUserBusinessBehaviorRequest
        @return: ModifyUserBusinessBehaviorResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_user_business_behavior_with_options(request, runtime)

    async def modify_user_business_behavior_async(
        self,
        request: ecs_20140526_models.ModifyUserBusinessBehaviorRequest,
    ) -> ecs_20140526_models.ModifyUserBusinessBehaviorResponse:
        """
        @deprecated OpenAPI ModifyUserBusinessBehavior is deprecated
        
        @summary 设置用户级别默认属性
        
        @param request: ModifyUserBusinessBehaviorRequest
        @return: ModifyUserBusinessBehaviorResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_user_business_behavior_with_options_async(request, runtime)

    def modify_vrouter_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyVRouterAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyVRouterAttributeResponse:
        """
        @deprecated OpenAPI ModifyVRouterAttribute is deprecated, please use Vpc::2016-04-28::ModifyVRouterAttribute instead.
        
        @summary ModifyVRouterAttribute
        
        @param request: ModifyVRouterAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVRouterAttributeResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vrouter_id):
            query['VRouterId'] = request.vrouter_id
        if not UtilClient.is_unset(request.vrouter_name):
            query['VRouterName'] = request.vrouter_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVRouterAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyVRouterAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_vrouter_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyVRouterAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyVRouterAttributeResponse:
        """
        @deprecated OpenAPI ModifyVRouterAttribute is deprecated, please use Vpc::2016-04-28::ModifyVRouterAttribute instead.
        
        @summary ModifyVRouterAttribute
        
        @param request: ModifyVRouterAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVRouterAttributeResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vrouter_id):
            query['VRouterId'] = request.vrouter_id
        if not UtilClient.is_unset(request.vrouter_name):
            query['VRouterName'] = request.vrouter_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVRouterAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyVRouterAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_vrouter_attribute(
        self,
        request: ecs_20140526_models.ModifyVRouterAttributeRequest,
    ) -> ecs_20140526_models.ModifyVRouterAttributeResponse:
        """
        @deprecated OpenAPI ModifyVRouterAttribute is deprecated, please use Vpc::2016-04-28::ModifyVRouterAttribute instead.
        
        @summary ModifyVRouterAttribute
        
        @param request: ModifyVRouterAttributeRequest
        @return: ModifyVRouterAttributeResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_vrouter_attribute_with_options(request, runtime)

    async def modify_vrouter_attribute_async(
        self,
        request: ecs_20140526_models.ModifyVRouterAttributeRequest,
    ) -> ecs_20140526_models.ModifyVRouterAttributeResponse:
        """
        @deprecated OpenAPI ModifyVRouterAttribute is deprecated, please use Vpc::2016-04-28::ModifyVRouterAttribute instead.
        
        @summary ModifyVRouterAttribute
        
        @param request: ModifyVRouterAttributeRequest
        @return: ModifyVRouterAttributeResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_vrouter_attribute_with_options_async(request, runtime)

    def modify_vswitch_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyVSwitchAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyVSwitchAttributeResponse:
        """
        @deprecated OpenAPI ModifyVSwitchAttribute is deprecated, please use Vpc::2016-04-28::ModifyVSwitchAttribute instead.
        
        @summary ModifyVSwitchAttribute
        
        @param request: ModifyVSwitchAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVSwitchAttributeResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.v_switch_name):
            query['VSwitchName'] = request.v_switch_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVSwitchAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyVSwitchAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_vswitch_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyVSwitchAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyVSwitchAttributeResponse:
        """
        @deprecated OpenAPI ModifyVSwitchAttribute is deprecated, please use Vpc::2016-04-28::ModifyVSwitchAttribute instead.
        
        @summary ModifyVSwitchAttribute
        
        @param request: ModifyVSwitchAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVSwitchAttributeResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.v_switch_name):
            query['VSwitchName'] = request.v_switch_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVSwitchAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyVSwitchAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_vswitch_attribute(
        self,
        request: ecs_20140526_models.ModifyVSwitchAttributeRequest,
    ) -> ecs_20140526_models.ModifyVSwitchAttributeResponse:
        """
        @deprecated OpenAPI ModifyVSwitchAttribute is deprecated, please use Vpc::2016-04-28::ModifyVSwitchAttribute instead.
        
        @summary ModifyVSwitchAttribute
        
        @param request: ModifyVSwitchAttributeRequest
        @return: ModifyVSwitchAttributeResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_vswitch_attribute_with_options(request, runtime)

    async def modify_vswitch_attribute_async(
        self,
        request: ecs_20140526_models.ModifyVSwitchAttributeRequest,
    ) -> ecs_20140526_models.ModifyVSwitchAttributeResponse:
        """
        @deprecated OpenAPI ModifyVSwitchAttribute is deprecated, please use Vpc::2016-04-28::ModifyVSwitchAttribute instead.
        
        @summary ModifyVSwitchAttribute
        
        @param request: ModifyVSwitchAttributeRequest
        @return: ModifyVSwitchAttributeResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_vswitch_attribute_with_options_async(request, runtime)

    def modify_virtual_border_router_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyVirtualBorderRouterAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyVirtualBorderRouterAttributeResponse:
        """
        @deprecated OpenAPI ModifyVirtualBorderRouterAttribute is deprecated, please use Vpc::2016-04-28::ModifyVirtualBorderRouterAttribute instead.
        
        @summary ModifyVirtualBorderRouterAttribute
        
        @param request: ModifyVirtualBorderRouterAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVirtualBorderRouterAttributeResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.circuit_code):
            query['CircuitCode'] = request.circuit_code
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.local_gateway_ip):
            query['LocalGatewayIp'] = request.local_gateway_ip
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_gateway_ip):
            query['PeerGatewayIp'] = request.peer_gateway_ip
        if not UtilClient.is_unset(request.peering_subnet_mask):
            query['PeeringSubnetMask'] = request.peering_subnet_mask
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        if not UtilClient.is_unset(request.vlan_id):
            query['VlanId'] = request.vlan_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVirtualBorderRouterAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyVirtualBorderRouterAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_virtual_border_router_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyVirtualBorderRouterAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyVirtualBorderRouterAttributeResponse:
        """
        @deprecated OpenAPI ModifyVirtualBorderRouterAttribute is deprecated, please use Vpc::2016-04-28::ModifyVirtualBorderRouterAttribute instead.
        
        @summary ModifyVirtualBorderRouterAttribute
        
        @param request: ModifyVirtualBorderRouterAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVirtualBorderRouterAttributeResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.circuit_code):
            query['CircuitCode'] = request.circuit_code
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.local_gateway_ip):
            query['LocalGatewayIp'] = request.local_gateway_ip
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_gateway_ip):
            query['PeerGatewayIp'] = request.peer_gateway_ip
        if not UtilClient.is_unset(request.peering_subnet_mask):
            query['PeeringSubnetMask'] = request.peering_subnet_mask
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        if not UtilClient.is_unset(request.vlan_id):
            query['VlanId'] = request.vlan_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVirtualBorderRouterAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyVirtualBorderRouterAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_virtual_border_router_attribute(
        self,
        request: ecs_20140526_models.ModifyVirtualBorderRouterAttributeRequest,
    ) -> ecs_20140526_models.ModifyVirtualBorderRouterAttributeResponse:
        """
        @deprecated OpenAPI ModifyVirtualBorderRouterAttribute is deprecated, please use Vpc::2016-04-28::ModifyVirtualBorderRouterAttribute instead.
        
        @summary ModifyVirtualBorderRouterAttribute
        
        @param request: ModifyVirtualBorderRouterAttributeRequest
        @return: ModifyVirtualBorderRouterAttributeResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_virtual_border_router_attribute_with_options(request, runtime)

    async def modify_virtual_border_router_attribute_async(
        self,
        request: ecs_20140526_models.ModifyVirtualBorderRouterAttributeRequest,
    ) -> ecs_20140526_models.ModifyVirtualBorderRouterAttributeResponse:
        """
        @deprecated OpenAPI ModifyVirtualBorderRouterAttribute is deprecated, please use Vpc::2016-04-28::ModifyVirtualBorderRouterAttribute instead.
        
        @summary ModifyVirtualBorderRouterAttribute
        
        @param request: ModifyVirtualBorderRouterAttributeRequest
        @return: ModifyVirtualBorderRouterAttributeResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_virtual_border_router_attribute_with_options_async(request, runtime)

    def modify_vpc_attribute_with_options(
        self,
        request: ecs_20140526_models.ModifyVpcAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyVpcAttributeResponse:
        """
        @deprecated OpenAPI ModifyVpcAttribute is deprecated, please use Vpc::2016-04-28::ModifyVpcAttribute instead.
        
        @summary ModifyVpcAttribute
        
        @param request: ModifyVpcAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpcAttributeResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cidr_block):
            query['CidrBlock'] = request.cidr_block
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.vpc_name):
            query['VpcName'] = request.vpc_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVpcAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyVpcAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_vpc_attribute_with_options_async(
        self,
        request: ecs_20140526_models.ModifyVpcAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ModifyVpcAttributeResponse:
        """
        @deprecated OpenAPI ModifyVpcAttribute is deprecated, please use Vpc::2016-04-28::ModifyVpcAttribute instead.
        
        @summary ModifyVpcAttribute
        
        @param request: ModifyVpcAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpcAttributeResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cidr_block):
            query['CidrBlock'] = request.cidr_block
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.vpc_name):
            query['VpcName'] = request.vpc_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVpcAttribute',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ModifyVpcAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_vpc_attribute(
        self,
        request: ecs_20140526_models.ModifyVpcAttributeRequest,
    ) -> ecs_20140526_models.ModifyVpcAttributeResponse:
        """
        @deprecated OpenAPI ModifyVpcAttribute is deprecated, please use Vpc::2016-04-28::ModifyVpcAttribute instead.
        
        @summary ModifyVpcAttribute
        
        @param request: ModifyVpcAttributeRequest
        @return: ModifyVpcAttributeResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_vpc_attribute_with_options(request, runtime)

    async def modify_vpc_attribute_async(
        self,
        request: ecs_20140526_models.ModifyVpcAttributeRequest,
    ) -> ecs_20140526_models.ModifyVpcAttributeResponse:
        """
        @deprecated OpenAPI ModifyVpcAttribute is deprecated, please use Vpc::2016-04-28::ModifyVpcAttribute instead.
        
        @summary ModifyVpcAttribute
        
        @param request: ModifyVpcAttributeRequest
        @return: ModifyVpcAttributeResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_vpc_attribute_with_options_async(request, runtime)

    def purchase_elasticity_assurance_with_options(
        self,
        request: ecs_20140526_models.PurchaseElasticityAssuranceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.PurchaseElasticityAssuranceResponse:
        """
        @summary Purchases an elasticity assurance that is not in the Active state and for which resources are prepared.
        
        @description Before you call this operation, familiarize yourself with the billing rules and [pricing](https://www.alibabacloud.com/zh?spm=5176.28117011.nav-v2-dropdown-language.exp-location-zh.9ae4165bF98IHz&_p_lc=1) of elasticity assurances.
        Before you purchase an elasticity assurance, you can call the [DescribeElasticityAssurances](https://help.aliyun.com/document_detail/2679748.html) operation to query the elasticity assurances that you can purchase.
        
        @param request: PurchaseElasticityAssuranceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PurchaseElasticityAssuranceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PurchaseElasticityAssurance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.PurchaseElasticityAssuranceResponse(),
            self.call_api(params, req, runtime)
        )

    async def purchase_elasticity_assurance_with_options_async(
        self,
        request: ecs_20140526_models.PurchaseElasticityAssuranceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.PurchaseElasticityAssuranceResponse:
        """
        @summary Purchases an elasticity assurance that is not in the Active state and for which resources are prepared.
        
        @description Before you call this operation, familiarize yourself with the billing rules and [pricing](https://www.alibabacloud.com/zh?spm=5176.28117011.nav-v2-dropdown-language.exp-location-zh.9ae4165bF98IHz&_p_lc=1) of elasticity assurances.
        Before you purchase an elasticity assurance, you can call the [DescribeElasticityAssurances](https://help.aliyun.com/document_detail/2679748.html) operation to query the elasticity assurances that you can purchase.
        
        @param request: PurchaseElasticityAssuranceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PurchaseElasticityAssuranceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PurchaseElasticityAssurance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.PurchaseElasticityAssuranceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def purchase_elasticity_assurance(
        self,
        request: ecs_20140526_models.PurchaseElasticityAssuranceRequest,
    ) -> ecs_20140526_models.PurchaseElasticityAssuranceResponse:
        """
        @summary Purchases an elasticity assurance that is not in the Active state and for which resources are prepared.
        
        @description Before you call this operation, familiarize yourself with the billing rules and [pricing](https://www.alibabacloud.com/zh?spm=5176.28117011.nav-v2-dropdown-language.exp-location-zh.9ae4165bF98IHz&_p_lc=1) of elasticity assurances.
        Before you purchase an elasticity assurance, you can call the [DescribeElasticityAssurances](https://help.aliyun.com/document_detail/2679748.html) operation to query the elasticity assurances that you can purchase.
        
        @param request: PurchaseElasticityAssuranceRequest
        @return: PurchaseElasticityAssuranceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.purchase_elasticity_assurance_with_options(request, runtime)

    async def purchase_elasticity_assurance_async(
        self,
        request: ecs_20140526_models.PurchaseElasticityAssuranceRequest,
    ) -> ecs_20140526_models.PurchaseElasticityAssuranceResponse:
        """
        @summary Purchases an elasticity assurance that is not in the Active state and for which resources are prepared.
        
        @description Before you call this operation, familiarize yourself with the billing rules and [pricing](https://www.alibabacloud.com/zh?spm=5176.28117011.nav-v2-dropdown-language.exp-location-zh.9ae4165bF98IHz&_p_lc=1) of elasticity assurances.
        Before you purchase an elasticity assurance, you can call the [DescribeElasticityAssurances](https://help.aliyun.com/document_detail/2679748.html) operation to query the elasticity assurances that you can purchase.
        
        @param request: PurchaseElasticityAssuranceRequest
        @return: PurchaseElasticityAssuranceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.purchase_elasticity_assurance_with_options_async(request, runtime)

    def purchase_reserved_instances_offering_with_options(
        self,
        request: ecs_20140526_models.PurchaseReservedInstancesOfferingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.PurchaseReservedInstancesOfferingResponse:
        """
        @summary Purchases a regional or zonal reserved instance to offset the bills of pay-as-you-go Elastic Compute Service (ECS) instances.
        
        @description *Before you call this operation, make sure that you are familiar with the billing methods and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of reserved instances.**\
        Before you call this operation, make sure that you are familiar with the billing rules of reserved instances. For more information, see [Reserved instances](https://help.aliyun.com/document_detail/100371.html).
        You can retain up to 20 regional reserved instances in all regions per Alibaba Cloud account.
        You can retain up to 20 zonal reserved instances per zone per Alibaba Cloud account.
        ## [](#)Sample requests
        Purchase a one-year regional reserved instance in the China (Hangzhou) region to offset the bills of three ecs.g5.large Linux pay-as-you-go instances.
        <!---->
        "RegionId":"cn-hangzhou", // Specify the China (Hangzhou) region."InstanceType":"ecs.g5.large", // Specify the instance type."Scope":"Region", // Set the scope of the reserved instance to regional."InstanceAmount":3, // Specify the reserved instance to match three pay-as-you-go instances of the same instance type."OfferingType":"All Upfront", // Specify the payment option. In this example, the default value is used, which is All Upfront."Platform":"Linux", // Specify the operating system platform of the ECS instances eligible for the reserved instance. In this example, the Linux or Unix-like operating system is used."Period":1, // Specify the term of the reserved instance. In this example, the one-year duration is used."PeriodUnit":"Year", // Set the unit of the term to year.
        Purchase a two-year zonal reserved instance in Hangzhou Zone H to offset the bills of five ecs.g5.large Windows pay-as-you-go instances.
        <!---->
        "RegionId":"cn-hangzhou",
        "ZoneId":"cn-hangzhou-h", // Specify Hangzhou Zone H."InstanceType":"ecs.g5.large",
        "Scope":"Zone", // Set the scope of the reserved instance to zonal."InstanceAmount":5, // Specify the reserved instance to match five pay-as-you-go instances of the same instance type."OfferingType":"All Upfront",
        "Platform":"Windows", // Specify the operating system platform of the ECS instances eligible for the reserved instance. In this example, the Windows operating system is used."Period":2, // Specify the term of the reserved instance. In this example, the two-year duration is used."PeriodUnit":"Year", // Set the unit of the term to year.
        
        @param request: PurchaseReservedInstancesOfferingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PurchaseReservedInstancesOfferingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_period):
            query['AutoRenewPeriod'] = request.auto_renew_period
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.instance_amount):
            query['InstanceAmount'] = request.instance_amount
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.offering_type):
            query['OfferingType'] = request.offering_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.reserved_instance_name):
            query['ReservedInstanceName'] = request.reserved_instance_name
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.scope):
            query['Scope'] = request.scope
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PurchaseReservedInstancesOffering',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.PurchaseReservedInstancesOfferingResponse(),
            self.call_api(params, req, runtime)
        )

    async def purchase_reserved_instances_offering_with_options_async(
        self,
        request: ecs_20140526_models.PurchaseReservedInstancesOfferingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.PurchaseReservedInstancesOfferingResponse:
        """
        @summary Purchases a regional or zonal reserved instance to offset the bills of pay-as-you-go Elastic Compute Service (ECS) instances.
        
        @description *Before you call this operation, make sure that you are familiar with the billing methods and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of reserved instances.**\
        Before you call this operation, make sure that you are familiar with the billing rules of reserved instances. For more information, see [Reserved instances](https://help.aliyun.com/document_detail/100371.html).
        You can retain up to 20 regional reserved instances in all regions per Alibaba Cloud account.
        You can retain up to 20 zonal reserved instances per zone per Alibaba Cloud account.
        ## [](#)Sample requests
        Purchase a one-year regional reserved instance in the China (Hangzhou) region to offset the bills of three ecs.g5.large Linux pay-as-you-go instances.
        <!---->
        "RegionId":"cn-hangzhou", // Specify the China (Hangzhou) region."InstanceType":"ecs.g5.large", // Specify the instance type."Scope":"Region", // Set the scope of the reserved instance to regional."InstanceAmount":3, // Specify the reserved instance to match three pay-as-you-go instances of the same instance type."OfferingType":"All Upfront", // Specify the payment option. In this example, the default value is used, which is All Upfront."Platform":"Linux", // Specify the operating system platform of the ECS instances eligible for the reserved instance. In this example, the Linux or Unix-like operating system is used."Period":1, // Specify the term of the reserved instance. In this example, the one-year duration is used."PeriodUnit":"Year", // Set the unit of the term to year.
        Purchase a two-year zonal reserved instance in Hangzhou Zone H to offset the bills of five ecs.g5.large Windows pay-as-you-go instances.
        <!---->
        "RegionId":"cn-hangzhou",
        "ZoneId":"cn-hangzhou-h", // Specify Hangzhou Zone H."InstanceType":"ecs.g5.large",
        "Scope":"Zone", // Set the scope of the reserved instance to zonal."InstanceAmount":5, // Specify the reserved instance to match five pay-as-you-go instances of the same instance type."OfferingType":"All Upfront",
        "Platform":"Windows", // Specify the operating system platform of the ECS instances eligible for the reserved instance. In this example, the Windows operating system is used."Period":2, // Specify the term of the reserved instance. In this example, the two-year duration is used."PeriodUnit":"Year", // Set the unit of the term to year.
        
        @param request: PurchaseReservedInstancesOfferingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PurchaseReservedInstancesOfferingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_period):
            query['AutoRenewPeriod'] = request.auto_renew_period
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.instance_amount):
            query['InstanceAmount'] = request.instance_amount
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.offering_type):
            query['OfferingType'] = request.offering_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.reserved_instance_name):
            query['ReservedInstanceName'] = request.reserved_instance_name
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.scope):
            query['Scope'] = request.scope
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PurchaseReservedInstancesOffering',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.PurchaseReservedInstancesOfferingResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def purchase_reserved_instances_offering(
        self,
        request: ecs_20140526_models.PurchaseReservedInstancesOfferingRequest,
    ) -> ecs_20140526_models.PurchaseReservedInstancesOfferingResponse:
        """
        @summary Purchases a regional or zonal reserved instance to offset the bills of pay-as-you-go Elastic Compute Service (ECS) instances.
        
        @description *Before you call this operation, make sure that you are familiar with the billing methods and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of reserved instances.**\
        Before you call this operation, make sure that you are familiar with the billing rules of reserved instances. For more information, see [Reserved instances](https://help.aliyun.com/document_detail/100371.html).
        You can retain up to 20 regional reserved instances in all regions per Alibaba Cloud account.
        You can retain up to 20 zonal reserved instances per zone per Alibaba Cloud account.
        ## [](#)Sample requests
        Purchase a one-year regional reserved instance in the China (Hangzhou) region to offset the bills of three ecs.g5.large Linux pay-as-you-go instances.
        <!---->
        "RegionId":"cn-hangzhou", // Specify the China (Hangzhou) region."InstanceType":"ecs.g5.large", // Specify the instance type."Scope":"Region", // Set the scope of the reserved instance to regional."InstanceAmount":3, // Specify the reserved instance to match three pay-as-you-go instances of the same instance type."OfferingType":"All Upfront", // Specify the payment option. In this example, the default value is used, which is All Upfront."Platform":"Linux", // Specify the operating system platform of the ECS instances eligible for the reserved instance. In this example, the Linux or Unix-like operating system is used."Period":1, // Specify the term of the reserved instance. In this example, the one-year duration is used."PeriodUnit":"Year", // Set the unit of the term to year.
        Purchase a two-year zonal reserved instance in Hangzhou Zone H to offset the bills of five ecs.g5.large Windows pay-as-you-go instances.
        <!---->
        "RegionId":"cn-hangzhou",
        "ZoneId":"cn-hangzhou-h", // Specify Hangzhou Zone H."InstanceType":"ecs.g5.large",
        "Scope":"Zone", // Set the scope of the reserved instance to zonal."InstanceAmount":5, // Specify the reserved instance to match five pay-as-you-go instances of the same instance type."OfferingType":"All Upfront",
        "Platform":"Windows", // Specify the operating system platform of the ECS instances eligible for the reserved instance. In this example, the Windows operating system is used."Period":2, // Specify the term of the reserved instance. In this example, the two-year duration is used."PeriodUnit":"Year", // Set the unit of the term to year.
        
        @param request: PurchaseReservedInstancesOfferingRequest
        @return: PurchaseReservedInstancesOfferingResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.purchase_reserved_instances_offering_with_options(request, runtime)

    async def purchase_reserved_instances_offering_async(
        self,
        request: ecs_20140526_models.PurchaseReservedInstancesOfferingRequest,
    ) -> ecs_20140526_models.PurchaseReservedInstancesOfferingResponse:
        """
        @summary Purchases a regional or zonal reserved instance to offset the bills of pay-as-you-go Elastic Compute Service (ECS) instances.
        
        @description *Before you call this operation, make sure that you are familiar with the billing methods and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of reserved instances.**\
        Before you call this operation, make sure that you are familiar with the billing rules of reserved instances. For more information, see [Reserved instances](https://help.aliyun.com/document_detail/100371.html).
        You can retain up to 20 regional reserved instances in all regions per Alibaba Cloud account.
        You can retain up to 20 zonal reserved instances per zone per Alibaba Cloud account.
        ## [](#)Sample requests
        Purchase a one-year regional reserved instance in the China (Hangzhou) region to offset the bills of three ecs.g5.large Linux pay-as-you-go instances.
        <!---->
        "RegionId":"cn-hangzhou", // Specify the China (Hangzhou) region."InstanceType":"ecs.g5.large", // Specify the instance type."Scope":"Region", // Set the scope of the reserved instance to regional."InstanceAmount":3, // Specify the reserved instance to match three pay-as-you-go instances of the same instance type."OfferingType":"All Upfront", // Specify the payment option. In this example, the default value is used, which is All Upfront."Platform":"Linux", // Specify the operating system platform of the ECS instances eligible for the reserved instance. In this example, the Linux or Unix-like operating system is used."Period":1, // Specify the term of the reserved instance. In this example, the one-year duration is used."PeriodUnit":"Year", // Set the unit of the term to year.
        Purchase a two-year zonal reserved instance in Hangzhou Zone H to offset the bills of five ecs.g5.large Windows pay-as-you-go instances.
        <!---->
        "RegionId":"cn-hangzhou",
        "ZoneId":"cn-hangzhou-h", // Specify Hangzhou Zone H."InstanceType":"ecs.g5.large",
        "Scope":"Zone", // Set the scope of the reserved instance to zonal."InstanceAmount":5, // Specify the reserved instance to match five pay-as-you-go instances of the same instance type."OfferingType":"All Upfront",
        "Platform":"Windows", // Specify the operating system platform of the ECS instances eligible for the reserved instance. In this example, the Windows operating system is used."Period":2, // Specify the term of the reserved instance. In this example, the two-year duration is used."PeriodUnit":"Year", // Set the unit of the term to year.
        
        @param request: PurchaseReservedInstancesOfferingRequest
        @return: PurchaseReservedInstancesOfferingResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.purchase_reserved_instances_offering_with_options_async(request, runtime)

    def purchase_storage_capacity_unit_with_options(
        self,
        request: ecs_20140526_models.PurchaseStorageCapacityUnitRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.PurchaseStorageCapacityUnitResponse:
        """
        @summary Purchases one or more storage capacity units (SCUs).
        
        @description *Before you call this operation, make sure that you understand the [billing methods](https://help.aliyun.com/document_detail/137897.html) and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of SCUs.
        
        @param request: PurchaseStorageCapacityUnitRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PurchaseStorageCapacityUnitResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.amount):
            query['Amount'] = request.amount
        if not UtilClient.is_unset(request.capacity):
            query['Capacity'] = request.capacity
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.from_app):
            query['FromApp'] = request.from_app
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PurchaseStorageCapacityUnit',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.PurchaseStorageCapacityUnitResponse(),
            self.call_api(params, req, runtime)
        )

    async def purchase_storage_capacity_unit_with_options_async(
        self,
        request: ecs_20140526_models.PurchaseStorageCapacityUnitRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.PurchaseStorageCapacityUnitResponse:
        """
        @summary Purchases one or more storage capacity units (SCUs).
        
        @description *Before you call this operation, make sure that you understand the [billing methods](https://help.aliyun.com/document_detail/137897.html) and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of SCUs.
        
        @param request: PurchaseStorageCapacityUnitRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PurchaseStorageCapacityUnitResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.amount):
            query['Amount'] = request.amount
        if not UtilClient.is_unset(request.capacity):
            query['Capacity'] = request.capacity
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.from_app):
            query['FromApp'] = request.from_app
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PurchaseStorageCapacityUnit',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.PurchaseStorageCapacityUnitResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def purchase_storage_capacity_unit(
        self,
        request: ecs_20140526_models.PurchaseStorageCapacityUnitRequest,
    ) -> ecs_20140526_models.PurchaseStorageCapacityUnitResponse:
        """
        @summary Purchases one or more storage capacity units (SCUs).
        
        @description *Before you call this operation, make sure that you understand the [billing methods](https://help.aliyun.com/document_detail/137897.html) and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of SCUs.
        
        @param request: PurchaseStorageCapacityUnitRequest
        @return: PurchaseStorageCapacityUnitResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.purchase_storage_capacity_unit_with_options(request, runtime)

    async def purchase_storage_capacity_unit_async(
        self,
        request: ecs_20140526_models.PurchaseStorageCapacityUnitRequest,
    ) -> ecs_20140526_models.PurchaseStorageCapacityUnitResponse:
        """
        @summary Purchases one or more storage capacity units (SCUs).
        
        @description *Before you call this operation, make sure that you understand the [billing methods](https://help.aliyun.com/document_detail/137897.html) and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of SCUs.
        
        @param request: PurchaseStorageCapacityUnitRequest
        @return: PurchaseStorageCapacityUnitResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.purchase_storage_capacity_unit_with_options_async(request, runtime)

    def re_activate_instances_with_options(
        self,
        request: ecs_20140526_models.ReActivateInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ReActivateInstancesResponse:
        """
        @summary Reactivates a pay-as-you-go Elastic Compute Service (ECS) instance that has expired or has been reclaimed due to overdue payments.
        
        @description After you complete the overdue payment for a pay-as-you-go ECS instance, you do not need to call this operation to reactivate the instance. The system automatically reactivates the instance to restore the instance to the status before the payment became overdue. Automatic reactivation occasionally fails. Take note of the status of automatic reactivation. If the automatic reactivation fails, call this operation to manually reactivate the instance.
        The instance must be in the **Expired** `(Stopped)` state.
        You cannot call this operation to start ECS instances that are locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        
        @param request: ReActivateInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReActivateInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReActivateInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ReActivateInstancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def re_activate_instances_with_options_async(
        self,
        request: ecs_20140526_models.ReActivateInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ReActivateInstancesResponse:
        """
        @summary Reactivates a pay-as-you-go Elastic Compute Service (ECS) instance that has expired or has been reclaimed due to overdue payments.
        
        @description After you complete the overdue payment for a pay-as-you-go ECS instance, you do not need to call this operation to reactivate the instance. The system automatically reactivates the instance to restore the instance to the status before the payment became overdue. Automatic reactivation occasionally fails. Take note of the status of automatic reactivation. If the automatic reactivation fails, call this operation to manually reactivate the instance.
        The instance must be in the **Expired** `(Stopped)` state.
        You cannot call this operation to start ECS instances that are locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        
        @param request: ReActivateInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReActivateInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReActivateInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ReActivateInstancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def re_activate_instances(
        self,
        request: ecs_20140526_models.ReActivateInstancesRequest,
    ) -> ecs_20140526_models.ReActivateInstancesResponse:
        """
        @summary Reactivates a pay-as-you-go Elastic Compute Service (ECS) instance that has expired or has been reclaimed due to overdue payments.
        
        @description After you complete the overdue payment for a pay-as-you-go ECS instance, you do not need to call this operation to reactivate the instance. The system automatically reactivates the instance to restore the instance to the status before the payment became overdue. Automatic reactivation occasionally fails. Take note of the status of automatic reactivation. If the automatic reactivation fails, call this operation to manually reactivate the instance.
        The instance must be in the **Expired** `(Stopped)` state.
        You cannot call this operation to start ECS instances that are locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        
        @param request: ReActivateInstancesRequest
        @return: ReActivateInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.re_activate_instances_with_options(request, runtime)

    async def re_activate_instances_async(
        self,
        request: ecs_20140526_models.ReActivateInstancesRequest,
    ) -> ecs_20140526_models.ReActivateInstancesResponse:
        """
        @summary Reactivates a pay-as-you-go Elastic Compute Service (ECS) instance that has expired or has been reclaimed due to overdue payments.
        
        @description After you complete the overdue payment for a pay-as-you-go ECS instance, you do not need to call this operation to reactivate the instance. The system automatically reactivates the instance to restore the instance to the status before the payment became overdue. Automatic reactivation occasionally fails. Take note of the status of automatic reactivation. If the automatic reactivation fails, call this operation to manually reactivate the instance.
        The instance must be in the **Expired** `(Stopped)` state.
        You cannot call this operation to start ECS instances that are locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        
        @param request: ReActivateInstancesRequest
        @return: ReActivateInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.re_activate_instances_with_options_async(request, runtime)

    def re_init_disk_with_options(
        self,
        request: ecs_20140526_models.ReInitDiskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ReInitDiskResponse:
        """
        @summary Re-initializes a cloud disk to the state when the cloud disk was created.
        
        @description Take note of the following items:
        The disk that you want to re-initialize must be in the **In Use** (`In_use`) state and the instance to which the disk is attached must be in the **Stopped** (`Stoppe`) state.
        If an instance has never been started since it was created, the disks attached to it cannot be re-initialized.
        If a local snapshot has been created for a disk, the disk cannot be re-initialized.
        If a system disk is re-initialized, the disk is restored to the state of the image from which it was created. If the image has been deleted, the disk cannot be re-initialized.
        For a data disk that was created from scratch, the disk is initialized to the empty disk state. For a data disk that is created from a snapshot, the disk is initialized to the snapshot state. If the snapshots were deleted, the disks cannot be re-initialized and an error is returned.
        
        @param request: ReInitDiskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReInitDiskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_start_instance):
            query['AutoStartInstance'] = request.auto_start_instance
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.password):
            query['Password'] = request.password
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_enhancement_strategy):
            query['SecurityEnhancementStrategy'] = request.security_enhancement_strategy
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReInitDisk',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ReInitDiskResponse(),
            self.call_api(params, req, runtime)
        )

    async def re_init_disk_with_options_async(
        self,
        request: ecs_20140526_models.ReInitDiskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ReInitDiskResponse:
        """
        @summary Re-initializes a cloud disk to the state when the cloud disk was created.
        
        @description Take note of the following items:
        The disk that you want to re-initialize must be in the **In Use** (`In_use`) state and the instance to which the disk is attached must be in the **Stopped** (`Stoppe`) state.
        If an instance has never been started since it was created, the disks attached to it cannot be re-initialized.
        If a local snapshot has been created for a disk, the disk cannot be re-initialized.
        If a system disk is re-initialized, the disk is restored to the state of the image from which it was created. If the image has been deleted, the disk cannot be re-initialized.
        For a data disk that was created from scratch, the disk is initialized to the empty disk state. For a data disk that is created from a snapshot, the disk is initialized to the snapshot state. If the snapshots were deleted, the disks cannot be re-initialized and an error is returned.
        
        @param request: ReInitDiskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReInitDiskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_start_instance):
            query['AutoStartInstance'] = request.auto_start_instance
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.password):
            query['Password'] = request.password
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_enhancement_strategy):
            query['SecurityEnhancementStrategy'] = request.security_enhancement_strategy
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReInitDisk',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ReInitDiskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def re_init_disk(
        self,
        request: ecs_20140526_models.ReInitDiskRequest,
    ) -> ecs_20140526_models.ReInitDiskResponse:
        """
        @summary Re-initializes a cloud disk to the state when the cloud disk was created.
        
        @description Take note of the following items:
        The disk that you want to re-initialize must be in the **In Use** (`In_use`) state and the instance to which the disk is attached must be in the **Stopped** (`Stoppe`) state.
        If an instance has never been started since it was created, the disks attached to it cannot be re-initialized.
        If a local snapshot has been created for a disk, the disk cannot be re-initialized.
        If a system disk is re-initialized, the disk is restored to the state of the image from which it was created. If the image has been deleted, the disk cannot be re-initialized.
        For a data disk that was created from scratch, the disk is initialized to the empty disk state. For a data disk that is created from a snapshot, the disk is initialized to the snapshot state. If the snapshots were deleted, the disks cannot be re-initialized and an error is returned.
        
        @param request: ReInitDiskRequest
        @return: ReInitDiskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.re_init_disk_with_options(request, runtime)

    async def re_init_disk_async(
        self,
        request: ecs_20140526_models.ReInitDiskRequest,
    ) -> ecs_20140526_models.ReInitDiskResponse:
        """
        @summary Re-initializes a cloud disk to the state when the cloud disk was created.
        
        @description Take note of the following items:
        The disk that you want to re-initialize must be in the **In Use** (`In_use`) state and the instance to which the disk is attached must be in the **Stopped** (`Stoppe`) state.
        If an instance has never been started since it was created, the disks attached to it cannot be re-initialized.
        If a local snapshot has been created for a disk, the disk cannot be re-initialized.
        If a system disk is re-initialized, the disk is restored to the state of the image from which it was created. If the image has been deleted, the disk cannot be re-initialized.
        For a data disk that was created from scratch, the disk is initialized to the empty disk state. For a data disk that is created from a snapshot, the disk is initialized to the snapshot state. If the snapshots were deleted, the disks cannot be re-initialized and an error is returned.
        
        @param request: ReInitDiskRequest
        @return: ReInitDiskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.re_init_disk_with_options_async(request, runtime)

    def reboot_instance_with_options(
        self,
        request: ecs_20140526_models.RebootInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RebootInstanceResponse:
        """
        @summary Restarts an Elastic Compute Service (ECS) instance.
        
        @description This operation is an asynchronous operation. After you call this operation to restart an ECS instance, the operation sets the status of the ECS instance to `Starting` and begins the restart process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instance. When the status of the ECS instance changes to `Running`, the instance is restarted.
        ### [](#)Considerations
        You cannot call this operation to restart an ECS instance that is locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        The ECS instance that you want to restart must be in the **Running** (`Running`) state.
        
        @param request: RebootInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RebootInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.force_stop):
            query['ForceStop'] = request.force_stop
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RebootInstance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RebootInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def reboot_instance_with_options_async(
        self,
        request: ecs_20140526_models.RebootInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RebootInstanceResponse:
        """
        @summary Restarts an Elastic Compute Service (ECS) instance.
        
        @description This operation is an asynchronous operation. After you call this operation to restart an ECS instance, the operation sets the status of the ECS instance to `Starting` and begins the restart process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instance. When the status of the ECS instance changes to `Running`, the instance is restarted.
        ### [](#)Considerations
        You cannot call this operation to restart an ECS instance that is locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        The ECS instance that you want to restart must be in the **Running** (`Running`) state.
        
        @param request: RebootInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RebootInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.force_stop):
            query['ForceStop'] = request.force_stop
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RebootInstance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RebootInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def reboot_instance(
        self,
        request: ecs_20140526_models.RebootInstanceRequest,
    ) -> ecs_20140526_models.RebootInstanceResponse:
        """
        @summary Restarts an Elastic Compute Service (ECS) instance.
        
        @description This operation is an asynchronous operation. After you call this operation to restart an ECS instance, the operation sets the status of the ECS instance to `Starting` and begins the restart process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instance. When the status of the ECS instance changes to `Running`, the instance is restarted.
        ### [](#)Considerations
        You cannot call this operation to restart an ECS instance that is locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        The ECS instance that you want to restart must be in the **Running** (`Running`) state.
        
        @param request: RebootInstanceRequest
        @return: RebootInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.reboot_instance_with_options(request, runtime)

    async def reboot_instance_async(
        self,
        request: ecs_20140526_models.RebootInstanceRequest,
    ) -> ecs_20140526_models.RebootInstanceResponse:
        """
        @summary Restarts an Elastic Compute Service (ECS) instance.
        
        @description This operation is an asynchronous operation. After you call this operation to restart an ECS instance, the operation sets the status of the ECS instance to `Starting` and begins the restart process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instance. When the status of the ECS instance changes to `Running`, the instance is restarted.
        ### [](#)Considerations
        You cannot call this operation to restart an ECS instance that is locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        The ECS instance that you want to restart must be in the **Running** (`Running`) state.
        
        @param request: RebootInstanceRequest
        @return: RebootInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.reboot_instance_with_options_async(request, runtime)

    def reboot_instances_with_options(
        self,
        request: ecs_20140526_models.RebootInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RebootInstancesResponse:
        """
        @summary Restarts Elastic Compute Service (ECS) instances. When you call this operation, you can configure parameters to specify a batch operation mode and whether to forcefully restart the instances.
        
        @description This operation is an asynchronous operation. After you call this operation to restart an ECS instance, the operation sets the status of the ECS instance to `Starting` and begins the restart process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instance. When the status of the ECS instance changes to `Running`, the instance is restarted.
        ### [](#)Limits
        You cannot call this operation to restart ECS instances that are locked due to security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        The ECS instances that you want to restart must be in the **Running** (`Running`) state.
        
        @param request: RebootInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RebootInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.batch_optimization):
            query['BatchOptimization'] = request.batch_optimization
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.force_reboot):
            query['ForceReboot'] = request.force_reboot
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RebootInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RebootInstancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def reboot_instances_with_options_async(
        self,
        request: ecs_20140526_models.RebootInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RebootInstancesResponse:
        """
        @summary Restarts Elastic Compute Service (ECS) instances. When you call this operation, you can configure parameters to specify a batch operation mode and whether to forcefully restart the instances.
        
        @description This operation is an asynchronous operation. After you call this operation to restart an ECS instance, the operation sets the status of the ECS instance to `Starting` and begins the restart process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instance. When the status of the ECS instance changes to `Running`, the instance is restarted.
        ### [](#)Limits
        You cannot call this operation to restart ECS instances that are locked due to security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        The ECS instances that you want to restart must be in the **Running** (`Running`) state.
        
        @param request: RebootInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RebootInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.batch_optimization):
            query['BatchOptimization'] = request.batch_optimization
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.force_reboot):
            query['ForceReboot'] = request.force_reboot
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RebootInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RebootInstancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def reboot_instances(
        self,
        request: ecs_20140526_models.RebootInstancesRequest,
    ) -> ecs_20140526_models.RebootInstancesResponse:
        """
        @summary Restarts Elastic Compute Service (ECS) instances. When you call this operation, you can configure parameters to specify a batch operation mode and whether to forcefully restart the instances.
        
        @description This operation is an asynchronous operation. After you call this operation to restart an ECS instance, the operation sets the status of the ECS instance to `Starting` and begins the restart process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instance. When the status of the ECS instance changes to `Running`, the instance is restarted.
        ### [](#)Limits
        You cannot call this operation to restart ECS instances that are locked due to security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        The ECS instances that you want to restart must be in the **Running** (`Running`) state.
        
        @param request: RebootInstancesRequest
        @return: RebootInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.reboot_instances_with_options(request, runtime)

    async def reboot_instances_async(
        self,
        request: ecs_20140526_models.RebootInstancesRequest,
    ) -> ecs_20140526_models.RebootInstancesResponse:
        """
        @summary Restarts Elastic Compute Service (ECS) instances. When you call this operation, you can configure parameters to specify a batch operation mode and whether to forcefully restart the instances.
        
        @description This operation is an asynchronous operation. After you call this operation to restart an ECS instance, the operation sets the status of the ECS instance to `Starting` and begins the restart process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instance. When the status of the ECS instance changes to `Running`, the instance is restarted.
        ### [](#)Limits
        You cannot call this operation to restart ECS instances that are locked due to security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        The ECS instances that you want to restart must be in the **Running** (`Running`) state.
        
        @param request: RebootInstancesRequest
        @return: RebootInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.reboot_instances_with_options_async(request, runtime)

    def recover_virtual_border_router_with_options(
        self,
        request: ecs_20140526_models.RecoverVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RecoverVirtualBorderRouterResponse:
        """
        @deprecated OpenAPI RecoverVirtualBorderRouter is deprecated, please use Vpc::2016-04-28::RecoverVirtualBorderRouter instead.
        
        @summary RecoverVirtualBorderRouter
        
        @param request: RecoverVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RecoverVirtualBorderRouterResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RecoverVirtualBorderRouter',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RecoverVirtualBorderRouterResponse(),
            self.call_api(params, req, runtime)
        )

    async def recover_virtual_border_router_with_options_async(
        self,
        request: ecs_20140526_models.RecoverVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RecoverVirtualBorderRouterResponse:
        """
        @deprecated OpenAPI RecoverVirtualBorderRouter is deprecated, please use Vpc::2016-04-28::RecoverVirtualBorderRouter instead.
        
        @summary RecoverVirtualBorderRouter
        
        @param request: RecoverVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RecoverVirtualBorderRouterResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RecoverVirtualBorderRouter',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RecoverVirtualBorderRouterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def recover_virtual_border_router(
        self,
        request: ecs_20140526_models.RecoverVirtualBorderRouterRequest,
    ) -> ecs_20140526_models.RecoverVirtualBorderRouterResponse:
        """
        @deprecated OpenAPI RecoverVirtualBorderRouter is deprecated, please use Vpc::2016-04-28::RecoverVirtualBorderRouter instead.
        
        @summary RecoverVirtualBorderRouter
        
        @param request: RecoverVirtualBorderRouterRequest
        @return: RecoverVirtualBorderRouterResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.recover_virtual_border_router_with_options(request, runtime)

    async def recover_virtual_border_router_async(
        self,
        request: ecs_20140526_models.RecoverVirtualBorderRouterRequest,
    ) -> ecs_20140526_models.RecoverVirtualBorderRouterResponse:
        """
        @deprecated OpenAPI RecoverVirtualBorderRouter is deprecated, please use Vpc::2016-04-28::RecoverVirtualBorderRouter instead.
        
        @summary RecoverVirtualBorderRouter
        
        @param request: RecoverVirtualBorderRouterRequest
        @return: RecoverVirtualBorderRouterResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.recover_virtual_border_router_with_options_async(request, runtime)

    def redeploy_dedicated_host_with_options(
        self,
        request: ecs_20140526_models.RedeployDedicatedHostRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RedeployDedicatedHostResponse:
        """
        @summary Migrates Elastic Compute Service (ECS) instances from a failed dedicated host.
        
        @description If a dedicated host is in the `UnderAssessment` state, we recommend that you call this operation to migrate ECS instances away from the dedicated host to prevent permanent failures. You can call the [DescribeDedicatedHosts](https://help.aliyun.com/document_detail/134242.html) operation to query the status of a dedicated host.
        
        @param request: RedeployDedicatedHostRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RedeployDedicatedHostResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dedicated_host_id):
            query['DedicatedHostId'] = request.dedicated_host_id
        if not UtilClient.is_unset(request.migration_type):
            query['MigrationType'] = request.migration_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RedeployDedicatedHost',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RedeployDedicatedHostResponse(),
            self.call_api(params, req, runtime)
        )

    async def redeploy_dedicated_host_with_options_async(
        self,
        request: ecs_20140526_models.RedeployDedicatedHostRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RedeployDedicatedHostResponse:
        """
        @summary Migrates Elastic Compute Service (ECS) instances from a failed dedicated host.
        
        @description If a dedicated host is in the `UnderAssessment` state, we recommend that you call this operation to migrate ECS instances away from the dedicated host to prevent permanent failures. You can call the [DescribeDedicatedHosts](https://help.aliyun.com/document_detail/134242.html) operation to query the status of a dedicated host.
        
        @param request: RedeployDedicatedHostRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RedeployDedicatedHostResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dedicated_host_id):
            query['DedicatedHostId'] = request.dedicated_host_id
        if not UtilClient.is_unset(request.migration_type):
            query['MigrationType'] = request.migration_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RedeployDedicatedHost',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RedeployDedicatedHostResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def redeploy_dedicated_host(
        self,
        request: ecs_20140526_models.RedeployDedicatedHostRequest,
    ) -> ecs_20140526_models.RedeployDedicatedHostResponse:
        """
        @summary Migrates Elastic Compute Service (ECS) instances from a failed dedicated host.
        
        @description If a dedicated host is in the `UnderAssessment` state, we recommend that you call this operation to migrate ECS instances away from the dedicated host to prevent permanent failures. You can call the [DescribeDedicatedHosts](https://help.aliyun.com/document_detail/134242.html) operation to query the status of a dedicated host.
        
        @param request: RedeployDedicatedHostRequest
        @return: RedeployDedicatedHostResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.redeploy_dedicated_host_with_options(request, runtime)

    async def redeploy_dedicated_host_async(
        self,
        request: ecs_20140526_models.RedeployDedicatedHostRequest,
    ) -> ecs_20140526_models.RedeployDedicatedHostResponse:
        """
        @summary Migrates Elastic Compute Service (ECS) instances from a failed dedicated host.
        
        @description If a dedicated host is in the `UnderAssessment` state, we recommend that you call this operation to migrate ECS instances away from the dedicated host to prevent permanent failures. You can call the [DescribeDedicatedHosts](https://help.aliyun.com/document_detail/134242.html) operation to query the status of a dedicated host.
        
        @param request: RedeployDedicatedHostRequest
        @return: RedeployDedicatedHostResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.redeploy_dedicated_host_with_options_async(request, runtime)

    def redeploy_instance_with_options(
        self,
        request: ecs_20140526_models.RedeployInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RedeployInstanceResponse:
        """
        @summary Redeploys an Elastic Compute Service (ECS) instance. You can call this operation to redeploy an ECS instance when the instance receives a system event notification.
        
        @description ## Usage notes
        RedeployInstance is an asynchronous operation. The operation migrates the instance to a healthy physical server and then restarts the instance. After the instance is redeployed, it enters the Running (`Running`) state. If the instance fails to be redeployed, it returns to the original physical server and the state before the redeployment.
        When you call this operation, take note of the following item:
        The instance must be in the Running (Running) or Stopped (Stopped) state. After the instance is redeployed, the following changes occur to the status of the instance:
        If the instance is in the Running (`Running`) state, the instance enters the Stopping (`Stopping`) state.
        If the instance is in the Stopped (`Stopped`) state, the instance enters the Starting (`Starting`) state.
        If an instance is deployed on a dedicated host, you cannot redeploy the instance.
        If `OperationLocks` in the response of the DescribeInstances operation contains `"LockReason": "security"` for an instance, the instance is locked for security reasons and cannot be redeployed.
        If an instance receives notifications about simulated events that are created by calling the CreateSimulatedSystemEvent operation for the instance, you cannot call this operation to redeploy the instance.
        When you handle a local disk-related system event for an instance, if the damaged local disk is isolated but the SystemMaintenance.RebootAndReInitErrorDisk (**instance restart and re-initialization of damaged disks due to system maintenance**) event is not sent, you can still call the RedeployInstance operation to redeploy the instance. For more information, see [O&#x26;M scenarios and system events for instances equipped with local disks](https://help.aliyun.com/document_detail/107693.html).
        The following table describes the types and states of events that you can handle by calling the RedeployInstance operation.
        |System event|Event status|
        |---|---|
        |Instance restart due to system maintenance (SystemMaintenance.Reboot)|Inquiring and Scheduled|
        |Instance redeployment due to system maintenance (SystemMaintenance.Redeploy)|Inquiring and Scheduled|
        |Instance restart and replacement of damaged disks due to system maintenance (SystemMaintenance.RebootAndIsolateErrorDisk)|Inquiring|
        |Instance restart and re-initialization of damaged disks due to system maintenance (SystemMaintenance.RebootAndReInitErrorDisk)|Inquiring|
        |Instance redeployment due to system errors (SystemFailure.Redeploy)|Inquiring|
        |For ECS instances that use only local disks: instance restart due to system errors (SystemFailure.Reboot)|Executing|
        |Isolation of damaged disks due to system maintenance (SystemMaintenance.IsolateErrorDisk)|Inquiring|
        |Re-initialization of damaged disks due to system maintenance (SystemMaintenance.ReInitErrorDisk)|Inquiring|
        *Note** When the system redeploys instances equipped with local disks, the local disks are re-initialized and data on the local disks is cleared.
        
        @param request: RedeployInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RedeployInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.force_stop):
            query['ForceStop'] = request.force_stop
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RedeployInstance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RedeployInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def redeploy_instance_with_options_async(
        self,
        request: ecs_20140526_models.RedeployInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RedeployInstanceResponse:
        """
        @summary Redeploys an Elastic Compute Service (ECS) instance. You can call this operation to redeploy an ECS instance when the instance receives a system event notification.
        
        @description ## Usage notes
        RedeployInstance is an asynchronous operation. The operation migrates the instance to a healthy physical server and then restarts the instance. After the instance is redeployed, it enters the Running (`Running`) state. If the instance fails to be redeployed, it returns to the original physical server and the state before the redeployment.
        When you call this operation, take note of the following item:
        The instance must be in the Running (Running) or Stopped (Stopped) state. After the instance is redeployed, the following changes occur to the status of the instance:
        If the instance is in the Running (`Running`) state, the instance enters the Stopping (`Stopping`) state.
        If the instance is in the Stopped (`Stopped`) state, the instance enters the Starting (`Starting`) state.
        If an instance is deployed on a dedicated host, you cannot redeploy the instance.
        If `OperationLocks` in the response of the DescribeInstances operation contains `"LockReason": "security"` for an instance, the instance is locked for security reasons and cannot be redeployed.
        If an instance receives notifications about simulated events that are created by calling the CreateSimulatedSystemEvent operation for the instance, you cannot call this operation to redeploy the instance.
        When you handle a local disk-related system event for an instance, if the damaged local disk is isolated but the SystemMaintenance.RebootAndReInitErrorDisk (**instance restart and re-initialization of damaged disks due to system maintenance**) event is not sent, you can still call the RedeployInstance operation to redeploy the instance. For more information, see [O&#x26;M scenarios and system events for instances equipped with local disks](https://help.aliyun.com/document_detail/107693.html).
        The following table describes the types and states of events that you can handle by calling the RedeployInstance operation.
        |System event|Event status|
        |---|---|
        |Instance restart due to system maintenance (SystemMaintenance.Reboot)|Inquiring and Scheduled|
        |Instance redeployment due to system maintenance (SystemMaintenance.Redeploy)|Inquiring and Scheduled|
        |Instance restart and replacement of damaged disks due to system maintenance (SystemMaintenance.RebootAndIsolateErrorDisk)|Inquiring|
        |Instance restart and re-initialization of damaged disks due to system maintenance (SystemMaintenance.RebootAndReInitErrorDisk)|Inquiring|
        |Instance redeployment due to system errors (SystemFailure.Redeploy)|Inquiring|
        |For ECS instances that use only local disks: instance restart due to system errors (SystemFailure.Reboot)|Executing|
        |Isolation of damaged disks due to system maintenance (SystemMaintenance.IsolateErrorDisk)|Inquiring|
        |Re-initialization of damaged disks due to system maintenance (SystemMaintenance.ReInitErrorDisk)|Inquiring|
        *Note** When the system redeploys instances equipped with local disks, the local disks are re-initialized and data on the local disks is cleared.
        
        @param request: RedeployInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RedeployInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.force_stop):
            query['ForceStop'] = request.force_stop
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RedeployInstance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RedeployInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def redeploy_instance(
        self,
        request: ecs_20140526_models.RedeployInstanceRequest,
    ) -> ecs_20140526_models.RedeployInstanceResponse:
        """
        @summary Redeploys an Elastic Compute Service (ECS) instance. You can call this operation to redeploy an ECS instance when the instance receives a system event notification.
        
        @description ## Usage notes
        RedeployInstance is an asynchronous operation. The operation migrates the instance to a healthy physical server and then restarts the instance. After the instance is redeployed, it enters the Running (`Running`) state. If the instance fails to be redeployed, it returns to the original physical server and the state before the redeployment.
        When you call this operation, take note of the following item:
        The instance must be in the Running (Running) or Stopped (Stopped) state. After the instance is redeployed, the following changes occur to the status of the instance:
        If the instance is in the Running (`Running`) state, the instance enters the Stopping (`Stopping`) state.
        If the instance is in the Stopped (`Stopped`) state, the instance enters the Starting (`Starting`) state.
        If an instance is deployed on a dedicated host, you cannot redeploy the instance.
        If `OperationLocks` in the response of the DescribeInstances operation contains `"LockReason": "security"` for an instance, the instance is locked for security reasons and cannot be redeployed.
        If an instance receives notifications about simulated events that are created by calling the CreateSimulatedSystemEvent operation for the instance, you cannot call this operation to redeploy the instance.
        When you handle a local disk-related system event for an instance, if the damaged local disk is isolated but the SystemMaintenance.RebootAndReInitErrorDisk (**instance restart and re-initialization of damaged disks due to system maintenance**) event is not sent, you can still call the RedeployInstance operation to redeploy the instance. For more information, see [O&#x26;M scenarios and system events for instances equipped with local disks](https://help.aliyun.com/document_detail/107693.html).
        The following table describes the types and states of events that you can handle by calling the RedeployInstance operation.
        |System event|Event status|
        |---|---|
        |Instance restart due to system maintenance (SystemMaintenance.Reboot)|Inquiring and Scheduled|
        |Instance redeployment due to system maintenance (SystemMaintenance.Redeploy)|Inquiring and Scheduled|
        |Instance restart and replacement of damaged disks due to system maintenance (SystemMaintenance.RebootAndIsolateErrorDisk)|Inquiring|
        |Instance restart and re-initialization of damaged disks due to system maintenance (SystemMaintenance.RebootAndReInitErrorDisk)|Inquiring|
        |Instance redeployment due to system errors (SystemFailure.Redeploy)|Inquiring|
        |For ECS instances that use only local disks: instance restart due to system errors (SystemFailure.Reboot)|Executing|
        |Isolation of damaged disks due to system maintenance (SystemMaintenance.IsolateErrorDisk)|Inquiring|
        |Re-initialization of damaged disks due to system maintenance (SystemMaintenance.ReInitErrorDisk)|Inquiring|
        *Note** When the system redeploys instances equipped with local disks, the local disks are re-initialized and data on the local disks is cleared.
        
        @param request: RedeployInstanceRequest
        @return: RedeployInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.redeploy_instance_with_options(request, runtime)

    async def redeploy_instance_async(
        self,
        request: ecs_20140526_models.RedeployInstanceRequest,
    ) -> ecs_20140526_models.RedeployInstanceResponse:
        """
        @summary Redeploys an Elastic Compute Service (ECS) instance. You can call this operation to redeploy an ECS instance when the instance receives a system event notification.
        
        @description ## Usage notes
        RedeployInstance is an asynchronous operation. The operation migrates the instance to a healthy physical server and then restarts the instance. After the instance is redeployed, it enters the Running (`Running`) state. If the instance fails to be redeployed, it returns to the original physical server and the state before the redeployment.
        When you call this operation, take note of the following item:
        The instance must be in the Running (Running) or Stopped (Stopped) state. After the instance is redeployed, the following changes occur to the status of the instance:
        If the instance is in the Running (`Running`) state, the instance enters the Stopping (`Stopping`) state.
        If the instance is in the Stopped (`Stopped`) state, the instance enters the Starting (`Starting`) state.
        If an instance is deployed on a dedicated host, you cannot redeploy the instance.
        If `OperationLocks` in the response of the DescribeInstances operation contains `"LockReason": "security"` for an instance, the instance is locked for security reasons and cannot be redeployed.
        If an instance receives notifications about simulated events that are created by calling the CreateSimulatedSystemEvent operation for the instance, you cannot call this operation to redeploy the instance.
        When you handle a local disk-related system event for an instance, if the damaged local disk is isolated but the SystemMaintenance.RebootAndReInitErrorDisk (**instance restart and re-initialization of damaged disks due to system maintenance**) event is not sent, you can still call the RedeployInstance operation to redeploy the instance. For more information, see [O&#x26;M scenarios and system events for instances equipped with local disks](https://help.aliyun.com/document_detail/107693.html).
        The following table describes the types and states of events that you can handle by calling the RedeployInstance operation.
        |System event|Event status|
        |---|---|
        |Instance restart due to system maintenance (SystemMaintenance.Reboot)|Inquiring and Scheduled|
        |Instance redeployment due to system maintenance (SystemMaintenance.Redeploy)|Inquiring and Scheduled|
        |Instance restart and replacement of damaged disks due to system maintenance (SystemMaintenance.RebootAndIsolateErrorDisk)|Inquiring|
        |Instance restart and re-initialization of damaged disks due to system maintenance (SystemMaintenance.RebootAndReInitErrorDisk)|Inquiring|
        |Instance redeployment due to system errors (SystemFailure.Redeploy)|Inquiring|
        |For ECS instances that use only local disks: instance restart due to system errors (SystemFailure.Reboot)|Executing|
        |Isolation of damaged disks due to system maintenance (SystemMaintenance.IsolateErrorDisk)|Inquiring|
        |Re-initialization of damaged disks due to system maintenance (SystemMaintenance.ReInitErrorDisk)|Inquiring|
        *Note** When the system redeploys instances equipped with local disks, the local disks are re-initialized and data on the local disks is cleared.
        
        @param request: RedeployInstanceRequest
        @return: RedeployInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.redeploy_instance_with_options_async(request, runtime)

    def release_capacity_reservation_with_options(
        self,
        request: ecs_20140526_models.ReleaseCapacityReservationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ReleaseCapacityReservationResponse:
        """
        @summary Releases a capacity reservation.
        
        @description If the release mode of a capacity reservation that takes effect immediately is set to manual release, you can call this operation to release the capacity reservation.
        
        @param request: ReleaseCapacityReservationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReleaseCapacityReservationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReleaseCapacityReservation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ReleaseCapacityReservationResponse(),
            self.call_api(params, req, runtime)
        )

    async def release_capacity_reservation_with_options_async(
        self,
        request: ecs_20140526_models.ReleaseCapacityReservationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ReleaseCapacityReservationResponse:
        """
        @summary Releases a capacity reservation.
        
        @description If the release mode of a capacity reservation that takes effect immediately is set to manual release, you can call this operation to release the capacity reservation.
        
        @param request: ReleaseCapacityReservationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReleaseCapacityReservationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReleaseCapacityReservation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ReleaseCapacityReservationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def release_capacity_reservation(
        self,
        request: ecs_20140526_models.ReleaseCapacityReservationRequest,
    ) -> ecs_20140526_models.ReleaseCapacityReservationResponse:
        """
        @summary Releases a capacity reservation.
        
        @description If the release mode of a capacity reservation that takes effect immediately is set to manual release, you can call this operation to release the capacity reservation.
        
        @param request: ReleaseCapacityReservationRequest
        @return: ReleaseCapacityReservationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.release_capacity_reservation_with_options(request, runtime)

    async def release_capacity_reservation_async(
        self,
        request: ecs_20140526_models.ReleaseCapacityReservationRequest,
    ) -> ecs_20140526_models.ReleaseCapacityReservationResponse:
        """
        @summary Releases a capacity reservation.
        
        @description If the release mode of a capacity reservation that takes effect immediately is set to manual release, you can call this operation to release the capacity reservation.
        
        @param request: ReleaseCapacityReservationRequest
        @return: ReleaseCapacityReservationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.release_capacity_reservation_with_options_async(request, runtime)

    def release_dedicated_host_with_options(
        self,
        request: ecs_20140526_models.ReleaseDedicatedHostRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ReleaseDedicatedHostResponse:
        """
        @summary Releases a pay-as-you-go dedicated host.
        
        @description ## Usage notes
        Before you release a pay-as-you-go dedicated host, make sure that no ECS instances are deployed on the dedicated host.
        
        @param request: ReleaseDedicatedHostRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReleaseDedicatedHostResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dedicated_host_id):
            query['DedicatedHostId'] = request.dedicated_host_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReleaseDedicatedHost',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ReleaseDedicatedHostResponse(),
            self.call_api(params, req, runtime)
        )

    async def release_dedicated_host_with_options_async(
        self,
        request: ecs_20140526_models.ReleaseDedicatedHostRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ReleaseDedicatedHostResponse:
        """
        @summary Releases a pay-as-you-go dedicated host.
        
        @description ## Usage notes
        Before you release a pay-as-you-go dedicated host, make sure that no ECS instances are deployed on the dedicated host.
        
        @param request: ReleaseDedicatedHostRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReleaseDedicatedHostResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dedicated_host_id):
            query['DedicatedHostId'] = request.dedicated_host_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReleaseDedicatedHost',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ReleaseDedicatedHostResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def release_dedicated_host(
        self,
        request: ecs_20140526_models.ReleaseDedicatedHostRequest,
    ) -> ecs_20140526_models.ReleaseDedicatedHostResponse:
        """
        @summary Releases a pay-as-you-go dedicated host.
        
        @description ## Usage notes
        Before you release a pay-as-you-go dedicated host, make sure that no ECS instances are deployed on the dedicated host.
        
        @param request: ReleaseDedicatedHostRequest
        @return: ReleaseDedicatedHostResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.release_dedicated_host_with_options(request, runtime)

    async def release_dedicated_host_async(
        self,
        request: ecs_20140526_models.ReleaseDedicatedHostRequest,
    ) -> ecs_20140526_models.ReleaseDedicatedHostResponse:
        """
        @summary Releases a pay-as-you-go dedicated host.
        
        @description ## Usage notes
        Before you release a pay-as-you-go dedicated host, make sure that no ECS instances are deployed on the dedicated host.
        
        @param request: ReleaseDedicatedHostRequest
        @return: ReleaseDedicatedHostResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.release_dedicated_host_with_options_async(request, runtime)

    def release_eip_address_with_options(
        self,
        request: ecs_20140526_models.ReleaseEipAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ReleaseEipAddressResponse:
        """
        @deprecated OpenAPI ReleaseEipAddress is deprecated, please use Vpc::2016-04-28::ReleaseEipAddress instead.
        
        @summary ReleaseEipAddress
        
        @param request: ReleaseEipAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReleaseEipAddressResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReleaseEipAddress',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ReleaseEipAddressResponse(),
            self.call_api(params, req, runtime)
        )

    async def release_eip_address_with_options_async(
        self,
        request: ecs_20140526_models.ReleaseEipAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ReleaseEipAddressResponse:
        """
        @deprecated OpenAPI ReleaseEipAddress is deprecated, please use Vpc::2016-04-28::ReleaseEipAddress instead.
        
        @summary ReleaseEipAddress
        
        @param request: ReleaseEipAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReleaseEipAddressResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReleaseEipAddress',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ReleaseEipAddressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def release_eip_address(
        self,
        request: ecs_20140526_models.ReleaseEipAddressRequest,
    ) -> ecs_20140526_models.ReleaseEipAddressResponse:
        """
        @deprecated OpenAPI ReleaseEipAddress is deprecated, please use Vpc::2016-04-28::ReleaseEipAddress instead.
        
        @summary ReleaseEipAddress
        
        @param request: ReleaseEipAddressRequest
        @return: ReleaseEipAddressResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.release_eip_address_with_options(request, runtime)

    async def release_eip_address_async(
        self,
        request: ecs_20140526_models.ReleaseEipAddressRequest,
    ) -> ecs_20140526_models.ReleaseEipAddressResponse:
        """
        @deprecated OpenAPI ReleaseEipAddress is deprecated, please use Vpc::2016-04-28::ReleaseEipAddress instead.
        
        @summary ReleaseEipAddress
        
        @param request: ReleaseEipAddressRequest
        @return: ReleaseEipAddressResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.release_eip_address_with_options_async(request, runtime)

    def release_public_ip_address_with_options(
        self,
        request: ecs_20140526_models.ReleasePublicIpAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ReleasePublicIpAddressResponse:
        """
        @deprecated OpenAPI ReleasePublicIpAddress is deprecated
        
        @summary Disassociates a public IP address from an Elastic Compute Service (ECS) instance.
        
        @param request: ReleasePublicIpAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReleasePublicIpAddressResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.public_ip_address):
            query['PublicIpAddress'] = request.public_ip_address
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReleasePublicIpAddress',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ReleasePublicIpAddressResponse(),
            self.call_api(params, req, runtime)
        )

    async def release_public_ip_address_with_options_async(
        self,
        request: ecs_20140526_models.ReleasePublicIpAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ReleasePublicIpAddressResponse:
        """
        @deprecated OpenAPI ReleasePublicIpAddress is deprecated
        
        @summary Disassociates a public IP address from an Elastic Compute Service (ECS) instance.
        
        @param request: ReleasePublicIpAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReleasePublicIpAddressResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.public_ip_address):
            query['PublicIpAddress'] = request.public_ip_address
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReleasePublicIpAddress',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ReleasePublicIpAddressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def release_public_ip_address(
        self,
        request: ecs_20140526_models.ReleasePublicIpAddressRequest,
    ) -> ecs_20140526_models.ReleasePublicIpAddressResponse:
        """
        @deprecated OpenAPI ReleasePublicIpAddress is deprecated
        
        @summary Disassociates a public IP address from an Elastic Compute Service (ECS) instance.
        
        @param request: ReleasePublicIpAddressRequest
        @return: ReleasePublicIpAddressResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.release_public_ip_address_with_options(request, runtime)

    async def release_public_ip_address_async(
        self,
        request: ecs_20140526_models.ReleasePublicIpAddressRequest,
    ) -> ecs_20140526_models.ReleasePublicIpAddressResponse:
        """
        @deprecated OpenAPI ReleasePublicIpAddress is deprecated
        
        @summary Disassociates a public IP address from an Elastic Compute Service (ECS) instance.
        
        @param request: ReleasePublicIpAddressRequest
        @return: ReleasePublicIpAddressResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.release_public_ip_address_with_options_async(request, runtime)

    def remove_bandwidth_package_ips_with_options(
        self,
        request: ecs_20140526_models.RemoveBandwidthPackageIpsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RemoveBandwidthPackageIpsResponse:
        """
        @deprecated OpenAPI RemoveBandwidthPackageIps is deprecated, please use Vpc::2016-04-28::RemoveBandwidthPackageIps instead.
        
        @summary RemoveBandwidthPackageIps
        
        @param request: RemoveBandwidthPackageIpsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveBandwidthPackageIpsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.removed_ip_addresses):
            query['RemovedIpAddresses'] = request.removed_ip_addresses
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveBandwidthPackageIps',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RemoveBandwidthPackageIpsResponse(),
            self.call_api(params, req, runtime)
        )

    async def remove_bandwidth_package_ips_with_options_async(
        self,
        request: ecs_20140526_models.RemoveBandwidthPackageIpsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RemoveBandwidthPackageIpsResponse:
        """
        @deprecated OpenAPI RemoveBandwidthPackageIps is deprecated, please use Vpc::2016-04-28::RemoveBandwidthPackageIps instead.
        
        @summary RemoveBandwidthPackageIps
        
        @param request: RemoveBandwidthPackageIpsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveBandwidthPackageIpsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.removed_ip_addresses):
            query['RemovedIpAddresses'] = request.removed_ip_addresses
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveBandwidthPackageIps',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RemoveBandwidthPackageIpsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def remove_bandwidth_package_ips(
        self,
        request: ecs_20140526_models.RemoveBandwidthPackageIpsRequest,
    ) -> ecs_20140526_models.RemoveBandwidthPackageIpsResponse:
        """
        @deprecated OpenAPI RemoveBandwidthPackageIps is deprecated, please use Vpc::2016-04-28::RemoveBandwidthPackageIps instead.
        
        @summary RemoveBandwidthPackageIps
        
        @param request: RemoveBandwidthPackageIpsRequest
        @return: RemoveBandwidthPackageIpsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.remove_bandwidth_package_ips_with_options(request, runtime)

    async def remove_bandwidth_package_ips_async(
        self,
        request: ecs_20140526_models.RemoveBandwidthPackageIpsRequest,
    ) -> ecs_20140526_models.RemoveBandwidthPackageIpsResponse:
        """
        @deprecated OpenAPI RemoveBandwidthPackageIps is deprecated, please use Vpc::2016-04-28::RemoveBandwidthPackageIps instead.
        
        @summary RemoveBandwidthPackageIps
        
        @param request: RemoveBandwidthPackageIpsRequest
        @return: RemoveBandwidthPackageIpsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.remove_bandwidth_package_ips_with_options_async(request, runtime)

    def remove_tags_with_options(
        self,
        request: ecs_20140526_models.RemoveTagsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RemoveTagsResponse:
        """
        @deprecated OpenAPI RemoveTags is deprecated, please use Ecs::2014-05-26::UntagResources instead.
        
        @summary Removes tags from a resource, such as an Elastic Compute Service (ECS) instance, disk, snapshot, image, or security group.
        
        @param request: RemoveTagsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveTagsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveTags',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RemoveTagsResponse(),
            self.call_api(params, req, runtime)
        )

    async def remove_tags_with_options_async(
        self,
        request: ecs_20140526_models.RemoveTagsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RemoveTagsResponse:
        """
        @deprecated OpenAPI RemoveTags is deprecated, please use Ecs::2014-05-26::UntagResources instead.
        
        @summary Removes tags from a resource, such as an Elastic Compute Service (ECS) instance, disk, snapshot, image, or security group.
        
        @param request: RemoveTagsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveTagsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveTags',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RemoveTagsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def remove_tags(
        self,
        request: ecs_20140526_models.RemoveTagsRequest,
    ) -> ecs_20140526_models.RemoveTagsResponse:
        """
        @deprecated OpenAPI RemoveTags is deprecated, please use Ecs::2014-05-26::UntagResources instead.
        
        @summary Removes tags from a resource, such as an Elastic Compute Service (ECS) instance, disk, snapshot, image, or security group.
        
        @param request: RemoveTagsRequest
        @return: RemoveTagsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.remove_tags_with_options(request, runtime)

    async def remove_tags_async(
        self,
        request: ecs_20140526_models.RemoveTagsRequest,
    ) -> ecs_20140526_models.RemoveTagsResponse:
        """
        @deprecated OpenAPI RemoveTags is deprecated, please use Ecs::2014-05-26::UntagResources instead.
        
        @summary Removes tags from a resource, such as an Elastic Compute Service (ECS) instance, disk, snapshot, image, or security group.
        
        @param request: RemoveTagsRequest
        @return: RemoveTagsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.remove_tags_with_options_async(request, runtime)

    def renew_dedicated_hosts_with_options(
        self,
        request: ecs_20140526_models.RenewDedicatedHostsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RenewDedicatedHostsResponse:
        """
        @summary Renews one or more subscription dedicated hosts.
        
        @description ## [](#)Usage notes
        When you renew subscription dedicated hosts, vouchers are used first by default. Make sure that your account supports credit card payments or balance payments.
        
        @param request: RenewDedicatedHostsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RenewDedicatedHostsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dedicated_host_ids):
            query['DedicatedHostIds'] = request.dedicated_host_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RenewDedicatedHosts',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RenewDedicatedHostsResponse(),
            self.call_api(params, req, runtime)
        )

    async def renew_dedicated_hosts_with_options_async(
        self,
        request: ecs_20140526_models.RenewDedicatedHostsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RenewDedicatedHostsResponse:
        """
        @summary Renews one or more subscription dedicated hosts.
        
        @description ## [](#)Usage notes
        When you renew subscription dedicated hosts, vouchers are used first by default. Make sure that your account supports credit card payments or balance payments.
        
        @param request: RenewDedicatedHostsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RenewDedicatedHostsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dedicated_host_ids):
            query['DedicatedHostIds'] = request.dedicated_host_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RenewDedicatedHosts',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RenewDedicatedHostsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def renew_dedicated_hosts(
        self,
        request: ecs_20140526_models.RenewDedicatedHostsRequest,
    ) -> ecs_20140526_models.RenewDedicatedHostsResponse:
        """
        @summary Renews one or more subscription dedicated hosts.
        
        @description ## [](#)Usage notes
        When you renew subscription dedicated hosts, vouchers are used first by default. Make sure that your account supports credit card payments or balance payments.
        
        @param request: RenewDedicatedHostsRequest
        @return: RenewDedicatedHostsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.renew_dedicated_hosts_with_options(request, runtime)

    async def renew_dedicated_hosts_async(
        self,
        request: ecs_20140526_models.RenewDedicatedHostsRequest,
    ) -> ecs_20140526_models.RenewDedicatedHostsResponse:
        """
        @summary Renews one or more subscription dedicated hosts.
        
        @description ## [](#)Usage notes
        When you renew subscription dedicated hosts, vouchers are used first by default. Make sure that your account supports credit card payments or balance payments.
        
        @param request: RenewDedicatedHostsRequest
        @return: RenewDedicatedHostsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.renew_dedicated_hosts_with_options_async(request, runtime)

    def renew_elasticity_assurances_with_options(
        self,
        request: ecs_20140526_models.RenewElasticityAssurancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RenewElasticityAssurancesResponse:
        """
        @summary Renews elasticity assurances that you purchased.
        
        @param request: RenewElasticityAssurancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RenewElasticityAssurancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_period):
            query['AutoRenewPeriod'] = request.auto_renew_period
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RenewElasticityAssurances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RenewElasticityAssurancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def renew_elasticity_assurances_with_options_async(
        self,
        request: ecs_20140526_models.RenewElasticityAssurancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RenewElasticityAssurancesResponse:
        """
        @summary Renews elasticity assurances that you purchased.
        
        @param request: RenewElasticityAssurancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RenewElasticityAssurancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_period):
            query['AutoRenewPeriod'] = request.auto_renew_period
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RenewElasticityAssurances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RenewElasticityAssurancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def renew_elasticity_assurances(
        self,
        request: ecs_20140526_models.RenewElasticityAssurancesRequest,
    ) -> ecs_20140526_models.RenewElasticityAssurancesResponse:
        """
        @summary Renews elasticity assurances that you purchased.
        
        @param request: RenewElasticityAssurancesRequest
        @return: RenewElasticityAssurancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.renew_elasticity_assurances_with_options(request, runtime)

    async def renew_elasticity_assurances_async(
        self,
        request: ecs_20140526_models.RenewElasticityAssurancesRequest,
    ) -> ecs_20140526_models.RenewElasticityAssurancesResponse:
        """
        @summary Renews elasticity assurances that you purchased.
        
        @param request: RenewElasticityAssurancesRequest
        @return: RenewElasticityAssurancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.renew_elasticity_assurances_with_options_async(request, runtime)

    def renew_instance_with_options(
        self,
        request: ecs_20140526_models.RenewInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RenewInstanceResponse:
        """
        @summary Renews a subscription Elastic Compute Service (ECS) instance. You can specify a renewal period or renew the instance to a unified expiration date.
        
        @description *Before you call this operation, make sure that you are familiar with the billing methods and [pricing](https://www.alibabacloud.com/product/ecs#pricing) of ECS**.
        Make sure that your account balance or credit balance is sufficient.
        Only subscription instances are supported. If you call this operation for a pay-as-you-go instance, an error is returned.
        You must specify the renewal period-related parameter pair (`Period` and `PeriodUnit`) or `ExpectedRenewDay`, but not both.
        
        @param request: RenewInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RenewInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.expected_renew_day):
            query['ExpectedRenewDay'] = request.expected_renew_day
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RenewInstance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RenewInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def renew_instance_with_options_async(
        self,
        request: ecs_20140526_models.RenewInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RenewInstanceResponse:
        """
        @summary Renews a subscription Elastic Compute Service (ECS) instance. You can specify a renewal period or renew the instance to a unified expiration date.
        
        @description *Before you call this operation, make sure that you are familiar with the billing methods and [pricing](https://www.alibabacloud.com/product/ecs#pricing) of ECS**.
        Make sure that your account balance or credit balance is sufficient.
        Only subscription instances are supported. If you call this operation for a pay-as-you-go instance, an error is returned.
        You must specify the renewal period-related parameter pair (`Period` and `PeriodUnit`) or `ExpectedRenewDay`, but not both.
        
        @param request: RenewInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RenewInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.expected_renew_day):
            query['ExpectedRenewDay'] = request.expected_renew_day
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RenewInstance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RenewInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def renew_instance(
        self,
        request: ecs_20140526_models.RenewInstanceRequest,
    ) -> ecs_20140526_models.RenewInstanceResponse:
        """
        @summary Renews a subscription Elastic Compute Service (ECS) instance. You can specify a renewal period or renew the instance to a unified expiration date.
        
        @description *Before you call this operation, make sure that you are familiar with the billing methods and [pricing](https://www.alibabacloud.com/product/ecs#pricing) of ECS**.
        Make sure that your account balance or credit balance is sufficient.
        Only subscription instances are supported. If you call this operation for a pay-as-you-go instance, an error is returned.
        You must specify the renewal period-related parameter pair (`Period` and `PeriodUnit`) or `ExpectedRenewDay`, but not both.
        
        @param request: RenewInstanceRequest
        @return: RenewInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.renew_instance_with_options(request, runtime)

    async def renew_instance_async(
        self,
        request: ecs_20140526_models.RenewInstanceRequest,
    ) -> ecs_20140526_models.RenewInstanceResponse:
        """
        @summary Renews a subscription Elastic Compute Service (ECS) instance. You can specify a renewal period or renew the instance to a unified expiration date.
        
        @description *Before you call this operation, make sure that you are familiar with the billing methods and [pricing](https://www.alibabacloud.com/product/ecs#pricing) of ECS**.
        Make sure that your account balance or credit balance is sufficient.
        Only subscription instances are supported. If you call this operation for a pay-as-you-go instance, an error is returned.
        You must specify the renewal period-related parameter pair (`Period` and `PeriodUnit`) or `ExpectedRenewDay`, but not both.
        
        @param request: RenewInstanceRequest
        @return: RenewInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.renew_instance_with_options_async(request, runtime)

    def renew_reserved_instances_with_options(
        self,
        request: ecs_20140526_models.RenewReservedInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RenewReservedInstancesResponse:
        """
        @summary Renews one or more reserved instances. When you renew reserved instances, you can specify a validity period (renewal period) and whether to enable auto-renewal for the reserved instances.
        
        @description *Before you call this operation, make sure that you are familiar with the billing and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of reserved instances.**\
        You can manually renew reserved instances or enable auto-renewal for reserved instances. For more information, see the [Renewal](~~100371#53bfc50b78sta~~) section of the "Reserved instances" topic.
        You can call the [DescribeReservedInstances](https://help.aliyun.com/document_detail/100065.html) operation to query the reserved instances that you purchased.
        You can call this operation to enable auto-renewal for reserved instances but cannot call this operation to disable auto-renewal for reserved instances. To disable auto-renewal for a reserved instance, call the [ModifyReservedInstanceAutoRenewAttribute](https://help.aliyun.com/document_detail/2679786.html) operation.
        
        @param request: RenewReservedInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RenewReservedInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_period):
            query['AutoRenewPeriod'] = request.auto_renew_period
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.reserved_instance_id):
            query['ReservedInstanceId'] = request.reserved_instance_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RenewReservedInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RenewReservedInstancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def renew_reserved_instances_with_options_async(
        self,
        request: ecs_20140526_models.RenewReservedInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RenewReservedInstancesResponse:
        """
        @summary Renews one or more reserved instances. When you renew reserved instances, you can specify a validity period (renewal period) and whether to enable auto-renewal for the reserved instances.
        
        @description *Before you call this operation, make sure that you are familiar with the billing and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of reserved instances.**\
        You can manually renew reserved instances or enable auto-renewal for reserved instances. For more information, see the [Renewal](~~100371#53bfc50b78sta~~) section of the "Reserved instances" topic.
        You can call the [DescribeReservedInstances](https://help.aliyun.com/document_detail/100065.html) operation to query the reserved instances that you purchased.
        You can call this operation to enable auto-renewal for reserved instances but cannot call this operation to disable auto-renewal for reserved instances. To disable auto-renewal for a reserved instance, call the [ModifyReservedInstanceAutoRenewAttribute](https://help.aliyun.com/document_detail/2679786.html) operation.
        
        @param request: RenewReservedInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RenewReservedInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_period):
            query['AutoRenewPeriod'] = request.auto_renew_period
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.reserved_instance_id):
            query['ReservedInstanceId'] = request.reserved_instance_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RenewReservedInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RenewReservedInstancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def renew_reserved_instances(
        self,
        request: ecs_20140526_models.RenewReservedInstancesRequest,
    ) -> ecs_20140526_models.RenewReservedInstancesResponse:
        """
        @summary Renews one or more reserved instances. When you renew reserved instances, you can specify a validity period (renewal period) and whether to enable auto-renewal for the reserved instances.
        
        @description *Before you call this operation, make sure that you are familiar with the billing and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of reserved instances.**\
        You can manually renew reserved instances or enable auto-renewal for reserved instances. For more information, see the [Renewal](~~100371#53bfc50b78sta~~) section of the "Reserved instances" topic.
        You can call the [DescribeReservedInstances](https://help.aliyun.com/document_detail/100065.html) operation to query the reserved instances that you purchased.
        You can call this operation to enable auto-renewal for reserved instances but cannot call this operation to disable auto-renewal for reserved instances. To disable auto-renewal for a reserved instance, call the [ModifyReservedInstanceAutoRenewAttribute](https://help.aliyun.com/document_detail/2679786.html) operation.
        
        @param request: RenewReservedInstancesRequest
        @return: RenewReservedInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.renew_reserved_instances_with_options(request, runtime)

    async def renew_reserved_instances_async(
        self,
        request: ecs_20140526_models.RenewReservedInstancesRequest,
    ) -> ecs_20140526_models.RenewReservedInstancesResponse:
        """
        @summary Renews one or more reserved instances. When you renew reserved instances, you can specify a validity period (renewal period) and whether to enable auto-renewal for the reserved instances.
        
        @description *Before you call this operation, make sure that you are familiar with the billing and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of reserved instances.**\
        You can manually renew reserved instances or enable auto-renewal for reserved instances. For more information, see the [Renewal](~~100371#53bfc50b78sta~~) section of the "Reserved instances" topic.
        You can call the [DescribeReservedInstances](https://help.aliyun.com/document_detail/100065.html) operation to query the reserved instances that you purchased.
        You can call this operation to enable auto-renewal for reserved instances but cannot call this operation to disable auto-renewal for reserved instances. To disable auto-renewal for a reserved instance, call the [ModifyReservedInstanceAutoRenewAttribute](https://help.aliyun.com/document_detail/2679786.html) operation.
        
        @param request: RenewReservedInstancesRequest
        @return: RenewReservedInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.renew_reserved_instances_with_options_async(request, runtime)

    def replace_system_disk_with_options(
        self,
        request: ecs_20140526_models.ReplaceSystemDiskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ReplaceSystemDiskResponse:
        """
        @summary Replaces the operating system (system disk) of an ECS instance. After the operating system of the ECS instance is replaced, the original system disk of the instance is released and a new system disk is generated for the instance. This causes the ID of the system disk to change.
        
        @description Before you call this operation, refer to [Replace the operating system (system disk) of an instance](https://help.aliyun.com/document_detail/50134.html).
        When you call this operation for an ECS instance, take note of the following items:
        The billing method of the system disk cannot be changed.
        The category of the system disk cannot be changed.
        Make sure that no unpaid orders are associated with the instance.
        The instance must be in the `Stopped` state.
        
        *Note** The operation is applicable only to instances of the Virtual Private Cloud (VPC) type. If the instance is a pay-as-you-go instance and default economical mode is enabled, enable standard mode when you stop the instance. This prevents the instance from being unable to restart due to insufficient ECS resources after the system disk is replaced. For more information, see [StopInstance](https://help.aliyun.com/document_detail/25501.html).
        The instance cannot be locked for security reasons. If the value of `OperationLocks` in the DescribeInstances response contains `"LockReason": "security"` for an instance, the instance is locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        You can configure `SystemDisk.Size` to specify the capacity of the new system disk.
        After you call the ReplaceSystemDisk operation, you can use one of the following methods to check whether the system disk is replaced:
        Call the [DescribeDisks](https://help.aliyun.com/document_detail/25514.html) operation to query the status of the new system disk. If the new system disk is in the In Use state, the system disk is replaced.
        Call the [DescribeInstances](https://help.aliyun.com/document_detail/25506.html) operation to query the status of the instance whose system disk is replaced. If the `OperationLocks` parameter is empty, the system disk is replaced.
        
        @param request: ReplaceSystemDiskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReplaceSystemDiskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.architecture):
            query['Architecture'] = request.architecture
        if not UtilClient.is_unset(request.arn):
            query['Arn'] = request.arn
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.encrypt_algorithm):
            query['EncryptAlgorithm'] = request.encrypt_algorithm
        if not UtilClient.is_unset(request.encrypted):
            query['Encrypted'] = request.encrypted
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.kmskey_id):
            query['KMSKeyId'] = request.kmskey_id
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.password):
            query['Password'] = request.password
        if not UtilClient.is_unset(request.password_inherit):
            query['PasswordInherit'] = request.password_inherit
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_enhancement_strategy):
            query['SecurityEnhancementStrategy'] = request.security_enhancement_strategy
        if not UtilClient.is_unset(request.use_additional_service):
            query['UseAdditionalService'] = request.use_additional_service
        if not UtilClient.is_unset(request.system_disk):
            query['SystemDisk'] = request.system_disk
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReplaceSystemDisk',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ReplaceSystemDiskResponse(),
            self.call_api(params, req, runtime)
        )

    async def replace_system_disk_with_options_async(
        self,
        request: ecs_20140526_models.ReplaceSystemDiskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ReplaceSystemDiskResponse:
        """
        @summary Replaces the operating system (system disk) of an ECS instance. After the operating system of the ECS instance is replaced, the original system disk of the instance is released and a new system disk is generated for the instance. This causes the ID of the system disk to change.
        
        @description Before you call this operation, refer to [Replace the operating system (system disk) of an instance](https://help.aliyun.com/document_detail/50134.html).
        When you call this operation for an ECS instance, take note of the following items:
        The billing method of the system disk cannot be changed.
        The category of the system disk cannot be changed.
        Make sure that no unpaid orders are associated with the instance.
        The instance must be in the `Stopped` state.
        
        *Note** The operation is applicable only to instances of the Virtual Private Cloud (VPC) type. If the instance is a pay-as-you-go instance and default economical mode is enabled, enable standard mode when you stop the instance. This prevents the instance from being unable to restart due to insufficient ECS resources after the system disk is replaced. For more information, see [StopInstance](https://help.aliyun.com/document_detail/25501.html).
        The instance cannot be locked for security reasons. If the value of `OperationLocks` in the DescribeInstances response contains `"LockReason": "security"` for an instance, the instance is locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        You can configure `SystemDisk.Size` to specify the capacity of the new system disk.
        After you call the ReplaceSystemDisk operation, you can use one of the following methods to check whether the system disk is replaced:
        Call the [DescribeDisks](https://help.aliyun.com/document_detail/25514.html) operation to query the status of the new system disk. If the new system disk is in the In Use state, the system disk is replaced.
        Call the [DescribeInstances](https://help.aliyun.com/document_detail/25506.html) operation to query the status of the instance whose system disk is replaced. If the `OperationLocks` parameter is empty, the system disk is replaced.
        
        @param request: ReplaceSystemDiskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReplaceSystemDiskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.architecture):
            query['Architecture'] = request.architecture
        if not UtilClient.is_unset(request.arn):
            query['Arn'] = request.arn
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.encrypt_algorithm):
            query['EncryptAlgorithm'] = request.encrypt_algorithm
        if not UtilClient.is_unset(request.encrypted):
            query['Encrypted'] = request.encrypted
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.kmskey_id):
            query['KMSKeyId'] = request.kmskey_id
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.password):
            query['Password'] = request.password
        if not UtilClient.is_unset(request.password_inherit):
            query['PasswordInherit'] = request.password_inherit
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_enhancement_strategy):
            query['SecurityEnhancementStrategy'] = request.security_enhancement_strategy
        if not UtilClient.is_unset(request.use_additional_service):
            query['UseAdditionalService'] = request.use_additional_service
        if not UtilClient.is_unset(request.system_disk):
            query['SystemDisk'] = request.system_disk
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReplaceSystemDisk',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ReplaceSystemDiskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def replace_system_disk(
        self,
        request: ecs_20140526_models.ReplaceSystemDiskRequest,
    ) -> ecs_20140526_models.ReplaceSystemDiskResponse:
        """
        @summary Replaces the operating system (system disk) of an ECS instance. After the operating system of the ECS instance is replaced, the original system disk of the instance is released and a new system disk is generated for the instance. This causes the ID of the system disk to change.
        
        @description Before you call this operation, refer to [Replace the operating system (system disk) of an instance](https://help.aliyun.com/document_detail/50134.html).
        When you call this operation for an ECS instance, take note of the following items:
        The billing method of the system disk cannot be changed.
        The category of the system disk cannot be changed.
        Make sure that no unpaid orders are associated with the instance.
        The instance must be in the `Stopped` state.
        
        *Note** The operation is applicable only to instances of the Virtual Private Cloud (VPC) type. If the instance is a pay-as-you-go instance and default economical mode is enabled, enable standard mode when you stop the instance. This prevents the instance from being unable to restart due to insufficient ECS resources after the system disk is replaced. For more information, see [StopInstance](https://help.aliyun.com/document_detail/25501.html).
        The instance cannot be locked for security reasons. If the value of `OperationLocks` in the DescribeInstances response contains `"LockReason": "security"` for an instance, the instance is locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        You can configure `SystemDisk.Size` to specify the capacity of the new system disk.
        After you call the ReplaceSystemDisk operation, you can use one of the following methods to check whether the system disk is replaced:
        Call the [DescribeDisks](https://help.aliyun.com/document_detail/25514.html) operation to query the status of the new system disk. If the new system disk is in the In Use state, the system disk is replaced.
        Call the [DescribeInstances](https://help.aliyun.com/document_detail/25506.html) operation to query the status of the instance whose system disk is replaced. If the `OperationLocks` parameter is empty, the system disk is replaced.
        
        @param request: ReplaceSystemDiskRequest
        @return: ReplaceSystemDiskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.replace_system_disk_with_options(request, runtime)

    async def replace_system_disk_async(
        self,
        request: ecs_20140526_models.ReplaceSystemDiskRequest,
    ) -> ecs_20140526_models.ReplaceSystemDiskResponse:
        """
        @summary Replaces the operating system (system disk) of an ECS instance. After the operating system of the ECS instance is replaced, the original system disk of the instance is released and a new system disk is generated for the instance. This causes the ID of the system disk to change.
        
        @description Before you call this operation, refer to [Replace the operating system (system disk) of an instance](https://help.aliyun.com/document_detail/50134.html).
        When you call this operation for an ECS instance, take note of the following items:
        The billing method of the system disk cannot be changed.
        The category of the system disk cannot be changed.
        Make sure that no unpaid orders are associated with the instance.
        The instance must be in the `Stopped` state.
        
        *Note** The operation is applicable only to instances of the Virtual Private Cloud (VPC) type. If the instance is a pay-as-you-go instance and default economical mode is enabled, enable standard mode when you stop the instance. This prevents the instance from being unable to restart due to insufficient ECS resources after the system disk is replaced. For more information, see [StopInstance](https://help.aliyun.com/document_detail/25501.html).
        The instance cannot be locked for security reasons. If the value of `OperationLocks` in the DescribeInstances response contains `"LockReason": "security"` for an instance, the instance is locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        You can configure `SystemDisk.Size` to specify the capacity of the new system disk.
        After you call the ReplaceSystemDisk operation, you can use one of the following methods to check whether the system disk is replaced:
        Call the [DescribeDisks](https://help.aliyun.com/document_detail/25514.html) operation to query the status of the new system disk. If the new system disk is in the In Use state, the system disk is replaced.
        Call the [DescribeInstances](https://help.aliyun.com/document_detail/25506.html) operation to query the status of the instance whose system disk is replaced. If the `OperationLocks` parameter is empty, the system disk is replaced.
        
        @param request: ReplaceSystemDiskRequest
        @return: ReplaceSystemDiskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.replace_system_disk_with_options_async(request, runtime)

    def report_instances_status_with_options(
        self,
        request: ecs_20140526_models.ReportInstancesStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ReportInstancesStatusResponse:
        """
        @summary Reports an exception on Elastic Compute Service (ECS) instances. You can report the same exception on multiple ECS instances or on multiple disks of an ECS instance.
        
        @param request: ReportInstancesStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReportInstancesStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.device):
            query['Device'] = request.device
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.issue_category):
            query['IssueCategory'] = request.issue_category
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.reason):
            query['Reason'] = request.reason
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReportInstancesStatus',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ReportInstancesStatusResponse(),
            self.call_api(params, req, runtime)
        )

    async def report_instances_status_with_options_async(
        self,
        request: ecs_20140526_models.ReportInstancesStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ReportInstancesStatusResponse:
        """
        @summary Reports an exception on Elastic Compute Service (ECS) instances. You can report the same exception on multiple ECS instances or on multiple disks of an ECS instance.
        
        @param request: ReportInstancesStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReportInstancesStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.device):
            query['Device'] = request.device
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.issue_category):
            query['IssueCategory'] = request.issue_category
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.reason):
            query['Reason'] = request.reason
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReportInstancesStatus',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ReportInstancesStatusResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def report_instances_status(
        self,
        request: ecs_20140526_models.ReportInstancesStatusRequest,
    ) -> ecs_20140526_models.ReportInstancesStatusResponse:
        """
        @summary Reports an exception on Elastic Compute Service (ECS) instances. You can report the same exception on multiple ECS instances or on multiple disks of an ECS instance.
        
        @param request: ReportInstancesStatusRequest
        @return: ReportInstancesStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.report_instances_status_with_options(request, runtime)

    async def report_instances_status_async(
        self,
        request: ecs_20140526_models.ReportInstancesStatusRequest,
    ) -> ecs_20140526_models.ReportInstancesStatusResponse:
        """
        @summary Reports an exception on Elastic Compute Service (ECS) instances. You can report the same exception on multiple ECS instances or on multiple disks of an ECS instance.
        
        @param request: ReportInstancesStatusRequest
        @return: ReportInstancesStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.report_instances_status_with_options_async(request, runtime)

    def reset_disk_with_options(
        self,
        request: ecs_20140526_models.ResetDiskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ResetDiskResponse:
        """
        @summary Rolls back a cloud disk to a snapshot from an earlier point in time.
        
        @description Before you call this operation, read [Roll back a disk by using a snapshot](https://help.aliyun.com/document_detail/25450.html).
        Take note of the following items:
        The cloud disk that you want to roll back must be in the In Use (`In_use`) or Unattached (`Available`) state.
        The instance to which the cloud disk is attached must be in the `Stopped` state. You can call the [StopInstances](https://help.aliyun.com/document_detail/155372.html) operation to stop the instance.
        The snapshot specified by `SnapshotId` must be created from the disk specified by `DiskId`.
        If the response contains `{"OperationLocks": {"LockReason" : "security"}}` when you query information about an instance by calling the [DescribeInstances](https://help.aliyun.com/document_detail/25506.html) operation, the instance is locked for security reasons and no operations can be performed on the instance.
        
        @param request: ResetDiskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ResetDiskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ResetDisk',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ResetDiskResponse(),
            self.call_api(params, req, runtime)
        )

    async def reset_disk_with_options_async(
        self,
        request: ecs_20140526_models.ResetDiskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ResetDiskResponse:
        """
        @summary Rolls back a cloud disk to a snapshot from an earlier point in time.
        
        @description Before you call this operation, read [Roll back a disk by using a snapshot](https://help.aliyun.com/document_detail/25450.html).
        Take note of the following items:
        The cloud disk that you want to roll back must be in the In Use (`In_use`) or Unattached (`Available`) state.
        The instance to which the cloud disk is attached must be in the `Stopped` state. You can call the [StopInstances](https://help.aliyun.com/document_detail/155372.html) operation to stop the instance.
        The snapshot specified by `SnapshotId` must be created from the disk specified by `DiskId`.
        If the response contains `{"OperationLocks": {"LockReason" : "security"}}` when you query information about an instance by calling the [DescribeInstances](https://help.aliyun.com/document_detail/25506.html) operation, the instance is locked for security reasons and no operations can be performed on the instance.
        
        @param request: ResetDiskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ResetDiskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snapshot_id):
            query['SnapshotId'] = request.snapshot_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ResetDisk',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ResetDiskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def reset_disk(
        self,
        request: ecs_20140526_models.ResetDiskRequest,
    ) -> ecs_20140526_models.ResetDiskResponse:
        """
        @summary Rolls back a cloud disk to a snapshot from an earlier point in time.
        
        @description Before you call this operation, read [Roll back a disk by using a snapshot](https://help.aliyun.com/document_detail/25450.html).
        Take note of the following items:
        The cloud disk that you want to roll back must be in the In Use (`In_use`) or Unattached (`Available`) state.
        The instance to which the cloud disk is attached must be in the `Stopped` state. You can call the [StopInstances](https://help.aliyun.com/document_detail/155372.html) operation to stop the instance.
        The snapshot specified by `SnapshotId` must be created from the disk specified by `DiskId`.
        If the response contains `{"OperationLocks": {"LockReason" : "security"}}` when you query information about an instance by calling the [DescribeInstances](https://help.aliyun.com/document_detail/25506.html) operation, the instance is locked for security reasons and no operations can be performed on the instance.
        
        @param request: ResetDiskRequest
        @return: ResetDiskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.reset_disk_with_options(request, runtime)

    async def reset_disk_async(
        self,
        request: ecs_20140526_models.ResetDiskRequest,
    ) -> ecs_20140526_models.ResetDiskResponse:
        """
        @summary Rolls back a cloud disk to a snapshot from an earlier point in time.
        
        @description Before you call this operation, read [Roll back a disk by using a snapshot](https://help.aliyun.com/document_detail/25450.html).
        Take note of the following items:
        The cloud disk that you want to roll back must be in the In Use (`In_use`) or Unattached (`Available`) state.
        The instance to which the cloud disk is attached must be in the `Stopped` state. You can call the [StopInstances](https://help.aliyun.com/document_detail/155372.html) operation to stop the instance.
        The snapshot specified by `SnapshotId` must be created from the disk specified by `DiskId`.
        If the response contains `{"OperationLocks": {"LockReason" : "security"}}` when you query information about an instance by calling the [DescribeInstances](https://help.aliyun.com/document_detail/25506.html) operation, the instance is locked for security reasons and no operations can be performed on the instance.
        
        @param request: ResetDiskRequest
        @return: ResetDiskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.reset_disk_with_options_async(request, runtime)

    def reset_disk_default_kmskey_id_with_options(
        self,
        request: ecs_20140526_models.ResetDiskDefaultKMSKeyIdRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ResetDiskDefaultKMSKeyIdResponse:
        """
        @summary Resets the Key Management Service (KMS) key used by Account-level Elastic Block Storage (EBS) Default Encryption in a region to the service key.
        
        @description    You must grant the RAM user the `AliyunECSFullAccess` permissions. For information about how to grant permissions to a RAM user, see [Grant permissions to a RAM user](https://help.aliyun.com/document_detail/116146.html).
        Before you can call this operation in a region, make sure that the **Account-level Elastic Block Storage (EBS) Default Encryption** feature is enabled in the region.
        
        @param request: ResetDiskDefaultKMSKeyIdRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ResetDiskDefaultKMSKeyIdResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ResetDiskDefaultKMSKeyId',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ResetDiskDefaultKMSKeyIdResponse(),
            self.call_api(params, req, runtime)
        )

    async def reset_disk_default_kmskey_id_with_options_async(
        self,
        request: ecs_20140526_models.ResetDiskDefaultKMSKeyIdRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ResetDiskDefaultKMSKeyIdResponse:
        """
        @summary Resets the Key Management Service (KMS) key used by Account-level Elastic Block Storage (EBS) Default Encryption in a region to the service key.
        
        @description    You must grant the RAM user the `AliyunECSFullAccess` permissions. For information about how to grant permissions to a RAM user, see [Grant permissions to a RAM user](https://help.aliyun.com/document_detail/116146.html).
        Before you can call this operation in a region, make sure that the **Account-level Elastic Block Storage (EBS) Default Encryption** feature is enabled in the region.
        
        @param request: ResetDiskDefaultKMSKeyIdRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ResetDiskDefaultKMSKeyIdResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ResetDiskDefaultKMSKeyId',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ResetDiskDefaultKMSKeyIdResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def reset_disk_default_kmskey_id(
        self,
        request: ecs_20140526_models.ResetDiskDefaultKMSKeyIdRequest,
    ) -> ecs_20140526_models.ResetDiskDefaultKMSKeyIdResponse:
        """
        @summary Resets the Key Management Service (KMS) key used by Account-level Elastic Block Storage (EBS) Default Encryption in a region to the service key.
        
        @description    You must grant the RAM user the `AliyunECSFullAccess` permissions. For information about how to grant permissions to a RAM user, see [Grant permissions to a RAM user](https://help.aliyun.com/document_detail/116146.html).
        Before you can call this operation in a region, make sure that the **Account-level Elastic Block Storage (EBS) Default Encryption** feature is enabled in the region.
        
        @param request: ResetDiskDefaultKMSKeyIdRequest
        @return: ResetDiskDefaultKMSKeyIdResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.reset_disk_default_kmskey_id_with_options(request, runtime)

    async def reset_disk_default_kmskey_id_async(
        self,
        request: ecs_20140526_models.ResetDiskDefaultKMSKeyIdRequest,
    ) -> ecs_20140526_models.ResetDiskDefaultKMSKeyIdResponse:
        """
        @summary Resets the Key Management Service (KMS) key used by Account-level Elastic Block Storage (EBS) Default Encryption in a region to the service key.
        
        @description    You must grant the RAM user the `AliyunECSFullAccess` permissions. For information about how to grant permissions to a RAM user, see [Grant permissions to a RAM user](https://help.aliyun.com/document_detail/116146.html).
        Before you can call this operation in a region, make sure that the **Account-level Elastic Block Storage (EBS) Default Encryption** feature is enabled in the region.
        
        @param request: ResetDiskDefaultKMSKeyIdRequest
        @return: ResetDiskDefaultKMSKeyIdResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.reset_disk_default_kmskey_id_with_options_async(request, runtime)

    def reset_disks_with_options(
        self,
        request: ecs_20140526_models.ResetDisksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ResetDisksResponse:
        """
        @summary Rolls back one or more disks by using a snapshot-consistent group.
        
        @description This operation will be removed in the future. We recommend that you call the [ResetDisk](https://help.aliyun.com/document_detail/25520.html) operation to roll back a disk.
        
        @param request: ResetDisksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ResetDisksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.disk):
            query['Disk'] = request.disk
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ResetDisks',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ResetDisksResponse(),
            self.call_api(params, req, runtime)
        )

    async def reset_disks_with_options_async(
        self,
        request: ecs_20140526_models.ResetDisksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ResetDisksResponse:
        """
        @summary Rolls back one or more disks by using a snapshot-consistent group.
        
        @description This operation will be removed in the future. We recommend that you call the [ResetDisk](https://help.aliyun.com/document_detail/25520.html) operation to roll back a disk.
        
        @param request: ResetDisksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ResetDisksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.disk):
            query['Disk'] = request.disk
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ResetDisks',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ResetDisksResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def reset_disks(
        self,
        request: ecs_20140526_models.ResetDisksRequest,
    ) -> ecs_20140526_models.ResetDisksResponse:
        """
        @summary Rolls back one or more disks by using a snapshot-consistent group.
        
        @description This operation will be removed in the future. We recommend that you call the [ResetDisk](https://help.aliyun.com/document_detail/25520.html) operation to roll back a disk.
        
        @param request: ResetDisksRequest
        @return: ResetDisksResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.reset_disks_with_options(request, runtime)

    async def reset_disks_async(
        self,
        request: ecs_20140526_models.ResetDisksRequest,
    ) -> ecs_20140526_models.ResetDisksResponse:
        """
        @summary Rolls back one or more disks by using a snapshot-consistent group.
        
        @description This operation will be removed in the future. We recommend that you call the [ResetDisk](https://help.aliyun.com/document_detail/25520.html) operation to roll back a disk.
        
        @param request: ResetDisksRequest
        @return: ResetDisksResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.reset_disks_with_options_async(request, runtime)

    def resize_disk_with_options(
        self,
        request: ecs_20140526_models.ResizeDiskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ResizeDiskResponse:
        """
        @summary Resizes a system disk or a data disk.
        
        @description >  Before you call this operation to resize a disk, you must check the partition format of the disk. You cannot resize a master boot record (MBR) disk to a size that is larger than 2 TiB. If you resize an MBR disk to a size that is larger than 2 TiB, data may be lost. If you want to resize an MBR disk to a size that is larger than 2 TiB, we recommend that you perform the following steps: Create a new data disk that is larger than 2 TiB in size, partition and format the new data disk by using the GUID Partition Table (GPT) format, and then copy data from the MBR disk to the GPT data disk. For more information, see [Step 1: Resize a disk to extend the disk capacity](https://help.aliyun.com/document_detail/44986.html).
        You can resize disks of the following disk categories: basic disks (`cloud`), ultra disks (`cloud_efficiency`), standard SSDs (`cloud_ssd`), Enterprise SSDs (ESSDs) (`cloud_essd`), ESSD AutoPL disks (cloud_auto), standard elastic ephemeral disks (elastic_ephemeral_disk_standard), and premium elastic ephemeral disks (elastic_ephemeral_disk_premium).
        You cannot resize a cloud disk when a snapshot is being created for the disk. Wait until the snapshot is created before you resize the cloud disk.
        You cannot call this operation to resize partitions or file systems on a cloud disk. You must manually resize the partitions and file systems after the disk is resized. For more information, see [Step 2: Resize partitions and file systems](https://help.aliyun.com/document_detail/470068.html).
        If the multi-attach feature is enabled for a cloud disk, you can resize the disk online or offline. Make sure that the Elastic Compute Service (ECS) instances to which the disk is attached meet the following requirements:
        If you want to resize the disk online, the ECS instances must be in the **Running** (`Running`) state.
        If you want to resize the disk offline, the ECS instances must be in the **Running** (`Running`) or **Stopped** (`Stopped`) state.
        The cloud disk that you want to resize must meet the following requirements:
        The disk is in the In Use (`In_use`) or Unattached (`Available`) state.
        (Recommended) Snapshots are created for the disk to back up disk data. For information about how to create snapshots for a disk, see [Create a snapshot](https://help.aliyun.com/document_detail/25455.html).
        If the disk is a new data disk, initialize the disk before you resize the disk. For more information, see [Overview](https://help.aliyun.com/document_detail/466323.html).
        
        @param request: ResizeDiskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ResizeDiskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.new_size):
            query['NewSize'] = request.new_size
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ResizeDisk',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ResizeDiskResponse(),
            self.call_api(params, req, runtime)
        )

    async def resize_disk_with_options_async(
        self,
        request: ecs_20140526_models.ResizeDiskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.ResizeDiskResponse:
        """
        @summary Resizes a system disk or a data disk.
        
        @description >  Before you call this operation to resize a disk, you must check the partition format of the disk. You cannot resize a master boot record (MBR) disk to a size that is larger than 2 TiB. If you resize an MBR disk to a size that is larger than 2 TiB, data may be lost. If you want to resize an MBR disk to a size that is larger than 2 TiB, we recommend that you perform the following steps: Create a new data disk that is larger than 2 TiB in size, partition and format the new data disk by using the GUID Partition Table (GPT) format, and then copy data from the MBR disk to the GPT data disk. For more information, see [Step 1: Resize a disk to extend the disk capacity](https://help.aliyun.com/document_detail/44986.html).
        You can resize disks of the following disk categories: basic disks (`cloud`), ultra disks (`cloud_efficiency`), standard SSDs (`cloud_ssd`), Enterprise SSDs (ESSDs) (`cloud_essd`), ESSD AutoPL disks (cloud_auto), standard elastic ephemeral disks (elastic_ephemeral_disk_standard), and premium elastic ephemeral disks (elastic_ephemeral_disk_premium).
        You cannot resize a cloud disk when a snapshot is being created for the disk. Wait until the snapshot is created before you resize the cloud disk.
        You cannot call this operation to resize partitions or file systems on a cloud disk. You must manually resize the partitions and file systems after the disk is resized. For more information, see [Step 2: Resize partitions and file systems](https://help.aliyun.com/document_detail/470068.html).
        If the multi-attach feature is enabled for a cloud disk, you can resize the disk online or offline. Make sure that the Elastic Compute Service (ECS) instances to which the disk is attached meet the following requirements:
        If you want to resize the disk online, the ECS instances must be in the **Running** (`Running`) state.
        If you want to resize the disk offline, the ECS instances must be in the **Running** (`Running`) or **Stopped** (`Stopped`) state.
        The cloud disk that you want to resize must meet the following requirements:
        The disk is in the In Use (`In_use`) or Unattached (`Available`) state.
        (Recommended) Snapshots are created for the disk to back up disk data. For information about how to create snapshots for a disk, see [Create a snapshot](https://help.aliyun.com/document_detail/25455.html).
        If the disk is a new data disk, initialize the disk before you resize the disk. For more information, see [Overview](https://help.aliyun.com/document_detail/466323.html).
        
        @param request: ResizeDiskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ResizeDiskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.disk_id):
            query['DiskId'] = request.disk_id
        if not UtilClient.is_unset(request.new_size):
            query['NewSize'] = request.new_size
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ResizeDisk',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.ResizeDiskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def resize_disk(
        self,
        request: ecs_20140526_models.ResizeDiskRequest,
    ) -> ecs_20140526_models.ResizeDiskResponse:
        """
        @summary Resizes a system disk or a data disk.
        
        @description >  Before you call this operation to resize a disk, you must check the partition format of the disk. You cannot resize a master boot record (MBR) disk to a size that is larger than 2 TiB. If you resize an MBR disk to a size that is larger than 2 TiB, data may be lost. If you want to resize an MBR disk to a size that is larger than 2 TiB, we recommend that you perform the following steps: Create a new data disk that is larger than 2 TiB in size, partition and format the new data disk by using the GUID Partition Table (GPT) format, and then copy data from the MBR disk to the GPT data disk. For more information, see [Step 1: Resize a disk to extend the disk capacity](https://help.aliyun.com/document_detail/44986.html).
        You can resize disks of the following disk categories: basic disks (`cloud`), ultra disks (`cloud_efficiency`), standard SSDs (`cloud_ssd`), Enterprise SSDs (ESSDs) (`cloud_essd`), ESSD AutoPL disks (cloud_auto), standard elastic ephemeral disks (elastic_ephemeral_disk_standard), and premium elastic ephemeral disks (elastic_ephemeral_disk_premium).
        You cannot resize a cloud disk when a snapshot is being created for the disk. Wait until the snapshot is created before you resize the cloud disk.
        You cannot call this operation to resize partitions or file systems on a cloud disk. You must manually resize the partitions and file systems after the disk is resized. For more information, see [Step 2: Resize partitions and file systems](https://help.aliyun.com/document_detail/470068.html).
        If the multi-attach feature is enabled for a cloud disk, you can resize the disk online or offline. Make sure that the Elastic Compute Service (ECS) instances to which the disk is attached meet the following requirements:
        If you want to resize the disk online, the ECS instances must be in the **Running** (`Running`) state.
        If you want to resize the disk offline, the ECS instances must be in the **Running** (`Running`) or **Stopped** (`Stopped`) state.
        The cloud disk that you want to resize must meet the following requirements:
        The disk is in the In Use (`In_use`) or Unattached (`Available`) state.
        (Recommended) Snapshots are created for the disk to back up disk data. For information about how to create snapshots for a disk, see [Create a snapshot](https://help.aliyun.com/document_detail/25455.html).
        If the disk is a new data disk, initialize the disk before you resize the disk. For more information, see [Overview](https://help.aliyun.com/document_detail/466323.html).
        
        @param request: ResizeDiskRequest
        @return: ResizeDiskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.resize_disk_with_options(request, runtime)

    async def resize_disk_async(
        self,
        request: ecs_20140526_models.ResizeDiskRequest,
    ) -> ecs_20140526_models.ResizeDiskResponse:
        """
        @summary Resizes a system disk or a data disk.
        
        @description >  Before you call this operation to resize a disk, you must check the partition format of the disk. You cannot resize a master boot record (MBR) disk to a size that is larger than 2 TiB. If you resize an MBR disk to a size that is larger than 2 TiB, data may be lost. If you want to resize an MBR disk to a size that is larger than 2 TiB, we recommend that you perform the following steps: Create a new data disk that is larger than 2 TiB in size, partition and format the new data disk by using the GUID Partition Table (GPT) format, and then copy data from the MBR disk to the GPT data disk. For more information, see [Step 1: Resize a disk to extend the disk capacity](https://help.aliyun.com/document_detail/44986.html).
        You can resize disks of the following disk categories: basic disks (`cloud`), ultra disks (`cloud_efficiency`), standard SSDs (`cloud_ssd`), Enterprise SSDs (ESSDs) (`cloud_essd`), ESSD AutoPL disks (cloud_auto), standard elastic ephemeral disks (elastic_ephemeral_disk_standard), and premium elastic ephemeral disks (elastic_ephemeral_disk_premium).
        You cannot resize a cloud disk when a snapshot is being created for the disk. Wait until the snapshot is created before you resize the cloud disk.
        You cannot call this operation to resize partitions or file systems on a cloud disk. You must manually resize the partitions and file systems after the disk is resized. For more information, see [Step 2: Resize partitions and file systems](https://help.aliyun.com/document_detail/470068.html).
        If the multi-attach feature is enabled for a cloud disk, you can resize the disk online or offline. Make sure that the Elastic Compute Service (ECS) instances to which the disk is attached meet the following requirements:
        If you want to resize the disk online, the ECS instances must be in the **Running** (`Running`) state.
        If you want to resize the disk offline, the ECS instances must be in the **Running** (`Running`) or **Stopped** (`Stopped`) state.
        The cloud disk that you want to resize must meet the following requirements:
        The disk is in the In Use (`In_use`) or Unattached (`Available`) state.
        (Recommended) Snapshots are created for the disk to back up disk data. For information about how to create snapshots for a disk, see [Create a snapshot](https://help.aliyun.com/document_detail/25455.html).
        If the disk is a new data disk, initialize the disk before you resize the disk. For more information, see [Overview](https://help.aliyun.com/document_detail/466323.html).
        
        @param request: ResizeDiskRequest
        @return: ResizeDiskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.resize_disk_with_options_async(request, runtime)

    def revoke_security_group_with_options(
        self,
        request: ecs_20140526_models.RevokeSecurityGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RevokeSecurityGroupResponse:
        """
        @summary Deletes inbound security group rules from a specific security group.
        
        @description >  Alibaba Cloud modified verification rules for the RevokeSecurityGroup operation on July 8, 2024. When you call the RevokeSecurityGroup operation to delete a security group rule that does not exist, the "InvalidParam.SecurityGroupRuleId" error code is returned instead of a success response. Update the RevokeSecurityGroup operation to use the new verification rules with the new error code based on your business requirements.
        You can use one of the following groups of parameters to specify the security group rules that you want to delete:
        Parameters used to specify the IDs of security group rules. We recommend that you specify the IDs of security group rules to delete the rules.
        If a specified security group rule ID does not exist, the call to RevokeSecurityGroup fails.
        Parameters that start with Permissions.
        If no security group rule matches the specified parameters, the call to RevokeSecurityGroup is successful but no security group rules are deleted.
        Define an inbound security group rule by configuring the following parameters together:
        Source: You can specify one parameter from SourceCidrIp (IPv4 address), Ipv6SourceCidrIp (IPv6 address), SourcetPrefixListId (prefix list ID), and SourceGroupId (source security group ID).
        PortRange: specifies the destination port range.
        IpProtocol: specifies the protocol.
        Policy: specifies the action.
        >  You cannot specify the IDs of security group rules and the parameters that start with Permissions in the same request.
        ### [](#)Sample requests
        Delete a security group rule based on the rule ID:
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***", //Specify the ID of the security group.
        "SecurityGroupRuleId":["sgr-bpdfmk***","sgr-bpdfmg****"] //Specify the ID of the security group rule.
        Delete a security group rule based on an IPv4 CIDR block:
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***",
        "Permissions":[
        {
        "SourceCidrIp":"10.0.0.0/8", //Specify the source IPv4 CIDR block.
        "IpProtocol":"TCP", //Specify the protocol.
        "PortRange":"80/80", //Specify the destination port range.
        "Policy":"accept" //Specify the action.
        }
        ]
        Delete a security group rule in which a security group is referenced:
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***",
        "Permissions":[
        {
        "SourceGroupId":"sg-bp67acfmxa123b***", //Specify the ID of the source security group.
        "IpProtocol":"TCP,"
        "PortRange":"80/80",
        "Policy":"accept"
        ]
        }
        Delete a security group rule in which a prefix list is referenced:
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***",
        "Permissions":[
        {
        "SourcePrefixListId":pl-x1j1k5ykzqlixdcy***", //Specify the ID of the source prefix list.
        "IpProtocol":"TCP",
        "PortRange":"80/80",
        "Policy":"accept"
        }
        ]
        
        @param request: RevokeSecurityGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RevokeSecurityGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dest_cidr_ip):
            query['DestCidrIp'] = request.dest_cidr_ip
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.ipv_6dest_cidr_ip):
            query['Ipv6DestCidrIp'] = request.ipv_6dest_cidr_ip
        if not UtilClient.is_unset(request.ipv_6source_cidr_ip):
            query['Ipv6SourceCidrIp'] = request.ipv_6source_cidr_ip
        if not UtilClient.is_unset(request.nic_type):
            query['NicType'] = request.nic_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.permissions):
            query['Permissions'] = request.permissions
        if not UtilClient.is_unset(request.policy):
            query['Policy'] = request.policy
        if not UtilClient.is_unset(request.port_range):
            query['PortRange'] = request.port_range
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_rule_id):
            query['SecurityGroupRuleId'] = request.security_group_rule_id
        if not UtilClient.is_unset(request.source_cidr_ip):
            query['SourceCidrIp'] = request.source_cidr_ip
        if not UtilClient.is_unset(request.source_group_id):
            query['SourceGroupId'] = request.source_group_id
        if not UtilClient.is_unset(request.source_group_owner_account):
            query['SourceGroupOwnerAccount'] = request.source_group_owner_account
        if not UtilClient.is_unset(request.source_group_owner_id):
            query['SourceGroupOwnerId'] = request.source_group_owner_id
        if not UtilClient.is_unset(request.source_port_range):
            query['SourcePortRange'] = request.source_port_range
        if not UtilClient.is_unset(request.source_prefix_list_id):
            query['SourcePrefixListId'] = request.source_prefix_list_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RevokeSecurityGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RevokeSecurityGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def revoke_security_group_with_options_async(
        self,
        request: ecs_20140526_models.RevokeSecurityGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RevokeSecurityGroupResponse:
        """
        @summary Deletes inbound security group rules from a specific security group.
        
        @description >  Alibaba Cloud modified verification rules for the RevokeSecurityGroup operation on July 8, 2024. When you call the RevokeSecurityGroup operation to delete a security group rule that does not exist, the "InvalidParam.SecurityGroupRuleId" error code is returned instead of a success response. Update the RevokeSecurityGroup operation to use the new verification rules with the new error code based on your business requirements.
        You can use one of the following groups of parameters to specify the security group rules that you want to delete:
        Parameters used to specify the IDs of security group rules. We recommend that you specify the IDs of security group rules to delete the rules.
        If a specified security group rule ID does not exist, the call to RevokeSecurityGroup fails.
        Parameters that start with Permissions.
        If no security group rule matches the specified parameters, the call to RevokeSecurityGroup is successful but no security group rules are deleted.
        Define an inbound security group rule by configuring the following parameters together:
        Source: You can specify one parameter from SourceCidrIp (IPv4 address), Ipv6SourceCidrIp (IPv6 address), SourcetPrefixListId (prefix list ID), and SourceGroupId (source security group ID).
        PortRange: specifies the destination port range.
        IpProtocol: specifies the protocol.
        Policy: specifies the action.
        >  You cannot specify the IDs of security group rules and the parameters that start with Permissions in the same request.
        ### [](#)Sample requests
        Delete a security group rule based on the rule ID:
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***", //Specify the ID of the security group.
        "SecurityGroupRuleId":["sgr-bpdfmk***","sgr-bpdfmg****"] //Specify the ID of the security group rule.
        Delete a security group rule based on an IPv4 CIDR block:
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***",
        "Permissions":[
        {
        "SourceCidrIp":"10.0.0.0/8", //Specify the source IPv4 CIDR block.
        "IpProtocol":"TCP", //Specify the protocol.
        "PortRange":"80/80", //Specify the destination port range.
        "Policy":"accept" //Specify the action.
        }
        ]
        Delete a security group rule in which a security group is referenced:
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***",
        "Permissions":[
        {
        "SourceGroupId":"sg-bp67acfmxa123b***", //Specify the ID of the source security group.
        "IpProtocol":"TCP,"
        "PortRange":"80/80",
        "Policy":"accept"
        ]
        }
        Delete a security group rule in which a prefix list is referenced:
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***",
        "Permissions":[
        {
        "SourcePrefixListId":pl-x1j1k5ykzqlixdcy***", //Specify the ID of the source prefix list.
        "IpProtocol":"TCP",
        "PortRange":"80/80",
        "Policy":"accept"
        }
        ]
        
        @param request: RevokeSecurityGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RevokeSecurityGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dest_cidr_ip):
            query['DestCidrIp'] = request.dest_cidr_ip
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.ipv_6dest_cidr_ip):
            query['Ipv6DestCidrIp'] = request.ipv_6dest_cidr_ip
        if not UtilClient.is_unset(request.ipv_6source_cidr_ip):
            query['Ipv6SourceCidrIp'] = request.ipv_6source_cidr_ip
        if not UtilClient.is_unset(request.nic_type):
            query['NicType'] = request.nic_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.permissions):
            query['Permissions'] = request.permissions
        if not UtilClient.is_unset(request.policy):
            query['Policy'] = request.policy
        if not UtilClient.is_unset(request.port_range):
            query['PortRange'] = request.port_range
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_rule_id):
            query['SecurityGroupRuleId'] = request.security_group_rule_id
        if not UtilClient.is_unset(request.source_cidr_ip):
            query['SourceCidrIp'] = request.source_cidr_ip
        if not UtilClient.is_unset(request.source_group_id):
            query['SourceGroupId'] = request.source_group_id
        if not UtilClient.is_unset(request.source_group_owner_account):
            query['SourceGroupOwnerAccount'] = request.source_group_owner_account
        if not UtilClient.is_unset(request.source_group_owner_id):
            query['SourceGroupOwnerId'] = request.source_group_owner_id
        if not UtilClient.is_unset(request.source_port_range):
            query['SourcePortRange'] = request.source_port_range
        if not UtilClient.is_unset(request.source_prefix_list_id):
            query['SourcePrefixListId'] = request.source_prefix_list_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RevokeSecurityGroup',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RevokeSecurityGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def revoke_security_group(
        self,
        request: ecs_20140526_models.RevokeSecurityGroupRequest,
    ) -> ecs_20140526_models.RevokeSecurityGroupResponse:
        """
        @summary Deletes inbound security group rules from a specific security group.
        
        @description >  Alibaba Cloud modified verification rules for the RevokeSecurityGroup operation on July 8, 2024. When you call the RevokeSecurityGroup operation to delete a security group rule that does not exist, the "InvalidParam.SecurityGroupRuleId" error code is returned instead of a success response. Update the RevokeSecurityGroup operation to use the new verification rules with the new error code based on your business requirements.
        You can use one of the following groups of parameters to specify the security group rules that you want to delete:
        Parameters used to specify the IDs of security group rules. We recommend that you specify the IDs of security group rules to delete the rules.
        If a specified security group rule ID does not exist, the call to RevokeSecurityGroup fails.
        Parameters that start with Permissions.
        If no security group rule matches the specified parameters, the call to RevokeSecurityGroup is successful but no security group rules are deleted.
        Define an inbound security group rule by configuring the following parameters together:
        Source: You can specify one parameter from SourceCidrIp (IPv4 address), Ipv6SourceCidrIp (IPv6 address), SourcetPrefixListId (prefix list ID), and SourceGroupId (source security group ID).
        PortRange: specifies the destination port range.
        IpProtocol: specifies the protocol.
        Policy: specifies the action.
        >  You cannot specify the IDs of security group rules and the parameters that start with Permissions in the same request.
        ### [](#)Sample requests
        Delete a security group rule based on the rule ID:
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***", //Specify the ID of the security group.
        "SecurityGroupRuleId":["sgr-bpdfmk***","sgr-bpdfmg****"] //Specify the ID of the security group rule.
        Delete a security group rule based on an IPv4 CIDR block:
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***",
        "Permissions":[
        {
        "SourceCidrIp":"10.0.0.0/8", //Specify the source IPv4 CIDR block.
        "IpProtocol":"TCP", //Specify the protocol.
        "PortRange":"80/80", //Specify the destination port range.
        "Policy":"accept" //Specify the action.
        }
        ]
        Delete a security group rule in which a security group is referenced:
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***",
        "Permissions":[
        {
        "SourceGroupId":"sg-bp67acfmxa123b***", //Specify the ID of the source security group.
        "IpProtocol":"TCP,"
        "PortRange":"80/80",
        "Policy":"accept"
        ]
        }
        Delete a security group rule in which a prefix list is referenced:
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***",
        "Permissions":[
        {
        "SourcePrefixListId":pl-x1j1k5ykzqlixdcy***", //Specify the ID of the source prefix list.
        "IpProtocol":"TCP",
        "PortRange":"80/80",
        "Policy":"accept"
        }
        ]
        
        @param request: RevokeSecurityGroupRequest
        @return: RevokeSecurityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.revoke_security_group_with_options(request, runtime)

    async def revoke_security_group_async(
        self,
        request: ecs_20140526_models.RevokeSecurityGroupRequest,
    ) -> ecs_20140526_models.RevokeSecurityGroupResponse:
        """
        @summary Deletes inbound security group rules from a specific security group.
        
        @description >  Alibaba Cloud modified verification rules for the RevokeSecurityGroup operation on July 8, 2024. When you call the RevokeSecurityGroup operation to delete a security group rule that does not exist, the "InvalidParam.SecurityGroupRuleId" error code is returned instead of a success response. Update the RevokeSecurityGroup operation to use the new verification rules with the new error code based on your business requirements.
        You can use one of the following groups of parameters to specify the security group rules that you want to delete:
        Parameters used to specify the IDs of security group rules. We recommend that you specify the IDs of security group rules to delete the rules.
        If a specified security group rule ID does not exist, the call to RevokeSecurityGroup fails.
        Parameters that start with Permissions.
        If no security group rule matches the specified parameters, the call to RevokeSecurityGroup is successful but no security group rules are deleted.
        Define an inbound security group rule by configuring the following parameters together:
        Source: You can specify one parameter from SourceCidrIp (IPv4 address), Ipv6SourceCidrIp (IPv6 address), SourcetPrefixListId (prefix list ID), and SourceGroupId (source security group ID).
        PortRange: specifies the destination port range.
        IpProtocol: specifies the protocol.
        Policy: specifies the action.
        >  You cannot specify the IDs of security group rules and the parameters that start with Permissions in the same request.
        ### [](#)Sample requests
        Delete a security group rule based on the rule ID:
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***", //Specify the ID of the security group.
        "SecurityGroupRuleId":["sgr-bpdfmk***","sgr-bpdfmg****"] //Specify the ID of the security group rule.
        Delete a security group rule based on an IPv4 CIDR block:
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***",
        "Permissions":[
        {
        "SourceCidrIp":"10.0.0.0/8", //Specify the source IPv4 CIDR block.
        "IpProtocol":"TCP", //Specify the protocol.
        "PortRange":"80/80", //Specify the destination port range.
        "Policy":"accept" //Specify the action.
        }
        ]
        Delete a security group rule in which a security group is referenced:
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***",
        "Permissions":[
        {
        "SourceGroupId":"sg-bp67acfmxa123b***", //Specify the ID of the source security group.
        "IpProtocol":"TCP,"
        "PortRange":"80/80",
        "Policy":"accept"
        ]
        }
        Delete a security group rule in which a prefix list is referenced:
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***",
        "Permissions":[
        {
        "SourcePrefixListId":pl-x1j1k5ykzqlixdcy***", //Specify the ID of the source prefix list.
        "IpProtocol":"TCP",
        "PortRange":"80/80",
        "Policy":"accept"
        }
        ]
        
        @param request: RevokeSecurityGroupRequest
        @return: RevokeSecurityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.revoke_security_group_with_options_async(request, runtime)

    def revoke_security_group_egress_with_options(
        self,
        request: ecs_20140526_models.RevokeSecurityGroupEgressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RevokeSecurityGroupEgressResponse:
        """
        @summary Deletes outbound security group rules from a specified security group.
        
        @description >  Alibaba Cloud modified verification rules for the RevokeSecurityGroupEgress operation on July 8, 2024. When you use the RevokeSecurityGroupEgress operation to delete a security group rule that does not exist, the "InvalidSecurityGroupRule.RuleNotExist" error code is returned instead of a success response. Update the RevokeSecurityGroupEgress operation to use the new verification rules with the new error code based on your business requirements.
        You can use one of the following methods to delete a security group rule:
        Delete a rule by specifying the IDs of security group rules. We recommend that you specify the IDs of security group rules to delete the rules.
        If a security group rule ID that you specify does not exist, an error is reported.
        Delete a rule by specifying the Permissions parameter.
        If no security group rule matches the specified parameters, the call to RevokeSecurityGroup is successful but no security group rules are deleted.
        Delete a security group rule by configuring the following parameters together:
        One of the following parameters: DestCidrIp, Ipv6DestCidrIp, DestPrefixListId, and DestGroupId. DestCidrIp specifies the destination IPv4 CIDR block. Ipv6DestCidrIp specifies the destination IPv6 CIDR block. DestPrefixListId specifies the ID of the destination prefix list. DestGroupId specifies the destination security group.
        PortRange: specifies the range of destination port numbers.
        IpProtocol: specifies the protocol.
        Policy: specifies the action.
        >  You cannot set the security group rule ID and the Permissions parameter at the same time.
        ### [](#)Sample requests
        Delete a security group rule.
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***", //The security group ID.
        "SecurityGroupRuleId":["sgr-bpdfmk***","sgr-bpdfmg****"]  //The ID of the security group rule.
        Delete a security group rule based on the CIDR block.
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4ph**",
        "Permissions":[
        {
        "IpProtocol":"TCP", //The protocol.
        "DestCidrIp":"10.0.0.0/8", //The destination IPv4 CIDR block.
        "PortRange":"22/22", //The destination port range.
        "Policy":"accept" //The action.  }
        ]
        Delete a security group rule based on the ID of the destination security group.
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4ph**",
        "Permissions":[
        {
        "DestGroupId":"sg-bp67acfmxa123b***", //Set the ID of the target security group.
        "IpProtocol":"TCP",
        "PortRange":"22/22",
        "Policy":"accept"
        }
        ]
        Delete a security group rule based on a specified prefix list.
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4ph**",
        "Permissions":[
        {
        "IpProtocol":"TCP",
        "DestPrefixListId":"pl-x1j1k5ykzqlixdcy***", //The ID of the destination prefix list.    "PortRange":"22/22",
        "Policy":"accept",
        }
        ]
        
        @param request: RevokeSecurityGroupEgressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RevokeSecurityGroupEgressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dest_cidr_ip):
            query['DestCidrIp'] = request.dest_cidr_ip
        if not UtilClient.is_unset(request.dest_group_id):
            query['DestGroupId'] = request.dest_group_id
        if not UtilClient.is_unset(request.dest_group_owner_account):
            query['DestGroupOwnerAccount'] = request.dest_group_owner_account
        if not UtilClient.is_unset(request.dest_group_owner_id):
            query['DestGroupOwnerId'] = request.dest_group_owner_id
        if not UtilClient.is_unset(request.dest_prefix_list_id):
            query['DestPrefixListId'] = request.dest_prefix_list_id
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.ipv_6dest_cidr_ip):
            query['Ipv6DestCidrIp'] = request.ipv_6dest_cidr_ip
        if not UtilClient.is_unset(request.ipv_6source_cidr_ip):
            query['Ipv6SourceCidrIp'] = request.ipv_6source_cidr_ip
        if not UtilClient.is_unset(request.nic_type):
            query['NicType'] = request.nic_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.permissions):
            query['Permissions'] = request.permissions
        if not UtilClient.is_unset(request.policy):
            query['Policy'] = request.policy
        if not UtilClient.is_unset(request.port_range):
            query['PortRange'] = request.port_range
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_rule_id):
            query['SecurityGroupRuleId'] = request.security_group_rule_id
        if not UtilClient.is_unset(request.source_cidr_ip):
            query['SourceCidrIp'] = request.source_cidr_ip
        if not UtilClient.is_unset(request.source_port_range):
            query['SourcePortRange'] = request.source_port_range
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RevokeSecurityGroupEgress',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RevokeSecurityGroupEgressResponse(),
            self.call_api(params, req, runtime)
        )

    async def revoke_security_group_egress_with_options_async(
        self,
        request: ecs_20140526_models.RevokeSecurityGroupEgressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RevokeSecurityGroupEgressResponse:
        """
        @summary Deletes outbound security group rules from a specified security group.
        
        @description >  Alibaba Cloud modified verification rules for the RevokeSecurityGroupEgress operation on July 8, 2024. When you use the RevokeSecurityGroupEgress operation to delete a security group rule that does not exist, the "InvalidSecurityGroupRule.RuleNotExist" error code is returned instead of a success response. Update the RevokeSecurityGroupEgress operation to use the new verification rules with the new error code based on your business requirements.
        You can use one of the following methods to delete a security group rule:
        Delete a rule by specifying the IDs of security group rules. We recommend that you specify the IDs of security group rules to delete the rules.
        If a security group rule ID that you specify does not exist, an error is reported.
        Delete a rule by specifying the Permissions parameter.
        If no security group rule matches the specified parameters, the call to RevokeSecurityGroup is successful but no security group rules are deleted.
        Delete a security group rule by configuring the following parameters together:
        One of the following parameters: DestCidrIp, Ipv6DestCidrIp, DestPrefixListId, and DestGroupId. DestCidrIp specifies the destination IPv4 CIDR block. Ipv6DestCidrIp specifies the destination IPv6 CIDR block. DestPrefixListId specifies the ID of the destination prefix list. DestGroupId specifies the destination security group.
        PortRange: specifies the range of destination port numbers.
        IpProtocol: specifies the protocol.
        Policy: specifies the action.
        >  You cannot set the security group rule ID and the Permissions parameter at the same time.
        ### [](#)Sample requests
        Delete a security group rule.
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***", //The security group ID.
        "SecurityGroupRuleId":["sgr-bpdfmk***","sgr-bpdfmg****"]  //The ID of the security group rule.
        Delete a security group rule based on the CIDR block.
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4ph**",
        "Permissions":[
        {
        "IpProtocol":"TCP", //The protocol.
        "DestCidrIp":"10.0.0.0/8", //The destination IPv4 CIDR block.
        "PortRange":"22/22", //The destination port range.
        "Policy":"accept" //The action.  }
        ]
        Delete a security group rule based on the ID of the destination security group.
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4ph**",
        "Permissions":[
        {
        "DestGroupId":"sg-bp67acfmxa123b***", //Set the ID of the target security group.
        "IpProtocol":"TCP",
        "PortRange":"22/22",
        "Policy":"accept"
        }
        ]
        Delete a security group rule based on a specified prefix list.
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4ph**",
        "Permissions":[
        {
        "IpProtocol":"TCP",
        "DestPrefixListId":"pl-x1j1k5ykzqlixdcy***", //The ID of the destination prefix list.    "PortRange":"22/22",
        "Policy":"accept",
        }
        ]
        
        @param request: RevokeSecurityGroupEgressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RevokeSecurityGroupEgressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dest_cidr_ip):
            query['DestCidrIp'] = request.dest_cidr_ip
        if not UtilClient.is_unset(request.dest_group_id):
            query['DestGroupId'] = request.dest_group_id
        if not UtilClient.is_unset(request.dest_group_owner_account):
            query['DestGroupOwnerAccount'] = request.dest_group_owner_account
        if not UtilClient.is_unset(request.dest_group_owner_id):
            query['DestGroupOwnerId'] = request.dest_group_owner_id
        if not UtilClient.is_unset(request.dest_prefix_list_id):
            query['DestPrefixListId'] = request.dest_prefix_list_id
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.ipv_6dest_cidr_ip):
            query['Ipv6DestCidrIp'] = request.ipv_6dest_cidr_ip
        if not UtilClient.is_unset(request.ipv_6source_cidr_ip):
            query['Ipv6SourceCidrIp'] = request.ipv_6source_cidr_ip
        if not UtilClient.is_unset(request.nic_type):
            query['NicType'] = request.nic_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.permissions):
            query['Permissions'] = request.permissions
        if not UtilClient.is_unset(request.policy):
            query['Policy'] = request.policy
        if not UtilClient.is_unset(request.port_range):
            query['PortRange'] = request.port_range
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_rule_id):
            query['SecurityGroupRuleId'] = request.security_group_rule_id
        if not UtilClient.is_unset(request.source_cidr_ip):
            query['SourceCidrIp'] = request.source_cidr_ip
        if not UtilClient.is_unset(request.source_port_range):
            query['SourcePortRange'] = request.source_port_range
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RevokeSecurityGroupEgress',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RevokeSecurityGroupEgressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def revoke_security_group_egress(
        self,
        request: ecs_20140526_models.RevokeSecurityGroupEgressRequest,
    ) -> ecs_20140526_models.RevokeSecurityGroupEgressResponse:
        """
        @summary Deletes outbound security group rules from a specified security group.
        
        @description >  Alibaba Cloud modified verification rules for the RevokeSecurityGroupEgress operation on July 8, 2024. When you use the RevokeSecurityGroupEgress operation to delete a security group rule that does not exist, the "InvalidSecurityGroupRule.RuleNotExist" error code is returned instead of a success response. Update the RevokeSecurityGroupEgress operation to use the new verification rules with the new error code based on your business requirements.
        You can use one of the following methods to delete a security group rule:
        Delete a rule by specifying the IDs of security group rules. We recommend that you specify the IDs of security group rules to delete the rules.
        If a security group rule ID that you specify does not exist, an error is reported.
        Delete a rule by specifying the Permissions parameter.
        If no security group rule matches the specified parameters, the call to RevokeSecurityGroup is successful but no security group rules are deleted.
        Delete a security group rule by configuring the following parameters together:
        One of the following parameters: DestCidrIp, Ipv6DestCidrIp, DestPrefixListId, and DestGroupId. DestCidrIp specifies the destination IPv4 CIDR block. Ipv6DestCidrIp specifies the destination IPv6 CIDR block. DestPrefixListId specifies the ID of the destination prefix list. DestGroupId specifies the destination security group.
        PortRange: specifies the range of destination port numbers.
        IpProtocol: specifies the protocol.
        Policy: specifies the action.
        >  You cannot set the security group rule ID and the Permissions parameter at the same time.
        ### [](#)Sample requests
        Delete a security group rule.
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***", //The security group ID.
        "SecurityGroupRuleId":["sgr-bpdfmk***","sgr-bpdfmg****"]  //The ID of the security group rule.
        Delete a security group rule based on the CIDR block.
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4ph**",
        "Permissions":[
        {
        "IpProtocol":"TCP", //The protocol.
        "DestCidrIp":"10.0.0.0/8", //The destination IPv4 CIDR block.
        "PortRange":"22/22", //The destination port range.
        "Policy":"accept" //The action.  }
        ]
        Delete a security group rule based on the ID of the destination security group.
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4ph**",
        "Permissions":[
        {
        "DestGroupId":"sg-bp67acfmxa123b***", //Set the ID of the target security group.
        "IpProtocol":"TCP",
        "PortRange":"22/22",
        "Policy":"accept"
        }
        ]
        Delete a security group rule based on a specified prefix list.
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4ph**",
        "Permissions":[
        {
        "IpProtocol":"TCP",
        "DestPrefixListId":"pl-x1j1k5ykzqlixdcy***", //The ID of the destination prefix list.    "PortRange":"22/22",
        "Policy":"accept",
        }
        ]
        
        @param request: RevokeSecurityGroupEgressRequest
        @return: RevokeSecurityGroupEgressResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.revoke_security_group_egress_with_options(request, runtime)

    async def revoke_security_group_egress_async(
        self,
        request: ecs_20140526_models.RevokeSecurityGroupEgressRequest,
    ) -> ecs_20140526_models.RevokeSecurityGroupEgressResponse:
        """
        @summary Deletes outbound security group rules from a specified security group.
        
        @description >  Alibaba Cloud modified verification rules for the RevokeSecurityGroupEgress operation on July 8, 2024. When you use the RevokeSecurityGroupEgress operation to delete a security group rule that does not exist, the "InvalidSecurityGroupRule.RuleNotExist" error code is returned instead of a success response. Update the RevokeSecurityGroupEgress operation to use the new verification rules with the new error code based on your business requirements.
        You can use one of the following methods to delete a security group rule:
        Delete a rule by specifying the IDs of security group rules. We recommend that you specify the IDs of security group rules to delete the rules.
        If a security group rule ID that you specify does not exist, an error is reported.
        Delete a rule by specifying the Permissions parameter.
        If no security group rule matches the specified parameters, the call to RevokeSecurityGroup is successful but no security group rules are deleted.
        Delete a security group rule by configuring the following parameters together:
        One of the following parameters: DestCidrIp, Ipv6DestCidrIp, DestPrefixListId, and DestGroupId. DestCidrIp specifies the destination IPv4 CIDR block. Ipv6DestCidrIp specifies the destination IPv6 CIDR block. DestPrefixListId specifies the ID of the destination prefix list. DestGroupId specifies the destination security group.
        PortRange: specifies the range of destination port numbers.
        IpProtocol: specifies the protocol.
        Policy: specifies the action.
        >  You cannot set the security group rule ID and the Permissions parameter at the same time.
        ### [](#)Sample requests
        Delete a security group rule.
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4p***", //The security group ID.
        "SecurityGroupRuleId":["sgr-bpdfmk***","sgr-bpdfmg****"]  //The ID of the security group rule.
        Delete a security group rule based on the CIDR block.
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4ph**",
        "Permissions":[
        {
        "IpProtocol":"TCP", //The protocol.
        "DestCidrIp":"10.0.0.0/8", //The destination IPv4 CIDR block.
        "PortRange":"22/22", //The destination port range.
        "Policy":"accept" //The action.  }
        ]
        Delete a security group rule based on the ID of the destination security group.
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4ph**",
        "Permissions":[
        {
        "DestGroupId":"sg-bp67acfmxa123b***", //Set the ID of the target security group.
        "IpProtocol":"TCP",
        "PortRange":"22/22",
        "Policy":"accept"
        }
        ]
        Delete a security group rule based on a specified prefix list.
        <!---->
        "SecurityGroupId":"sg-bp67acfmxazb4ph**",
        "Permissions":[
        {
        "IpProtocol":"TCP",
        "DestPrefixListId":"pl-x1j1k5ykzqlixdcy***", //The ID of the destination prefix list.    "PortRange":"22/22",
        "Policy":"accept",
        }
        ]
        
        @param request: RevokeSecurityGroupEgressRequest
        @return: RevokeSecurityGroupEgressResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.revoke_security_group_egress_with_options_async(request, runtime)

    def run_command_with_options(
        self,
        tmp_req: ecs_20140526_models.RunCommandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RunCommandResponse:
        """
        @summary Creates and runs a Cloud Assistant command on one or more Elastic Compute Service (ECS) instances. Shell, PowerShell, and batch commands are supported. You can run the command based on a schedule, include custom parameters in the command, or run the command in containers on instances.
        
        @description This operation is an asynchronous operation. After a request is sent, a response that contains a command ID and a command task ID is immediately returned. You can call the [DescribeInvocations](https://help.aliyun.com/document_detail/2679916.html) or [DescribeInvocationResults](https://help.aliyun.com/document_detail/2679916.html) operation with the command ID or task ID to query the execution results of the command.
        ### [](#)Precautions
        The instances on which you want to create and run a Cloud Assistant command must be in the Running (`Running`) state. You can call the [DescribeInstances](https://help.aliyun.com/document_detail/25506.html) operation to query the status of instances.
        [Cloud Assistant Agent](https://help.aliyun.com/document_detail/64921.html) must be pre-installed on the instances on which you want to create and run a Cloud Assistant command. You can call the [InstallCloudAssistant](https://help.aliyun.com/document_detail/2679925.html) operation to install Cloud Assistant Agent on instances and the [DescribeCloudAssistantStatus](https://help.aliyun.com/document_detail/2679924.html) operation to query whether Cloud Assistant Agent is installed on instances.
        *\
        *Note** By default, Cloud Assistant Agent is pre-installed on instances created from public images on or after December 1, 2017.
        Before you run a PowerShell command on a Windows instance, make sure that the PowerShell module is installed on the instance.
        ### [](#)Considerations
        You can retain up to 500 to 50,000 Cloud Assistant commands in each region. You can also request a quota increase. For information about how to view quotas and request a quota increase, see [Manage quotas](https://help.aliyun.com/document_detail/184116.html).
        To ensure that scheduled tasks can run as expected, make sure that the Cloud Assistant Agent version is not earlier than the following versions. A scheduled task can run a command at a specific interval, only once at a specific time, or at designated times based on a cron expression in a specific year or time zone. If the `ClientNeedUpgrade` error code is returned, you must update Cloud Assistant Agent to the latest version. For more information, see [Upgrade or disable upgrades of Cloud Assistant Agent](https://help.aliyun.com/document_detail/134383.html).
        - Linux: 2.2.3.282
        - Windows: 2.1.3.282
        When you use a cron expression to specify a schedule, you can specify a time zone based on your business requirements. If you do not specify a time zone, the schedule is determined by the system time of the instances. Make sure that the time or time zone of the instances meets your business requirements. For information about time zones, see [Configure the NTP service for ECS instances that run CentOS 6](https://help.aliyun.com/document_detail/92803.html) or [Configure the NTP service for Windows instances](https://help.aliyun.com/document_detail/51890.html).
        ### [](#)Suggestions
        **Timeout settings**: You can set `Timeout` to specify the timeout period for command executions on instances. If an execution times out, Cloud Assistant Agent forcefully terminates the command process.
        When the one-time execution of the command times out, the execution status ([InvokeRecordStatus](https://help.aliyun.com/document_detail/64845.html)) of the command becomes Failed.
        For a scheduled task, the timeout period takes effect on every execution of the command. When a command execution times out, the subsequent executions of the command are not affected. When a scheduled execution of the command times out, the execution status ([InvokeRecordStatus](https://help.aliyun.com/document_detail/64845.html)) of the command becomes Failed.
        **Execution failure**: Command executions may fail due to instance status exceptions, network exceptions, or exceptions on Cloud Assistant Agent. If a command execution fails, no execution information is generated. For more information, see [Check execution results and troubleshoot common issues](https://help.aliyun.com/document_detail/87029.html).
        **Custom parameters**: If you set `EnableParameter` to true, the custom parameter feature is enabled. When you specify `CommandContent`, you can define custom parameters in the `{{parameter}}` format. Then, the key-value pairs of the custom parameters are passed in when you run the command.
        
        @param tmp_req: RunCommandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RunCommandResponse
        """
        UtilClient.validate_model(tmp_req)
        request = ecs_20140526_models.RunCommandShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.parameters):
            request.parameters_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.parameters, 'Parameters', 'json')
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.command_content):
            query['CommandContent'] = request.command_content
        if not UtilClient.is_unset(request.container_id):
            query['ContainerId'] = request.container_id
        if not UtilClient.is_unset(request.container_name):
            query['ContainerName'] = request.container_name
        if not UtilClient.is_unset(request.content_encoding):
            query['ContentEncoding'] = request.content_encoding
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enable_parameter):
            query['EnableParameter'] = request.enable_parameter
        if not UtilClient.is_unset(request.frequency):
            query['Frequency'] = request.frequency
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.keep_command):
            query['KeepCommand'] = request.keep_command
        if not UtilClient.is_unset(request.launcher):
            query['Launcher'] = request.launcher
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.oss_output_delivery):
            query['OssOutputDelivery'] = request.oss_output_delivery
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.parameters_shrink):
            query['Parameters'] = request.parameters_shrink
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_mode):
            query['RepeatMode'] = request.repeat_mode
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_tag):
            query['ResourceTag'] = request.resource_tag
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.termination_mode):
            query['TerminationMode'] = request.termination_mode
        if not UtilClient.is_unset(request.timed):
            query['Timed'] = request.timed
        if not UtilClient.is_unset(request.timeout):
            query['Timeout'] = request.timeout
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.username):
            query['Username'] = request.username
        if not UtilClient.is_unset(request.windows_password_name):
            query['WindowsPasswordName'] = request.windows_password_name
        if not UtilClient.is_unset(request.working_dir):
            query['WorkingDir'] = request.working_dir
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RunCommand',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RunCommandResponse(),
            self.call_api(params, req, runtime)
        )

    async def run_command_with_options_async(
        self,
        tmp_req: ecs_20140526_models.RunCommandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RunCommandResponse:
        """
        @summary Creates and runs a Cloud Assistant command on one or more Elastic Compute Service (ECS) instances. Shell, PowerShell, and batch commands are supported. You can run the command based on a schedule, include custom parameters in the command, or run the command in containers on instances.
        
        @description This operation is an asynchronous operation. After a request is sent, a response that contains a command ID and a command task ID is immediately returned. You can call the [DescribeInvocations](https://help.aliyun.com/document_detail/2679916.html) or [DescribeInvocationResults](https://help.aliyun.com/document_detail/2679916.html) operation with the command ID or task ID to query the execution results of the command.
        ### [](#)Precautions
        The instances on which you want to create and run a Cloud Assistant command must be in the Running (`Running`) state. You can call the [DescribeInstances](https://help.aliyun.com/document_detail/25506.html) operation to query the status of instances.
        [Cloud Assistant Agent](https://help.aliyun.com/document_detail/64921.html) must be pre-installed on the instances on which you want to create and run a Cloud Assistant command. You can call the [InstallCloudAssistant](https://help.aliyun.com/document_detail/2679925.html) operation to install Cloud Assistant Agent on instances and the [DescribeCloudAssistantStatus](https://help.aliyun.com/document_detail/2679924.html) operation to query whether Cloud Assistant Agent is installed on instances.
        *\
        *Note** By default, Cloud Assistant Agent is pre-installed on instances created from public images on or after December 1, 2017.
        Before you run a PowerShell command on a Windows instance, make sure that the PowerShell module is installed on the instance.
        ### [](#)Considerations
        You can retain up to 500 to 50,000 Cloud Assistant commands in each region. You can also request a quota increase. For information about how to view quotas and request a quota increase, see [Manage quotas](https://help.aliyun.com/document_detail/184116.html).
        To ensure that scheduled tasks can run as expected, make sure that the Cloud Assistant Agent version is not earlier than the following versions. A scheduled task can run a command at a specific interval, only once at a specific time, or at designated times based on a cron expression in a specific year or time zone. If the `ClientNeedUpgrade` error code is returned, you must update Cloud Assistant Agent to the latest version. For more information, see [Upgrade or disable upgrades of Cloud Assistant Agent](https://help.aliyun.com/document_detail/134383.html).
        - Linux: 2.2.3.282
        - Windows: 2.1.3.282
        When you use a cron expression to specify a schedule, you can specify a time zone based on your business requirements. If you do not specify a time zone, the schedule is determined by the system time of the instances. Make sure that the time or time zone of the instances meets your business requirements. For information about time zones, see [Configure the NTP service for ECS instances that run CentOS 6](https://help.aliyun.com/document_detail/92803.html) or [Configure the NTP service for Windows instances](https://help.aliyun.com/document_detail/51890.html).
        ### [](#)Suggestions
        **Timeout settings**: You can set `Timeout` to specify the timeout period for command executions on instances. If an execution times out, Cloud Assistant Agent forcefully terminates the command process.
        When the one-time execution of the command times out, the execution status ([InvokeRecordStatus](https://help.aliyun.com/document_detail/64845.html)) of the command becomes Failed.
        For a scheduled task, the timeout period takes effect on every execution of the command. When a command execution times out, the subsequent executions of the command are not affected. When a scheduled execution of the command times out, the execution status ([InvokeRecordStatus](https://help.aliyun.com/document_detail/64845.html)) of the command becomes Failed.
        **Execution failure**: Command executions may fail due to instance status exceptions, network exceptions, or exceptions on Cloud Assistant Agent. If a command execution fails, no execution information is generated. For more information, see [Check execution results and troubleshoot common issues](https://help.aliyun.com/document_detail/87029.html).
        **Custom parameters**: If you set `EnableParameter` to true, the custom parameter feature is enabled. When you specify `CommandContent`, you can define custom parameters in the `{{parameter}}` format. Then, the key-value pairs of the custom parameters are passed in when you run the command.
        
        @param tmp_req: RunCommandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RunCommandResponse
        """
        UtilClient.validate_model(tmp_req)
        request = ecs_20140526_models.RunCommandShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.parameters):
            request.parameters_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.parameters, 'Parameters', 'json')
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.command_content):
            query['CommandContent'] = request.command_content
        if not UtilClient.is_unset(request.container_id):
            query['ContainerId'] = request.container_id
        if not UtilClient.is_unset(request.container_name):
            query['ContainerName'] = request.container_name
        if not UtilClient.is_unset(request.content_encoding):
            query['ContentEncoding'] = request.content_encoding
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enable_parameter):
            query['EnableParameter'] = request.enable_parameter
        if not UtilClient.is_unset(request.frequency):
            query['Frequency'] = request.frequency
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.keep_command):
            query['KeepCommand'] = request.keep_command
        if not UtilClient.is_unset(request.launcher):
            query['Launcher'] = request.launcher
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.oss_output_delivery):
            query['OssOutputDelivery'] = request.oss_output_delivery
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.parameters_shrink):
            query['Parameters'] = request.parameters_shrink
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_mode):
            query['RepeatMode'] = request.repeat_mode
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_tag):
            query['ResourceTag'] = request.resource_tag
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.termination_mode):
            query['TerminationMode'] = request.termination_mode
        if not UtilClient.is_unset(request.timed):
            query['Timed'] = request.timed
        if not UtilClient.is_unset(request.timeout):
            query['Timeout'] = request.timeout
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.username):
            query['Username'] = request.username
        if not UtilClient.is_unset(request.windows_password_name):
            query['WindowsPasswordName'] = request.windows_password_name
        if not UtilClient.is_unset(request.working_dir):
            query['WorkingDir'] = request.working_dir
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RunCommand',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RunCommandResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def run_command(
        self,
        request: ecs_20140526_models.RunCommandRequest,
    ) -> ecs_20140526_models.RunCommandResponse:
        """
        @summary Creates and runs a Cloud Assistant command on one or more Elastic Compute Service (ECS) instances. Shell, PowerShell, and batch commands are supported. You can run the command based on a schedule, include custom parameters in the command, or run the command in containers on instances.
        
        @description This operation is an asynchronous operation. After a request is sent, a response that contains a command ID and a command task ID is immediately returned. You can call the [DescribeInvocations](https://help.aliyun.com/document_detail/2679916.html) or [DescribeInvocationResults](https://help.aliyun.com/document_detail/2679916.html) operation with the command ID or task ID to query the execution results of the command.
        ### [](#)Precautions
        The instances on which you want to create and run a Cloud Assistant command must be in the Running (`Running`) state. You can call the [DescribeInstances](https://help.aliyun.com/document_detail/25506.html) operation to query the status of instances.
        [Cloud Assistant Agent](https://help.aliyun.com/document_detail/64921.html) must be pre-installed on the instances on which you want to create and run a Cloud Assistant command. You can call the [InstallCloudAssistant](https://help.aliyun.com/document_detail/2679925.html) operation to install Cloud Assistant Agent on instances and the [DescribeCloudAssistantStatus](https://help.aliyun.com/document_detail/2679924.html) operation to query whether Cloud Assistant Agent is installed on instances.
        *\
        *Note** By default, Cloud Assistant Agent is pre-installed on instances created from public images on or after December 1, 2017.
        Before you run a PowerShell command on a Windows instance, make sure that the PowerShell module is installed on the instance.
        ### [](#)Considerations
        You can retain up to 500 to 50,000 Cloud Assistant commands in each region. You can also request a quota increase. For information about how to view quotas and request a quota increase, see [Manage quotas](https://help.aliyun.com/document_detail/184116.html).
        To ensure that scheduled tasks can run as expected, make sure that the Cloud Assistant Agent version is not earlier than the following versions. A scheduled task can run a command at a specific interval, only once at a specific time, or at designated times based on a cron expression in a specific year or time zone. If the `ClientNeedUpgrade` error code is returned, you must update Cloud Assistant Agent to the latest version. For more information, see [Upgrade or disable upgrades of Cloud Assistant Agent](https://help.aliyun.com/document_detail/134383.html).
        - Linux: 2.2.3.282
        - Windows: 2.1.3.282
        When you use a cron expression to specify a schedule, you can specify a time zone based on your business requirements. If you do not specify a time zone, the schedule is determined by the system time of the instances. Make sure that the time or time zone of the instances meets your business requirements. For information about time zones, see [Configure the NTP service for ECS instances that run CentOS 6](https://help.aliyun.com/document_detail/92803.html) or [Configure the NTP service for Windows instances](https://help.aliyun.com/document_detail/51890.html).
        ### [](#)Suggestions
        **Timeout settings**: You can set `Timeout` to specify the timeout period for command executions on instances. If an execution times out, Cloud Assistant Agent forcefully terminates the command process.
        When the one-time execution of the command times out, the execution status ([InvokeRecordStatus](https://help.aliyun.com/document_detail/64845.html)) of the command becomes Failed.
        For a scheduled task, the timeout period takes effect on every execution of the command. When a command execution times out, the subsequent executions of the command are not affected. When a scheduled execution of the command times out, the execution status ([InvokeRecordStatus](https://help.aliyun.com/document_detail/64845.html)) of the command becomes Failed.
        **Execution failure**: Command executions may fail due to instance status exceptions, network exceptions, or exceptions on Cloud Assistant Agent. If a command execution fails, no execution information is generated. For more information, see [Check execution results and troubleshoot common issues](https://help.aliyun.com/document_detail/87029.html).
        **Custom parameters**: If you set `EnableParameter` to true, the custom parameter feature is enabled. When you specify `CommandContent`, you can define custom parameters in the `{{parameter}}` format. Then, the key-value pairs of the custom parameters are passed in when you run the command.
        
        @param request: RunCommandRequest
        @return: RunCommandResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.run_command_with_options(request, runtime)

    async def run_command_async(
        self,
        request: ecs_20140526_models.RunCommandRequest,
    ) -> ecs_20140526_models.RunCommandResponse:
        """
        @summary Creates and runs a Cloud Assistant command on one or more Elastic Compute Service (ECS) instances. Shell, PowerShell, and batch commands are supported. You can run the command based on a schedule, include custom parameters in the command, or run the command in containers on instances.
        
        @description This operation is an asynchronous operation. After a request is sent, a response that contains a command ID and a command task ID is immediately returned. You can call the [DescribeInvocations](https://help.aliyun.com/document_detail/2679916.html) or [DescribeInvocationResults](https://help.aliyun.com/document_detail/2679916.html) operation with the command ID or task ID to query the execution results of the command.
        ### [](#)Precautions
        The instances on which you want to create and run a Cloud Assistant command must be in the Running (`Running`) state. You can call the [DescribeInstances](https://help.aliyun.com/document_detail/25506.html) operation to query the status of instances.
        [Cloud Assistant Agent](https://help.aliyun.com/document_detail/64921.html) must be pre-installed on the instances on which you want to create and run a Cloud Assistant command. You can call the [InstallCloudAssistant](https://help.aliyun.com/document_detail/2679925.html) operation to install Cloud Assistant Agent on instances and the [DescribeCloudAssistantStatus](https://help.aliyun.com/document_detail/2679924.html) operation to query whether Cloud Assistant Agent is installed on instances.
        *\
        *Note** By default, Cloud Assistant Agent is pre-installed on instances created from public images on or after December 1, 2017.
        Before you run a PowerShell command on a Windows instance, make sure that the PowerShell module is installed on the instance.
        ### [](#)Considerations
        You can retain up to 500 to 50,000 Cloud Assistant commands in each region. You can also request a quota increase. For information about how to view quotas and request a quota increase, see [Manage quotas](https://help.aliyun.com/document_detail/184116.html).
        To ensure that scheduled tasks can run as expected, make sure that the Cloud Assistant Agent version is not earlier than the following versions. A scheduled task can run a command at a specific interval, only once at a specific time, or at designated times based on a cron expression in a specific year or time zone. If the `ClientNeedUpgrade` error code is returned, you must update Cloud Assistant Agent to the latest version. For more information, see [Upgrade or disable upgrades of Cloud Assistant Agent](https://help.aliyun.com/document_detail/134383.html).
        - Linux: 2.2.3.282
        - Windows: 2.1.3.282
        When you use a cron expression to specify a schedule, you can specify a time zone based on your business requirements. If you do not specify a time zone, the schedule is determined by the system time of the instances. Make sure that the time or time zone of the instances meets your business requirements. For information about time zones, see [Configure the NTP service for ECS instances that run CentOS 6](https://help.aliyun.com/document_detail/92803.html) or [Configure the NTP service for Windows instances](https://help.aliyun.com/document_detail/51890.html).
        ### [](#)Suggestions
        **Timeout settings**: You can set `Timeout` to specify the timeout period for command executions on instances. If an execution times out, Cloud Assistant Agent forcefully terminates the command process.
        When the one-time execution of the command times out, the execution status ([InvokeRecordStatus](https://help.aliyun.com/document_detail/64845.html)) of the command becomes Failed.
        For a scheduled task, the timeout period takes effect on every execution of the command. When a command execution times out, the subsequent executions of the command are not affected. When a scheduled execution of the command times out, the execution status ([InvokeRecordStatus](https://help.aliyun.com/document_detail/64845.html)) of the command becomes Failed.
        **Execution failure**: Command executions may fail due to instance status exceptions, network exceptions, or exceptions on Cloud Assistant Agent. If a command execution fails, no execution information is generated. For more information, see [Check execution results and troubleshoot common issues](https://help.aliyun.com/document_detail/87029.html).
        **Custom parameters**: If you set `EnableParameter` to true, the custom parameter feature is enabled. When you specify `CommandContent`, you can define custom parameters in the `{{parameter}}` format. Then, the key-value pairs of the custom parameters are passed in when you run the command.
        
        @param request: RunCommandRequest
        @return: RunCommandResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.run_command_with_options_async(request, runtime)

    def run_instances_with_options(
        self,
        request: ecs_20140526_models.RunInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RunInstancesResponse:
        """
        @summary Batch creates Elastic Compute Service (ECS) instances. You can automatically start, assign public IP addresses to, and specify an automatic release time for the instances.
        
        @description Before you call this operation, familiarize yourself with the billing rules and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of ECS resources.
        This operation is an asynchronous operation. After a request to create ECS instances is sent, ECS instance IDs are returned but the creation and startup of the instances may be incomplete. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instances. When the status of an instance is `Running` in the DescribeInstanceStatus response, the instance is created and started.
        ### [](#)Considerations
        If the resource inventory is insufficient to complete instance creation, Alibaba Cloud immediately sends an instance creation failure event (SystemFailure.Delete). You can call the [DescribeInstanceHistoryEvents](https://help.aliyun.com/document_detail/2679897.html) operation to check whether an instance creation failure event exists. For more information, see [System events related to instance creation failures](https://help.aliyun.com/document_detail/2545990.html).
        Make sure that the number of ECS instances you create or the number of vCPUs on ECS instances of all instance types you create does not exceed the corresponding quota. Go to the [Quota Center](https://quotas.console.aliyun.com/products/ecs/quotas) to view the quotas.
        Before you create ECS instances of the Virtual Private Cloud (VPC) type in a region, [create a VPC](https://help.aliyun.com/document_detail/65430.html) in the region.
        ### [](#)Precautions
        If you create a subscription instance (`PrePaid`), available coupons in your account are automatically used.
        You can call the RunInstances operation to create up to 100 ECS instances in a single request. To create more than 100 ECS instances, we recommend that you initiate multiple requests in batches or concurrently.
        If you set `InternetMaxBandwidthOut` to a value greater than 0, public IP addresses are automatically assigned to the ECS instances to be created.
        >  For the limits on the sum of maximum public bandwidths of ECS instances that use the pay-by-bandwidth billing method for network usage per region per Alibaba Cloud account, see the [Public bandwidth](~~25412#BandwidthQuota~~) section of the "Limits and quotas on ECS" topic.
        ### [](#)Suggestions
        **Test scenarios**: Set `DryRun` to true to perform a dry run without performing the actual request.
        **Release of ECS instances**: Use `AutoReleaseTime` to configure an automatic release time for ECS instances in the request to RunInstances or call the [DeleteInstances](https://help.aliyun.com/document_detail/2679710.html) operation to release the instances.
        **Management and search of ECS instances**: Add tags to the ECS instances by specifying `Tag.N.Key` and `Tag.N.Value` and append incremental suffixes by specifying `UniqueSuffix` to the hostname specified by `HostName` and the instance name specified by `InstanceName`. For more information, see [Batch configure sequential names or hostnames for multiple instances](https://help.aliyun.com/document_detail/196048.html).
        **Launch template**: A launch template contains the parameters required to create an ECS instance so that you do not have to specify the parameters every time you create ECS instances. You can call the [CreateLaunchTemplate](https://help.aliyun.com/document_detail/2679729.html) operation to create a launch template. Then, in the request to `RunInstances`, you can specify `LaunchTemplateId` and `LaunchTemplateVersion` to use the launch template.
        **Disabling of Hyper-Threading (HT)**: In memory-intensive scenarios, set `CpuOptions.ThreadsPerCore` to 1 to disable HT and increase the memory-to-vCPU ratio.
        **Enabling of Jumbo Frames**: Set `NetworkOptions.EnableJumboFrame` to true to enable the `Jumbo Frames` feature when you create ECS instances. For more information, see [Jumbo Frames](https://help.aliyun.com/document_detail/200512.html).
        ## [](#)Sample requests
        Use a specific image to create ECS instances of a specific instance type in the China (Hangzhou) region. The instances use disks with a specific capacity as the system disk and data disks and are automatically assigned public IP addresses. The instances have user-defined names and logon passwords. The instances are assigned to a specific security group and connected to a specific vSwitch. Request parameters:
        RegionId:"cn-hangzhou", //Set the region ID to cn-hangzhou, which specifies the China (Hangzhou) region.
        ImageId:"aliyun_3_x64_20G_alibase_20221102.vhd", //Set the image ID to aliyun_3_x64_20G_alibase_20221102.vhd.
        InstanceType:"ecs.g7.large", //Set the instance type to ecs.g7.large.
        SecurityGroupId:"sg-bp150uqocpf9jj70***", //Set the security group ID to sg-bp150uqocpf9jj70****.
        VSwitchId:"vsw-bp1qo7s91cbch5i4l***", //Set the vSwitch ID to vsw-bp1qo7s91cbch5i4l****.
        SystemDisk:{
        Category:"cloud_essd", //Set the system disk category to cloud_essd, which specifies the Enterprise SSD (ESSD) category.
        Size:40, //Set the system disk size to 40. Unit: GiB.
        },
        DataDisk:[
        {
        Category:"cloud_essd", //Set the data disk category to cloud_essd, which specifies the ESSD category.
        Size:100, //Set the data disk size to 100. Unit: GiB.
        }
        ],
        HostName:"ECS-test", //Set the instance hostname to ECS-test.
        Password:"ECS@test1234", //Set the logon password to ECS@test1234.
        InternetMaxBandwidthOut:10 //Set the outbound public bandwidth to 10. Unit: Mbit/s.
        Examples on how to create instances of different types based on the preceding parameters:
        *Example: Create five subscription ECS instances for which auto-renewal is enabled**\
        Amount:5, //Set the number of ECS instances that you want to create to 5.
        InstanceChargeType:"PrePaid", //Set the billing method to PrePaid, which specifies the subscription billing method.
        PeriodUnit:"Month", //Set the subscription period unit to Month.
        Period:1, //Set the subscription period to 1. The unit is specified by PeriodUnit, which is Month in this example.
        AutoRenew:true, //Set this parameter to true to enable auto-renewal.
        AutoRenewPeriod:1 //Set the renewal period to 1. The unit is specified by PeriodUnit, which is Month in this example.
        *Example: Create 10 pay-as-you-go ECS instances**\
        Amount:10, //Set the number of ECS instances that you want to create to 10.
        InstanceChargeType:"PostPaid", //Set the billing method to PostPaid, which specifies the pay-as-you-go billing method.
        SpotStrategy:"NoSpot" //Set this parameter to NoSpot, which is the default value and specifies that the instances are created as pay-as-you-go instances.
        *Example: Create 20 spot instances that use a specific bidding policy and a protection period**\
        Amount:20, //Set the number of ECS instances that you want to create to 20.
        InstanceChargeType:"PostPaid",
        SpotStrategy:"SpotAsPriceGo", //Set the bidding policy to SpotAsPriceGo, which specifies that the instances are created as spot instances for which the market price at the time of purchase is automatically used as the bid price.
        SpotDuration:1 //Set the protection period of the spot instances to 1. Unit: hours.
        Use a launch template created by calling the [CreateLaunchTemplate](https://help.aliyun.com/document_detail/2679729.html) operation to create ECS instances in the China (Hangzhou) region. Examples:
        *Example: Create 10 ECS instances based on a launch template**\
        RegionId:"cn-hangzhou", //Set the region ID to cn-hangzhou, which specifies the China (Hangzhou) region.
        Amount:10, //Set the number of ECS instances that you want to create to 10.
        LaunchTemplateId:"lt-bp14xczpoxvb6rre***" //Set the launch template ID to lt-bp14xczpoxvb6rre****.
        >  If a parameter is specified both in the launch template that you reference in a request and in the instance parameters of the same request, the value specified in the instance parameters takes precedence. For example, if you set InstanceChargeType in the launch template to PrePaid (subscription) and set InstanceChargeType in the instance parameters to PostPaid (pay-as-you-go), the created instances are pay-as-you-go instances.
        *Example: Use a full image (an image that contains the system disk and data disks) to create an ECS instance**\
        RegionId:"cn-hangzhou", //Set the region ID to cn-hangzhou, which specifies the China (Hangzhou) region.
        ImageId = m-bp13ohd32cvzpq9e***, //Set the custom image ID to m-bp13ohd32cvzpq9e****.
        InstanceType = ecs.u1-c1m1.large, //Set the instance type to ecs.u1-c1m1.large.
        SecurityGroupId = sg-bp10jztp6b0sdsyl***, //Set the security group ID to sg-bp10jztp6b0sdsyl****.
        VSwitchId = vsw-bp19wo63nleroq22g***, //Set the vSwitch ID to vsw-bp19wo63nleroq22g****.
        SystemDisk.Size = 50, //Set the size of the system disk in the full image to 50. Unit: GiB.
        SystemDisk.Category = cloud_auto, //Set the category of the system disk in the full image to cloud_auto, which specifies the ESSD AutoPL disk category.
        DataDisk.0.Device = /dev/xvdb, //Set the mount point of the data disk in the full image to /dev/xvdb.
        DataDisk.0.Size = 50, //Set the size of the data disk in the full image to 50. Unit: GiB.
        DataDisk.0.Category = cloud_essd, //Set the category of the data disk in the full image to cloud_essd, which specifies the ESSD category.
        DataDisk.1.Device = /dev/xvdc, //Set the mount point of the new data disk to /dev/xvdc. If you want to use a new data disk to replace the data disk in the full image, set DataDisk.1.Device to /dev/xvdb (the default mount point of the data disk in the full image).
        DataDisk.1.Size = 70, //Set the size of the new data disk to 70. Unit: GiB.
        DataDisk.1.Category = cloud_auto, //Set the category of the new data disk to cloud_auto, which specifies the ESSD AutoPL disk category.
        
        @param request: RunInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RunInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.affinity):
            query['Affinity'] = request.affinity
        if not UtilClient.is_unset(request.amount):
            query['Amount'] = request.amount
        if not UtilClient.is_unset(request.arn):
            query['Arn'] = request.arn
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.auto_release_time):
            query['AutoReleaseTime'] = request.auto_release_time
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_period):
            query['AutoRenewPeriod'] = request.auto_renew_period
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.credit_specification):
            query['CreditSpecification'] = request.credit_specification
        if not UtilClient.is_unset(request.data_disk):
            query['DataDisk'] = request.data_disk
        if not UtilClient.is_unset(request.dedicated_host_id):
            query['DedicatedHostId'] = request.dedicated_host_id
        if not UtilClient.is_unset(request.deletion_protection):
            query['DeletionProtection'] = request.deletion_protection
        if not UtilClient.is_unset(request.deployment_set_group_no):
            query['DeploymentSetGroupNo'] = request.deployment_set_group_no
        if not UtilClient.is_unset(request.deployment_set_id):
            query['DeploymentSetId'] = request.deployment_set_id
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.host_name):
            query['HostName'] = request.host_name
        if not UtilClient.is_unset(request.host_names):
            query['HostNames'] = request.host_names
        if not UtilClient.is_unset(request.hpc_cluster_id):
            query['HpcClusterId'] = request.hpc_cluster_id
        if not UtilClient.is_unset(request.http_endpoint):
            query['HttpEndpoint'] = request.http_endpoint
        if not UtilClient.is_unset(request.http_put_response_hop_limit):
            query['HttpPutResponseHopLimit'] = request.http_put_response_hop_limit
        if not UtilClient.is_unset(request.http_tokens):
            query['HttpTokens'] = request.http_tokens
        if not UtilClient.is_unset(request.image_family):
            query['ImageFamily'] = request.image_family
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.image_options):
            query['ImageOptions'] = request.image_options
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.internet_max_bandwidth_in):
            query['InternetMaxBandwidthIn'] = request.internet_max_bandwidth_in
        if not UtilClient.is_unset(request.internet_max_bandwidth_out):
            query['InternetMaxBandwidthOut'] = request.internet_max_bandwidth_out
        if not UtilClient.is_unset(request.io_optimized):
            query['IoOptimized'] = request.io_optimized
        if not UtilClient.is_unset(request.ipv_6address):
            query['Ipv6Address'] = request.ipv_6address
        if not UtilClient.is_unset(request.ipv_6address_count):
            query['Ipv6AddressCount'] = request.ipv_6address_count
        if not UtilClient.is_unset(request.isp):
            query['Isp'] = request.isp
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.launch_template_id):
            query['LaunchTemplateId'] = request.launch_template_id
        if not UtilClient.is_unset(request.launch_template_name):
            query['LaunchTemplateName'] = request.launch_template_name
        if not UtilClient.is_unset(request.launch_template_version):
            query['LaunchTemplateVersion'] = request.launch_template_version
        if not UtilClient.is_unset(request.min_amount):
            query['MinAmount'] = request.min_amount
        if not UtilClient.is_unset(request.network_interface):
            query['NetworkInterface'] = request.network_interface
        if not UtilClient.is_unset(request.network_interface_queue_number):
            query['NetworkInterfaceQueueNumber'] = request.network_interface_queue_number
        if not UtilClient.is_unset(request.network_options):
            query['NetworkOptions'] = request.network_options
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.password):
            query['Password'] = request.password
        if not UtilClient.is_unset(request.password_inherit):
            query['PasswordInherit'] = request.password_inherit
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.private_dns_name_options):
            query['PrivateDnsNameOptions'] = request.private_dns_name_options
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.ram_role_name):
            query['RamRoleName'] = request.ram_role_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_enhancement_strategy):
            query['SecurityEnhancementStrategy'] = request.security_enhancement_strategy
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_ids):
            query['SecurityGroupIds'] = request.security_group_ids
        if not UtilClient.is_unset(request.spot_duration):
            query['SpotDuration'] = request.spot_duration
        if not UtilClient.is_unset(request.spot_interruption_behavior):
            query['SpotInterruptionBehavior'] = request.spot_interruption_behavior
        if not UtilClient.is_unset(request.spot_price_limit):
            query['SpotPriceLimit'] = request.spot_price_limit
        if not UtilClient.is_unset(request.spot_strategy):
            query['SpotStrategy'] = request.spot_strategy
        if not UtilClient.is_unset(request.storage_set_id):
            query['StorageSetId'] = request.storage_set_id
        if not UtilClient.is_unset(request.storage_set_partition_number):
            query['StorageSetPartitionNumber'] = request.storage_set_partition_number
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.tenancy):
            query['Tenancy'] = request.tenancy
        if not UtilClient.is_unset(request.unique_suffix):
            query['UniqueSuffix'] = request.unique_suffix
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.cpu_options):
            query['CpuOptions'] = request.cpu_options
        if not UtilClient.is_unset(request.hibernation_options):
            query['HibernationOptions'] = request.hibernation_options
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        if not UtilClient.is_unset(request.scheduler_options):
            query['SchedulerOptions'] = request.scheduler_options
        if not UtilClient.is_unset(request.security_options):
            query['SecurityOptions'] = request.security_options
        if not UtilClient.is_unset(request.system_disk):
            query['SystemDisk'] = request.system_disk
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RunInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RunInstancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def run_instances_with_options_async(
        self,
        request: ecs_20140526_models.RunInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.RunInstancesResponse:
        """
        @summary Batch creates Elastic Compute Service (ECS) instances. You can automatically start, assign public IP addresses to, and specify an automatic release time for the instances.
        
        @description Before you call this operation, familiarize yourself with the billing rules and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of ECS resources.
        This operation is an asynchronous operation. After a request to create ECS instances is sent, ECS instance IDs are returned but the creation and startup of the instances may be incomplete. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instances. When the status of an instance is `Running` in the DescribeInstanceStatus response, the instance is created and started.
        ### [](#)Considerations
        If the resource inventory is insufficient to complete instance creation, Alibaba Cloud immediately sends an instance creation failure event (SystemFailure.Delete). You can call the [DescribeInstanceHistoryEvents](https://help.aliyun.com/document_detail/2679897.html) operation to check whether an instance creation failure event exists. For more information, see [System events related to instance creation failures](https://help.aliyun.com/document_detail/2545990.html).
        Make sure that the number of ECS instances you create or the number of vCPUs on ECS instances of all instance types you create does not exceed the corresponding quota. Go to the [Quota Center](https://quotas.console.aliyun.com/products/ecs/quotas) to view the quotas.
        Before you create ECS instances of the Virtual Private Cloud (VPC) type in a region, [create a VPC](https://help.aliyun.com/document_detail/65430.html) in the region.
        ### [](#)Precautions
        If you create a subscription instance (`PrePaid`), available coupons in your account are automatically used.
        You can call the RunInstances operation to create up to 100 ECS instances in a single request. To create more than 100 ECS instances, we recommend that you initiate multiple requests in batches or concurrently.
        If you set `InternetMaxBandwidthOut` to a value greater than 0, public IP addresses are automatically assigned to the ECS instances to be created.
        >  For the limits on the sum of maximum public bandwidths of ECS instances that use the pay-by-bandwidth billing method for network usage per region per Alibaba Cloud account, see the [Public bandwidth](~~25412#BandwidthQuota~~) section of the "Limits and quotas on ECS" topic.
        ### [](#)Suggestions
        **Test scenarios**: Set `DryRun` to true to perform a dry run without performing the actual request.
        **Release of ECS instances**: Use `AutoReleaseTime` to configure an automatic release time for ECS instances in the request to RunInstances or call the [DeleteInstances](https://help.aliyun.com/document_detail/2679710.html) operation to release the instances.
        **Management and search of ECS instances**: Add tags to the ECS instances by specifying `Tag.N.Key` and `Tag.N.Value` and append incremental suffixes by specifying `UniqueSuffix` to the hostname specified by `HostName` and the instance name specified by `InstanceName`. For more information, see [Batch configure sequential names or hostnames for multiple instances](https://help.aliyun.com/document_detail/196048.html).
        **Launch template**: A launch template contains the parameters required to create an ECS instance so that you do not have to specify the parameters every time you create ECS instances. You can call the [CreateLaunchTemplate](https://help.aliyun.com/document_detail/2679729.html) operation to create a launch template. Then, in the request to `RunInstances`, you can specify `LaunchTemplateId` and `LaunchTemplateVersion` to use the launch template.
        **Disabling of Hyper-Threading (HT)**: In memory-intensive scenarios, set `CpuOptions.ThreadsPerCore` to 1 to disable HT and increase the memory-to-vCPU ratio.
        **Enabling of Jumbo Frames**: Set `NetworkOptions.EnableJumboFrame` to true to enable the `Jumbo Frames` feature when you create ECS instances. For more information, see [Jumbo Frames](https://help.aliyun.com/document_detail/200512.html).
        ## [](#)Sample requests
        Use a specific image to create ECS instances of a specific instance type in the China (Hangzhou) region. The instances use disks with a specific capacity as the system disk and data disks and are automatically assigned public IP addresses. The instances have user-defined names and logon passwords. The instances are assigned to a specific security group and connected to a specific vSwitch. Request parameters:
        RegionId:"cn-hangzhou", //Set the region ID to cn-hangzhou, which specifies the China (Hangzhou) region.
        ImageId:"aliyun_3_x64_20G_alibase_20221102.vhd", //Set the image ID to aliyun_3_x64_20G_alibase_20221102.vhd.
        InstanceType:"ecs.g7.large", //Set the instance type to ecs.g7.large.
        SecurityGroupId:"sg-bp150uqocpf9jj70***", //Set the security group ID to sg-bp150uqocpf9jj70****.
        VSwitchId:"vsw-bp1qo7s91cbch5i4l***", //Set the vSwitch ID to vsw-bp1qo7s91cbch5i4l****.
        SystemDisk:{
        Category:"cloud_essd", //Set the system disk category to cloud_essd, which specifies the Enterprise SSD (ESSD) category.
        Size:40, //Set the system disk size to 40. Unit: GiB.
        },
        DataDisk:[
        {
        Category:"cloud_essd", //Set the data disk category to cloud_essd, which specifies the ESSD category.
        Size:100, //Set the data disk size to 100. Unit: GiB.
        }
        ],
        HostName:"ECS-test", //Set the instance hostname to ECS-test.
        Password:"ECS@test1234", //Set the logon password to ECS@test1234.
        InternetMaxBandwidthOut:10 //Set the outbound public bandwidth to 10. Unit: Mbit/s.
        Examples on how to create instances of different types based on the preceding parameters:
        *Example: Create five subscription ECS instances for which auto-renewal is enabled**\
        Amount:5, //Set the number of ECS instances that you want to create to 5.
        InstanceChargeType:"PrePaid", //Set the billing method to PrePaid, which specifies the subscription billing method.
        PeriodUnit:"Month", //Set the subscription period unit to Month.
        Period:1, //Set the subscription period to 1. The unit is specified by PeriodUnit, which is Month in this example.
        AutoRenew:true, //Set this parameter to true to enable auto-renewal.
        AutoRenewPeriod:1 //Set the renewal period to 1. The unit is specified by PeriodUnit, which is Month in this example.
        *Example: Create 10 pay-as-you-go ECS instances**\
        Amount:10, //Set the number of ECS instances that you want to create to 10.
        InstanceChargeType:"PostPaid", //Set the billing method to PostPaid, which specifies the pay-as-you-go billing method.
        SpotStrategy:"NoSpot" //Set this parameter to NoSpot, which is the default value and specifies that the instances are created as pay-as-you-go instances.
        *Example: Create 20 spot instances that use a specific bidding policy and a protection period**\
        Amount:20, //Set the number of ECS instances that you want to create to 20.
        InstanceChargeType:"PostPaid",
        SpotStrategy:"SpotAsPriceGo", //Set the bidding policy to SpotAsPriceGo, which specifies that the instances are created as spot instances for which the market price at the time of purchase is automatically used as the bid price.
        SpotDuration:1 //Set the protection period of the spot instances to 1. Unit: hours.
        Use a launch template created by calling the [CreateLaunchTemplate](https://help.aliyun.com/document_detail/2679729.html) operation to create ECS instances in the China (Hangzhou) region. Examples:
        *Example: Create 10 ECS instances based on a launch template**\
        RegionId:"cn-hangzhou", //Set the region ID to cn-hangzhou, which specifies the China (Hangzhou) region.
        Amount:10, //Set the number of ECS instances that you want to create to 10.
        LaunchTemplateId:"lt-bp14xczpoxvb6rre***" //Set the launch template ID to lt-bp14xczpoxvb6rre****.
        >  If a parameter is specified both in the launch template that you reference in a request and in the instance parameters of the same request, the value specified in the instance parameters takes precedence. For example, if you set InstanceChargeType in the launch template to PrePaid (subscription) and set InstanceChargeType in the instance parameters to PostPaid (pay-as-you-go), the created instances are pay-as-you-go instances.
        *Example: Use a full image (an image that contains the system disk and data disks) to create an ECS instance**\
        RegionId:"cn-hangzhou", //Set the region ID to cn-hangzhou, which specifies the China (Hangzhou) region.
        ImageId = m-bp13ohd32cvzpq9e***, //Set the custom image ID to m-bp13ohd32cvzpq9e****.
        InstanceType = ecs.u1-c1m1.large, //Set the instance type to ecs.u1-c1m1.large.
        SecurityGroupId = sg-bp10jztp6b0sdsyl***, //Set the security group ID to sg-bp10jztp6b0sdsyl****.
        VSwitchId = vsw-bp19wo63nleroq22g***, //Set the vSwitch ID to vsw-bp19wo63nleroq22g****.
        SystemDisk.Size = 50, //Set the size of the system disk in the full image to 50. Unit: GiB.
        SystemDisk.Category = cloud_auto, //Set the category of the system disk in the full image to cloud_auto, which specifies the ESSD AutoPL disk category.
        DataDisk.0.Device = /dev/xvdb, //Set the mount point of the data disk in the full image to /dev/xvdb.
        DataDisk.0.Size = 50, //Set the size of the data disk in the full image to 50. Unit: GiB.
        DataDisk.0.Category = cloud_essd, //Set the category of the data disk in the full image to cloud_essd, which specifies the ESSD category.
        DataDisk.1.Device = /dev/xvdc, //Set the mount point of the new data disk to /dev/xvdc. If you want to use a new data disk to replace the data disk in the full image, set DataDisk.1.Device to /dev/xvdb (the default mount point of the data disk in the full image).
        DataDisk.1.Size = 70, //Set the size of the new data disk to 70. Unit: GiB.
        DataDisk.1.Category = cloud_auto, //Set the category of the new data disk to cloud_auto, which specifies the ESSD AutoPL disk category.
        
        @param request: RunInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RunInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.affinity):
            query['Affinity'] = request.affinity
        if not UtilClient.is_unset(request.amount):
            query['Amount'] = request.amount
        if not UtilClient.is_unset(request.arn):
            query['Arn'] = request.arn
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.auto_release_time):
            query['AutoReleaseTime'] = request.auto_release_time
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.auto_renew_period):
            query['AutoRenewPeriod'] = request.auto_renew_period
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.credit_specification):
            query['CreditSpecification'] = request.credit_specification
        if not UtilClient.is_unset(request.data_disk):
            query['DataDisk'] = request.data_disk
        if not UtilClient.is_unset(request.dedicated_host_id):
            query['DedicatedHostId'] = request.dedicated_host_id
        if not UtilClient.is_unset(request.deletion_protection):
            query['DeletionProtection'] = request.deletion_protection
        if not UtilClient.is_unset(request.deployment_set_group_no):
            query['DeploymentSetGroupNo'] = request.deployment_set_group_no
        if not UtilClient.is_unset(request.deployment_set_id):
            query['DeploymentSetId'] = request.deployment_set_id
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.host_name):
            query['HostName'] = request.host_name
        if not UtilClient.is_unset(request.host_names):
            query['HostNames'] = request.host_names
        if not UtilClient.is_unset(request.hpc_cluster_id):
            query['HpcClusterId'] = request.hpc_cluster_id
        if not UtilClient.is_unset(request.http_endpoint):
            query['HttpEndpoint'] = request.http_endpoint
        if not UtilClient.is_unset(request.http_put_response_hop_limit):
            query['HttpPutResponseHopLimit'] = request.http_put_response_hop_limit
        if not UtilClient.is_unset(request.http_tokens):
            query['HttpTokens'] = request.http_tokens
        if not UtilClient.is_unset(request.image_family):
            query['ImageFamily'] = request.image_family
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.image_options):
            query['ImageOptions'] = request.image_options
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_name):
            query['InstanceName'] = request.instance_name
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.internet_max_bandwidth_in):
            query['InternetMaxBandwidthIn'] = request.internet_max_bandwidth_in
        if not UtilClient.is_unset(request.internet_max_bandwidth_out):
            query['InternetMaxBandwidthOut'] = request.internet_max_bandwidth_out
        if not UtilClient.is_unset(request.io_optimized):
            query['IoOptimized'] = request.io_optimized
        if not UtilClient.is_unset(request.ipv_6address):
            query['Ipv6Address'] = request.ipv_6address
        if not UtilClient.is_unset(request.ipv_6address_count):
            query['Ipv6AddressCount'] = request.ipv_6address_count
        if not UtilClient.is_unset(request.isp):
            query['Isp'] = request.isp
        if not UtilClient.is_unset(request.key_pair_name):
            query['KeyPairName'] = request.key_pair_name
        if not UtilClient.is_unset(request.launch_template_id):
            query['LaunchTemplateId'] = request.launch_template_id
        if not UtilClient.is_unset(request.launch_template_name):
            query['LaunchTemplateName'] = request.launch_template_name
        if not UtilClient.is_unset(request.launch_template_version):
            query['LaunchTemplateVersion'] = request.launch_template_version
        if not UtilClient.is_unset(request.min_amount):
            query['MinAmount'] = request.min_amount
        if not UtilClient.is_unset(request.network_interface):
            query['NetworkInterface'] = request.network_interface
        if not UtilClient.is_unset(request.network_interface_queue_number):
            query['NetworkInterfaceQueueNumber'] = request.network_interface_queue_number
        if not UtilClient.is_unset(request.network_options):
            query['NetworkOptions'] = request.network_options
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.password):
            query['Password'] = request.password
        if not UtilClient.is_unset(request.password_inherit):
            query['PasswordInherit'] = request.password_inherit
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.period_unit):
            query['PeriodUnit'] = request.period_unit
        if not UtilClient.is_unset(request.private_dns_name_options):
            query['PrivateDnsNameOptions'] = request.private_dns_name_options
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.ram_role_name):
            query['RamRoleName'] = request.ram_role_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_enhancement_strategy):
            query['SecurityEnhancementStrategy'] = request.security_enhancement_strategy
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.security_group_ids):
            query['SecurityGroupIds'] = request.security_group_ids
        if not UtilClient.is_unset(request.spot_duration):
            query['SpotDuration'] = request.spot_duration
        if not UtilClient.is_unset(request.spot_interruption_behavior):
            query['SpotInterruptionBehavior'] = request.spot_interruption_behavior
        if not UtilClient.is_unset(request.spot_price_limit):
            query['SpotPriceLimit'] = request.spot_price_limit
        if not UtilClient.is_unset(request.spot_strategy):
            query['SpotStrategy'] = request.spot_strategy
        if not UtilClient.is_unset(request.storage_set_id):
            query['StorageSetId'] = request.storage_set_id
        if not UtilClient.is_unset(request.storage_set_partition_number):
            query['StorageSetPartitionNumber'] = request.storage_set_partition_number
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.tenancy):
            query['Tenancy'] = request.tenancy
        if not UtilClient.is_unset(request.unique_suffix):
            query['UniqueSuffix'] = request.unique_suffix
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        if not UtilClient.is_unset(request.cpu_options):
            query['CpuOptions'] = request.cpu_options
        if not UtilClient.is_unset(request.hibernation_options):
            query['HibernationOptions'] = request.hibernation_options
        if not UtilClient.is_unset(request.private_pool_options):
            query['PrivatePoolOptions'] = request.private_pool_options
        if not UtilClient.is_unset(request.scheduler_options):
            query['SchedulerOptions'] = request.scheduler_options
        if not UtilClient.is_unset(request.security_options):
            query['SecurityOptions'] = request.security_options
        if not UtilClient.is_unset(request.system_disk):
            query['SystemDisk'] = request.system_disk
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RunInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.RunInstancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def run_instances(
        self,
        request: ecs_20140526_models.RunInstancesRequest,
    ) -> ecs_20140526_models.RunInstancesResponse:
        """
        @summary Batch creates Elastic Compute Service (ECS) instances. You can automatically start, assign public IP addresses to, and specify an automatic release time for the instances.
        
        @description Before you call this operation, familiarize yourself with the billing rules and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of ECS resources.
        This operation is an asynchronous operation. After a request to create ECS instances is sent, ECS instance IDs are returned but the creation and startup of the instances may be incomplete. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instances. When the status of an instance is `Running` in the DescribeInstanceStatus response, the instance is created and started.
        ### [](#)Considerations
        If the resource inventory is insufficient to complete instance creation, Alibaba Cloud immediately sends an instance creation failure event (SystemFailure.Delete). You can call the [DescribeInstanceHistoryEvents](https://help.aliyun.com/document_detail/2679897.html) operation to check whether an instance creation failure event exists. For more information, see [System events related to instance creation failures](https://help.aliyun.com/document_detail/2545990.html).
        Make sure that the number of ECS instances you create or the number of vCPUs on ECS instances of all instance types you create does not exceed the corresponding quota. Go to the [Quota Center](https://quotas.console.aliyun.com/products/ecs/quotas) to view the quotas.
        Before you create ECS instances of the Virtual Private Cloud (VPC) type in a region, [create a VPC](https://help.aliyun.com/document_detail/65430.html) in the region.
        ### [](#)Precautions
        If you create a subscription instance (`PrePaid`), available coupons in your account are automatically used.
        You can call the RunInstances operation to create up to 100 ECS instances in a single request. To create more than 100 ECS instances, we recommend that you initiate multiple requests in batches or concurrently.
        If you set `InternetMaxBandwidthOut` to a value greater than 0, public IP addresses are automatically assigned to the ECS instances to be created.
        >  For the limits on the sum of maximum public bandwidths of ECS instances that use the pay-by-bandwidth billing method for network usage per region per Alibaba Cloud account, see the [Public bandwidth](~~25412#BandwidthQuota~~) section of the "Limits and quotas on ECS" topic.
        ### [](#)Suggestions
        **Test scenarios**: Set `DryRun` to true to perform a dry run without performing the actual request.
        **Release of ECS instances**: Use `AutoReleaseTime` to configure an automatic release time for ECS instances in the request to RunInstances or call the [DeleteInstances](https://help.aliyun.com/document_detail/2679710.html) operation to release the instances.
        **Management and search of ECS instances**: Add tags to the ECS instances by specifying `Tag.N.Key` and `Tag.N.Value` and append incremental suffixes by specifying `UniqueSuffix` to the hostname specified by `HostName` and the instance name specified by `InstanceName`. For more information, see [Batch configure sequential names or hostnames for multiple instances](https://help.aliyun.com/document_detail/196048.html).
        **Launch template**: A launch template contains the parameters required to create an ECS instance so that you do not have to specify the parameters every time you create ECS instances. You can call the [CreateLaunchTemplate](https://help.aliyun.com/document_detail/2679729.html) operation to create a launch template. Then, in the request to `RunInstances`, you can specify `LaunchTemplateId` and `LaunchTemplateVersion` to use the launch template.
        **Disabling of Hyper-Threading (HT)**: In memory-intensive scenarios, set `CpuOptions.ThreadsPerCore` to 1 to disable HT and increase the memory-to-vCPU ratio.
        **Enabling of Jumbo Frames**: Set `NetworkOptions.EnableJumboFrame` to true to enable the `Jumbo Frames` feature when you create ECS instances. For more information, see [Jumbo Frames](https://help.aliyun.com/document_detail/200512.html).
        ## [](#)Sample requests
        Use a specific image to create ECS instances of a specific instance type in the China (Hangzhou) region. The instances use disks with a specific capacity as the system disk and data disks and are automatically assigned public IP addresses. The instances have user-defined names and logon passwords. The instances are assigned to a specific security group and connected to a specific vSwitch. Request parameters:
        RegionId:"cn-hangzhou", //Set the region ID to cn-hangzhou, which specifies the China (Hangzhou) region.
        ImageId:"aliyun_3_x64_20G_alibase_20221102.vhd", //Set the image ID to aliyun_3_x64_20G_alibase_20221102.vhd.
        InstanceType:"ecs.g7.large", //Set the instance type to ecs.g7.large.
        SecurityGroupId:"sg-bp150uqocpf9jj70***", //Set the security group ID to sg-bp150uqocpf9jj70****.
        VSwitchId:"vsw-bp1qo7s91cbch5i4l***", //Set the vSwitch ID to vsw-bp1qo7s91cbch5i4l****.
        SystemDisk:{
        Category:"cloud_essd", //Set the system disk category to cloud_essd, which specifies the Enterprise SSD (ESSD) category.
        Size:40, //Set the system disk size to 40. Unit: GiB.
        },
        DataDisk:[
        {
        Category:"cloud_essd", //Set the data disk category to cloud_essd, which specifies the ESSD category.
        Size:100, //Set the data disk size to 100. Unit: GiB.
        }
        ],
        HostName:"ECS-test", //Set the instance hostname to ECS-test.
        Password:"ECS@test1234", //Set the logon password to ECS@test1234.
        InternetMaxBandwidthOut:10 //Set the outbound public bandwidth to 10. Unit: Mbit/s.
        Examples on how to create instances of different types based on the preceding parameters:
        *Example: Create five subscription ECS instances for which auto-renewal is enabled**\
        Amount:5, //Set the number of ECS instances that you want to create to 5.
        InstanceChargeType:"PrePaid", //Set the billing method to PrePaid, which specifies the subscription billing method.
        PeriodUnit:"Month", //Set the subscription period unit to Month.
        Period:1, //Set the subscription period to 1. The unit is specified by PeriodUnit, which is Month in this example.
        AutoRenew:true, //Set this parameter to true to enable auto-renewal.
        AutoRenewPeriod:1 //Set the renewal period to 1. The unit is specified by PeriodUnit, which is Month in this example.
        *Example: Create 10 pay-as-you-go ECS instances**\
        Amount:10, //Set the number of ECS instances that you want to create to 10.
        InstanceChargeType:"PostPaid", //Set the billing method to PostPaid, which specifies the pay-as-you-go billing method.
        SpotStrategy:"NoSpot" //Set this parameter to NoSpot, which is the default value and specifies that the instances are created as pay-as-you-go instances.
        *Example: Create 20 spot instances that use a specific bidding policy and a protection period**\
        Amount:20, //Set the number of ECS instances that you want to create to 20.
        InstanceChargeType:"PostPaid",
        SpotStrategy:"SpotAsPriceGo", //Set the bidding policy to SpotAsPriceGo, which specifies that the instances are created as spot instances for which the market price at the time of purchase is automatically used as the bid price.
        SpotDuration:1 //Set the protection period of the spot instances to 1. Unit: hours.
        Use a launch template created by calling the [CreateLaunchTemplate](https://help.aliyun.com/document_detail/2679729.html) operation to create ECS instances in the China (Hangzhou) region. Examples:
        *Example: Create 10 ECS instances based on a launch template**\
        RegionId:"cn-hangzhou", //Set the region ID to cn-hangzhou, which specifies the China (Hangzhou) region.
        Amount:10, //Set the number of ECS instances that you want to create to 10.
        LaunchTemplateId:"lt-bp14xczpoxvb6rre***" //Set the launch template ID to lt-bp14xczpoxvb6rre****.
        >  If a parameter is specified both in the launch template that you reference in a request and in the instance parameters of the same request, the value specified in the instance parameters takes precedence. For example, if you set InstanceChargeType in the launch template to PrePaid (subscription) and set InstanceChargeType in the instance parameters to PostPaid (pay-as-you-go), the created instances are pay-as-you-go instances.
        *Example: Use a full image (an image that contains the system disk and data disks) to create an ECS instance**\
        RegionId:"cn-hangzhou", //Set the region ID to cn-hangzhou, which specifies the China (Hangzhou) region.
        ImageId = m-bp13ohd32cvzpq9e***, //Set the custom image ID to m-bp13ohd32cvzpq9e****.
        InstanceType = ecs.u1-c1m1.large, //Set the instance type to ecs.u1-c1m1.large.
        SecurityGroupId = sg-bp10jztp6b0sdsyl***, //Set the security group ID to sg-bp10jztp6b0sdsyl****.
        VSwitchId = vsw-bp19wo63nleroq22g***, //Set the vSwitch ID to vsw-bp19wo63nleroq22g****.
        SystemDisk.Size = 50, //Set the size of the system disk in the full image to 50. Unit: GiB.
        SystemDisk.Category = cloud_auto, //Set the category of the system disk in the full image to cloud_auto, which specifies the ESSD AutoPL disk category.
        DataDisk.0.Device = /dev/xvdb, //Set the mount point of the data disk in the full image to /dev/xvdb.
        DataDisk.0.Size = 50, //Set the size of the data disk in the full image to 50. Unit: GiB.
        DataDisk.0.Category = cloud_essd, //Set the category of the data disk in the full image to cloud_essd, which specifies the ESSD category.
        DataDisk.1.Device = /dev/xvdc, //Set the mount point of the new data disk to /dev/xvdc. If you want to use a new data disk to replace the data disk in the full image, set DataDisk.1.Device to /dev/xvdb (the default mount point of the data disk in the full image).
        DataDisk.1.Size = 70, //Set the size of the new data disk to 70. Unit: GiB.
        DataDisk.1.Category = cloud_auto, //Set the category of the new data disk to cloud_auto, which specifies the ESSD AutoPL disk category.
        
        @param request: RunInstancesRequest
        @return: RunInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.run_instances_with_options(request, runtime)

    async def run_instances_async(
        self,
        request: ecs_20140526_models.RunInstancesRequest,
    ) -> ecs_20140526_models.RunInstancesResponse:
        """
        @summary Batch creates Elastic Compute Service (ECS) instances. You can automatically start, assign public IP addresses to, and specify an automatic release time for the instances.
        
        @description Before you call this operation, familiarize yourself with the billing rules and [pricing](https://www.alibabacloud.com/zh/pricing-calculator#/commodity/vm_intl) of ECS resources.
        This operation is an asynchronous operation. After a request to create ECS instances is sent, ECS instance IDs are returned but the creation and startup of the instances may be incomplete. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instances. When the status of an instance is `Running` in the DescribeInstanceStatus response, the instance is created and started.
        ### [](#)Considerations
        If the resource inventory is insufficient to complete instance creation, Alibaba Cloud immediately sends an instance creation failure event (SystemFailure.Delete). You can call the [DescribeInstanceHistoryEvents](https://help.aliyun.com/document_detail/2679897.html) operation to check whether an instance creation failure event exists. For more information, see [System events related to instance creation failures](https://help.aliyun.com/document_detail/2545990.html).
        Make sure that the number of ECS instances you create or the number of vCPUs on ECS instances of all instance types you create does not exceed the corresponding quota. Go to the [Quota Center](https://quotas.console.aliyun.com/products/ecs/quotas) to view the quotas.
        Before you create ECS instances of the Virtual Private Cloud (VPC) type in a region, [create a VPC](https://help.aliyun.com/document_detail/65430.html) in the region.
        ### [](#)Precautions
        If you create a subscription instance (`PrePaid`), available coupons in your account are automatically used.
        You can call the RunInstances operation to create up to 100 ECS instances in a single request. To create more than 100 ECS instances, we recommend that you initiate multiple requests in batches or concurrently.
        If you set `InternetMaxBandwidthOut` to a value greater than 0, public IP addresses are automatically assigned to the ECS instances to be created.
        >  For the limits on the sum of maximum public bandwidths of ECS instances that use the pay-by-bandwidth billing method for network usage per region per Alibaba Cloud account, see the [Public bandwidth](~~25412#BandwidthQuota~~) section of the "Limits and quotas on ECS" topic.
        ### [](#)Suggestions
        **Test scenarios**: Set `DryRun` to true to perform a dry run without performing the actual request.
        **Release of ECS instances**: Use `AutoReleaseTime` to configure an automatic release time for ECS instances in the request to RunInstances or call the [DeleteInstances](https://help.aliyun.com/document_detail/2679710.html) operation to release the instances.
        **Management and search of ECS instances**: Add tags to the ECS instances by specifying `Tag.N.Key` and `Tag.N.Value` and append incremental suffixes by specifying `UniqueSuffix` to the hostname specified by `HostName` and the instance name specified by `InstanceName`. For more information, see [Batch configure sequential names or hostnames for multiple instances](https://help.aliyun.com/document_detail/196048.html).
        **Launch template**: A launch template contains the parameters required to create an ECS instance so that you do not have to specify the parameters every time you create ECS instances. You can call the [CreateLaunchTemplate](https://help.aliyun.com/document_detail/2679729.html) operation to create a launch template. Then, in the request to `RunInstances`, you can specify `LaunchTemplateId` and `LaunchTemplateVersion` to use the launch template.
        **Disabling of Hyper-Threading (HT)**: In memory-intensive scenarios, set `CpuOptions.ThreadsPerCore` to 1 to disable HT and increase the memory-to-vCPU ratio.
        **Enabling of Jumbo Frames**: Set `NetworkOptions.EnableJumboFrame` to true to enable the `Jumbo Frames` feature when you create ECS instances. For more information, see [Jumbo Frames](https://help.aliyun.com/document_detail/200512.html).
        ## [](#)Sample requests
        Use a specific image to create ECS instances of a specific instance type in the China (Hangzhou) region. The instances use disks with a specific capacity as the system disk and data disks and are automatically assigned public IP addresses. The instances have user-defined names and logon passwords. The instances are assigned to a specific security group and connected to a specific vSwitch. Request parameters:
        RegionId:"cn-hangzhou", //Set the region ID to cn-hangzhou, which specifies the China (Hangzhou) region.
        ImageId:"aliyun_3_x64_20G_alibase_20221102.vhd", //Set the image ID to aliyun_3_x64_20G_alibase_20221102.vhd.
        InstanceType:"ecs.g7.large", //Set the instance type to ecs.g7.large.
        SecurityGroupId:"sg-bp150uqocpf9jj70***", //Set the security group ID to sg-bp150uqocpf9jj70****.
        VSwitchId:"vsw-bp1qo7s91cbch5i4l***", //Set the vSwitch ID to vsw-bp1qo7s91cbch5i4l****.
        SystemDisk:{
        Category:"cloud_essd", //Set the system disk category to cloud_essd, which specifies the Enterprise SSD (ESSD) category.
        Size:40, //Set the system disk size to 40. Unit: GiB.
        },
        DataDisk:[
        {
        Category:"cloud_essd", //Set the data disk category to cloud_essd, which specifies the ESSD category.
        Size:100, //Set the data disk size to 100. Unit: GiB.
        }
        ],
        HostName:"ECS-test", //Set the instance hostname to ECS-test.
        Password:"ECS@test1234", //Set the logon password to ECS@test1234.
        InternetMaxBandwidthOut:10 //Set the outbound public bandwidth to 10. Unit: Mbit/s.
        Examples on how to create instances of different types based on the preceding parameters:
        *Example: Create five subscription ECS instances for which auto-renewal is enabled**\
        Amount:5, //Set the number of ECS instances that you want to create to 5.
        InstanceChargeType:"PrePaid", //Set the billing method to PrePaid, which specifies the subscription billing method.
        PeriodUnit:"Month", //Set the subscription period unit to Month.
        Period:1, //Set the subscription period to 1. The unit is specified by PeriodUnit, which is Month in this example.
        AutoRenew:true, //Set this parameter to true to enable auto-renewal.
        AutoRenewPeriod:1 //Set the renewal period to 1. The unit is specified by PeriodUnit, which is Month in this example.
        *Example: Create 10 pay-as-you-go ECS instances**\
        Amount:10, //Set the number of ECS instances that you want to create to 10.
        InstanceChargeType:"PostPaid", //Set the billing method to PostPaid, which specifies the pay-as-you-go billing method.
        SpotStrategy:"NoSpot" //Set this parameter to NoSpot, which is the default value and specifies that the instances are created as pay-as-you-go instances.
        *Example: Create 20 spot instances that use a specific bidding policy and a protection period**\
        Amount:20, //Set the number of ECS instances that you want to create to 20.
        InstanceChargeType:"PostPaid",
        SpotStrategy:"SpotAsPriceGo", //Set the bidding policy to SpotAsPriceGo, which specifies that the instances are created as spot instances for which the market price at the time of purchase is automatically used as the bid price.
        SpotDuration:1 //Set the protection period of the spot instances to 1. Unit: hours.
        Use a launch template created by calling the [CreateLaunchTemplate](https://help.aliyun.com/document_detail/2679729.html) operation to create ECS instances in the China (Hangzhou) region. Examples:
        *Example: Create 10 ECS instances based on a launch template**\
        RegionId:"cn-hangzhou", //Set the region ID to cn-hangzhou, which specifies the China (Hangzhou) region.
        Amount:10, //Set the number of ECS instances that you want to create to 10.
        LaunchTemplateId:"lt-bp14xczpoxvb6rre***" //Set the launch template ID to lt-bp14xczpoxvb6rre****.
        >  If a parameter is specified both in the launch template that you reference in a request and in the instance parameters of the same request, the value specified in the instance parameters takes precedence. For example, if you set InstanceChargeType in the launch template to PrePaid (subscription) and set InstanceChargeType in the instance parameters to PostPaid (pay-as-you-go), the created instances are pay-as-you-go instances.
        *Example: Use a full image (an image that contains the system disk and data disks) to create an ECS instance**\
        RegionId:"cn-hangzhou", //Set the region ID to cn-hangzhou, which specifies the China (Hangzhou) region.
        ImageId = m-bp13ohd32cvzpq9e***, //Set the custom image ID to m-bp13ohd32cvzpq9e****.
        InstanceType = ecs.u1-c1m1.large, //Set the instance type to ecs.u1-c1m1.large.
        SecurityGroupId = sg-bp10jztp6b0sdsyl***, //Set the security group ID to sg-bp10jztp6b0sdsyl****.
        VSwitchId = vsw-bp19wo63nleroq22g***, //Set the vSwitch ID to vsw-bp19wo63nleroq22g****.
        SystemDisk.Size = 50, //Set the size of the system disk in the full image to 50. Unit: GiB.
        SystemDisk.Category = cloud_auto, //Set the category of the system disk in the full image to cloud_auto, which specifies the ESSD AutoPL disk category.
        DataDisk.0.Device = /dev/xvdb, //Set the mount point of the data disk in the full image to /dev/xvdb.
        DataDisk.0.Size = 50, //Set the size of the data disk in the full image to 50. Unit: GiB.
        DataDisk.0.Category = cloud_essd, //Set the category of the data disk in the full image to cloud_essd, which specifies the ESSD category.
        DataDisk.1.Device = /dev/xvdc, //Set the mount point of the new data disk to /dev/xvdc. If you want to use a new data disk to replace the data disk in the full image, set DataDisk.1.Device to /dev/xvdb (the default mount point of the data disk in the full image).
        DataDisk.1.Size = 70, //Set the size of the new data disk to 70. Unit: GiB.
        DataDisk.1.Category = cloud_auto, //Set the category of the new data disk to cloud_auto, which specifies the ESSD AutoPL disk category.
        
        @param request: RunInstancesRequest
        @return: RunInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.run_instances_with_options_async(request, runtime)

    def send_file_with_options(
        self,
        request: ecs_20140526_models.SendFileRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.SendFileResponse:
        """
        @summary Sends a file to one or more Elastic Compute Service (ECS) instances.
        
        @description ## [](#)Usage notes
        The instances to which you want to send a file must be in the Running (`Running`) state.
        [Cloud Assistant Agent](https://help.aliyun.com/document_detail/64921.html) must be installed on the instances.
        Only Cloud Assistant Agent versions that are later than the following ones support file sending. If the `ClientNeedUpgrade` error code is returned, update Cloud Assistant Agent to the latest version.
        For Linux instances, the version of Cloud Assistant Agent must be later than 1.0.2.569.
        For Windows instances, the version of Cloud Assistant Agent must be later than 1.0.0.149.
        The file to be sent must not exceed 32 KB in size after it is encoded in Base64.
        The file may fail to be sent due to instance exceptions, network exceptions, or exceptions on Cloud Assistant Agent. If the file fails to be sent, call the [DescribeSendFileResults](https://help.aliyun.com/document_detail/184117.html) operation or see [Check execution results and troubleshoot common issues](https://help.aliyun.com/document_detail/87029.html) for troubleshooting.
        
        @param request: SendFileRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SendFileResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.content):
            query['Content'] = request.content
        if not UtilClient.is_unset(request.content_type):
            query['ContentType'] = request.content_type
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.file_group):
            query['FileGroup'] = request.file_group
        if not UtilClient.is_unset(request.file_mode):
            query['FileMode'] = request.file_mode
        if not UtilClient.is_unset(request.file_owner):
            query['FileOwner'] = request.file_owner
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.overwrite):
            query['Overwrite'] = request.overwrite
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.target_dir):
            query['TargetDir'] = request.target_dir
        if not UtilClient.is_unset(request.timeout):
            query['Timeout'] = request.timeout
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SendFile',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.SendFileResponse(),
            self.call_api(params, req, runtime)
        )

    async def send_file_with_options_async(
        self,
        request: ecs_20140526_models.SendFileRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.SendFileResponse:
        """
        @summary Sends a file to one or more Elastic Compute Service (ECS) instances.
        
        @description ## [](#)Usage notes
        The instances to which you want to send a file must be in the Running (`Running`) state.
        [Cloud Assistant Agent](https://help.aliyun.com/document_detail/64921.html) must be installed on the instances.
        Only Cloud Assistant Agent versions that are later than the following ones support file sending. If the `ClientNeedUpgrade` error code is returned, update Cloud Assistant Agent to the latest version.
        For Linux instances, the version of Cloud Assistant Agent must be later than 1.0.2.569.
        For Windows instances, the version of Cloud Assistant Agent must be later than 1.0.0.149.
        The file to be sent must not exceed 32 KB in size after it is encoded in Base64.
        The file may fail to be sent due to instance exceptions, network exceptions, or exceptions on Cloud Assistant Agent. If the file fails to be sent, call the [DescribeSendFileResults](https://help.aliyun.com/document_detail/184117.html) operation or see [Check execution results and troubleshoot common issues](https://help.aliyun.com/document_detail/87029.html) for troubleshooting.
        
        @param request: SendFileRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SendFileResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.content):
            query['Content'] = request.content
        if not UtilClient.is_unset(request.content_type):
            query['ContentType'] = request.content_type
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.file_group):
            query['FileGroup'] = request.file_group
        if not UtilClient.is_unset(request.file_mode):
            query['FileMode'] = request.file_mode
        if not UtilClient.is_unset(request.file_owner):
            query['FileOwner'] = request.file_owner
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.overwrite):
            query['Overwrite'] = request.overwrite
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.target_dir):
            query['TargetDir'] = request.target_dir
        if not UtilClient.is_unset(request.timeout):
            query['Timeout'] = request.timeout
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SendFile',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.SendFileResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def send_file(
        self,
        request: ecs_20140526_models.SendFileRequest,
    ) -> ecs_20140526_models.SendFileResponse:
        """
        @summary Sends a file to one or more Elastic Compute Service (ECS) instances.
        
        @description ## [](#)Usage notes
        The instances to which you want to send a file must be in the Running (`Running`) state.
        [Cloud Assistant Agent](https://help.aliyun.com/document_detail/64921.html) must be installed on the instances.
        Only Cloud Assistant Agent versions that are later than the following ones support file sending. If the `ClientNeedUpgrade` error code is returned, update Cloud Assistant Agent to the latest version.
        For Linux instances, the version of Cloud Assistant Agent must be later than 1.0.2.569.
        For Windows instances, the version of Cloud Assistant Agent must be later than 1.0.0.149.
        The file to be sent must not exceed 32 KB in size after it is encoded in Base64.
        The file may fail to be sent due to instance exceptions, network exceptions, or exceptions on Cloud Assistant Agent. If the file fails to be sent, call the [DescribeSendFileResults](https://help.aliyun.com/document_detail/184117.html) operation or see [Check execution results and troubleshoot common issues](https://help.aliyun.com/document_detail/87029.html) for troubleshooting.
        
        @param request: SendFileRequest
        @return: SendFileResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.send_file_with_options(request, runtime)

    async def send_file_async(
        self,
        request: ecs_20140526_models.SendFileRequest,
    ) -> ecs_20140526_models.SendFileResponse:
        """
        @summary Sends a file to one or more Elastic Compute Service (ECS) instances.
        
        @description ## [](#)Usage notes
        The instances to which you want to send a file must be in the Running (`Running`) state.
        [Cloud Assistant Agent](https://help.aliyun.com/document_detail/64921.html) must be installed on the instances.
        Only Cloud Assistant Agent versions that are later than the following ones support file sending. If the `ClientNeedUpgrade` error code is returned, update Cloud Assistant Agent to the latest version.
        For Linux instances, the version of Cloud Assistant Agent must be later than 1.0.2.569.
        For Windows instances, the version of Cloud Assistant Agent must be later than 1.0.0.149.
        The file to be sent must not exceed 32 KB in size after it is encoded in Base64.
        The file may fail to be sent due to instance exceptions, network exceptions, or exceptions on Cloud Assistant Agent. If the file fails to be sent, call the [DescribeSendFileResults](https://help.aliyun.com/document_detail/184117.html) operation or see [Check execution results and troubleshoot common issues](https://help.aliyun.com/document_detail/87029.html) for troubleshooting.
        
        @param request: SendFileRequest
        @return: SendFileResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.send_file_with_options_async(request, runtime)

    def start_image_pipeline_execution_with_options(
        self,
        request: ecs_20140526_models.StartImagePipelineExecutionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.StartImagePipelineExecutionResponse:
        """
        @summary Executes an image creation task (image building task) by using an image template.
        
        @description    After you create an image template, you can call the StartImagePipelineExecution operation to create a pipeline task. The system creates, copies, and shares images based on the parameters configured in the image template.
        You can execute only one pipeline task for each image template.
        
        @param request: StartImagePipelineExecutionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartImagePipelineExecutionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.image_pipeline_id):
            query['ImagePipelineId'] = request.image_pipeline_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.template_tag):
            query['TemplateTag'] = request.template_tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartImagePipelineExecution',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.StartImagePipelineExecutionResponse(),
            self.call_api(params, req, runtime)
        )

    async def start_image_pipeline_execution_with_options_async(
        self,
        request: ecs_20140526_models.StartImagePipelineExecutionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.StartImagePipelineExecutionResponse:
        """
        @summary Executes an image creation task (image building task) by using an image template.
        
        @description    After you create an image template, you can call the StartImagePipelineExecution operation to create a pipeline task. The system creates, copies, and shares images based on the parameters configured in the image template.
        You can execute only one pipeline task for each image template.
        
        @param request: StartImagePipelineExecutionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartImagePipelineExecutionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.image_pipeline_id):
            query['ImagePipelineId'] = request.image_pipeline_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.template_tag):
            query['TemplateTag'] = request.template_tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartImagePipelineExecution',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.StartImagePipelineExecutionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def start_image_pipeline_execution(
        self,
        request: ecs_20140526_models.StartImagePipelineExecutionRequest,
    ) -> ecs_20140526_models.StartImagePipelineExecutionResponse:
        """
        @summary Executes an image creation task (image building task) by using an image template.
        
        @description    After you create an image template, you can call the StartImagePipelineExecution operation to create a pipeline task. The system creates, copies, and shares images based on the parameters configured in the image template.
        You can execute only one pipeline task for each image template.
        
        @param request: StartImagePipelineExecutionRequest
        @return: StartImagePipelineExecutionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.start_image_pipeline_execution_with_options(request, runtime)

    async def start_image_pipeline_execution_async(
        self,
        request: ecs_20140526_models.StartImagePipelineExecutionRequest,
    ) -> ecs_20140526_models.StartImagePipelineExecutionResponse:
        """
        @summary Executes an image creation task (image building task) by using an image template.
        
        @description    After you create an image template, you can call the StartImagePipelineExecution operation to create a pipeline task. The system creates, copies, and shares images based on the parameters configured in the image template.
        You can execute only one pipeline task for each image template.
        
        @param request: StartImagePipelineExecutionRequest
        @return: StartImagePipelineExecutionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.start_image_pipeline_execution_with_options_async(request, runtime)

    def start_instance_with_options(
        self,
        request: ecs_20140526_models.StartInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.StartInstanceResponse:
        """
        @summary Starts an Elastic Compute Service (ECS) instance. You can specify the ID of an ECS instance and parameters, such as InitLocalDisk, in the request based on your business requirements to start the instance.
        
        @description This operation is an asynchronous operation. After you call this operation to start an ECS instance, the operation sets the status of the ECS instance to Starting and begins the startup process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the ECS instance. When the status of the ECS instance changes to `Running`, the instance is started.
        ### [](#)Precautions
        You cannot call this operation to start an ECS instance that is locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        The ECS instance that you want to start must be in the **Stopped** (`Stopped`) state.
        If an ECS instance is stopped in economical mode, the instance may fail to be started due to insufficient resources.
        
        @param request: StartInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.init_local_disk):
            query['InitLocalDisk'] = request.init_local_disk
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartInstance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.StartInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def start_instance_with_options_async(
        self,
        request: ecs_20140526_models.StartInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.StartInstanceResponse:
        """
        @summary Starts an Elastic Compute Service (ECS) instance. You can specify the ID of an ECS instance and parameters, such as InitLocalDisk, in the request based on your business requirements to start the instance.
        
        @description This operation is an asynchronous operation. After you call this operation to start an ECS instance, the operation sets the status of the ECS instance to Starting and begins the startup process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the ECS instance. When the status of the ECS instance changes to `Running`, the instance is started.
        ### [](#)Precautions
        You cannot call this operation to start an ECS instance that is locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        The ECS instance that you want to start must be in the **Stopped** (`Stopped`) state.
        If an ECS instance is stopped in economical mode, the instance may fail to be started due to insufficient resources.
        
        @param request: StartInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.init_local_disk):
            query['InitLocalDisk'] = request.init_local_disk
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartInstance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.StartInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def start_instance(
        self,
        request: ecs_20140526_models.StartInstanceRequest,
    ) -> ecs_20140526_models.StartInstanceResponse:
        """
        @summary Starts an Elastic Compute Service (ECS) instance. You can specify the ID of an ECS instance and parameters, such as InitLocalDisk, in the request based on your business requirements to start the instance.
        
        @description This operation is an asynchronous operation. After you call this operation to start an ECS instance, the operation sets the status of the ECS instance to Starting and begins the startup process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the ECS instance. When the status of the ECS instance changes to `Running`, the instance is started.
        ### [](#)Precautions
        You cannot call this operation to start an ECS instance that is locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        The ECS instance that you want to start must be in the **Stopped** (`Stopped`) state.
        If an ECS instance is stopped in economical mode, the instance may fail to be started due to insufficient resources.
        
        @param request: StartInstanceRequest
        @return: StartInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.start_instance_with_options(request, runtime)

    async def start_instance_async(
        self,
        request: ecs_20140526_models.StartInstanceRequest,
    ) -> ecs_20140526_models.StartInstanceResponse:
        """
        @summary Starts an Elastic Compute Service (ECS) instance. You can specify the ID of an ECS instance and parameters, such as InitLocalDisk, in the request based on your business requirements to start the instance.
        
        @description This operation is an asynchronous operation. After you call this operation to start an ECS instance, the operation sets the status of the ECS instance to Starting and begins the startup process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the ECS instance. When the status of the ECS instance changes to `Running`, the instance is started.
        ### [](#)Precautions
        You cannot call this operation to start an ECS instance that is locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        The ECS instance that you want to start must be in the **Stopped** (`Stopped`) state.
        If an ECS instance is stopped in economical mode, the instance may fail to be started due to insufficient resources.
        
        @param request: StartInstanceRequest
        @return: StartInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.start_instance_with_options_async(request, runtime)

    def start_instances_with_options(
        self,
        request: ecs_20140526_models.StartInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.StartInstancesResponse:
        """
        @summary Starts Elastic Compute Service (ECS) instances that are in the Stopped state.
        
        @description This operation is an asynchronous operation. After you call this operation to start ECS instances, the operation sets the status of the ECS instances to Starting and begins the startup process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instances. When the status of the ECS instances changes to `Running`, the instances are started.
        ### [](#)Precautions
        You cannot call this operation to start ECS instances that are locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        The ECS instances that you want to start must be in the **Stopped** (`Stopped`) state.
        ECS instances stopped in economical mode may fail to be started due to insufficient resources.
        
        @param request: StartInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.batch_optimization):
            query['BatchOptimization'] = request.batch_optimization
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.StartInstancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def start_instances_with_options_async(
        self,
        request: ecs_20140526_models.StartInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.StartInstancesResponse:
        """
        @summary Starts Elastic Compute Service (ECS) instances that are in the Stopped state.
        
        @description This operation is an asynchronous operation. After you call this operation to start ECS instances, the operation sets the status of the ECS instances to Starting and begins the startup process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instances. When the status of the ECS instances changes to `Running`, the instances are started.
        ### [](#)Precautions
        You cannot call this operation to start ECS instances that are locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        The ECS instances that you want to start must be in the **Stopped** (`Stopped`) state.
        ECS instances stopped in economical mode may fail to be started due to insufficient resources.
        
        @param request: StartInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.batch_optimization):
            query['BatchOptimization'] = request.batch_optimization
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.StartInstancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def start_instances(
        self,
        request: ecs_20140526_models.StartInstancesRequest,
    ) -> ecs_20140526_models.StartInstancesResponse:
        """
        @summary Starts Elastic Compute Service (ECS) instances that are in the Stopped state.
        
        @description This operation is an asynchronous operation. After you call this operation to start ECS instances, the operation sets the status of the ECS instances to Starting and begins the startup process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instances. When the status of the ECS instances changes to `Running`, the instances are started.
        ### [](#)Precautions
        You cannot call this operation to start ECS instances that are locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        The ECS instances that you want to start must be in the **Stopped** (`Stopped`) state.
        ECS instances stopped in economical mode may fail to be started due to insufficient resources.
        
        @param request: StartInstancesRequest
        @return: StartInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.start_instances_with_options(request, runtime)

    async def start_instances_async(
        self,
        request: ecs_20140526_models.StartInstancesRequest,
    ) -> ecs_20140526_models.StartInstancesResponse:
        """
        @summary Starts Elastic Compute Service (ECS) instances that are in the Stopped state.
        
        @description This operation is an asynchronous operation. After you call this operation to start ECS instances, the operation sets the status of the ECS instances to Starting and begins the startup process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the instances. When the status of the ECS instances changes to `Running`, the instances are started.
        ### [](#)Precautions
        You cannot call this operation to start ECS instances that are locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        The ECS instances that you want to start must be in the **Stopped** (`Stopped`) state.
        ECS instances stopped in economical mode may fail to be started due to insufficient resources.
        
        @param request: StartInstancesRequest
        @return: StartInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.start_instances_with_options_async(request, runtime)

    def start_terminal_session_with_options(
        self,
        request: ecs_20140526_models.StartTerminalSessionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.StartTerminalSessionResponse:
        """
        @summary Creates a session by using the session management feature. When you call this operation, you can include the ID of an Elastic Compute Service (ECS) instance in the request to create a WebSocket session for the instance. The URL of the WebSocket session returned by the operation can be used to connect to the instance.
        
        @description ## [](#)Usage notes
        When you use custom code to connect to an ECS instance that serves as a client, you can call this operation to obtain the WebSocket URL that is used to connect to the instance. Take note of the following items:
        The ECS instance must be in the Running state.
        Cloud Assistant Agent must be installed on the ECS instance. You can call the [DescribeCloudAssistantStatus](https://help.aliyun.com/document_detail/87346.html) operation to check whether Cloud Assistant Agent is installed on the ECS instance and query the version number of the installed Cloud Assistant Agent.
        If Cloud Assistant Agent is not installed on the ECS instance, call the [InstallCloudAssistant](https://help.aliyun.com/document_detail/85916.html) operation to install Cloud Assistant Agent.
        The Cloud Assistant Agent versions that are later than the following ones support the session management feature. If you need to upgrade the Cloud Assistant Agent version, follow the instructions in [Upgrade or disable upgrades of Cloud Assistant Agent](https://help.aliyun.com/document_detail/134383.html).
        Linux operating system: 2.2.3.256
        Windows operating system: 2.1.3.256
        Each WebSocket URL returned by the StartTerminalSession operation remains valid for 10 minutes.
        If no data is transferred over a session within 3 minutes, Cloud Assistant closes the session connection.
        Up to 1,000 sessions can be created and available in a region. Each ECS instance can have up to 20 sessions in the connected state. Each session supports a bandwidth of up to 200 Kbit/s.
        The port forwarding feature supports only TCP port forwarding. UDP port forwarding is not supported.
        If you want to permanently close a session and invalidate the WebSocket URL, call the EndTerminalSession operation.
        
        @param request: StartTerminalSessionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartTerminalSessionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.command_line):
            query['CommandLine'] = request.command_line
        if not UtilClient.is_unset(request.connection_type):
            query['ConnectionType'] = request.connection_type
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.password_name):
            query['PasswordName'] = request.password_name
        if not UtilClient.is_unset(request.port_number):
            query['PortNumber'] = request.port_number
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.target_server):
            query['TargetServer'] = request.target_server
        if not UtilClient.is_unset(request.username):
            query['Username'] = request.username
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartTerminalSession',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.StartTerminalSessionResponse(),
            self.call_api(params, req, runtime)
        )

    async def start_terminal_session_with_options_async(
        self,
        request: ecs_20140526_models.StartTerminalSessionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.StartTerminalSessionResponse:
        """
        @summary Creates a session by using the session management feature. When you call this operation, you can include the ID of an Elastic Compute Service (ECS) instance in the request to create a WebSocket session for the instance. The URL of the WebSocket session returned by the operation can be used to connect to the instance.
        
        @description ## [](#)Usage notes
        When you use custom code to connect to an ECS instance that serves as a client, you can call this operation to obtain the WebSocket URL that is used to connect to the instance. Take note of the following items:
        The ECS instance must be in the Running state.
        Cloud Assistant Agent must be installed on the ECS instance. You can call the [DescribeCloudAssistantStatus](https://help.aliyun.com/document_detail/87346.html) operation to check whether Cloud Assistant Agent is installed on the ECS instance and query the version number of the installed Cloud Assistant Agent.
        If Cloud Assistant Agent is not installed on the ECS instance, call the [InstallCloudAssistant](https://help.aliyun.com/document_detail/85916.html) operation to install Cloud Assistant Agent.
        The Cloud Assistant Agent versions that are later than the following ones support the session management feature. If you need to upgrade the Cloud Assistant Agent version, follow the instructions in [Upgrade or disable upgrades of Cloud Assistant Agent](https://help.aliyun.com/document_detail/134383.html).
        Linux operating system: 2.2.3.256
        Windows operating system: 2.1.3.256
        Each WebSocket URL returned by the StartTerminalSession operation remains valid for 10 minutes.
        If no data is transferred over a session within 3 minutes, Cloud Assistant closes the session connection.
        Up to 1,000 sessions can be created and available in a region. Each ECS instance can have up to 20 sessions in the connected state. Each session supports a bandwidth of up to 200 Kbit/s.
        The port forwarding feature supports only TCP port forwarding. UDP port forwarding is not supported.
        If you want to permanently close a session and invalidate the WebSocket URL, call the EndTerminalSession operation.
        
        @param request: StartTerminalSessionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartTerminalSessionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.command_line):
            query['CommandLine'] = request.command_line
        if not UtilClient.is_unset(request.connection_type):
            query['ConnectionType'] = request.connection_type
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.password_name):
            query['PasswordName'] = request.password_name
        if not UtilClient.is_unset(request.port_number):
            query['PortNumber'] = request.port_number
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.target_server):
            query['TargetServer'] = request.target_server
        if not UtilClient.is_unset(request.username):
            query['Username'] = request.username
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartTerminalSession',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.StartTerminalSessionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def start_terminal_session(
        self,
        request: ecs_20140526_models.StartTerminalSessionRequest,
    ) -> ecs_20140526_models.StartTerminalSessionResponse:
        """
        @summary Creates a session by using the session management feature. When you call this operation, you can include the ID of an Elastic Compute Service (ECS) instance in the request to create a WebSocket session for the instance. The URL of the WebSocket session returned by the operation can be used to connect to the instance.
        
        @description ## [](#)Usage notes
        When you use custom code to connect to an ECS instance that serves as a client, you can call this operation to obtain the WebSocket URL that is used to connect to the instance. Take note of the following items:
        The ECS instance must be in the Running state.
        Cloud Assistant Agent must be installed on the ECS instance. You can call the [DescribeCloudAssistantStatus](https://help.aliyun.com/document_detail/87346.html) operation to check whether Cloud Assistant Agent is installed on the ECS instance and query the version number of the installed Cloud Assistant Agent.
        If Cloud Assistant Agent is not installed on the ECS instance, call the [InstallCloudAssistant](https://help.aliyun.com/document_detail/85916.html) operation to install Cloud Assistant Agent.
        The Cloud Assistant Agent versions that are later than the following ones support the session management feature. If you need to upgrade the Cloud Assistant Agent version, follow the instructions in [Upgrade or disable upgrades of Cloud Assistant Agent](https://help.aliyun.com/document_detail/134383.html).
        Linux operating system: 2.2.3.256
        Windows operating system: 2.1.3.256
        Each WebSocket URL returned by the StartTerminalSession operation remains valid for 10 minutes.
        If no data is transferred over a session within 3 minutes, Cloud Assistant closes the session connection.
        Up to 1,000 sessions can be created and available in a region. Each ECS instance can have up to 20 sessions in the connected state. Each session supports a bandwidth of up to 200 Kbit/s.
        The port forwarding feature supports only TCP port forwarding. UDP port forwarding is not supported.
        If you want to permanently close a session and invalidate the WebSocket URL, call the EndTerminalSession operation.
        
        @param request: StartTerminalSessionRequest
        @return: StartTerminalSessionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.start_terminal_session_with_options(request, runtime)

    async def start_terminal_session_async(
        self,
        request: ecs_20140526_models.StartTerminalSessionRequest,
    ) -> ecs_20140526_models.StartTerminalSessionResponse:
        """
        @summary Creates a session by using the session management feature. When you call this operation, you can include the ID of an Elastic Compute Service (ECS) instance in the request to create a WebSocket session for the instance. The URL of the WebSocket session returned by the operation can be used to connect to the instance.
        
        @description ## [](#)Usage notes
        When you use custom code to connect to an ECS instance that serves as a client, you can call this operation to obtain the WebSocket URL that is used to connect to the instance. Take note of the following items:
        The ECS instance must be in the Running state.
        Cloud Assistant Agent must be installed on the ECS instance. You can call the [DescribeCloudAssistantStatus](https://help.aliyun.com/document_detail/87346.html) operation to check whether Cloud Assistant Agent is installed on the ECS instance and query the version number of the installed Cloud Assistant Agent.
        If Cloud Assistant Agent is not installed on the ECS instance, call the [InstallCloudAssistant](https://help.aliyun.com/document_detail/85916.html) operation to install Cloud Assistant Agent.
        The Cloud Assistant Agent versions that are later than the following ones support the session management feature. If you need to upgrade the Cloud Assistant Agent version, follow the instructions in [Upgrade or disable upgrades of Cloud Assistant Agent](https://help.aliyun.com/document_detail/134383.html).
        Linux operating system: 2.2.3.256
        Windows operating system: 2.1.3.256
        Each WebSocket URL returned by the StartTerminalSession operation remains valid for 10 minutes.
        If no data is transferred over a session within 3 minutes, Cloud Assistant closes the session connection.
        Up to 1,000 sessions can be created and available in a region. Each ECS instance can have up to 20 sessions in the connected state. Each session supports a bandwidth of up to 200 Kbit/s.
        The port forwarding feature supports only TCP port forwarding. UDP port forwarding is not supported.
        If you want to permanently close a session and invalidate the WebSocket URL, call the EndTerminalSession operation.
        
        @param request: StartTerminalSessionRequest
        @return: StartTerminalSessionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.start_terminal_session_with_options_async(request, runtime)

    def stop_instance_with_options(
        self,
        request: ecs_20140526_models.StopInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.StopInstanceResponse:
        """
        @summary Stops an Elastic Compute Service (ECS) instance. You can specify parameters to determine whether to forcefully stop the instance and the stop mode.
        
        @description This operation is an asynchronous operation. After you call this operation to stop an ECS instance, the operation sets the status of the ECS instance to Stopping and begins the stop process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the ECS instance. When the status of the ECS instance changes to `Stopped`, the instance is stopped.
        ### [](#)Precautions
        You cannot call this operation to stop an ECS instance that is locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        After you enable the default economical mode for all pay-as-you-go ECS instances located in virtual private clouds (VPCs) in your account, you can set `StoppedMode` to KeepCharging for the ECS instance that you want to stop to enable standard mode. This way, the ECS instance continues to be billed after the instance is stopped. The instance type resources and public IP address of the instance are retained.
        
        @param request: StopInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.confirm_stop):
            query['ConfirmStop'] = request.confirm_stop
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.force_stop):
            query['ForceStop'] = request.force_stop
        if not UtilClient.is_unset(request.hibernate):
            query['Hibernate'] = request.hibernate
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.stopped_mode):
            query['StoppedMode'] = request.stopped_mode
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopInstance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.StopInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def stop_instance_with_options_async(
        self,
        request: ecs_20140526_models.StopInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.StopInstanceResponse:
        """
        @summary Stops an Elastic Compute Service (ECS) instance. You can specify parameters to determine whether to forcefully stop the instance and the stop mode.
        
        @description This operation is an asynchronous operation. After you call this operation to stop an ECS instance, the operation sets the status of the ECS instance to Stopping and begins the stop process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the ECS instance. When the status of the ECS instance changes to `Stopped`, the instance is stopped.
        ### [](#)Precautions
        You cannot call this operation to stop an ECS instance that is locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        After you enable the default economical mode for all pay-as-you-go ECS instances located in virtual private clouds (VPCs) in your account, you can set `StoppedMode` to KeepCharging for the ECS instance that you want to stop to enable standard mode. This way, the ECS instance continues to be billed after the instance is stopped. The instance type resources and public IP address of the instance are retained.
        
        @param request: StopInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.confirm_stop):
            query['ConfirmStop'] = request.confirm_stop
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.force_stop):
            query['ForceStop'] = request.force_stop
        if not UtilClient.is_unset(request.hibernate):
            query['Hibernate'] = request.hibernate
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.stopped_mode):
            query['StoppedMode'] = request.stopped_mode
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopInstance',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.StopInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def stop_instance(
        self,
        request: ecs_20140526_models.StopInstanceRequest,
    ) -> ecs_20140526_models.StopInstanceResponse:
        """
        @summary Stops an Elastic Compute Service (ECS) instance. You can specify parameters to determine whether to forcefully stop the instance and the stop mode.
        
        @description This operation is an asynchronous operation. After you call this operation to stop an ECS instance, the operation sets the status of the ECS instance to Stopping and begins the stop process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the ECS instance. When the status of the ECS instance changes to `Stopped`, the instance is stopped.
        ### [](#)Precautions
        You cannot call this operation to stop an ECS instance that is locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        After you enable the default economical mode for all pay-as-you-go ECS instances located in virtual private clouds (VPCs) in your account, you can set `StoppedMode` to KeepCharging for the ECS instance that you want to stop to enable standard mode. This way, the ECS instance continues to be billed after the instance is stopped. The instance type resources and public IP address of the instance are retained.
        
        @param request: StopInstanceRequest
        @return: StopInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.stop_instance_with_options(request, runtime)

    async def stop_instance_async(
        self,
        request: ecs_20140526_models.StopInstanceRequest,
    ) -> ecs_20140526_models.StopInstanceResponse:
        """
        @summary Stops an Elastic Compute Service (ECS) instance. You can specify parameters to determine whether to forcefully stop the instance and the stop mode.
        
        @description This operation is an asynchronous operation. After you call this operation to stop an ECS instance, the operation sets the status of the ECS instance to Stopping and begins the stop process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the ECS instance. When the status of the ECS instance changes to `Stopped`, the instance is stopped.
        ### [](#)Precautions
        You cannot call this operation to stop an ECS instance that is locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        After you enable the default economical mode for all pay-as-you-go ECS instances located in virtual private clouds (VPCs) in your account, you can set `StoppedMode` to KeepCharging for the ECS instance that you want to stop to enable standard mode. This way, the ECS instance continues to be billed after the instance is stopped. The instance type resources and public IP address of the instance are retained.
        
        @param request: StopInstanceRequest
        @return: StopInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.stop_instance_with_options_async(request, runtime)

    def stop_instances_with_options(
        self,
        request: ecs_20140526_models.StopInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.StopInstancesResponse:
        """
        @summary Stops Elastic Compute Service (ECS) instances. You can specify parameters to determine whether to forcefully stop the instances and the stop mode.
        
        @description This operation is an asynchronous operation. After you call this operation to stop an ECS instance, the operation sets the status of the ECS instance to Stopping and begins the stop process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the ECS instance. When the status of the ECS instance changes to `Stopped`, the instance is stopped.
        ### [](#)Considerations
        The instance is unavailable after you stop the instance. Make sure that stopping the instance does not affect your business. You can also call the [StartInstance](https://help.aliyun.com/document_detail/2679679.html) or [StartInstances](https://help.aliyun.com/document_detail/2679680.html) operation to start the instance.
        You cannot call this operation to stop ECS instances that are locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        
        @param request: StopInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.batch_optimization):
            query['BatchOptimization'] = request.batch_optimization
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.force_stop):
            query['ForceStop'] = request.force_stop
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.stopped_mode):
            query['StoppedMode'] = request.stopped_mode
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.StopInstancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def stop_instances_with_options_async(
        self,
        request: ecs_20140526_models.StopInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.StopInstancesResponse:
        """
        @summary Stops Elastic Compute Service (ECS) instances. You can specify parameters to determine whether to forcefully stop the instances and the stop mode.
        
        @description This operation is an asynchronous operation. After you call this operation to stop an ECS instance, the operation sets the status of the ECS instance to Stopping and begins the stop process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the ECS instance. When the status of the ECS instance changes to `Stopped`, the instance is stopped.
        ### [](#)Considerations
        The instance is unavailable after you stop the instance. Make sure that stopping the instance does not affect your business. You can also call the [StartInstance](https://help.aliyun.com/document_detail/2679679.html) or [StartInstances](https://help.aliyun.com/document_detail/2679680.html) operation to start the instance.
        You cannot call this operation to stop ECS instances that are locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        
        @param request: StopInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.batch_optimization):
            query['BatchOptimization'] = request.batch_optimization
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.force_stop):
            query['ForceStop'] = request.force_stop
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.stopped_mode):
            query['StoppedMode'] = request.stopped_mode
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopInstances',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.StopInstancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def stop_instances(
        self,
        request: ecs_20140526_models.StopInstancesRequest,
    ) -> ecs_20140526_models.StopInstancesResponse:
        """
        @summary Stops Elastic Compute Service (ECS) instances. You can specify parameters to determine whether to forcefully stop the instances and the stop mode.
        
        @description This operation is an asynchronous operation. After you call this operation to stop an ECS instance, the operation sets the status of the ECS instance to Stopping and begins the stop process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the ECS instance. When the status of the ECS instance changes to `Stopped`, the instance is stopped.
        ### [](#)Considerations
        The instance is unavailable after you stop the instance. Make sure that stopping the instance does not affect your business. You can also call the [StartInstance](https://help.aliyun.com/document_detail/2679679.html) or [StartInstances](https://help.aliyun.com/document_detail/2679680.html) operation to start the instance.
        You cannot call this operation to stop ECS instances that are locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        
        @param request: StopInstancesRequest
        @return: StopInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.stop_instances_with_options(request, runtime)

    async def stop_instances_async(
        self,
        request: ecs_20140526_models.StopInstancesRequest,
    ) -> ecs_20140526_models.StopInstancesResponse:
        """
        @summary Stops Elastic Compute Service (ECS) instances. You can specify parameters to determine whether to forcefully stop the instances and the stop mode.
        
        @description This operation is an asynchronous operation. After you call this operation to stop an ECS instance, the operation sets the status of the ECS instance to Stopping and begins the stop process. You can call the [DescribeInstanceStatus](https://help.aliyun.com/document_detail/2679688.html) operation to query the status of the ECS instance. When the status of the ECS instance changes to `Stopped`, the instance is stopped.
        ### [](#)Considerations
        The instance is unavailable after you stop the instance. Make sure that stopping the instance does not affect your business. You can also call the [StartInstance](https://help.aliyun.com/document_detail/2679679.html) or [StartInstances](https://help.aliyun.com/document_detail/2679680.html) operation to start the instance.
        You cannot call this operation to stop ECS instances that are locked for security reasons. For more information, see [API behavior when an instance is locked for security reasons](https://help.aliyun.com/document_detail/25695.html).
        
        @param request: StopInstancesRequest
        @return: StopInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.stop_instances_with_options_async(request, runtime)

    def stop_invocation_with_options(
        self,
        request: ecs_20140526_models.StopInvocationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.StopInvocationResponse:
        """
        @summary \\   If you stop the process of a command that runs only once, the executions that have started are not interrupted. The executions that have not started are canceled.
        \\   If you stop the process of a scheduled invocation command, the executions that have started are not interrupted. However, the execution does not start in the next period.
        
        @description ## [](#)Usage notes
        If you stop the process of a command that runs only once, the executions that have started are not interrupted. The executions that have not started are canceled.
        If you stop the process of a command that runs on a schedule, the executions that have started are not interrupted. Subsequent executions are not scheduled.
        
        @param request: StopInvocationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopInvocationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.invoke_id):
            query['InvokeId'] = request.invoke_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopInvocation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.StopInvocationResponse(),
            self.call_api(params, req, runtime)
        )

    async def stop_invocation_with_options_async(
        self,
        request: ecs_20140526_models.StopInvocationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.StopInvocationResponse:
        """
        @summary \\   If you stop the process of a command that runs only once, the executions that have started are not interrupted. The executions that have not started are canceled.
        \\   If you stop the process of a scheduled invocation command, the executions that have started are not interrupted. However, the execution does not start in the next period.
        
        @description ## [](#)Usage notes
        If you stop the process of a command that runs only once, the executions that have started are not interrupted. The executions that have not started are canceled.
        If you stop the process of a command that runs on a schedule, the executions that have started are not interrupted. Subsequent executions are not scheduled.
        
        @param request: StopInvocationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopInvocationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.invoke_id):
            query['InvokeId'] = request.invoke_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopInvocation',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.StopInvocationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def stop_invocation(
        self,
        request: ecs_20140526_models.StopInvocationRequest,
    ) -> ecs_20140526_models.StopInvocationResponse:
        """
        @summary \\   If you stop the process of a command that runs only once, the executions that have started are not interrupted. The executions that have not started are canceled.
        \\   If you stop the process of a scheduled invocation command, the executions that have started are not interrupted. However, the execution does not start in the next period.
        
        @description ## [](#)Usage notes
        If you stop the process of a command that runs only once, the executions that have started are not interrupted. The executions that have not started are canceled.
        If you stop the process of a command that runs on a schedule, the executions that have started are not interrupted. Subsequent executions are not scheduled.
        
        @param request: StopInvocationRequest
        @return: StopInvocationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.stop_invocation_with_options(request, runtime)

    async def stop_invocation_async(
        self,
        request: ecs_20140526_models.StopInvocationRequest,
    ) -> ecs_20140526_models.StopInvocationResponse:
        """
        @summary \\   If you stop the process of a command that runs only once, the executions that have started are not interrupted. The executions that have not started are canceled.
        \\   If you stop the process of a scheduled invocation command, the executions that have started are not interrupted. However, the execution does not start in the next period.
        
        @description ## [](#)Usage notes
        If you stop the process of a command that runs only once, the executions that have started are not interrupted. The executions that have not started are canceled.
        If you stop the process of a command that runs on a schedule, the executions that have started are not interrupted. Subsequent executions are not scheduled.
        
        @param request: StopInvocationRequest
        @return: StopInvocationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.stop_invocation_with_options_async(request, runtime)

    def tag_resources_with_options(
        self,
        request: ecs_20140526_models.TagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.TagResourcesResponse:
        """
        @summary Creates and adds tags to Elastic Compute Service (ECS) resources.
        
        @description ## [](#)Usage notes
        Before you add tags to a resource, Alibaba Cloud checks the number of existing tags of the resource. If the maximum number of tags is reached, an error message is returned. For more information, see [Tag limits](https://help.aliyun.com/document_detail/25412.html).
        
        @param request: TagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TagResources',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.TagResourcesResponse(),
            self.call_api(params, req, runtime)
        )

    async def tag_resources_with_options_async(
        self,
        request: ecs_20140526_models.TagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.TagResourcesResponse:
        """
        @summary Creates and adds tags to Elastic Compute Service (ECS) resources.
        
        @description ## [](#)Usage notes
        Before you add tags to a resource, Alibaba Cloud checks the number of existing tags of the resource. If the maximum number of tags is reached, an error message is returned. For more information, see [Tag limits](https://help.aliyun.com/document_detail/25412.html).
        
        @param request: TagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TagResources',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.TagResourcesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def tag_resources(
        self,
        request: ecs_20140526_models.TagResourcesRequest,
    ) -> ecs_20140526_models.TagResourcesResponse:
        """
        @summary Creates and adds tags to Elastic Compute Service (ECS) resources.
        
        @description ## [](#)Usage notes
        Before you add tags to a resource, Alibaba Cloud checks the number of existing tags of the resource. If the maximum number of tags is reached, an error message is returned. For more information, see [Tag limits](https://help.aliyun.com/document_detail/25412.html).
        
        @param request: TagResourcesRequest
        @return: TagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.tag_resources_with_options(request, runtime)

    async def tag_resources_async(
        self,
        request: ecs_20140526_models.TagResourcesRequest,
    ) -> ecs_20140526_models.TagResourcesResponse:
        """
        @summary Creates and adds tags to Elastic Compute Service (ECS) resources.
        
        @description ## [](#)Usage notes
        Before you add tags to a resource, Alibaba Cloud checks the number of existing tags of the resource. If the maximum number of tags is reached, an error message is returned. For more information, see [Tag limits](https://help.aliyun.com/document_detail/25412.html).
        
        @param request: TagResourcesRequest
        @return: TagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.tag_resources_with_options_async(request, runtime)

    def terminate_physical_connection_with_options(
        self,
        request: ecs_20140526_models.TerminatePhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.TerminatePhysicalConnectionResponse:
        """
        @deprecated OpenAPI TerminatePhysicalConnection is deprecated, please use Vpc::2016-04-28::TerminatePhysicalConnection instead.
        
        @summary TerminatePhysicalConnection
        
        @param request: TerminatePhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TerminatePhysicalConnectionResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TerminatePhysicalConnection',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.TerminatePhysicalConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def terminate_physical_connection_with_options_async(
        self,
        request: ecs_20140526_models.TerminatePhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.TerminatePhysicalConnectionResponse:
        """
        @deprecated OpenAPI TerminatePhysicalConnection is deprecated, please use Vpc::2016-04-28::TerminatePhysicalConnection instead.
        
        @summary TerminatePhysicalConnection
        
        @param request: TerminatePhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TerminatePhysicalConnectionResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TerminatePhysicalConnection',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.TerminatePhysicalConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def terminate_physical_connection(
        self,
        request: ecs_20140526_models.TerminatePhysicalConnectionRequest,
    ) -> ecs_20140526_models.TerminatePhysicalConnectionResponse:
        """
        @deprecated OpenAPI TerminatePhysicalConnection is deprecated, please use Vpc::2016-04-28::TerminatePhysicalConnection instead.
        
        @summary TerminatePhysicalConnection
        
        @param request: TerminatePhysicalConnectionRequest
        @return: TerminatePhysicalConnectionResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.terminate_physical_connection_with_options(request, runtime)

    async def terminate_physical_connection_async(
        self,
        request: ecs_20140526_models.TerminatePhysicalConnectionRequest,
    ) -> ecs_20140526_models.TerminatePhysicalConnectionResponse:
        """
        @deprecated OpenAPI TerminatePhysicalConnection is deprecated, please use Vpc::2016-04-28::TerminatePhysicalConnection instead.
        
        @summary TerminatePhysicalConnection
        
        @param request: TerminatePhysicalConnectionRequest
        @return: TerminatePhysicalConnectionResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.terminate_physical_connection_with_options_async(request, runtime)

    def terminate_virtual_border_router_with_options(
        self,
        request: ecs_20140526_models.TerminateVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.TerminateVirtualBorderRouterResponse:
        """
        @deprecated OpenAPI TerminateVirtualBorderRouter is deprecated, please use Vpc::2016-04-28::TerminateVirtualBorderRouter instead.
        
        @summary TerminateVirtualBorderRouter
        
        @param request: TerminateVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TerminateVirtualBorderRouterResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TerminateVirtualBorderRouter',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.TerminateVirtualBorderRouterResponse(),
            self.call_api(params, req, runtime)
        )

    async def terminate_virtual_border_router_with_options_async(
        self,
        request: ecs_20140526_models.TerminateVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.TerminateVirtualBorderRouterResponse:
        """
        @deprecated OpenAPI TerminateVirtualBorderRouter is deprecated, please use Vpc::2016-04-28::TerminateVirtualBorderRouter instead.
        
        @summary TerminateVirtualBorderRouter
        
        @param request: TerminateVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TerminateVirtualBorderRouterResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TerminateVirtualBorderRouter',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.TerminateVirtualBorderRouterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def terminate_virtual_border_router(
        self,
        request: ecs_20140526_models.TerminateVirtualBorderRouterRequest,
    ) -> ecs_20140526_models.TerminateVirtualBorderRouterResponse:
        """
        @deprecated OpenAPI TerminateVirtualBorderRouter is deprecated, please use Vpc::2016-04-28::TerminateVirtualBorderRouter instead.
        
        @summary TerminateVirtualBorderRouter
        
        @param request: TerminateVirtualBorderRouterRequest
        @return: TerminateVirtualBorderRouterResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.terminate_virtual_border_router_with_options(request, runtime)

    async def terminate_virtual_border_router_async(
        self,
        request: ecs_20140526_models.TerminateVirtualBorderRouterRequest,
    ) -> ecs_20140526_models.TerminateVirtualBorderRouterResponse:
        """
        @deprecated OpenAPI TerminateVirtualBorderRouter is deprecated, please use Vpc::2016-04-28::TerminateVirtualBorderRouter instead.
        
        @summary TerminateVirtualBorderRouter
        
        @param request: TerminateVirtualBorderRouterRequest
        @return: TerminateVirtualBorderRouterResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.terminate_virtual_border_router_with_options_async(request, runtime)

    def unassign_ipv_6addresses_with_options(
        self,
        request: ecs_20140526_models.UnassignIpv6AddressesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.UnassignIpv6AddressesResponse:
        """
        @summary Unassigns one or more IPv6 addresses from an elastic network interface (ENI).
        
        @description ## [](#)Usage notes
        Take note of the following items:
        The ENI must be in the **Available** (Available) or **InUse** (InUse) state.
        If the ENI is a primary ENI, the Elastic Compute Service (ECS) instance to which the ENI is attached must be in the **Running** (Running) or **Stopped** (Stopped) state.
        
        @param request: UnassignIpv6AddressesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassignIpv6AddressesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_6address):
            query['Ipv6Address'] = request.ipv_6address
        if not UtilClient.is_unset(request.ipv_6prefix):
            query['Ipv6Prefix'] = request.ipv_6prefix
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassignIpv6Addresses',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.UnassignIpv6AddressesResponse(),
            self.call_api(params, req, runtime)
        )

    async def unassign_ipv_6addresses_with_options_async(
        self,
        request: ecs_20140526_models.UnassignIpv6AddressesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.UnassignIpv6AddressesResponse:
        """
        @summary Unassigns one or more IPv6 addresses from an elastic network interface (ENI).
        
        @description ## [](#)Usage notes
        Take note of the following items:
        The ENI must be in the **Available** (Available) or **InUse** (InUse) state.
        If the ENI is a primary ENI, the Elastic Compute Service (ECS) instance to which the ENI is attached must be in the **Running** (Running) or **Stopped** (Stopped) state.
        
        @param request: UnassignIpv6AddressesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassignIpv6AddressesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_6address):
            query['Ipv6Address'] = request.ipv_6address
        if not UtilClient.is_unset(request.ipv_6prefix):
            query['Ipv6Prefix'] = request.ipv_6prefix
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassignIpv6Addresses',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.UnassignIpv6AddressesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def unassign_ipv_6addresses(
        self,
        request: ecs_20140526_models.UnassignIpv6AddressesRequest,
    ) -> ecs_20140526_models.UnassignIpv6AddressesResponse:
        """
        @summary Unassigns one or more IPv6 addresses from an elastic network interface (ENI).
        
        @description ## [](#)Usage notes
        Take note of the following items:
        The ENI must be in the **Available** (Available) or **InUse** (InUse) state.
        If the ENI is a primary ENI, the Elastic Compute Service (ECS) instance to which the ENI is attached must be in the **Running** (Running) or **Stopped** (Stopped) state.
        
        @param request: UnassignIpv6AddressesRequest
        @return: UnassignIpv6AddressesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.unassign_ipv_6addresses_with_options(request, runtime)

    async def unassign_ipv_6addresses_async(
        self,
        request: ecs_20140526_models.UnassignIpv6AddressesRequest,
    ) -> ecs_20140526_models.UnassignIpv6AddressesResponse:
        """
        @summary Unassigns one or more IPv6 addresses from an elastic network interface (ENI).
        
        @description ## [](#)Usage notes
        Take note of the following items:
        The ENI must be in the **Available** (Available) or **InUse** (InUse) state.
        If the ENI is a primary ENI, the Elastic Compute Service (ECS) instance to which the ENI is attached must be in the **Running** (Running) or **Stopped** (Stopped) state.
        
        @param request: UnassignIpv6AddressesRequest
        @return: UnassignIpv6AddressesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.unassign_ipv_6addresses_with_options_async(request, runtime)

    def unassign_private_ip_addresses_with_options(
        self,
        request: ecs_20140526_models.UnassignPrivateIpAddressesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.UnassignPrivateIpAddressesResponse:
        """
        @summary Unassigns secondary private IP addresses from an elastic network interface (ENI).
        
        @description ## [](#)Usage notes
        The ENI from which to unassign secondary private IP addresses must be in the **Available** (Available) or **InUse** (InUse) state.
        If the ENI is a primary ENI, the Elastic Compute Service (ECS) instance to which the ENI is attached must be in the **Running** (Running) or **Stopped** (Stopped) state.
        
        @param request: UnassignPrivateIpAddressesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassignPrivateIpAddressesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_4prefix):
            query['Ipv4Prefix'] = request.ipv_4prefix
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassignPrivateIpAddresses',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.UnassignPrivateIpAddressesResponse(),
            self.call_api(params, req, runtime)
        )

    async def unassign_private_ip_addresses_with_options_async(
        self,
        request: ecs_20140526_models.UnassignPrivateIpAddressesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.UnassignPrivateIpAddressesResponse:
        """
        @summary Unassigns secondary private IP addresses from an elastic network interface (ENI).
        
        @description ## [](#)Usage notes
        The ENI from which to unassign secondary private IP addresses must be in the **Available** (Available) or **InUse** (InUse) state.
        If the ENI is a primary ENI, the Elastic Compute Service (ECS) instance to which the ENI is attached must be in the **Running** (Running) or **Stopped** (Stopped) state.
        
        @param request: UnassignPrivateIpAddressesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassignPrivateIpAddressesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_4prefix):
            query['Ipv4Prefix'] = request.ipv_4prefix
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassignPrivateIpAddresses',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.UnassignPrivateIpAddressesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def unassign_private_ip_addresses(
        self,
        request: ecs_20140526_models.UnassignPrivateIpAddressesRequest,
    ) -> ecs_20140526_models.UnassignPrivateIpAddressesResponse:
        """
        @summary Unassigns secondary private IP addresses from an elastic network interface (ENI).
        
        @description ## [](#)Usage notes
        The ENI from which to unassign secondary private IP addresses must be in the **Available** (Available) or **InUse** (InUse) state.
        If the ENI is a primary ENI, the Elastic Compute Service (ECS) instance to which the ENI is attached must be in the **Running** (Running) or **Stopped** (Stopped) state.
        
        @param request: UnassignPrivateIpAddressesRequest
        @return: UnassignPrivateIpAddressesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.unassign_private_ip_addresses_with_options(request, runtime)

    async def unassign_private_ip_addresses_async(
        self,
        request: ecs_20140526_models.UnassignPrivateIpAddressesRequest,
    ) -> ecs_20140526_models.UnassignPrivateIpAddressesResponse:
        """
        @summary Unassigns secondary private IP addresses from an elastic network interface (ENI).
        
        @description ## [](#)Usage notes
        The ENI from which to unassign secondary private IP addresses must be in the **Available** (Available) or **InUse** (InUse) state.
        If the ENI is a primary ENI, the Elastic Compute Service (ECS) instance to which the ENI is attached must be in the **Running** (Running) or **Stopped** (Stopped) state.
        
        @param request: UnassignPrivateIpAddressesRequest
        @return: UnassignPrivateIpAddressesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.unassign_private_ip_addresses_with_options_async(request, runtime)

    def unassociate_eip_address_with_options(
        self,
        request: ecs_20140526_models.UnassociateEipAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.UnassociateEipAddressResponse:
        """
        @deprecated OpenAPI UnassociateEipAddress is deprecated, please use Vpc::2016-04-28::UnassociateEipAddress instead.
        
        @summary UnassociateEipAddress
        
        @param request: UnassociateEipAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassociateEipAddressResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassociateEipAddress',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.UnassociateEipAddressResponse(),
            self.call_api(params, req, runtime)
        )

    async def unassociate_eip_address_with_options_async(
        self,
        request: ecs_20140526_models.UnassociateEipAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.UnassociateEipAddressResponse:
        """
        @deprecated OpenAPI UnassociateEipAddress is deprecated, please use Vpc::2016-04-28::UnassociateEipAddress instead.
        
        @summary UnassociateEipAddress
        
        @param request: UnassociateEipAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassociateEipAddressResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassociateEipAddress',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.UnassociateEipAddressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def unassociate_eip_address(
        self,
        request: ecs_20140526_models.UnassociateEipAddressRequest,
    ) -> ecs_20140526_models.UnassociateEipAddressResponse:
        """
        @deprecated OpenAPI UnassociateEipAddress is deprecated, please use Vpc::2016-04-28::UnassociateEipAddress instead.
        
        @summary UnassociateEipAddress
        
        @param request: UnassociateEipAddressRequest
        @return: UnassociateEipAddressResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.unassociate_eip_address_with_options(request, runtime)

    async def unassociate_eip_address_async(
        self,
        request: ecs_20140526_models.UnassociateEipAddressRequest,
    ) -> ecs_20140526_models.UnassociateEipAddressResponse:
        """
        @deprecated OpenAPI UnassociateEipAddress is deprecated, please use Vpc::2016-04-28::UnassociateEipAddress instead.
        
        @summary UnassociateEipAddress
        
        @param request: UnassociateEipAddressRequest
        @return: UnassociateEipAddressResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.unassociate_eip_address_with_options_async(request, runtime)

    def unassociate_ha_vip_with_options(
        self,
        request: ecs_20140526_models.UnassociateHaVipRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.UnassociateHaVipResponse:
        """
        @deprecated OpenAPI UnassociateHaVip is deprecated, please use Vpc::2016-04-28::UnassociateHaVip instead.
        
        @summary UnassociateHaVip
        
        @param request: UnassociateHaVipRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassociateHaVipResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.ha_vip_id):
            query['HaVipId'] = request.ha_vip_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassociateHaVip',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.UnassociateHaVipResponse(),
            self.call_api(params, req, runtime)
        )

    async def unassociate_ha_vip_with_options_async(
        self,
        request: ecs_20140526_models.UnassociateHaVipRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.UnassociateHaVipResponse:
        """
        @deprecated OpenAPI UnassociateHaVip is deprecated, please use Vpc::2016-04-28::UnassociateHaVip instead.
        
        @summary UnassociateHaVip
        
        @param request: UnassociateHaVipRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassociateHaVipResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.ha_vip_id):
            query['HaVipId'] = request.ha_vip_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassociateHaVip',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.UnassociateHaVipResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def unassociate_ha_vip(
        self,
        request: ecs_20140526_models.UnassociateHaVipRequest,
    ) -> ecs_20140526_models.UnassociateHaVipResponse:
        """
        @deprecated OpenAPI UnassociateHaVip is deprecated, please use Vpc::2016-04-28::UnassociateHaVip instead.
        
        @summary UnassociateHaVip
        
        @param request: UnassociateHaVipRequest
        @return: UnassociateHaVipResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.unassociate_ha_vip_with_options(request, runtime)

    async def unassociate_ha_vip_async(
        self,
        request: ecs_20140526_models.UnassociateHaVipRequest,
    ) -> ecs_20140526_models.UnassociateHaVipResponse:
        """
        @deprecated OpenAPI UnassociateHaVip is deprecated, please use Vpc::2016-04-28::UnassociateHaVip instead.
        
        @summary UnassociateHaVip
        
        @param request: UnassociateHaVipRequest
        @return: UnassociateHaVipResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.unassociate_ha_vip_with_options_async(request, runtime)

    def untag_resources_with_options(
        self,
        request: ecs_20140526_models.UntagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.UntagResourcesResponse:
        """
        @summary Removes tags from Elastic Compute Service (ECS) resources. After a tag is removed from a resource, the tag is automatically deleted if it is not added to other resources.
        
        @param request: UntagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UntagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.all):
            query['All'] = request.all
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag_key):
            query['TagKey'] = request.tag_key
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UntagResources',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.UntagResourcesResponse(),
            self.call_api(params, req, runtime)
        )

    async def untag_resources_with_options_async(
        self,
        request: ecs_20140526_models.UntagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> ecs_20140526_models.UntagResourcesResponse:
        """
        @summary Removes tags from Elastic Compute Service (ECS) resources. After a tag is removed from a resource, the tag is automatically deleted if it is not added to other resources.
        
        @param request: UntagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UntagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.all):
            query['All'] = request.all
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag_key):
            query['TagKey'] = request.tag_key
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UntagResources',
            version='2014-05-26',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            ecs_20140526_models.UntagResourcesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def untag_resources(
        self,
        request: ecs_20140526_models.UntagResourcesRequest,
    ) -> ecs_20140526_models.UntagResourcesResponse:
        """
        @summary Removes tags from Elastic Compute Service (ECS) resources. After a tag is removed from a resource, the tag is automatically deleted if it is not added to other resources.
        
        @param request: UntagResourcesRequest
        @return: UntagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.untag_resources_with_options(request, runtime)

    async def untag_resources_async(
        self,
        request: ecs_20140526_models.UntagResourcesRequest,
    ) -> ecs_20140526_models.UntagResourcesResponse:
        """
        @summary Removes tags from Elastic Compute Service (ECS) resources. After a tag is removed from a resource, the tag is automatically deleted if it is not added to other resources.
        
        @param request: UntagResourcesRequest
        @return: UntagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.untag_resources_with_options_async(request, runtime)
